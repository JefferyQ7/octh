inline namespace __1 {
template < int __v > struct __attribute__(()) integral_constant {
  static const int value = __v;
};
template < class > struct __attribute__(()) pointer_traits;
template < class _Tp > struct __attribute__(()) pointer_traits< _Tp * > {
  typedef _Tp element_type;
  template < class _Up > using rebind = _Up *;

};
template < class _From, class _To > struct __rebind_pointer {
  typedef typename pointer_traits< _From >::template rebind< _To > type;
};
namespace __pointer_type_imp {
template < class , class , bool = integral_constant< 0 >::value >
struct __pointer_type;
template < class _Tp, class _Dp > struct __pointer_type< _Tp, _Dp> {
  typedef _Tp *type;
};
} struct __pointer_type {
  typedef __pointer_type_imp::__pointer_type< int, int >::type type;
};
template < class _Ptr > struct __void_pointer { typedef _Ptr type; };
template < class > struct __attribute__(()) allocator_traits {
  typedef __pointer_type::type pointer;
  typedef __void_pointer< pointer >::type void_pointer;
};
class allocator;
struct __rebind_alloc_helper {
  typedef allocator_traits< allocator > type;
};
template < class , class > class __tree_node;
template < class > struct __tree_key_value_types {};
struct __tree_node_base_types {
  typedef ;
};
template < class _NodePtr,
           class = typename pointer_traits< _NodePtr >::element_type >
struct __tree_node_types;
template < class _NodePtr, class _Tp, class _VoidPtr >
struct __tree_node_types< _NodePtr, __tree_node< _Tp, _VoidPtr > >
    : __tree_key_value_types< _Tp > {
  typedef _NodePtr __node_pointer;
};
template < class _VoidPtr > struct __make_tree_node_types {
  typedef __tree_node_types< typename __rebind_pointer<
      _VoidPtr, __tree_node< int, _VoidPtr > >::type >
      type;
};
template < class > class __attribute__(()) __tree_const_iterator;
template < class , class _Allocator > class __tree {
typedef allocator_traits< _Allocator > __alloc_traits;
  typedef typename __make_tree_node_types<
      typename __alloc_traits::void_pointer >::type _NodeTypes;

public:
  typename _NodeTypes::__void_pointer;
  typedef typename _NodeTypes::__node_pointer __node_pointer;
  typedef __tree_const_iterator< __node_pointer > const_iterator;
};
template < class >
class __attribute__(()) __map_const_iterator {};
class __attribute__(()) map {
  typedef allocator allocator_type;
  typedef __tree< int, __rebind_alloc_helper::type > __base;
  typedef allocator_traits< allocator_type > __alloc_traits;

public:
  __alloc_traits::pointer pointer;
  typedef __map_const_iterator< __base::const_iterator >
      const_iterator;
};
} // __1
namespace octave {
class stream {
map::const_iterator lookup_cache;
};
} 