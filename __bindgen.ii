 typedef long long int64_t;
   typedef union {
  }
   __mbstate_t;
   typedef __mbstate_t __darwin_mbstate_t;
   typedef long unsigned int __darwin_size_t;
   typedef int __darwin_wint_t;
   typedef __darwin_size_t size_t;
   typedef struct {
  }
   div_t;
   typedef struct {
  }
   ldiv_t;
   typedef struct {
  }
   lldiv_t;
   typedef long int ptrdiff_t;
   namespace std {
      typedef decltype(nullptr) nullptr_t;
  }
   namespace std {
  inline namespace __1 {
 template <class _T1, class _T2> struct __attribute__ ((__type_visibility__("default"))) pair;
 template <class _Tp> class __attribute__ ((__type_visibility__("default"))) reference_wrapper;
 template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) hash;
 template <class> struct __void_t { typedef void type; };
 template <class _Tp> struct __identity { typedef _Tp type; };
 template <class _Tp, bool> struct __attribute__ ((__type_visibility__("default"))) __dependent_type : public _Tp {};
 template <bool _Bp, class _If, class _Then>     struct __attribute__ ((__type_visibility__("default"))) conditional {typedef _If type;};
 template <class _If, class _Then>     struct __attribute__ ((__type_visibility__("default"))) conditional<false, _If, _Then> {typedef _Then type;};
 template <bool, class _Tp = void> struct __attribute__ ((__type_visibility__("default"))) enable_if {};
 template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) enable_if<true, _Tp> {typedef _Tp type;};
 struct __two {char __lx[2];};
 template <class _Tp, _Tp __v> struct __attribute__ ((__type_visibility__("default"))) integral_constant {     static constexpr const _Tp value = __v;     typedef _Tp value_type;     typedef integral_constant type;     __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))         constexpr operator value_type() const noexcept ; };
 template <class _Tp, _Tp __v> constexpr const _Tp integral_constant<_Tp, __v>::value;
 typedef integral_constant<bool,(true)> true_type;
 typedef integral_constant<bool,(false)> false_type;
 template <bool _Last, class ..._Preds> struct __lazy_and_impl;
 template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_const : public false_type {};
 template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_const<_Tp const> : public true_type {};
 template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_volatile : public false_type {};
 template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_volatile<_Tp volatile> : public true_type {};
 template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_const {typedef _Tp type;};
 template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_const<const _Tp> {typedef _Tp type;};
 template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_volatile {typedef _Tp type;};
 template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_volatile<volatile _Tp> {typedef _Tp type;};
 template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_cv {typedef typename remove_volatile<typename remove_const<_Tp>::type>::type type;};
 template <class _Tp> struct __libcpp_is_void : public false_type {};
 template <> struct __libcpp_is_void<void> : public true_type {};
 template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_void     : public __libcpp_is_void<typename remove_cv<_Tp>::type> {};
 template <class _Tp> struct __is_nullptr_t_impl : public false_type {};
 template <> struct __is_nullptr_t_impl<nullptr_t> : public true_type {};
 template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) __is_nullptr_t     : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};
 template <class _Tp> struct __libcpp_is_integral : public false_type {};
 template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_integral     : public __libcpp_is_integral<typename remove_cv<_Tp>::type> {};
 template <class _Tp> struct __libcpp_is_floating_point : public false_type {};
 template <> struct __libcpp_is_floating_point<long double> : public true_type {};
 template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_floating_point     : public __libcpp_is_floating_point<typename remove_cv<_Tp>::type> {};
 template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_array     : public false_type {};
 template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_array<_Tp[]>     : public true_type {};
 template <class _Tp, size_t _Np> struct __attribute__ ((__type_visibility__("default"))) is_array<_Tp[_Np]>     : public true_type {};
 template <class _Tp> struct __libcpp_is_pointer : public false_type {};
 template <class _Tp> struct __libcpp_is_pointer<_Tp*> : public true_type {};
 template <class _Tp> struct __libcpp_remove_objc_qualifiers { typedef _Tp type; };
 template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_pointer     : public __libcpp_is_pointer<typename __libcpp_remove_objc_qualifiers<typename remove_cv<_Tp>::type>::type> {};
 template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_lvalue_reference : public false_type {};
 template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_lvalue_reference<_Tp&> : public true_type {};
 template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_rvalue_reference : public false_type {};
 template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_rvalue_reference<_Tp&&> : public true_type {};
 template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_reference : public false_type {};
 template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_union     : public integral_constant<bool, __is_union(_Tp)> {};
 template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_class     : public integral_constant<bool, __is_class(_Tp)> {};
 template <class _Tp, class _Up> struct __attribute__ ((__type_visibility__("default"))) is_same : public false_type {};
 template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_same<_Tp, _Tp> : public true_type {};
 namespace __libcpp_is_function_imp { struct __dummy_type {}; template <class _Tp> char __test(_Tp*); template <class _Tp> char __test(__dummy_type); template <class _Tp> __two __test(...); template <class _Tp> _Tp& __source(int); ; }
 template <class _Tp, bool = is_class<_Tp>::value ||                             is_union<_Tp>::value ||                             is_void<_Tp>::value ||                             is_reference<_Tp>::value ||                             __is_nullptr_t<_Tp>::value > struct __libcpp_is_function     : public integral_constant<bool, sizeof(__libcpp_is_function_imp::__test<_Tp>(__libcpp_is_function_imp::__source<_Tp>(0))) == 1>     {};
 template <class _Tp> struct __libcpp_is_function<_Tp, true> : public false_type {};
 template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_function     : public __libcpp_is_function<_Tp> {};
 template <class _MP, bool _IsMemberFunctionPtr, bool _IsMemberObjectPtr> struct __member_pointer_traits_imp { };
 template <class _Tp> struct __libcpp_is_member_function_pointer     : public false_type {};
 template <class _Ret, class _Class> struct __libcpp_is_member_function_pointer<_Ret _Class::*>     : public is_function<_Ret> {};
 template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_member_function_pointer     : public __libcpp_is_member_function_pointer<typename remove_cv<_Tp>::type>::type {};
 template <class _Tp> struct __libcpp_is_member_pointer : public false_type {};
 template <class _Tp, class _Up> struct __libcpp_is_member_pointer<_Tp _Up::*> : public true_type {};
 template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_member_pointer     : public __libcpp_is_member_pointer<typename remove_cv<_Tp>::type> {};
 template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_member_object_pointer     : public integral_constant<bool, is_member_pointer<_Tp>::value &&                                     !is_member_function_pointer<_Tp>::value> {};
 template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_enum     : public integral_constant<bool, __is_enum(_Tp)> {};
 template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_arithmetic     : public integral_constant<bool, is_integral<_Tp>::value ||                                      is_floating_point<_Tp>::value> {};
 template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_fundamental     : public integral_constant<bool, is_void<_Tp>::value ||                                      __is_nullptr_t<_Tp>::value ||                                      is_arithmetic<_Tp>::value> {};
 template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_scalar     : public integral_constant<bool, is_arithmetic<_Tp>::value ||                                      is_member_pointer<_Tp>::value ||                                      is_pointer<_Tp>::value ||                                      __is_nullptr_t<_Tp>::value ||                                      is_enum<_Tp>::value > {};
 template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_compound     : public integral_constant<bool, !is_fundamental<_Tp>::value> {};
 struct __is_referenceable_impl {     template <class _Tp> static _Tp& __test(int);     ; };
 template <class _Tp> struct __is_referenceable : integral_constant<bool,     !is_same<decltype(__is_referenceable_impl::__test<_Tp>(0)), __two>::value> {};
 template <class _Tp, bool = is_reference<_Tp>::value ||                             is_function<_Tp>::value ||                             is_const<_Tp>::value > struct __add_const {typedef _Tp type;};
 template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_reference {typedef _Tp type;};
 template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_reference<_Tp&> {typedef _Tp type;};
 template <class _Tp, bool = __is_referenceable<_Tp>::value> struct __add_rvalue_reference_impl { typedef _Tp type; };
 template <class _Tp > struct __add_rvalue_reference_impl<_Tp, true> { typedef _Tp&& type; };
 template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) add_rvalue_reference {typedef typename __add_rvalue_reference_impl<_Tp>::type type;};
 template <class _Tp> _Tp&& __declval(int);
 ;
 template <class _Tp> decltype(std::__1::__declval<_Tp>(0)) declval() noexcept;
 template <class _Tp,         bool = __is_referenceable<_Tp>::value ||                 is_same<typename remove_cv<_Tp>::type, void>::value> struct __add_pointer_impl     {typedef typename remove_reference<_Tp>::type* type;};
 template <class _Tp> struct __add_pointer_impl<_Tp, false>     {typedef _Tp type;};
 template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) add_pointer     {typedef typename __add_pointer_impl<_Tp>::type type;};
 template <class _Tp, bool = is_integral<_Tp>::value> struct __libcpp_is_signed_impl : public integral_constant<bool,(_Tp(-1) < _Tp(0))> {};
 template <class _Tp, unsigned _Ip = 0> struct __attribute__ ((__type_visibility__("default"))) extent     : public integral_constant<size_t, 0> {};
 template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) extent<_Tp[], 0>     : public integral_constant<size_t, 0> {};
 template <class _Tp, size_t _Np, unsigned _Ip> struct __attribute__ ((__type_visibility__("default"))) extent<_Tp[_Np], _Ip>     : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};
 template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_extent     {typedef _Tp type;};
 template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_all_extents     {typedef _Tp type;};
 template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_all_extents<_Tp[]>     {typedef typename remove_all_extents<_Tp>::type type;};
 template <class _Tp, size_t _Np> struct __attribute__ ((__type_visibility__("default"))) remove_all_extents<_Tp[_Np]>     {typedef typename remove_all_extents<_Tp>::type type;};
 template <class _Up, bool> struct __decay {     typedef typename remove_cv<_Up>::type type; };
 template <class _Up> struct __decay<_Up, true> { public:     typedef typename conditional                      <                          is_array<_Up>::value,                          typename remove_extent<_Up>::type*,                          typename conditional                          <                               is_function<_Up>::value,                               typename add_pointer<_Up>::type,                               typename remove_cv<_Up>::type                          >::type                      >::type type; };
 template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) decay { private:     typedef typename remove_reference<_Tp>::type _Up; public:     typedef typename __decay<_Up, __is_referenceable<_Up>::value>::type type; };
 template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_abstract     : public integral_constant<bool, __is_abstract(_Tp)> {};
 template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) __libcpp_is_final : public integral_constant<bool, __is_final(_Tp)> {};
 template <class _Bp, class _Dp> struct __attribute__ ((__type_visibility__("default"))) is_base_of     : public integral_constant<bool, __is_base_of(_Bp, _Dp)> {};
 template <class _T1, class _T2> struct __attribute__ ((__type_visibility__("default"))) is_convertible     : public integral_constant<bool, __is_convertible_to(_T1, _T2) &&                                      !is_abstract<_T2>::value> {};
 template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_empty     : public integral_constant<bool, __is_empty(_Tp)> {};
 template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_polymorphic     : public integral_constant<bool, __is_polymorphic(_Tp)> {};
 template <class _Hp, class _Tp> struct __type_list {     typedef _Hp _Head;     typedef _Tp _Tail; };
 struct __nat {                     };
 typedef     __type_list<unsigned char,     __type_list<unsigned short,     __type_list<unsigned int,     __type_list<unsigned long,     __type_list<unsigned long long,     __type_list<__uint128_t,     __nat     >     > > > > > __unsigned_types;
 template <class _TypeList, size_t _Size, bool = _Size <= sizeof(typename _TypeList::_Head)> struct __find_first;
 template <class _Tp, class _Up, bool = is_const<typename remove_reference<_Tp>::type>::value,                              bool = is_volatile<typename remove_reference<_Tp>::type>::value> struct __apply_cv {     typedef _Up type; };
 template <class _Tp, class _Up> struct __apply_cv<_Tp, _Up, true, false> {     typedef const _Up type; };
 template <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value> struct __make_unsigned {};
 template <class _Tp> struct __make_unsigned<_Tp, true> {     typedef typename __find_first<__unsigned_types, sizeof(_Tp)>::type type; };
 template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) make_unsigned {     typedef typename __apply_cv<_Tp, typename __make_unsigned<typename remove_cv<_Tp>::type>::type>::type type; };
 template <class ..._Tp> struct __attribute__ ((__type_visibility__("default"))) common_type {};
 template<typename, typename _Tp> struct __select_2nd { typedef _Tp type; };
 template <class _Tp, class _Arg> typename __select_2nd<decltype((std::__1::declval<_Tp>() = std::__1::declval<_Arg>())), true_type>::type __is_assignable_test(int);
 ;
 template <class _Tp, class _Arg, bool = is_void<_Tp>::value || is_void<_Arg>::value> struct __is_assignable_imp     : public decltype((std::__1::__is_assignable_test<_Tp, _Arg>(0))) {};
 template <class _Tp, class _Arg> struct __is_assignable_imp<_Tp, _Arg, true>     : public false_type { };
 template <class _Tp, class _Arg> struct is_assignable     : public __is_assignable_imp<_Tp, _Arg> {};
 template <class _Tp>  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr _Tp&& forward(typename remove_reference<_Tp>::type& __t) noexcept ;
  ;
 template <class _DecayedFp> struct __member_pointer_class_type {};
 template <class _Ret, class _ClassType> struct __member_pointer_class_type<_Ret _ClassType::*> {   typedef _ClassType type; };
 template <class _Tp, class ..._Args> struct __attribute__ ((__type_visibility__("default"))) is_constructible     : public integral_constant<bool, __is_constructible(_Tp, _Args...)>     {};
 template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_default_constructible     : public is_constructible<_Tp>     {};
 template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_standard_layout     : public integral_constant<bool, __is_standard_layout(_Tp)>     {};
 template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_copyable     : public integral_constant<bool, __is_trivially_copyable(_Tp)>     {};
 template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivial     : public integral_constant<bool, __is_trivial(_Tp)>     {};
 template <class _Tp> struct __is_reference_wrapper_impl : public false_type {};
 template <class _Tp> struct __is_reference_wrapper_impl<reference_wrapper<_Tp> > : public true_type {};
 template <class _Tp> struct __is_reference_wrapper     : public __is_reference_wrapper_impl<typename remove_cv<_Tp>::type> {};
 template <class _Fp, class _A0,          class _DecayFp = typename decay<_Fp>::type,          class _DecayA0 = typename decay<_A0>::type> using __enable_if_bullet5 = typename enable_if     <         is_member_object_pointer<_DecayFp>::value         && __is_reference_wrapper<_DecayA0>::value     >::type;
 template <class _Fp, class _A0,          class _DecayFp = typename decay<_Fp>::type,          class _DecayA0 = typename decay<_A0>::type,          class _ClassT = typename __member_pointer_class_type<_DecayFp>::type> using __enable_if_bullet6 = typename enable_if     <         is_member_object_pointer<_DecayFp>::value         && !is_base_of<_ClassT, _DecayA0>::value         && !__is_reference_wrapper<_DecayA0>::value     >::type;
 template <class _Fp, class _A0,           class = __enable_if_bullet6<_Fp, _A0>>  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr auto __invoke_constexpr(_Fp&& __f, _A0&& __a0) noexcept(noexcept((*std::__1::forward<_A0>(__a0)).*__f)) -> decltype((*std::__1::forward<_A0>(__a0)).*__f) ;
 template <class _Fp, class ..._Args>  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) auto __invoke(_Fp&& __f, _Args&& ...__args) noexcept(noexcept(std::__1::forward<_Fp>(__f)(std::__1::forward<_Args>(__args)...))) -> decltype(std::__1::forward<_Fp>(__f)(std::__1::forward<_Args>(__args)...)) ;
 template <class _Fp, class ..._Args>  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr auto __invoke_constexpr(_Fp&& __f, _Args&& ...__args) noexcept(noexcept(std::__1::forward<_Fp>(__f)(std::__1::forward<_Args>(__args)...))) -> decltype(std::__1::forward<_Fp>(__f)(std::__1::forward<_Args>(__args)...)) ;
 template <class _Ret, class _Fp, class ..._Args> struct __invokable_r {     using _Result = decltype(         std::__1::__invoke(std::__1::declval<_Fp>(), std::__1::declval<_Args>()...));     using type =         typename conditional<             !is_same<_Result, __nat>::value,             typename conditional<                 is_void<_Ret>::value,                 true_type,                 is_convertible<_Result, _Ret>             >::type,             false_type         >::type;     static const bool value = type::value; };
 template <class _Fp, class ..._Args> using __invokable = __invokable_r<void, _Fp, _Args...>;
    ;
 }
  class __attribute__ ((__visibility__("default"))) exception {
 public:     __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) exception() noexcept ;
           };
  }
   typedef __darwin_mbstate_t mbstate_t;
   struct __sbuf {
  }
   FILE;
   typedef __darwin_wint_t wint_t;
   namespace std {
  inline namespace __1 {
 class __attribute__ ((__visibility__("default"))) ios_base;
 template<class _CharT> struct __attribute__ ((__type_visibility__("default"))) char_traits;
 template<class _Tp> class __attribute__ ((__type_visibility__("default"))) allocator;
 template <class _CharT, class _Traits = char_traits<_CharT> >     class __attribute__ ((__type_visibility__("default"))) basic_ios;
 template <class _CharT, class _Traits = char_traits<_CharT> >     class __attribute__ ((__type_visibility__("default"))) basic_streambuf;
 template <class _CharT, class _Traits = char_traits<_CharT> >     class __attribute__ ((__type_visibility__("default"))) basic_istream;
 template <class _CharT, class _Traits = char_traits<_CharT> >     class __attribute__ ((__type_visibility__("default"))) basic_ostream;
 template <class _CharT, class _Traits = char_traits<_CharT> >     class __attribute__ ((__type_visibility__("default"))) basic_iostream;
 template <class _State> class __attribute__ ((__type_visibility__("default"))) fpos;
 typedef fpos<mbstate_t> streampos;
 typedef fpos<mbstate_t> u32streampos;
 typedef long long streamoff;
 template <class _CharT,           class _Traits = char_traits<_CharT>,           class _Allocator = allocator<_CharT> >     class __attribute__ ((__type_visibility__("default"))) basic_string;
 typedef basic_string<char, char_traits<char>, allocator<char> > string;
 template <class _Arg1, class _Arg2, class _Result> struct __attribute__ ((__type_visibility__("default"))) binary_function {     typedef _Arg1 first_argument_type;     typedef _Arg2 second_argument_type;     typedef _Result result_type; };
 template <class _Tp> struct __has_result_type { private:     struct __two {char __lx; char __lxx;};     template <class _Up> static __two __test(...);     ; public:     static const bool value = sizeof(__test<_Tp>(0)) == 1; };
 template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) less : binary_function<_Tp, _Tp, bool> {                                   __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))     bool operator()(const _Tp& __x, const _Tp& __y) const         ; };
 template <class _Tp> struct __derives_from_unary_function { private:     struct __two {char __lx; char __lxx;};          ; public:     static const bool value = !is_same<decltype(__test((_Tp*)0)), __two>::value;     typedef decltype(__test((_Tp*)0)) type; };
 struct __attribute__ ((__type_visibility__("default"))) input_iterator_tag {};
 struct __attribute__ ((__type_visibility__("default"))) output_iterator_tag {};
 struct __attribute__ ((__type_visibility__("default"))) forward_iterator_tag : public input_iterator_tag {};
 struct __attribute__ ((__type_visibility__("default"))) bidirectional_iterator_tag : public forward_iterator_tag {};
 struct __attribute__ ((__type_visibility__("default"))) random_access_iterator_tag : public bidirectional_iterator_tag {};
 template <class _Tp> struct __has_iterator_typedefs { private:     struct __two {char __lx; char __lxx;};     ;     ; public:     static const bool value = sizeof(__test<_Tp>(0,0,0,0,0)) == 1; };
 template <class _Tp> struct __has_iterator_category { private:     struct __two {char __lx; char __lxx;};     ;     ; public:     static const bool value = sizeof(__test<_Tp>(0)) == 1; };
 template <class _Iter, bool> struct __iterator_traits_impl {};
 template <class _Iter> struct __iterator_traits_impl<_Iter, true> {     typedef typename _Iter::difference_type difference_type;     typedef typename _Iter::value_type value_type;     typedef typename _Iter::pointer pointer;     typedef typename _Iter::reference reference;     typedef typename _Iter::iterator_category iterator_category; };
 template <class _Iter, bool> struct __iterator_traits {};
 template <class _Iter> struct __attribute__ ((__type_visibility__("default"))) iterator_traits     : __iterator_traits<_Iter, __has_iterator_typedefs<_Iter>::value> {};
 template<class _Category, class _Tp, class _Distance = ptrdiff_t,          class _Pointer = _Tp*, class _Reference = _Tp&> struct __attribute__ ((__type_visibility__("default"))) iterator {     typedef _Tp value_type;     typedef _Distance difference_type;     typedef _Pointer pointer;     typedef _Reference reference;     typedef _Category iterator_category; };
 template <class _Tp, class = void> struct __is_stashing_iterator : false_type {};
 template <class _Iter> class __attribute__ ((__type_visibility__("default"))) reverse_iterator     : public iterator<typename iterator_traits<_Iter>::iterator_category,                       typename iterator_traits<_Iter>::value_type,                       typename iterator_traits<_Iter>::difference_type,                       typename iterator_traits<_Iter>::pointer,                       typename iterator_traits<_Iter>::reference> { private:      _Iter __t;     static_assert(!__is_stashing_iterator<_Iter>::value,       "The specified iterator type cannot be used with reverse_iterator; "       "Using stashing iterators with reverse_iterator causes undefined behavior"); protected:     _Iter current; public:     typedef _Iter iterator_type;     typedef typename iterator_traits<_Iter>::difference_type difference_type;     typedef typename iterator_traits<_Iter>::reference reference;     typedef typename iterator_traits<_Iter>::pointer pointer;                ;                  ;          __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))     reference operator*() const ;     __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))     pointer operator->() const ;     __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))     reverse_iterator& operator++() ;     __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))     reverse_iterator operator++(int) ;     __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))     reverse_iterator& operator--() ;                               };
 template <class _Tp, class = void> struct __has_element_type : false_type {};
 template <class _Ptr, bool = __has_element_type<_Ptr>::value> struct __pointer_traits_element_type;
 template <class _Tp, class = void> struct __has_difference_type : false_type {};
 template <class _Ptr, bool = __has_difference_type<_Ptr>::value> struct __pointer_traits_difference_type {     typedef ptrdiff_t type; };
 template <class _Tp, class _Up> struct __has_rebind { private:     struct __two {char __lx; char __lxx;};     ;     template <class _Xp> static char __test(typename _Xp::template rebind<_Up>* = 0); public:     static const bool value = sizeof(__test<_Tp>(0)) == 1; };
 template <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value> struct __pointer_traits_rebind {     typedef typename _Tp::template rebind<_Up> type; };
 template <class _Ptr> struct __attribute__ ((__type_visibility__("default"))) pointer_traits {     typedef _Ptr pointer;     typedef typename __pointer_traits_element_type<pointer>::type element_type;     typedef typename __pointer_traits_difference_type<pointer>::type difference_type;     template <class _Up> using rebind = typename __pointer_traits_rebind<pointer, _Up>::type; private:     struct __nat {}; public:      };
 template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) pointer_traits<_Tp*> {     typedef _Tp* pointer;     typedef _Tp element_type;     typedef ptrdiff_t difference_type;     template <class _Up> using rebind = _Up*; private:     struct __nat {}; public:      };
 template <class _From, class _To> struct __rebind_pointer {     typedef typename pointer_traits<_From>::template rebind<_To> type; };
 template <class _Tp, class = void> struct __has_pointer_type : false_type {};
 namespace __pointer_type_imp { template <class _Tp, class _Dp, bool = __has_pointer_type<_Dp>::value> struct __pointer_type {     typedef typename _Dp::pointer type; }; template <class _Tp, class _Dp> struct __pointer_type<_Tp, _Dp, false> {     typedef _Tp* type; }; }
 template <class _Tp, class _Dp> struct __pointer_type {     typedef typename __pointer_type_imp::__pointer_type<_Tp, typename remove_reference<_Dp>::type>::type type; };
 template <class _Tp, class = void> struct __has_const_pointer : false_type {};
 template <class _Tp, class _Ptr, class _Alloc, bool = __has_const_pointer<_Alloc>::value> struct __const_pointer {     typedef typename _Alloc::const_pointer type; };
 template <class _Tp, class = void> struct __has_void_pointer : false_type {};
 template <class _Ptr, class _Alloc, bool = __has_void_pointer<_Alloc>::value> struct __void_pointer {     typedef typename _Alloc::void_pointer type; };
 template <class _Ptr, class _Alloc> struct __void_pointer<_Ptr, _Alloc, false> {     typedef typename pointer_traits<_Ptr>::template rebind<void> type; };
 template <class _Tp, class = void> struct __has_const_void_pointer : false_type {};
 template <class _Ptr, class _Alloc, bool = __has_const_void_pointer<_Alloc>::value> struct __const_void_pointer {     typedef typename _Alloc::const_void_pointer type; };
 template <class _Ptr, class _Alloc> struct __const_void_pointer<_Ptr, _Alloc, false> {     typedef typename pointer_traits<_Ptr>::template rebind<const void> type; };
 template <class _Tp, class = void> struct __has_size_type : false_type {};
 template <class _Tp> struct __has_size_type<_Tp,                typename __void_t<typename _Tp::size_type>::type> : true_type {};
 template <class _Alloc, class _DiffType, bool = __has_size_type<_Alloc>::value> struct __size_type {     typedef typename make_unsigned<_DiffType>::type type; };
 template <class _Alloc, class _DiffType> struct __size_type<_Alloc, _DiffType, true> {     typedef typename _Alloc::size_type type; };
 template <class _Tp, class = void> struct __has_propagate_on_container_copy_assignment : false_type {};
 template <class _Alloc, bool = __has_propagate_on_container_copy_assignment<_Alloc>::value> struct __propagate_on_container_copy_assignment {     typedef false_type type; };
 template <class _Tp, class = void> struct __has_propagate_on_container_move_assignment : false_type {};
 template <class _Alloc, bool = __has_propagate_on_container_move_assignment<_Alloc>::value> struct __propagate_on_container_move_assignment {     typedef false_type type; };
 template <class _Tp, class = void> struct __has_propagate_on_container_swap : false_type {};
 template <class _Alloc, bool = __has_propagate_on_container_swap<_Alloc>::value> struct __propagate_on_container_swap {     typedef false_type type; };
 template <class _Tp, class = void> struct __has_is_always_equal : false_type {};
 template <class _Alloc, bool = __has_is_always_equal<_Alloc>::value> struct __is_always_equal {     typedef typename std::__1::is_empty<_Alloc>::type type; };
 template <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value> struct __has_rebind_other { private:     struct __two {char __lx; char __lxx;};     template <class _Xp> static __two __test(...);     template <class _Xp> static char __test(typename _Xp::template rebind<_Up>::other* = 0); public:     static const bool value = sizeof(__test<_Tp>(0)) == 1; };
 template <class _Tp, class _Up, bool = __has_rebind_other<_Tp, _Up>::value> struct __allocator_traits_rebind {     typedef typename _Tp::template rebind<_Up>::other type; };
 template <class _Alloc, class _Ptr, bool = __has_difference_type<_Alloc>::value> struct __alloc_traits_difference_type {     typedef typename pointer_traits<_Ptr>::difference_type type; };
 template <class _Alloc> struct __attribute__ ((__type_visibility__("default"))) allocator_traits {     typedef _Alloc allocator_type;     typedef typename allocator_type::value_type value_type;     typedef typename __pointer_type<value_type, allocator_type>::type pointer;     typedef typename __const_pointer<value_type, pointer, allocator_type>::type const_pointer;     typedef typename __void_pointer<pointer, allocator_type>::type void_pointer;     typedef typename __const_void_pointer<pointer, allocator_type>::type const_void_pointer;     typedef typename __alloc_traits_difference_type<allocator_type, pointer>::type difference_type;     typedef typename __size_type<allocator_type, difference_type>::type size_type;     typedef typename __propagate_on_container_copy_assignment<allocator_type>::type                      propagate_on_container_copy_assignment;     typedef typename __propagate_on_container_move_assignment<allocator_type>::type                      propagate_on_container_move_assignment;     typedef typename __propagate_on_container_swap<allocator_type>::type                      propagate_on_container_swap;     typedef typename __is_always_equal<allocator_type>::type                      is_always_equal;     template <class _Tp> using rebind_alloc =                   typename __allocator_traits_rebind<allocator_type, _Tp>::type;     template <class _Tp> using rebind_traits = allocator_traits<rebind_alloc<_Tp>>;                                   __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))     static pointer allocate(allocator_type& __a, size_type __n)         ;                                   __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))     static pointer allocate(allocator_type& __a, size_type __n, const_void_pointer __hint)         ;     __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))     static void deallocate(allocator_type& __a, pointer __p, size_type __n) noexcept         ;     template <class _Tp, class... _Args>         __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))         static void construct(allocator_type& __a, _Tp* __p, _Args&&... __args)             ;     template <class _Tp>         __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))         static void destroy(allocator_type& __a, _Tp* __p)             ;                        ;              ;              ;              ;              ;              ; private:                            ;                  ;                  ;                  ;                     };
 template <class _Traits, class _Tp> struct __rebind_alloc_helper {     typedef typename _Traits::template rebind_alloc<_Tp> type; };
 template <class _Tp> class __attribute__ ((__type_visibility__("default"))) allocator { public:     typedef size_t size_type;     typedef ptrdiff_t difference_type;     typedef _Tp* pointer;     typedef const _Tp* const_pointer;     typedef _Tp& reference;     typedef const _Tp& const_reference;     typedef _Tp value_type;     typedef true_type propagate_on_container_move_assignment;     typedef true_type is_always_equal;     template <class _Up> struct rebind {typedef allocator<_Up> other;};           ;                                                                     ;      };
 template <class _Tp, int _Idx,           bool _CanBeEmptyBase =               is_empty<_Tp>::value && !__libcpp_is_final<_Tp>::value> struct __compressed_pair_elem {   typedef _Tp _ParamT;   typedef _Tp& reference;   typedef const _Tp& const_reference;           ;    ;       private:   _Tp __value_; };
 template <class _T1, class _T2> class __compressed_pair : private __compressed_pair_elem<_T1, 0>,                           private __compressed_pair_elem<_T2, 1> {   typedef __compressed_pair_elem<_T1, 0> _Base1;   typedef __compressed_pair_elem<_T2, 1> _Base2;   static_assert((!is_same<_T1, _T2>::value),     "__compressed_pair cannot be instantated when T1 and T2 are the same type; "     "The current implementation is NOT ABI-compatible with the previous "     "implementation for this configuration"); public:    ;    ;    ;    ;    ;                };
 template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) default_delete {     static_assert(!is_function<_Tp>::value,                   "default_delete cannot be instantiated for function types");       ;    };
 template <class _Deleter> struct __unique_ptr_deleter_sfinae {   static_assert(!is_reference<_Deleter>::value, "incorrect specialization");   typedef const _Deleter& __lval_ref_type;   typedef _Deleter&& __good_rval_ref_type;   typedef true_type __enable_rval_overload; };
 template <class _Tp, class _Dp = default_delete<_Tp> > class __attribute__ ((__type_visibility__("default"))) unique_ptr { public:   typedef _Tp element_type;   typedef _Dp deleter_type;   typedef typename __pointer_type<_Tp, deleter_type>::type pointer;   static_assert(!is_rvalue_reference<deleter_type>::value,                 "the specified deleter type cannot be an rvalue reference"); private:   __compressed_pair<pointer, deleter_type> __ptr_;   struct __nat { int __for_bool_; };   typedef __unique_ptr_deleter_sfinae<_Dp> _DeleterSFINAE;   template <bool _Dummy>   using _LValRefType =       typename __dependent_type<_DeleterSFINAE, _Dummy>::__lval_ref_type;   template <bool _Dummy>   using _GoodRValRefType =       typename __dependent_type<_DeleterSFINAE, _Dummy>::__good_rval_ref_type;   template <bool _Dummy>   using _BadRValRefType =       typename __dependent_type<_DeleterSFINAE, _Dummy>::__bad_rval_ref_type;   template <bool _Dummy, class _Deleter = typename __dependent_type<                              __identity<deleter_type>, _Dummy>::type>   using _EnableIfDeleterDefaultConstructible =       typename enable_if<is_default_constructible<_Deleter>::value &&                          !is_pointer<_Deleter>::value>::type;   template <class _ArgType>   using _EnableIfDeleterConstructible =       typename enable_if<is_constructible<deleter_type, _ArgType>::value>::type;   template <class _UPtr, class _Up>   using _EnableIfMoveConvertible = typename enable_if<       is_convertible<typename _UPtr::pointer, pointer>::value &&       !is_array<_Up>::value   >::type;   template <class _UDel>   using _EnableIfDeleterConvertible = typename enable_if<       (is_reference<_Dp>::value && is_same<_Dp, _UDel>::value) ||       (!is_reference<_Dp>::value && is_convertible<_UDel, _Dp>::value)     >::type;   template <class _UDel>   using _EnableIfDeleterAssignable = typename enable_if<       is_assignable<_Dp&, _UDel&&>::value     >::type; public:    ;    ;    ;    ;   template <bool _Dummy = true,             class = _EnableIfDeleterConstructible<_GoodRValRefType<_Dummy>>>   __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))   unique_ptr(pointer __p, _GoodRValRefType<_Dummy> __d) ;   template <bool _Dummy = true,             class = _EnableIfDeleterConstructible<_BadRValRefType<_Dummy>>>   __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))   unique_ptr(pointer __p, _BadRValRefType<_Dummy> __d) = delete;       ;    ;       ;    ;                                  };
 }
  inline namespace __1 {
 }
    template <typename T>   class refcount   {
   };
  }
   typedef enum : unsigned int {
  QOS_CLASS_USER_INTERACTIVE __attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0))) = 0x21, QOS_CLASS_USER_INITIATED __attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0))) = 0x19, QOS_CLASS_DEFAULT __attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0))) = 0x15, QOS_CLASS_UTILITY __attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0))) = 0x11, QOS_CLASS_BACKGROUND __attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0))) = 0x09, QOS_CLASS_UNSPECIFIED __attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0))) = 0x00, }
   qos_class_t;
   namespace std {
  inline namespace __1 {
 template <class _Pointer> class __tree_end_node;
 template <class _VoidPtr> class __tree_node_base;
 template <class _Tp, class _VoidPtr> class __tree_node;
 template <class _Key, class _Value> struct __value_type;
 template <class _Tp> struct __tree_key_value_types {   typedef _Tp key_type;   typedef _Tp __node_value_type;   typedef _Tp __container_value_type;   static const bool __is_map = false; };
 template <class _Key, class _Tp> struct __tree_key_value_types<__value_type<_Key, _Tp> > {   typedef _Key key_type;   typedef _Tp mapped_type;   typedef __value_type<_Key, _Tp> __node_value_type;   typedef pair<const _Key, _Tp> __container_value_type;   typedef __container_value_type __map_value_type;   static const bool __is_map = true;    ;    ; };
 template <class _VoidPtr> struct __tree_node_base_types {   typedef _VoidPtr __void_pointer;   typedef __tree_node_base<__void_pointer> __node_base_type;   typedef typename __rebind_pointer<_VoidPtr, __node_base_type>::type                                                              __node_base_pointer;   typedef __tree_end_node<__node_base_pointer> __end_node_type;   typedef typename __rebind_pointer<_VoidPtr, __end_node_type>::type                                                              __end_node_pointer;   typedef typename conditional<       is_pointer<__end_node_pointer>::value,         __end_node_pointer,         __node_base_pointer>::type __parent_pointer; private:   static_assert((is_same<typename pointer_traits<_VoidPtr>::element_type, void>::value),                   "_VoidPtr does not point to unqualified void type"); };
 template <class _Tp, class _AllocPtr, class _KVTypes = __tree_key_value_types<_Tp>,          bool = _KVTypes::__is_map> struct __tree_map_pointer_types {};
 template <class _Tp, class _AllocPtr, class _KVTypes> struct __tree_map_pointer_types<_Tp, _AllocPtr, _KVTypes, true> {   typedef typename _KVTypes::__map_value_type _Mv;   typedef typename __rebind_pointer<_AllocPtr, _Mv>::type                                                        __map_value_type_pointer;   typedef typename __rebind_pointer<_AllocPtr, const _Mv>::type                                                  __const_map_value_type_pointer; };
 template <class _NodePtr, class _NodeT = typename pointer_traits<_NodePtr>::element_type> struct __tree_node_types;
 template <class _NodePtr, class _Tp, class _VoidPtr> struct __tree_node_types<_NodePtr, __tree_node<_Tp, _VoidPtr> >     : public __tree_node_base_types<_VoidPtr>,              __tree_key_value_types<_Tp>,              __tree_map_pointer_types<_Tp, _VoidPtr> {   typedef __tree_node_base_types<_VoidPtr> __base;   typedef __tree_key_value_types<_Tp> __key_base;   typedef __tree_map_pointer_types<_Tp, _VoidPtr> __map_pointer_base; public:   typedef typename pointer_traits<_NodePtr>::element_type __node_type;   typedef _NodePtr __node_pointer;   typedef _Tp __node_value_type;   typedef typename __rebind_pointer<_VoidPtr, __node_value_type>::type                                                       __node_value_type_pointer;   typedef typename __rebind_pointer<_VoidPtr, const __node_value_type>::type                                                 __const_node_value_type_pointer;   typedef typename conditional<       is_pointer<__node_pointer>::value,         typename __base::__end_node_pointer,         __node_pointer>::type __iter_pointer; private:     static_assert(!is_const<__node_type>::value,                 "_NodePtr should never be a pointer to const");     static_assert((is_same<typename __rebind_pointer<_VoidPtr, __node_type>::type,                           _NodePtr>::value), "_VoidPtr does not rebind to _NodePtr."); };
 template <class _ValueTp, class _VoidPtr> struct __make_tree_node_types {   typedef typename __rebind_pointer<_VoidPtr, __tree_node<_ValueTp, _VoidPtr> >::type                                                                         _NodePtr;   typedef __tree_node_types<_NodePtr> type; };
 template <class _Pointer> class __tree_end_node { public:     typedef _Pointer pointer;     pointer __left_; };
 template <class _Allocator> class __tree_node_destructor {     typedef _Allocator allocator_type;     typedef allocator_traits<allocator_type> __alloc_traits; public:     typedef typename __alloc_traits::pointer pointer; private:     typedef __tree_node_types<pointer> _NodeTypes;     allocator_type& __na_; public:     bool __value_constructed;     template <class> friend class __map_node_destructor; };
 template <class _Tp, class _NodePtr, class _DiffType> class __attribute__ ((__type_visibility__("default"))) __tree_iterator {     typedef __tree_node_types<_NodePtr> _NodeTypes;     typedef _NodePtr __node_pointer;     typedef typename _NodeTypes::__node_base_pointer __node_base_pointer;     typedef typename _NodeTypes::__end_node_pointer __end_node_pointer;     typedef typename _NodeTypes::__iter_pointer __iter_pointer;     typedef pointer_traits<__node_pointer> __pointer_traits;     __iter_pointer __ptr_; public:     typedef bidirectional_iterator_tag iterator_category;     typedef _Tp value_type;     typedef _DiffType difference_type;     typedef value_type& reference;     typedef typename _NodeTypes::__node_value_type_pointer pointer; private:     template <class, class, class> friend class __tree;     template <class, class, class> friend class __attribute__ ((__type_visibility__("default"))) __tree_const_iterator;     template <class> friend class __attribute__ ((__type_visibility__("default"))) __map_iterator;     template <class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) map;     template <class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) multimap;     template <class, class, class> friend class __attribute__ ((__type_visibility__("default"))) set;     template <class, class, class> friend class __attribute__ ((__type_visibility__("default"))) multiset; };
 template <class _Tp, class _NodePtr, class _DiffType> class __attribute__ ((__type_visibility__("default"))) __tree_const_iterator {     typedef __tree_node_types<_NodePtr> _NodeTypes;     typedef typename _NodeTypes::__node_pointer __node_pointer;     typedef typename _NodeTypes::__node_base_pointer __node_base_pointer;     typedef typename _NodeTypes::__end_node_pointer __end_node_pointer;     typedef typename _NodeTypes::__iter_pointer __iter_pointer;     typedef pointer_traits<__node_pointer> __pointer_traits;     __iter_pointer __ptr_; public:     typedef bidirectional_iterator_tag iterator_category;     typedef _Tp value_type;     typedef _DiffType difference_type;     typedef const value_type& reference;     typedef typename _NodeTypes::__const_node_value_type_pointer pointer; private:     typedef __tree_iterator<value_type, __node_pointer, difference_type>                                                            __non_const_iterator; public: private:     template <class, class, class> friend class __tree;     template <class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) map;     template <class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) multimap;     template <class, class, class> friend class __attribute__ ((__type_visibility__("default"))) set;     template <class, class, class> friend class __attribute__ ((__type_visibility__("default"))) multiset;     template <class> friend class __attribute__ ((__type_visibility__("default"))) __map_const_iterator; };
 template<class _Tp, class _Compare>     __attribute__((diagnose_if(!std::__invokable<_Compare const&, _Tp const&, _Tp const&>::value, "the specified comparator type does not provide a const call operator", "warning"))) int __diagnose_non_const_comparator();
 template <class _Tp, class _Compare, class _Allocator> class __tree { public:     typedef _Tp value_type;     typedef _Compare value_compare;     typedef _Allocator allocator_type; private:     typedef allocator_traits<allocator_type> __alloc_traits;     typedef typename __make_tree_node_types<value_type,         typename __alloc_traits::void_pointer>::type                                                     _NodeTypes;     typedef typename _NodeTypes::key_type key_type; public:     typedef typename _NodeTypes::__node_value_type __node_value_type;     typedef typename _NodeTypes::__container_value_type __container_value_type;     typedef typename __alloc_traits::pointer pointer;     typedef typename __alloc_traits::const_pointer const_pointer;     typedef typename __alloc_traits::size_type size_type;     typedef typename __alloc_traits::difference_type difference_type; public:     typedef typename _NodeTypes::__void_pointer __void_pointer;     typedef typename _NodeTypes::__node_type __node;     typedef typename _NodeTypes::__node_pointer __node_pointer;     typedef typename _NodeTypes::__node_base_type __node_base;     typedef typename _NodeTypes::__node_base_pointer __node_base_pointer;     typedef typename _NodeTypes::__end_node_type __end_node_t;     typedef typename _NodeTypes::__end_node_pointer __end_node_ptr;     typedef typename _NodeTypes::__parent_pointer __parent_pointer;     typedef typename _NodeTypes::__iter_pointer __iter_pointer;     typedef typename __rebind_alloc_helper<__alloc_traits, __node>::type __node_allocator;     typedef allocator_traits<__node_allocator> __node_traits; private:     static_assert((is_same<__node_pointer, typename __node_traits::pointer>::value),                   "Allocator does not rebind pointers in a sane manner.");     typedef typename __rebind_alloc_helper<__node_traits, __node_base>::type         __node_base_allocator;     typedef allocator_traits<__node_base_allocator> __node_base_traits;     static_assert((is_same<__node_base_pointer, typename __node_base_traits::pointer>::value),                  "Allocator does not rebind pointers in a sane manner."); private:     __iter_pointer __begin_node_;     __compressed_pair<__end_node_t, __node_allocator> __pair1_;     __compressed_pair<size_type, value_compare> __pair3_; public: private: public: private: public: public:     typedef __tree_iterator<value_type, __node_pointer, difference_type> iterator;     typedef __tree_const_iterator<value_type, __node_pointer, difference_type> const_iterator;     ;     ;     ;     ;     ;     ;     ;     ;      ;      ;      ;      ;      ;      ;      ;      ;      ;      ;      ;      ;      ;      ;      ;      ;     ;     ;     ;     ;     ;     ;             ;     ;             ;     ;             ;     ;             ;     ;     ;     ;     ;     ;     typedef __tree_node_destructor<__node_allocator> _Dp;     typedef unique_ptr<__node, _Dp> __node_holder; private:     ;      ;     ;     ;     template <class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) map;     template <class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) multimap; };
 }
  inline namespace __1 {
 template <class _Key, class _CP, class _Compare,           bool = is_empty<_Compare>::value && !__libcpp_is_final<_Compare>::value> class __map_value_compare     : private _Compare { public: };
 template <class _Allocator> class __map_node_destructor {     typedef _Allocator allocator_type;     typedef allocator_traits<allocator_type> __alloc_traits; public:     typedef typename __alloc_traits::pointer pointer; private:     allocator_type& __na_; public:     bool __first_constructed;     bool __second_constructed; };
 template <class _TreeIterator> class __attribute__ ((__type_visibility__("default"))) __map_iterator {     typedef typename _TreeIterator::_NodeTypes _NodeTypes;     typedef typename _TreeIterator::__pointer_traits __pointer_traits;     _TreeIterator __i_; public:     typedef bidirectional_iterator_tag iterator_category;     typedef typename _NodeTypes::__map_value_type value_type;     typedef typename _TreeIterator::difference_type difference_type;     typedef value_type& reference;     typedef typename _NodeTypes::__map_value_type_pointer pointer;     template <class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) map;     template <class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) multimap;     template <class> friend class __attribute__ ((__type_visibility__("default"))) __map_const_iterator; };
 template <class _TreeIterator> class __attribute__ ((__type_visibility__("default"))) __map_const_iterator {     typedef typename _TreeIterator::_NodeTypes _NodeTypes;     typedef typename _TreeIterator::__pointer_traits __pointer_traits;     _TreeIterator __i_; public:     typedef bidirectional_iterator_tag iterator_category;     typedef typename _NodeTypes::__map_value_type value_type;     typedef typename _TreeIterator::difference_type difference_type;     typedef const value_type& reference;     typedef typename _NodeTypes::__const_map_value_type_pointer pointer;     template <class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) map;     template <class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) multimap;     template <class, class, class> friend class __attribute__ ((__type_visibility__("default"))) __tree_const_iterator; };
 template <class _Key, class _Tp, class _Compare = less<_Key>,           class _Allocator = allocator<pair<const _Key, _Tp> > > class __attribute__ ((__type_visibility__("default"))) map { public:     typedef _Key key_type;     typedef _Tp mapped_type;     typedef pair<const key_type, mapped_type> value_type;     typedef _Compare key_compare;     typedef _Allocator allocator_type;     typedef value_type& reference;     typedef const value_type& const_reference;     static_assert(sizeof(__diagnose_non_const_comparator<_Key, _Compare>()), "");     static_assert((is_same<typename allocator_type::value_type, value_type>::value),                   "Allocator::value_type must be same type as value_type");     class __attribute__ ((__type_visibility__("default"))) value_compare         : public binary_function<value_type, value_type, bool>     {         friend class map;     protected:         key_compare comp;     public:     }; private:     typedef std::__1::__value_type<key_type, mapped_type> __value_type;     typedef __map_value_compare<key_type, __value_type, key_compare> __vc;     typedef typename __rebind_alloc_helper<allocator_traits<allocator_type>,                                                  __value_type>::type __allocator_type;     typedef __tree<__value_type, __vc, __allocator_type> __base;     typedef typename __base::__node_traits __node_traits;     typedef allocator_traits<allocator_type> __alloc_traits;     __base __tree_; public:     typedef typename __alloc_traits::pointer pointer;     typedef typename __alloc_traits::const_pointer const_pointer;     typedef typename __alloc_traits::size_type size_type;     typedef typename __alloc_traits::difference_type difference_type;     typedef __map_iterator<typename __base::iterator> iterator;     typedef __map_const_iterator<typename __base::const_iterator> const_iterator;     typedef std::__1::reverse_iterator<iterator> reverse_iterator;     typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;     template <class _Key2, class _Value2, class _Comp2, class _Alloc2>         friend class __attribute__ ((__type_visibility__("default"))) map;     template <class _Key2, class _Value2, class _Comp2, class _Alloc2>         friend class __attribute__ ((__type_visibility__("default"))) multimap;         ;         ;      ;      ;             ;             ;         ; private:     typedef typename __base::__node __node;     typedef typename __base::__node_allocator __node_allocator;     typedef typename __base::__node_pointer __node_pointer;     typedef typename __base::__node_base_pointer __node_base_pointer;     typedef typename __base::__parent_pointer __parent_pointer;     typedef __map_node_destructor<__node_allocator> _Dp;     typedef unique_ptr<__node, _Dp> __node_holder; };
 }
  }
   namespace octave {
    namespace mach_info   {
   }
    class   base_stream   {
   };
    class   stream   {
   public:   private:     typedef std::map<int, stream> ostrl_map;
     mutable ostrl_map::const_iterator lookup_cache;
   };
  }
