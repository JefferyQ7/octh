# 1 "<built-in>" 1
# 1 "<built-in>" 3
namespace std {   typedef long unsigned int size_t;   typedef long int ptrdiff_t;   typedef decltype(nullptr) nullptr_t; }
 namespace std {   inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { } }
 namespace __gnu_cxx {   inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { } }
 typedef unsigned char __u_char;
 typedef unsigned short int __u_short;
 typedef unsigned int __u_int;
 typedef unsigned long int __u_long;
 typedef signed char __int8_t;
 typedef unsigned char __uint8_t;
 typedef signed short int __int16_t;
 typedef unsigned short int __uint16_t;
 typedef signed int __int32_t;
 typedef unsigned int __uint32_t;
 typedef signed long int __int64_t;
 typedef unsigned long int __uint64_t;
 typedef __int8_t __int_least8_t;
 typedef __uint8_t __uint_least8_t;
 typedef __int16_t __int_least16_t;
 typedef __uint16_t __uint_least16_t;
 typedef __int32_t __int_least32_t;
 typedef __uint32_t __uint_least32_t;
 typedef __int64_t __int_least64_t;
 typedef __uint64_t __uint_least64_t;
 typedef long int __quad_t;
 typedef unsigned long int __u_quad_t;
 typedef long int __intmax_t;
 typedef unsigned long int __uintmax_t;
 typedef unsigned long int __dev_t;
  typedef unsigned int __uid_t;
  typedef unsigned int __gid_t;
  typedef unsigned long int __ino_t;
  typedef unsigned long int __ino64_t;
  typedef unsigned int __mode_t;
  typedef unsigned long int __nlink_t;
  typedef long int __off_t;
  typedef long int __off64_t;
  typedef int __pid_t;
  typedef struct { int __val[2]; }
 __fsid_t;
  typedef long int __clock_t;
  typedef unsigned long int __rlim_t;
  typedef unsigned long int __rlim64_t;
  typedef unsigned int __id_t;
  typedef long int __time_t;
  typedef unsigned int __useconds_t;
  typedef long int __suseconds_t;
  typedef int __daddr_t;
  typedef int __key_t;
  typedef int __clockid_t;
 typedef void * __timer_t;
 typedef long int __blksize_t;
 typedef long int __blkcnt_t;
 typedef long int __blkcnt64_t;
 typedef unsigned long int __fsblkcnt_t;
 typedef unsigned long int __fsblkcnt64_t;
 typedef unsigned long int __fsfilcnt_t;
 typedef unsigned long int __fsfilcnt64_t;
 typedef long int __fsword_t;
 typedef long int __ssize_t;
  typedef long int __syscall_slong_t;
 typedef unsigned long int __syscall_ulong_t;
 typedef __off64_t __loff_t;
  typedef char *__caddr_t;
 typedef long int __intptr_t;
 typedef unsigned int __socklen_t;
 typedef int __sig_atomic_t;
 typedef __int8_t int8_t;
 typedef __int16_t int16_t;
 typedef __int32_t int32_t;
 typedef __int64_t int64_t;
 typedef __uint8_t uint8_t;
 typedef __uint16_t uint16_t;
 typedef __uint32_t uint32_t;
 typedef __uint64_t uint64_t;
 typedef __int_least8_t int_least8_t;
 typedef __int_least16_t int_least16_t;
 typedef __int_least32_t int_least32_t;
 typedef __int_least64_t int_least64_t;
 typedef __uint_least8_t uint_least8_t;
 typedef __uint_least16_t uint_least16_t;
 typedef __uint_least32_t uint_least32_t;
 typedef __uint_least64_t uint_least64_t;
 typedef signed char int_fast8_t;
 typedef long int int_fast16_t;
 typedef long int int_fast32_t;
 typedef long int int_fast64_t;
 typedef unsigned char uint_fast8_t;
 typedef unsigned long int uint_fast16_t;
 typedef unsigned long int uint_fast32_t;
 typedef unsigned long int uint_fast64_t;
 typedef long int intptr_t;
 typedef unsigned long int uintptr_t;
 typedef __intmax_t intmax_t;
 typedef __uintmax_t uintmax_t;
 namespace std {   using ::int8_t;   using ::int16_t;   using ::int32_t;   using ::int64_t;   using ::int_fast8_t;   using ::int_fast16_t;   using ::int_fast32_t;   using ::int_fast64_t;   using ::int_least8_t;   using ::int_least16_t;   using ::int_least32_t;   using ::int_least64_t;   using ::intmax_t;   using ::intptr_t;   using ::uint8_t;   using ::uint16_t;   using ::uint32_t;   using ::uint64_t;   using ::uint_fast8_t;   using ::uint_fast16_t;   using ::uint_fast32_t;   using ::uint_fast64_t;   using ::uint_least8_t;   using ::uint_least16_t;   using ::uint_least32_t;   using ::uint_least64_t;   using ::uintmax_t;   using ::uintptr_t; }
   ;
 typedef int64_t octave_idx_type;
 typedef int32_t octave_f77_int_type;
 extern "C" { ; ; ; }
 typedef long int ptrdiff_t;
 typedef long unsigned int size_t;
 typedef struct {   long long __clang_max_align_nonce1       __attribute__((__aligned__(__alignof__(long long))));   long double __clang_max_align_nonce2       __attribute__((__aligned__(__alignof__(long double)))); }
 max_align_t;
 extern "C++" { namespace std {   using ::max_align_t; } }
  namespace std __attribute__ ((__visibility__ ("default"))) {   namespace rel_ops   {            ;            ;            ;            ;   }  }
  namespace std __attribute__ ((__visibility__ ("default"))) {        ; }
  namespace std __attribute__ ((__visibility__ ("default"))) {   template<typename _Tp, _Tp __v>     struct integral_constant     {       static constexpr _Tp value = __v;       typedef _Tp value_type;       typedef integral_constant<_Tp, __v> type;            };   template<typename _Tp, _Tp __v>     constexpr _Tp integral_constant<_Tp, __v>::value;   typedef integral_constant<bool, true> true_type;   typedef integral_constant<bool, false> false_type;   template<bool __v>     using __bool_constant = integral_constant<bool, __v>;   template<bool, typename, typename>     struct conditional;   template<typename...>     struct __or_;   template<>     struct __or_<>     : public false_type     { };   template<typename _B1>     struct __or_<_B1>     : public _B1     { };   template<typename _B1, typename _B2>     struct __or_<_B1, _B2>     : public conditional<_B1::value, _B1, _B2>::type     { };   template<typename _B1, typename _B2, typename _B3, typename... _Bn>     struct __or_<_B1, _B2, _B3, _Bn...>     : public conditional<_B1::value, _B1, __or_<_B2, _B3, _Bn...>>::type     { };   template<typename...>     struct __and_;   template<>     struct __and_<>     : public true_type     { };   template<typename _B1>     struct __and_<_B1>     : public _B1     { };   template<typename _B1, typename _B2>     struct __and_<_B1, _B2>     : public conditional<_B1::value, _B2, _B1>::type     { };   template<typename _B1, typename _B2, typename _B3, typename... _Bn>     struct __and_<_B1, _B2, _B3, _Bn...>     : public conditional<_B1::value, __and_<_B2, _B3, _Bn...>, _B1>::type     { };   template<typename _Pp>     struct __not_     : public __bool_constant<!bool(_Pp::value)>     { };   template<typename _Tp>     struct __success_type     { typedef _Tp type; };   struct __failure_type   { };   template<typename>     struct remove_cv;   template<typename>     struct __is_void_helper     : public false_type { };   template<>     struct __is_void_helper<void>     : public true_type { };   template<typename _Tp>     struct is_void     : public __is_void_helper<typename remove_cv<_Tp>::type>::type     { };   template<typename>     struct __is_integral_helper     : public false_type { };   template<>     struct __is_integral_helper<bool>     : public true_type { };   template<>     struct __is_integral_helper<char>     : public true_type { };   template<>     struct __is_integral_helper<signed char>     : public true_type { };   template<>     struct __is_integral_helper<unsigned char>     : public true_type { };   template<>     struct __is_integral_helper<wchar_t>     : public true_type { };   template<>     struct __is_integral_helper<char16_t>     : public true_type { };   template<>     struct __is_integral_helper<char32_t>     : public true_type { };   template<>     struct __is_integral_helper<short>     : public true_type { };   template<>     struct __is_integral_helper<unsigned short>     : public true_type { };   template<>     struct __is_integral_helper<int>     : public true_type { };   template<>     struct __is_integral_helper<unsigned int>     : public true_type { };   template<>     struct __is_integral_helper<long>     : public true_type { };   template<>     struct __is_integral_helper<unsigned long>     : public true_type { };   template<>     struct __is_integral_helper<long long>     : public true_type { };   template<>     struct __is_integral_helper<unsigned long long>     : public true_type { };   template<>     struct __is_integral_helper<__int128>     : public true_type { };   template<>     struct __is_integral_helper<unsigned __int128>     : public true_type { };   template<typename _Tp>     struct is_integral     : public __is_integral_helper<typename remove_cv<_Tp>::type>::type     { };   template<typename>     struct __is_floating_point_helper     : public false_type { };   template<>     struct __is_floating_point_helper<float>     : public true_type { };   template<>     struct __is_floating_point_helper<double>     : public true_type { };   template<>     struct __is_floating_point_helper<long double>     : public true_type { };   template<>     struct __is_floating_point_helper<__float128>     : public true_type { };   template<typename _Tp>     struct is_floating_point     : public __is_floating_point_helper<typename remove_cv<_Tp>::type>::type     { };   template<typename>     struct is_array     : public false_type { };   template<typename _Tp, std::size_t _Size>     struct is_array<_Tp[_Size]>     : public true_type { };   template<typename _Tp>     struct is_array<_Tp[]>     : public true_type { };   template<typename>     struct __is_pointer_helper     : public false_type { };   template<typename _Tp>     struct __is_pointer_helper<_Tp*>     : public true_type { };   template<typename _Tp>     struct is_pointer     : public __is_pointer_helper<typename remove_cv<_Tp>::type>::type     { };   template<typename>     struct is_lvalue_reference     : public false_type { };   template<typename _Tp>     struct is_lvalue_reference<_Tp&>     : public true_type { };   template<typename>     struct is_rvalue_reference     : public false_type { };   template<typename _Tp>     struct is_rvalue_reference<_Tp&&>     : public true_type { };   template<typename>     struct is_function;   template<typename>     struct __is_member_object_pointer_helper     : public false_type { };   template<typename _Tp, typename _Cp>     struct __is_member_object_pointer_helper<_Tp _Cp::*>     : public __not_<is_function<_Tp>>::type { };   template<typename _Tp>     struct is_member_object_pointer     : public __is_member_object_pointer_helper<     typename remove_cv<_Tp>::type>::type     { };   template<typename>     struct __is_member_function_pointer_helper     : public false_type { };   template<typename _Tp, typename _Cp>     struct __is_member_function_pointer_helper<_Tp _Cp::*>     : public is_function<_Tp>::type { };   template<typename _Tp>     struct is_member_function_pointer     : public __is_member_function_pointer_helper<     typename remove_cv<_Tp>::type>::type     { };   template<typename _Tp>     struct is_enum     : public integral_constant<bool, __is_enum(_Tp)>     { };   template<typename _Tp>     struct is_union     : public integral_constant<bool, __is_union(_Tp)>     { };   template<typename _Tp>     struct is_class     : public integral_constant<bool, __is_class(_Tp)>     { };   template<typename>     struct is_function     : public false_type { };   template<typename _Res, typename... _ArgTypes >     struct is_function<_Res(_ArgTypes...) >     : public true_type { };   template<typename _Res, typename... _ArgTypes >     struct is_function<_Res(_ArgTypes...) & >     : public true_type { };   template<typename _Res, typename... _ArgTypes >     struct is_function<_Res(_ArgTypes...) && >     : public true_type { };   template<typename _Res, typename... _ArgTypes >     struct is_function<_Res(_ArgTypes......) >     : public true_type { };   template<typename _Res, typename... _ArgTypes >     struct is_function<_Res(_ArgTypes......) & >     : public true_type { };   template<typename _Res, typename... _ArgTypes >     struct is_function<_Res(_ArgTypes......) && >     : public true_type { };   template<typename _Res, typename... _ArgTypes >     struct is_function<_Res(_ArgTypes...) const >     : public true_type { };   template<typename _Res, typename... _ArgTypes >     struct is_function<_Res(_ArgTypes...) const & >     : public true_type { };   template<typename _Res, typename... _ArgTypes >     struct is_function<_Res(_ArgTypes...) const && >     : public true_type { };   template<typename _Res, typename... _ArgTypes >     struct is_function<_Res(_ArgTypes......) const >     : public true_type { };   template<typename _Res, typename... _ArgTypes >     struct is_function<_Res(_ArgTypes......) const & >     : public true_type { };   template<typename _Res, typename... _ArgTypes >     struct is_function<_Res(_ArgTypes......) const && >     : public true_type { };   template<typename _Res, typename... _ArgTypes >     struct is_function<_Res(_ArgTypes...) volatile >     : public true_type { };   template<typename _Res, typename... _ArgTypes >     struct is_function<_Res(_ArgTypes...) volatile & >     : public true_type { };   template<typename _Res, typename... _ArgTypes >     struct is_function<_Res(_ArgTypes...) volatile && >     : public true_type { };   template<typename _Res, typename... _ArgTypes >     struct is_function<_Res(_ArgTypes......) volatile >     : public true_type { };   template<typename _Res, typename... _ArgTypes >     struct is_function<_Res(_ArgTypes......) volatile & >     : public true_type { };   template<typename _Res, typename... _ArgTypes >     struct is_function<_Res(_ArgTypes......) volatile && >     : public true_type { };   template<typename _Res, typename... _ArgTypes >     struct is_function<_Res(_ArgTypes...) const volatile >     : public true_type { };   template<typename _Res, typename... _ArgTypes >     struct is_function<_Res(_ArgTypes...) const volatile & >     : public true_type { };   template<typename _Res, typename... _ArgTypes >     struct is_function<_Res(_ArgTypes...) const volatile && >     : public true_type { };   template<typename _Res, typename... _ArgTypes >     struct is_function<_Res(_ArgTypes......) const volatile >     : public true_type { };   template<typename _Res, typename... _ArgTypes >     struct is_function<_Res(_ArgTypes......) const volatile & >     : public true_type { };   template<typename _Res, typename... _ArgTypes >     struct is_function<_Res(_ArgTypes......) const volatile && >     : public true_type { };   template<typename>     struct __is_null_pointer_helper     : public false_type { };   template<>     struct __is_null_pointer_helper<std::nullptr_t>     : public true_type { };   template<typename _Tp>     struct is_null_pointer     : public __is_null_pointer_helper<typename remove_cv<_Tp>::type>::type     { };   template<typename _Tp>     struct __is_nullptr_t     : public is_null_pointer<_Tp>     { };   template<typename _Tp>     struct is_reference     : public __or_<is_lvalue_reference<_Tp>,                    is_rvalue_reference<_Tp>>::type     { };   template<typename _Tp>     struct is_arithmetic     : public __or_<is_integral<_Tp>, is_floating_point<_Tp>>::type     { };   template<typename _Tp>     struct is_fundamental     : public __or_<is_arithmetic<_Tp>, is_void<_Tp>,      is_null_pointer<_Tp>>::type     { };   template<typename _Tp>     struct is_object     : public __not_<__or_<is_function<_Tp>, is_reference<_Tp>,                           is_void<_Tp>>>::type     { };   template<typename>     struct is_member_pointer;   template<typename _Tp>     struct is_scalar     : public __or_<is_arithmetic<_Tp>, is_enum<_Tp>, is_pointer<_Tp>,                    is_member_pointer<_Tp>, is_null_pointer<_Tp>>::type     { };   template<typename _Tp>     struct is_compound     : public __not_<is_fundamental<_Tp>>::type { };   template<typename _Tp>     struct __is_member_pointer_helper     : public false_type { };   template<typename _Tp, typename _Cp>     struct __is_member_pointer_helper<_Tp _Cp::*>     : public true_type { };   template<typename _Tp>     struct is_member_pointer     : public __is_member_pointer_helper<typename remove_cv<_Tp>::type>::type     { };   template<typename _Tp>     struct __is_referenceable     : public __or_<is_object<_Tp>, is_reference<_Tp>>::type     { };   template<typename _Res, typename... _Args >     struct __is_referenceable<_Res(_Args...) >     : public true_type     { };   template<typename _Res, typename... _Args >     struct __is_referenceable<_Res(_Args......) >     : public true_type     { };   template<typename>     struct is_const     : public false_type { };   template<typename _Tp>     struct is_const<_Tp const>     : public true_type { };   template<typename>     struct is_volatile     : public false_type { };   template<typename _Tp>     struct is_volatile<_Tp volatile>     : public true_type { };   template<typename _Tp>     struct is_trivial     : public integral_constant<bool, __is_trivial(_Tp)>     { };   template<typename _Tp>     struct is_trivially_copyable     : public integral_constant<bool, __is_trivially_copyable(_Tp)>     { };   template<typename _Tp>     struct is_standard_layout     : public integral_constant<bool, __is_standard_layout(_Tp)>     { };   template<typename _Tp>     struct is_pod     : public integral_constant<bool, __is_pod(_Tp)>     { };   template<typename _Tp>     struct is_literal_type     : public integral_constant<bool, __is_literal_type(_Tp)>     { };   template<typename _Tp>     struct is_empty     : public integral_constant<bool, __is_empty(_Tp)>     { };   template<typename _Tp>     struct is_polymorphic     : public integral_constant<bool, __is_polymorphic(_Tp)>     { };   template<typename _Tp>     struct is_abstract     : public integral_constant<bool, __is_abstract(_Tp)>     { };   template<typename _Tp,     bool = is_arithmetic<_Tp>::value>     struct __is_signed_helper     : public false_type { };   template<typename _Tp>     struct __is_signed_helper<_Tp, true>     : public integral_constant<bool, _Tp(-1) < _Tp(0)>     { };   template<typename _Tp>     struct is_signed     : public __is_signed_helper<_Tp>::type     { };   template<typename _Tp>     struct is_unsigned     : public __and_<is_arithmetic<_Tp>, __not_<is_signed<_Tp>>>     { };   template<typename _Tp, typename _Up = _Tp&&>     _Up     __declval(int);   ;   template<typename _Tp>     auto declval() noexcept -> decltype(__declval<_Tp>(0));   template<typename, unsigned = 0>     struct extent;   template<typename>     struct remove_all_extents;   template<typename _Tp>     struct __is_array_known_bounds     : public integral_constant<bool, (extent<_Tp>::value > 0)>     { };   template<typename _Tp>     struct __is_array_unknown_bounds     : public __and_<is_array<_Tp>, __not_<extent<_Tp>>>     { };   struct __do_is_destructible_impl   {     ;     ;   };   template<typename _Tp>     struct __is_destructible_impl     : public __do_is_destructible_impl     {       typedef decltype(__test<_Tp>(0)) type;     };   template<typename _Tp,            bool = __or_<is_void<_Tp>,                         __is_array_unknown_bounds<_Tp>,                         is_function<_Tp>>::value,            bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>     struct __is_destructible_safe;   template<typename _Tp>     struct __is_destructible_safe<_Tp, false, false>     : public __is_destructible_impl<typename                remove_all_extents<_Tp>::type>::type     { };   template<typename _Tp>     struct __is_destructible_safe<_Tp, true, false>     : public false_type { };   template<typename _Tp>     struct __is_destructible_safe<_Tp, false, true>     : public true_type { };   template<typename _Tp>     struct is_destructible     : public __is_destructible_safe<_Tp>::type     { };   struct __do_is_nt_destructible_impl   {     ;     ;   };   template<typename _Tp>     struct __is_nt_destructible_impl     : public __do_is_nt_destructible_impl     {       typedef decltype(__test<_Tp>(0)) type;     };   template<typename _Tp,            bool = __or_<is_void<_Tp>,                         __is_array_unknown_bounds<_Tp>,                         is_function<_Tp>>::value,            bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>     struct __is_nt_destructible_safe;   template<typename _Tp>     struct __is_nt_destructible_safe<_Tp, false, false>     : public __is_nt_destructible_impl<typename                remove_all_extents<_Tp>::type>::type     { };   template<typename _Tp>     struct __is_nt_destructible_safe<_Tp, true, false>     : public false_type { };   template<typename _Tp>     struct __is_nt_destructible_safe<_Tp, false, true>     : public true_type { };   template<typename _Tp>     struct is_nothrow_destructible     : public __is_nt_destructible_safe<_Tp>::type     { };   template<typename _Tp, typename... _Args>     struct is_constructible       : public __bool_constant<__is_constructible(_Tp, _Args...)>     { };   template<typename _Tp>     struct is_default_constructible     : public is_constructible<_Tp>::type     { };   template<typename _Tp, bool = __is_referenceable<_Tp>::value>     struct __is_copy_constructible_impl;   template<typename _Tp>     struct __is_copy_constructible_impl<_Tp, false>     : public false_type { };   template<typename _Tp>     struct __is_copy_constructible_impl<_Tp, true>     : public is_constructible<_Tp, const _Tp&>     { };   template<typename _Tp>     struct is_copy_constructible     : public __is_copy_constructible_impl<_Tp>     { };   template<typename _Tp, bool = __is_referenceable<_Tp>::value>     struct __is_move_constructible_impl;   template<typename _Tp>     struct __is_move_constructible_impl<_Tp, false>     : public false_type { };   template<typename _Tp>     struct __is_move_constructible_impl<_Tp, true>     : public is_constructible<_Tp, _Tp&&>     { };   template<typename _Tp>     struct is_move_constructible     : public __is_move_constructible_impl<_Tp>     { };   template<typename _Tp>     struct __is_nt_default_constructible_atom     : public integral_constant<bool, noexcept(_Tp())>     { };   template<typename _Tp, bool = is_array<_Tp>::value>     struct __is_nt_default_constructible_impl;   template<typename _Tp>     struct __is_nt_default_constructible_impl<_Tp, true>     : public __and_<__is_array_known_bounds<_Tp>,       __is_nt_default_constructible_atom<typename                       remove_all_extents<_Tp>::type>>     { };   template<typename _Tp>     struct __is_nt_default_constructible_impl<_Tp, false>     : public __is_nt_default_constructible_atom<_Tp>     { };   template<typename _Tp>     struct is_nothrow_default_constructible     : public __and_<is_default_constructible<_Tp>,                     __is_nt_default_constructible_impl<_Tp>>     { };   template<typename _Tp, typename... _Args>     struct __is_nt_constructible_impl     : public integral_constant<bool, noexcept(_Tp(declval<_Args>()...))>     { };   template<typename _Tp, typename _Arg>     struct __is_nt_constructible_impl<_Tp, _Arg>     : public integral_constant<bool,                                noexcept(static_cast<_Tp>(declval<_Arg>()))>     { };   template<typename _Tp>     struct __is_nt_constructible_impl<_Tp>     : public is_nothrow_default_constructible<_Tp>     { };   template<typename _Tp, typename... _Args>     struct is_nothrow_constructible     : public __and_<is_constructible<_Tp, _Args...>,       __is_nt_constructible_impl<_Tp, _Args...>>     { };   template<typename _Tp, bool = __is_referenceable<_Tp>::value>     struct __is_nothrow_copy_constructible_impl;   template<typename _Tp>     struct __is_nothrow_copy_constructible_impl<_Tp, false>     : public false_type { };   template<typename _Tp>     struct __is_nothrow_copy_constructible_impl<_Tp, true>     : public is_nothrow_constructible<_Tp, const _Tp&>     { };   template<typename _Tp>     struct is_nothrow_copy_constructible     : public __is_nothrow_copy_constructible_impl<_Tp>     { };   template<typename _Tp, bool = __is_referenceable<_Tp>::value>     struct __is_nothrow_move_constructible_impl;   template<typename _Tp>     struct __is_nothrow_move_constructible_impl<_Tp, false>     : public false_type { };   template<typename _Tp>     struct __is_nothrow_move_constructible_impl<_Tp, true>     : public is_nothrow_constructible<_Tp, _Tp&&>     { };   template<typename _Tp>     struct is_nothrow_move_constructible     : public __is_nothrow_move_constructible_impl<_Tp>     { };   template<typename _Tp, typename _Up>     struct is_assignable       : public __bool_constant<__is_assignable(_Tp, _Up)>     { };   template<typename _Tp, bool = __is_referenceable<_Tp>::value>     struct __is_copy_assignable_impl;   template<typename _Tp>     struct __is_copy_assignable_impl<_Tp, false>     : public false_type { };   template<typename _Tp>     struct __is_copy_assignable_impl<_Tp, true>     : public is_assignable<_Tp&, const _Tp&>     { };   template<typename _Tp>     struct is_copy_assignable     : public __is_copy_assignable_impl<_Tp>     { };   template<typename _Tp, bool = __is_referenceable<_Tp>::value>     struct __is_move_assignable_impl;   template<typename _Tp>     struct __is_move_assignable_impl<_Tp, false>     : public false_type { };   template<typename _Tp>     struct __is_move_assignable_impl<_Tp, true>     : public is_assignable<_Tp&, _Tp&&>     { };   template<typename _Tp>     struct is_move_assignable     : public __is_move_assignable_impl<_Tp>     { };   template<typename _Tp, typename _Up>     struct __is_nt_assignable_impl     : public integral_constant<bool, noexcept(declval<_Tp>() = declval<_Up>())>     { };   template<typename _Tp, typename _Up>     struct is_nothrow_assignable     : public __and_<is_assignable<_Tp, _Up>,       __is_nt_assignable_impl<_Tp, _Up>>     { };   template<typename _Tp, bool = __is_referenceable<_Tp>::value>     struct __is_nt_copy_assignable_impl;   template<typename _Tp>     struct __is_nt_copy_assignable_impl<_Tp, false>     : public false_type { };   template<typename _Tp>     struct __is_nt_copy_assignable_impl<_Tp, true>     : public is_nothrow_assignable<_Tp&, const _Tp&>     { };   template<typename _Tp>     struct is_nothrow_copy_assignable     : public __is_nt_copy_assignable_impl<_Tp>     { };   template<typename _Tp, bool = __is_referenceable<_Tp>::value>     struct __is_nt_move_assignable_impl;   template<typename _Tp>     struct __is_nt_move_assignable_impl<_Tp, false>     : public false_type { };   template<typename _Tp>     struct __is_nt_move_assignable_impl<_Tp, true>     : public is_nothrow_assignable<_Tp&, _Tp&&>     { };   template<typename _Tp>     struct is_nothrow_move_assignable     : public __is_nt_move_assignable_impl<_Tp>     { };   template<typename _Tp, typename... _Args>     struct is_trivially_constructible     : public __bool_constant<__is_trivially_constructible(_Tp, _Args...)>     { };   template<typename _Tp>     struct is_trivially_default_constructible     : public is_trivially_constructible<_Tp>::type     { };   struct __do_is_implicitly_default_constructible_impl   {     ;     ;        };   template<typename _Tp>     struct __is_implicitly_default_constructible_impl     : public __do_is_implicitly_default_constructible_impl     {       typedef decltype(__test(declval<_Tp>())) type;     };   template<typename _Tp>     struct __is_implicitly_default_constructible_safe     : public __is_implicitly_default_constructible_impl<_Tp>::type     { };   template <typename _Tp>     struct __is_implicitly_default_constructible     : public __and_<is_default_constructible<_Tp>,       __is_implicitly_default_constructible_safe<_Tp>>     { };   template<typename _Tp, bool = __is_referenceable<_Tp>::value>     struct __is_trivially_copy_constructible_impl;   template<typename _Tp>     struct __is_trivially_copy_constructible_impl<_Tp, false>     : public false_type { };   template<typename _Tp>     struct __is_trivially_copy_constructible_impl<_Tp, true>     : public __and_<is_copy_constructible<_Tp>,       integral_constant<bool,    __is_trivially_constructible(_Tp, const _Tp&)>>     { };   template<typename _Tp>     struct is_trivially_copy_constructible     : public __is_trivially_copy_constructible_impl<_Tp>     { };   template<typename _Tp, bool = __is_referenceable<_Tp>::value>     struct __is_trivially_move_constructible_impl;   template<typename _Tp>     struct __is_trivially_move_constructible_impl<_Tp, false>     : public false_type { };   template<typename _Tp>     struct __is_trivially_move_constructible_impl<_Tp, true>     : public __and_<is_move_constructible<_Tp>,       integral_constant<bool,    __is_trivially_constructible(_Tp, _Tp&&)>>     { };   template<typename _Tp>     struct is_trivially_move_constructible     : public __is_trivially_move_constructible_impl<_Tp>     { };   template<typename _Tp, typename _Up>     struct is_trivially_assignable     : public __bool_constant<__is_trivially_assignable(_Tp, _Up)>     { };   template<typename _Tp, bool = __is_referenceable<_Tp>::value>     struct __is_trivially_copy_assignable_impl;   template<typename _Tp>     struct __is_trivially_copy_assignable_impl<_Tp, false>     : public false_type { };   template<typename _Tp>     struct __is_trivially_copy_assignable_impl<_Tp, true>     : public __bool_constant<__is_trivially_assignable(_Tp&, const _Tp&)>     { };   template<typename _Tp>     struct is_trivially_copy_assignable     : public __is_trivially_copy_assignable_impl<_Tp>     { };   template<typename _Tp, bool = __is_referenceable<_Tp>::value>     struct __is_trivially_move_assignable_impl;   template<typename _Tp>     struct __is_trivially_move_assignable_impl<_Tp, false>     : public false_type { };   template<typename _Tp>     struct __is_trivially_move_assignable_impl<_Tp, true>     : public __bool_constant<__is_trivially_assignable(_Tp&, _Tp&&)>     { };   template<typename _Tp>     struct is_trivially_move_assignable     : public __is_trivially_move_assignable_impl<_Tp>     { };   template<typename _Tp>     struct is_trivially_destructible     : public __and_<is_destructible<_Tp>,       __bool_constant<__has_trivial_destructor(_Tp)>>     { };   template<typename _Tp>     struct has_virtual_destructor     : public integral_constant<bool, __has_virtual_destructor(_Tp)>     { };   template<typename _Tp>     struct alignment_of     : public integral_constant<std::size_t, alignof(_Tp)> { };   template<typename>     struct rank     : public integral_constant<std::size_t, 0> { };   template<typename _Tp, std::size_t _Size>     struct rank<_Tp[_Size]>     : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };   template<typename _Tp>     struct rank<_Tp[]>     : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };   template<typename, unsigned _Uint>     struct extent     : public integral_constant<std::size_t, 0> { };   template<typename _Tp, unsigned _Uint, std::size_t _Size>     struct extent<_Tp[_Size], _Uint>     : public integral_constant<std::size_t,           _Uint == 0 ? _Size : extent<_Tp,           _Uint - 1>::value>     { };   template<typename _Tp, unsigned _Uint>     struct extent<_Tp[], _Uint>     : public integral_constant<std::size_t,           _Uint == 0 ? 0 : extent<_Tp,              _Uint - 1>::value>     { };   template<typename, typename>     struct is_same     : public false_type { };   template<typename _Tp>     struct is_same<_Tp, _Tp>     : public true_type { };   template<typename _Base, typename _Derived>     struct is_base_of     : public integral_constant<bool, __is_base_of(_Base, _Derived)>     { };   template<typename _From, typename _To,            bool = __or_<is_void<_From>, is_function<_To>,                         is_array<_To>>::value>     struct __is_convertible_helper     {       typedef typename is_void<_To>::type type;     };   template<typename _From, typename _To>     class __is_convertible_helper<_From, _To, false>     {       ;       ;       ;     public:       typedef decltype(__test<_From, _To>(0)) type;     };   template<typename _From, typename _To>     struct is_convertible     : public __is_convertible_helper<_From, _To>::type     { };   template<typename _Tp>     struct remove_const     { typedef _Tp type; };   template<typename _Tp>     struct remove_const<_Tp const>     { typedef _Tp type; };   template<typename _Tp>     struct remove_volatile     { typedef _Tp type; };   template<typename _Tp>     struct remove_volatile<_Tp volatile>     { typedef _Tp type; };   template<typename _Tp>     struct remove_cv     {       typedef typename       remove_const<typename remove_volatile<_Tp>::type>::type type;     };   template<typename _Tp>     struct add_const     { typedef _Tp const type; };   template<typename _Tp>     struct add_volatile     { typedef _Tp volatile type; };   template<typename _Tp>     struct add_cv     {       typedef typename       add_const<typename add_volatile<_Tp>::type>::type type;     };   template<typename _Tp>     struct remove_reference     { typedef _Tp type; };   template<typename _Tp>     struct remove_reference<_Tp&>     { typedef _Tp type; };   template<typename _Tp>     struct remove_reference<_Tp&&>     { typedef _Tp type; };   template<typename _Tp, bool = __is_referenceable<_Tp>::value>     struct __add_lvalue_reference_helper     { typedef _Tp type; };   template<typename _Tp>     struct __add_lvalue_reference_helper<_Tp, true>     { typedef _Tp& type; };   template<typename _Tp>     struct add_lvalue_reference     : public __add_lvalue_reference_helper<_Tp>     { };   template<typename _Tp, bool = __is_referenceable<_Tp>::value>     struct __add_rvalue_reference_helper     { typedef _Tp type; };   template<typename _Tp>     struct __add_rvalue_reference_helper<_Tp, true>     { typedef _Tp&& type; };   template<typename _Tp>     struct add_rvalue_reference     : public __add_rvalue_reference_helper<_Tp>     { };   template<typename _Unqualified, bool _IsConst, bool _IsVol>     struct __cv_selector;   template<typename _Unqualified>     struct __cv_selector<_Unqualified, false, false>     { typedef _Unqualified __type; };   template<typename _Unqualified>     struct __cv_selector<_Unqualified, false, true>     { typedef volatile _Unqualified __type; };   template<typename _Unqualified>     struct __cv_selector<_Unqualified, true, false>     { typedef const _Unqualified __type; };   template<typename _Unqualified>     struct __cv_selector<_Unqualified, true, true>     { typedef const volatile _Unqualified __type; };   template<typename _Qualified, typename _Unqualified,     bool _IsConst = is_const<_Qualified>::value,     bool _IsVol = is_volatile<_Qualified>::value>     class __match_cv_qualifiers     {       typedef __cv_selector<_Unqualified, _IsConst, _IsVol> __match;     public:       typedef typename __match::__type __type;     };   template<typename _Tp>     struct __make_unsigned     { typedef _Tp __type; };   template<>     struct __make_unsigned<char>     { typedef unsigned char __type; };   template<>     struct __make_unsigned<signed char>     { typedef unsigned char __type; };   template<>     struct __make_unsigned<short>     { typedef unsigned short __type; };   template<>     struct __make_unsigned<int>     { typedef unsigned int __type; };   template<>     struct __make_unsigned<long>     { typedef unsigned long __type; };   template<>     struct __make_unsigned<long long>     { typedef unsigned long long __type; };   template<>     struct __make_unsigned<__int128>     { typedef unsigned __int128 __type; };   template<typename _Tp,     bool _IsInt = is_integral<_Tp>::value,     bool _IsEnum = is_enum<_Tp>::value>     class __make_unsigned_selector;   template<typename _Tp>     class __make_unsigned_selector<_Tp, true, false>     {       using __unsigned_type  = typename __make_unsigned<typename remove_cv<_Tp>::type>::__type;     public:       using __type  = typename __match_cv_qualifiers<_Tp, __unsigned_type>::__type;     };   class __make_unsigned_selector_base   {   protected:     template<typename...> struct _List { };     template<typename _Tp, typename... _Up>       struct _List<_Tp, _Up...> : _List<_Up...>       { static constexpr size_t __size = sizeof(_Tp); };     template<size_t _Sz, typename _Tp, bool = (_Sz <= _Tp::__size)>       struct __select;     template<size_t _Sz, typename _Uint, typename... _UInts>       struct __select<_Sz, _List<_Uint, _UInts...>, true>       { using __type = _Uint; };     template<size_t _Sz, typename _Uint, typename... _UInts>       struct __select<_Sz, _List<_Uint, _UInts...>, false>       : __select<_Sz, _List<_UInts...>>       { };   };   template<typename _Tp>     class __make_unsigned_selector<_Tp, false, true>     : __make_unsigned_selector_base     {       using _UInts = _List<unsigned char, unsigned short, unsigned int,       unsigned long, unsigned long long>;       using __unsigned_type = typename __select<sizeof(_Tp), _UInts>::__type;     public:       using __type  = typename __match_cv_qualifiers<_Tp, __unsigned_type>::__type;     };   template<>     struct __make_unsigned<wchar_t>     {       using __type  = typename __make_unsigned_selector<wchar_t, false, true>::__type;     };   template<>     struct __make_unsigned<char16_t>     {       using __type  = typename __make_unsigned_selector<char16_t, false, true>::__type;     };   template<>     struct __make_unsigned<char32_t>     {       using __type  = typename __make_unsigned_selector<char32_t, false, true>::__type;     };   template<typename _Tp>     struct make_unsigned     { typedef typename __make_unsigned_selector<_Tp>::__type type; };   template<>     struct make_unsigned<bool>;   template<typename _Tp>     struct __make_signed     { typedef _Tp __type; };   template<>     struct __make_signed<char>     { typedef signed char __type; };   template<>     struct __make_signed<unsigned char>     { typedef signed char __type; };   template<>     struct __make_signed<unsigned short>     { typedef signed short __type; };   template<>     struct __make_signed<unsigned int>     { typedef signed int __type; };   template<>     struct __make_signed<unsigned long>     { typedef signed long __type; };   template<>     struct __make_signed<unsigned long long>     { typedef signed long long __type; };   template<>     struct __make_signed<unsigned __int128>     { typedef __int128 __type; };   template<typename _Tp,     bool _IsInt = is_integral<_Tp>::value,     bool _IsEnum = is_enum<_Tp>::value>     class __make_signed_selector;   template<typename _Tp>     class __make_signed_selector<_Tp, true, false>     {       using __signed_type  = typename __make_signed<typename remove_cv<_Tp>::type>::__type;     public:       using __type  = typename __match_cv_qualifiers<_Tp, __signed_type>::__type;     };   template<typename _Tp>     class __make_signed_selector<_Tp, false, true>     {       typedef typename __make_unsigned_selector<_Tp>::__type __unsigned_type;     public:       typedef typename __make_signed_selector<__unsigned_type>::__type __type;     };   template<>     struct __make_signed<wchar_t>     {       using __type  = typename __make_signed_selector<wchar_t, false, true>::__type;     };   template<>     struct __make_signed<char16_t>     {       using __type  = typename __make_signed_selector<char16_t, false, true>::__type;     };   template<>     struct __make_signed<char32_t>     {       using __type  = typename __make_signed_selector<char32_t, false, true>::__type;     };   template<typename _Tp>     struct make_signed     { typedef typename __make_signed_selector<_Tp>::__type type; };   template<>     struct make_signed<bool>;   template<typename _Tp>     struct remove_extent     { typedef _Tp type; };   template<typename _Tp, std::size_t _Size>     struct remove_extent<_Tp[_Size]>     { typedef _Tp type; };   template<typename _Tp>     struct remove_extent<_Tp[]>     { typedef _Tp type; };   template<typename _Tp>     struct remove_all_extents     { typedef _Tp type; };   template<typename _Tp, std::size_t _Size>     struct remove_all_extents<_Tp[_Size]>     { typedef typename remove_all_extents<_Tp>::type type; };   template<typename _Tp>     struct remove_all_extents<_Tp[]>     { typedef typename remove_all_extents<_Tp>::type type; };   template<typename _Tp, typename>     struct __remove_pointer_helper     { typedef _Tp type; };   template<typename _Tp, typename _Up>     struct __remove_pointer_helper<_Tp, _Up*>     { typedef _Up type; };   template<typename _Tp>     struct remove_pointer     : public __remove_pointer_helper<_Tp, typename remove_cv<_Tp>::type>     { };   template<typename _Tp, bool = __or_<__is_referenceable<_Tp>,           is_void<_Tp>>::value>     struct __add_pointer_helper     { typedef _Tp type; };   template<typename _Tp>     struct __add_pointer_helper<_Tp, true>     { typedef typename remove_reference<_Tp>::type* type; };   template<typename _Tp>     struct add_pointer     : public __add_pointer_helper<_Tp>     { };   template<std::size_t _Len>     struct __aligned_storage_msa     {       union __type       {  unsigned char __data[_Len];  struct __attribute__((__aligned__)) { } __align;       };     };   template<std::size_t _Len, std::size_t _Align =     __alignof__(typename __aligned_storage_msa<_Len>::__type)>     struct aligned_storage     {       union type       {  unsigned char __data[_Len];  struct __attribute__((__aligned__((_Align)))) { } __align;       };     };   template <typename... _Types>     struct __strictest_alignment     {       static const size_t _S_alignment = 0;       static const size_t _S_size = 0;     };   template <typename _Tp, typename... _Types>     struct __strictest_alignment<_Tp, _Types...>     {       static const size_t _S_alignment =         alignof(_Tp) > __strictest_alignment<_Types...>::_S_alignment  ? alignof(_Tp) : __strictest_alignment<_Types...>::_S_alignment;       static const size_t _S_size =         sizeof(_Tp) > __strictest_alignment<_Types...>::_S_size  ? sizeof(_Tp) : __strictest_alignment<_Types...>::_S_size;     };   template <size_t _Len, typename... _Types>     struct aligned_union     {     private:       static_assert(sizeof...(_Types) != 0, "At least one type is required");       using __strictest = __strictest_alignment<_Types...>;       static const size_t _S_len = _Len > __strictest::_S_size  ? _Len : __strictest::_S_size;     public:       static const size_t alignment_value = __strictest::_S_alignment;       typedef typename aligned_storage<_S_len, alignment_value>::type type;     };   template <size_t _Len, typename... _Types>     const size_t aligned_union<_Len, _Types...>::alignment_value;   template<typename _Up,     bool _IsArray = is_array<_Up>::value,     bool _IsFunction = is_function<_Up>::value>     struct __decay_selector;   template<typename _Up>     struct __decay_selector<_Up, false, false>     { typedef typename remove_cv<_Up>::type __type; };   template<typename _Up>     struct __decay_selector<_Up, true, false>     { typedef typename remove_extent<_Up>::type* __type; };   template<typename _Up>     struct __decay_selector<_Up, false, true>     { typedef typename add_pointer<_Up>::type __type; };   template<typename _Tp>     class decay     {       typedef typename remove_reference<_Tp>::type __remove_type;     public:       typedef typename __decay_selector<__remove_type>::__type type;     };   template<typename _Tp>     class reference_wrapper;   template<typename _Tp>     struct __strip_reference_wrapper     {       typedef _Tp __type;     };   template<typename _Tp>     struct __strip_reference_wrapper<reference_wrapper<_Tp> >     {       typedef _Tp& __type;     };   template<typename _Tp>     struct __decay_and_strip     {       typedef typename __strip_reference_wrapper<  typename decay<_Tp>::type>::__type __type;     };   template<bool, typename _Tp = void>     struct enable_if     { };   template<typename _Tp>     struct enable_if<true, _Tp>     { typedef _Tp type; };   template<typename... _Cond>     using _Require = typename enable_if<__and_<_Cond...>::value>::type;   template<bool _Cond, typename _Iftrue, typename _Iffalse>     struct conditional     { typedef _Iftrue type; };   template<typename _Iftrue, typename _Iffalse>     struct conditional<false, _Iftrue, _Iffalse>     { typedef _Iffalse type; };   template<typename... _Tp>     struct common_type;   struct __do_common_type_impl   {     ;     ;   };   template<typename _Tp, typename _Up>     struct __common_type_impl     : private __do_common_type_impl     {       typedef decltype(_S_test<_Tp, _Up>(0)) type;     };   struct __do_member_type_wrapper   {     ;     ;   };   template<typename _Tp>     struct __member_type_wrapper     : private __do_member_type_wrapper     {       typedef decltype(_S_test<_Tp>(0)) type;     };   template<typename _CTp, typename... _Args>     struct __expanded_common_type_wrapper     {       typedef common_type<typename _CTp::type, _Args...> type;     };   template<typename... _Args>     struct __expanded_common_type_wrapper<__failure_type, _Args...>     { typedef __failure_type type; };   template<>     struct common_type<>     { };   template<typename _Tp>     struct common_type<_Tp>     : common_type<_Tp, _Tp>     { };   template<typename _Tp, typename _Up>     struct common_type<_Tp, _Up>     : public __common_type_impl<_Tp, _Up>::type     { };   template<typename _Tp, typename _Up, typename... _Vp>     struct common_type<_Tp, _Up, _Vp...>     : public __expanded_common_type_wrapper<typename __member_type_wrapper<                common_type<_Tp, _Up>>::type, _Vp...>::type     { };   template<typename _Tp, bool = is_enum<_Tp>::value>     struct __underlying_type_impl     {       using type = __underlying_type(_Tp);     };   template<typename _Tp>     struct __underlying_type_impl<_Tp, false>     { };   template<typename _Tp>     struct underlying_type     : public __underlying_type_impl<_Tp>     { };   template<typename _Tp>     struct __declval_protector     {       static const bool __stop = false;     };   template<typename _Tp>     auto declval() noexcept -> decltype(__declval<_Tp>(0))     ;   template<typename _Tp>     using __remove_cvref_t      = typename remove_cv<typename remove_reference<_Tp>::type>::type;   template<typename _Signature>     class result_of;   struct __invoke_memfun_ref { };   struct __invoke_memfun_deref { };   struct __invoke_memobj_ref { };   struct __invoke_memobj_deref { };   struct __invoke_other { };   template<typename _Tp, typename _Tag>     struct __result_of_success : __success_type<_Tp>     { using __invoke_type = _Tag; };   struct __result_of_memfun_ref_impl   {     ;     ;   };   template<typename _MemPtr, typename _Arg, typename... _Args>     struct __result_of_memfun_ref     : private __result_of_memfun_ref_impl     {       typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;     };   struct __result_of_memfun_deref_impl   {     ;     ;   };   template<typename _MemPtr, typename _Arg, typename... _Args>     struct __result_of_memfun_deref     : private __result_of_memfun_deref_impl     {       typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;     };   struct __result_of_memobj_ref_impl   {     ;     ;   };   template<typename _MemPtr, typename _Arg>     struct __result_of_memobj_ref     : private __result_of_memobj_ref_impl     {       typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;     };   struct __result_of_memobj_deref_impl   {     ;     ;   };   template<typename _MemPtr, typename _Arg>     struct __result_of_memobj_deref     : private __result_of_memobj_deref_impl     {       typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;     };   template<typename _MemPtr, typename _Arg>     struct __result_of_memobj;   template<typename _Res, typename _Class, typename _Arg>     struct __result_of_memobj<_Res _Class::*, _Arg>     {       typedef __remove_cvref_t<_Arg> _Argval;       typedef _Res _Class::* _MemPtr;       typedef typename conditional<__or_<is_same<_Argval, _Class>,         is_base_of<_Class, _Argval>>::value,         __result_of_memobj_ref<_MemPtr, _Arg>,         __result_of_memobj_deref<_MemPtr, _Arg>       >::type::type type;     };   template<typename _MemPtr, typename _Arg, typename... _Args>     struct __result_of_memfun;   template<typename _Res, typename _Class, typename _Arg, typename... _Args>     struct __result_of_memfun<_Res _Class::*, _Arg, _Args...>     {       typedef typename remove_reference<_Arg>::type _Argval;       typedef _Res _Class::* _MemPtr;       typedef typename conditional<is_base_of<_Class, _Argval>::value,         __result_of_memfun_ref<_MemPtr, _Arg, _Args...>,         __result_of_memfun_deref<_MemPtr, _Arg, _Args...>       >::type::type type;     };   template<typename _Tp, typename _Up = __remove_cvref_t<_Tp>>     struct __inv_unwrap     {       using type = _Tp;     };   template<typename _Tp, typename _Up>     struct __inv_unwrap<_Tp, reference_wrapper<_Up>>     {       using type = _Up&;     };   template<bool, bool, typename _Functor, typename... _ArgTypes>     struct __result_of_impl     {       typedef __failure_type type;     };   template<typename _MemPtr, typename _Arg>     struct __result_of_impl<true, false, _MemPtr, _Arg>     : public __result_of_memobj<typename decay<_MemPtr>::type,     typename __inv_unwrap<_Arg>::type>     { };   template<typename _MemPtr, typename _Arg, typename... _Args>     struct __result_of_impl<false, true, _MemPtr, _Arg, _Args...>     : public __result_of_memfun<typename decay<_MemPtr>::type,     typename __inv_unwrap<_Arg>::type, _Args...>     { };   struct __result_of_other_impl   {     ;     ;   };   template<typename _Functor, typename... _ArgTypes>     struct __result_of_impl<false, false, _Functor, _ArgTypes...>     : private __result_of_other_impl     {       typedef decltype(_S_test<_Functor, _ArgTypes...>(0)) type;     };   template<typename _Functor, typename... _ArgTypes>     struct __invoke_result     : public __result_of_impl<         is_member_object_pointer<           typename remove_reference<_Functor>::type         >::value,         is_member_function_pointer<           typename remove_reference<_Functor>::type         >::value,  _Functor, _ArgTypes...       >::type     { };   template<typename _Functor, typename... _ArgTypes>     struct result_of<_Functor(_ArgTypes...)>     : public __invoke_result<_Functor, _ArgTypes...>     { };   template<bool _Cond, typename _Tp = void>     using __enable_if_t = typename enable_if<_Cond, _Tp>::type;   template<typename...> using __void_t = void;   template<typename...> using void_t = void;   template<typename _Default, typename _AlwaysVoid,     template<typename...> class _Op, typename... _Args>     struct __detector     {       using value_t = false_type;       using type = _Default;     };   template<typename _Default, template<typename...> class _Op,      typename... _Args>     struct __detector<_Default, __void_t<_Op<_Args...>>, _Op, _Args...>     {       using value_t = true_type;       using type = _Op<_Args...>;     };   template<typename _Default, template<typename...> class _Op,     typename... _Args>     using __detected_or = __detector<_Default, void, _Op, _Args...>;   template<typename _Default, template<typename...> class _Op,     typename... _Args>     using __detected_or_t       = typename __detected_or<_Default, _Op, _Args...>::type;   template <typename _Tp>     struct __is_swappable;   template <typename _Tp>     struct __is_nothrow_swappable;   template<typename... _Elements>     class tuple;   template<typename>     struct __is_tuple_like_impl : false_type     { };   template<typename... _Tps>     struct __is_tuple_like_impl<tuple<_Tps...>> : true_type     { };   template<typename _Tp>     struct __is_tuple_like     : public __is_tuple_like_impl<__remove_cvref_t<_Tp>>::type     { };   ;   ;   namespace __swappable_details {          struct __do_is_swappable_impl     {       ;       ;     };     struct __do_is_nothrow_swappable_impl     {       ;       ;     };   }    template<typename _Tp>     struct __is_swappable_impl     : public __swappable_details::__do_is_swappable_impl     {       typedef decltype(__test<_Tp>(0)) type;     };   template<typename _Tp>     struct __is_nothrow_swappable_impl     : public __swappable_details::__do_is_nothrow_swappable_impl     {       typedef decltype(__test<_Tp>(0)) type;     };   template<typename _Tp>     struct __is_swappable     : public __is_swappable_impl<_Tp>::type     { };   template<typename _Tp>     struct __is_nothrow_swappable     : public __is_nothrow_swappable_impl<_Tp>::type     { };   template<typename _Tp>     struct is_swappable     : public __is_swappable_impl<_Tp>::type     { };   template<typename _Tp>     struct is_nothrow_swappable     : public __is_nothrow_swappable_impl<_Tp>::type     { };   namespace __swappable_with_details {          struct __do_is_swappable_with_impl     {       ;       ;     };     struct __do_is_nothrow_swappable_with_impl     {       ;       ;     };   }    template<typename _Tp, typename _Up>     struct __is_swappable_with_impl     : public __swappable_with_details::__do_is_swappable_with_impl     {       typedef decltype(__test<_Tp, _Up>(0)) type;     };   template<typename _Tp>     struct __is_swappable_with_impl<_Tp&, _Tp&>     : public __swappable_details::__do_is_swappable_impl     {       typedef decltype(__test<_Tp&>(0)) type;     };   template<typename _Tp, typename _Up>     struct __is_nothrow_swappable_with_impl     : public __swappable_with_details::__do_is_nothrow_swappable_with_impl     {       typedef decltype(__test<_Tp, _Up>(0)) type;     };   template<typename _Tp>     struct __is_nothrow_swappable_with_impl<_Tp&, _Tp&>     : public __swappable_details::__do_is_nothrow_swappable_impl     {       typedef decltype(__test<_Tp&>(0)) type;     };   template<typename _Tp, typename _Up>     struct is_swappable_with     : public __is_swappable_with_impl<_Tp, _Up>::type     { };   template<typename _Tp, typename _Up>     struct is_nothrow_swappable_with     : public __is_nothrow_swappable_with_impl<_Tp, _Up>::type     { };   template<typename _Result, typename _Ret, typename = void>     struct __is_invocable_impl : false_type { };   template<typename _Result, typename _Ret>     struct __is_invocable_impl<_Result, _Ret, __void_t<typename _Result::type>>     : __or_<is_void<_Ret>, is_convertible<typename _Result::type, _Ret>>::type     { };   template<typename _Fn, typename... _ArgTypes>     struct __is_invocable     : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>::type     { };        ;        ;        ;   template<typename _Fn, typename _Tp>     constexpr bool __call_is_nt(__invoke_memobj_deref)     ;   template<typename _Fn, typename... _Args>     constexpr bool __call_is_nt(__invoke_other)     ;   template<typename _Result, typename _Fn, typename... _Args>     struct __call_is_nothrow     : __bool_constant<  std::__call_is_nt<_Fn, _Args...>(typename _Result::__invoke_type{})       >     { };   template<typename _Fn, typename... _Args>     using __call_is_nothrow_       = __call_is_nothrow<__invoke_result<_Fn, _Args...>, _Fn, _Args...>;   template<typename _Fn, typename... _Args>     struct __is_nothrow_invocable     : __and_<__is_invocable<_Fn, _Args...>,              __call_is_nothrow_<_Fn, _Args...>>::type     { };   struct __nonesuch {     __nonesuch() = delete;     ~__nonesuch() = delete;     __nonesuch(__nonesuch const&) = delete;     void operator=(__nonesuch const&) = delete;   }; }
  namespace std __attribute__ ((__visibility__ ("default"))) {   template<typename _Tp>     constexpr _Tp&&     forward(typename std::remove_reference<_Tp>::type& __t) noexcept     ;   template<typename _Tp>     constexpr _Tp&&     forward(typename std::remove_reference<_Tp>::type&& __t) noexcept     ;   template<typename _Tp>     constexpr typename std::remove_reference<_Tp>::type&&     move(_Tp&& __t) noexcept     ;   template<typename _Tp>     struct __move_if_noexcept_cond     : public __and_<__not_<is_nothrow_move_constructible<_Tp>>,                     is_copy_constructible<_Tp>>::type { };   template<typename _Tp>     constexpr typename     conditional<__move_if_noexcept_cond<_Tp>::value, const _Tp&, _Tp&&>::type     move_if_noexcept(_Tp& __x) noexcept     ;   template<typename _Tp>      _Tp*     addressof(_Tp& __r) noexcept     ;   template<typename _Tp>     const _Tp* addressof(const _Tp&&) = delete;   template <typename _Tp, typename _Up = _Tp>      _Tp     __exchange(_Tp& __obj, _Up&& __new_val)     ;        ;        ; }
  namespace std __attribute__ ((__visibility__ ("default"))) {   struct piecewise_construct_t { explicit piecewise_construct_t() = default; };                     constexpr piecewise_construct_t piecewise_construct =     piecewise_construct_t();   template<typename...>     class tuple;   template<std::size_t...>     struct _Index_tuple;   template <bool, typename _T1, typename _T2>     struct _PCC     {       template <typename _U1, typename _U2>       static constexpr bool _ConstructiblePair()       ;       template <typename _U1, typename _U2>       static constexpr bool _ImplicitlyConvertiblePair()       ;       template <typename _U1, typename _U2>       static constexpr bool _MoveConstructiblePair()       ;       template <typename _U1, typename _U2>       static constexpr bool _ImplicitlyMoveConvertiblePair()       ;       template <bool __implicit, typename _U1, typename _U2>       static constexpr bool _CopyMovePair()       ;              ;   };   template <typename _T1, typename _T2>     struct _PCC<false, _T1, _T2>     {              ;              ;              ;              ;   };   struct __nonesuch_no_braces : std::__nonesuch {        };   template<typename _U1, typename _U2> class __pair_base   {     template<typename _T1, typename _T2> friend struct pair;                       };  /**    *  @brief Struct holding two objects of arbitrary type.    *    *  @tparam _T1  Type of first object.    *  @tparam _T2  Type of second object.    */  template<typename _T1, typename _T2>     struct pair     : private __pair_base<_T1, _T2>     {       typedef _T1 first_type;        typedef _T2 second_type;        _T1 first;        _T2 second;        /** The default constructor creates @c first and @c second using their        *  respective default constructors.  */        ;         ;       /** Two objects may be passed to a @c pair constructor to be copied.  */      using _PCCP = _PCC<true, _T1, _T2>;         ;          ;       template <typename _U1, typename _U2>         using _PCCFP = _PCC<!is_same<_T1, _U1>::value        || !is_same<_T2, _U2>::value,        _T1, _T2>;         ;         ;                       ;         ;         ;         ;         ;         ;         ;         ;       ;                       ;         ;            private:       ;     };        ;        ;        ;        ;        ;        ;   template<typename _T1, typename _T2>          typename enable_if<__and_<__is_swappable<_T1>,                               __is_swappable<_T2>>::value>::type     swap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)     noexcept(noexcept(__x.swap(__y)))     ;   template<typename _T1, typename _T2>     typename enable_if<!__and_<__is_swappable<_T1>,           __is_swappable<_T2>>::value>::type     swap(pair<_T1, _T2>&, pair<_T1, _T2>&) = delete;   template<typename _T1, typename _T2>     constexpr pair<typename __decay_and_strip<_T1>::__type,                    typename __decay_and_strip<_T2>::__type>     make_pair(_T1&& __x, _T2&& __y)     ; }
#pragma GCC visibility push(default)
namespace std {   template<class _E>     class initializer_list     {     public:       typedef _E value_type;       typedef const _E& reference;       typedef const _E& const_reference;       typedef size_t size_type;       typedef const _E* iterator;       typedef const _E* const_iterator;     private:       iterator _M_array;       size_type _M_len;            public:                                 };        ;        ; }
#pragma GCC visibility pop
namespace std __attribute__ ((__visibility__ ("default"))) {   template<typename _Tp>     struct tuple_size;   template<typename _Tp,     typename _Up = typename remove_cv<_Tp>::type,     typename = typename enable_if<is_same<_Tp, _Up>::value>::type,     size_t = tuple_size<_Tp>::value>     using __enable_if_has_tuple_size = _Tp;   template<typename _Tp>     struct tuple_size<const __enable_if_has_tuple_size<_Tp>>     : public tuple_size<_Tp> { };   template<typename _Tp>     struct tuple_size<volatile __enable_if_has_tuple_size<_Tp>>     : public tuple_size<_Tp> { };   template<typename _Tp>     struct tuple_size<const volatile __enable_if_has_tuple_size<_Tp>>     : public tuple_size<_Tp> { };   template<std::size_t __i, typename _Tp>     struct tuple_element;   template<std::size_t __i, typename _Tp>     using __tuple_element_t = typename tuple_element<__i, _Tp>::type;   template<std::size_t __i, typename _Tp>     struct tuple_element<__i, const _Tp>     {       typedef typename add_const<__tuple_element_t<__i, _Tp>>::type type;     };   template<std::size_t __i, typename _Tp>     struct tuple_element<__i, volatile _Tp>     {       typedef typename add_volatile<__tuple_element_t<__i, _Tp>>::type type;     };   template<std::size_t __i, typename _Tp>     struct tuple_element<__i, const volatile _Tp>     {       typedef typename add_cv<__tuple_element_t<__i, _Tp>>::type type;     };   template<typename _T1, typename _T2>     struct __is_tuple_like_impl<std::pair<_T1, _T2>> : true_type     { };   template<class _Tp1, class _Tp2>     struct tuple_size<std::pair<_Tp1, _Tp2>>     : public integral_constant<std::size_t, 2> { };   template<class _Tp1, class _Tp2>     struct tuple_element<0, std::pair<_Tp1, _Tp2>>     { typedef _Tp1 type; };   template<class _Tp1, class _Tp2>     struct tuple_element<1, std::pair<_Tp1, _Tp2>>     { typedef _Tp2 type; };   template<std::size_t _Int>     struct __pair_get;   template<>     struct __pair_get<0>     {                ;                ;                ;                ;     };   template<>     struct __pair_get<1>     {                ;                ;                ;                ;     };        ;        ;        ;        ;   template<size_t... _Indexes> struct _Index_tuple { };   template<size_t _Num>     struct _Build_index_tuple     {       template<typename, size_t... _Indices>         using _IdxTuple = _Index_tuple<_Indices...>;       using __type = __make_integer_seq<_IdxTuple, size_t, _Num>;     }; }
  /*  *  * Copyright (c) 1994  * Hewlett-Packard Company  *  * Permission to use, copy, modify, distribute and sell this software  * and its documentation for any purpose is hereby granted without fee,  * provided that the above copyright notice appear in all copies and  * that both that copyright notice and this permission notice appear  * in supporting documentation.  Hewlett-Packard Company makes no  * representations about the suitability of this software for any  * purpose.  It is provided "as is" without express or implied warranty.  *  *  * Copyright (c) 1996-1998  * Silicon Graphics Computer Systems, Inc.  *  * Permission to use, copy, modify, distribute and sell this software  * and its documentation for any purpose is hereby granted without fee,  * provided that the above copyright notice appear in all copies and  * that both that copyright notice and this permission notice appear  * in supporting documentation.  Silicon Graphics makes no  * representations about the suitability of this software for any  * purpose.  It is provided "as is" without express or implied warranty.  */
/** @file bits/stl_algobase.h  *  This is an internal header file, included by other library headers.  *  Do not attempt to use it directly. @headername{algorithm}
  */
/** @file bits/functexcept.h  *  This is an internal header file, included by other library headers.  *  Do not attempt to use it directly. @headername{exception}
  *  *  This header provides support for -fno-exceptions.  */
/** @file bits/exception_defines.h  *  This is an internal header file, included by other library headers.  *  Do not attempt to use it directly. @headername{exception}
  */
namespace std __attribute__ ((__visibility__ ("default"))) {                                                      void   __throw_future_error(int) __attribute__((__noreturn__));   void   __throw_bad_function_call() __attribute__((__noreturn__)); }
  /** @file bits/cpp_type_traits.h  *  This is an internal header file, included by other library headers.  *  Do not attempt to use it directly. @headername{ext/type_traits}
  */
extern "C++" { namespace std __attribute__ ((__visibility__ ("default"))) {   struct __true_type { };   struct __false_type { };   template<bool>     struct __truth_type     { typedef __false_type __type; };   template<>     struct __truth_type<true>     { typedef __true_type __type; };   template<class _Sp, class _Tp>     struct __traitor     {       enum { __value = bool(_Sp::__value) || bool(_Tp::__value) };       typedef typename __truth_type<__value>::__type __type;     };   template<typename, typename>     struct __are_same     {       enum { __value = 0 };       typedef __false_type __type;     };   template<typename _Tp>     struct __are_same<_Tp, _Tp>     {       enum { __value = 1 };       typedef __true_type __type;     };   template<typename _Tp>     struct __is_void     {       enum { __value = 0 };       typedef __false_type __type;     };   template<>     struct __is_void<void>     {       enum { __value = 1 };       typedef __true_type __type;     };   template<typename _Tp>     struct __is_integer     {       enum { __value = 0 };       typedef __false_type __type;     };   template<>     struct __is_integer<bool>     {       enum { __value = 1 };       typedef __true_type __type;     };   template<>     struct __is_integer<char>     {       enum { __value = 1 };       typedef __true_type __type;     };   template<>     struct __is_integer<signed char>     {       enum { __value = 1 };       typedef __true_type __type;     };   template<>     struct __is_integer<unsigned char>     {       enum { __value = 1 };       typedef __true_type __type;     };   template<>     struct __is_integer<wchar_t>     {       enum { __value = 1 };       typedef __true_type __type;     };   template<>     struct __is_integer<char16_t>     {       enum { __value = 1 };       typedef __true_type __type;     };   template<>     struct __is_integer<char32_t>     {       enum { __value = 1 };       typedef __true_type __type;     };   template<>     struct __is_integer<short>     {       enum { __value = 1 };       typedef __true_type __type;     };   template<>     struct __is_integer<unsigned short>     {       enum { __value = 1 };       typedef __true_type __type;     };   template<>     struct __is_integer<int>     {       enum { __value = 1 };       typedef __true_type __type;     };   template<>     struct __is_integer<unsigned int>     {       enum { __value = 1 };       typedef __true_type __type;     };   template<>     struct __is_integer<long>     {       enum { __value = 1 };       typedef __true_type __type;     };   template<>     struct __is_integer<unsigned long>     {       enum { __value = 1 };       typedef __true_type __type;     };   template<>     struct __is_integer<long long>     {       enum { __value = 1 };       typedef __true_type __type;     };   template<>     struct __is_integer<unsigned long long>     {       enum { __value = 1 };       typedef __true_type __type;     }; template<> struct __is_integer<__int128> { enum { __value = 1 }; typedef __true_type __type; }; template<> struct __is_integer<unsigned __int128> { enum { __value = 1 }; typedef __true_type __type; };   template<typename _Tp>     struct __is_floating     {       enum { __value = 0 };       typedef __false_type __type;     };   template<>     struct __is_floating<float>     {       enum { __value = 1 };       typedef __true_type __type;     };   template<>     struct __is_floating<double>     {       enum { __value = 1 };       typedef __true_type __type;     };   template<>     struct __is_floating<long double>     {       enum { __value = 1 };       typedef __true_type __type;     };   template<typename _Tp>     struct __is_pointer     {       enum { __value = 0 };       typedef __false_type __type;     };   template<typename _Tp>     struct __is_pointer<_Tp*>     {       enum { __value = 1 };       typedef __true_type __type;     };   template<typename _Tp>     struct __is_arithmetic     : public __traitor<__is_integer<_Tp>, __is_floating<_Tp> >     { };   template<typename _Tp>     struct __is_scalar     : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> >     { };   template<typename _Tp>     struct __is_char     {       enum { __value = 0 };       typedef __false_type __type;     };   template<>     struct __is_char<char>     {       enum { __value = 1 };       typedef __true_type __type;     };   template<>     struct __is_char<wchar_t>     {       enum { __value = 1 };       typedef __true_type __type;     };   template<typename _Tp>     struct __is_byte     {       enum { __value = 0 };       typedef __false_type __type;     };   template<>     struct __is_byte<char>     {       enum { __value = 1 };       typedef __true_type __type;     };   template<>     struct __is_byte<signed char>     {       enum { __value = 1 };       typedef __true_type __type;     };   template<>     struct __is_byte<unsigned char>     {       enum { __value = 1 };       typedef __true_type __type;     };   template<typename _Tp>     struct __is_move_iterator     {       enum { __value = 0 };       typedef __false_type __type;     };   template<typename _Iterator>      _Iterator     __miter_base(_Iterator __it)     ; }  }
  extern "C++" { namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {   template<bool, typename>     struct __enable_if     { };   template<typename _Tp>     struct __enable_if<true, _Tp>     { typedef _Tp __type; };   template<bool _Cond, typename _Iftrue, typename _Iffalse>     struct __conditional_type     { typedef _Iftrue __type; };   template<typename _Iftrue, typename _Iffalse>     struct __conditional_type<false, _Iftrue, _Iffalse>     { typedef _Iffalse __type; };   template<typename _Tp>     struct __add_unsigned     {     private:       typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;     public:       typedef typename __if_type::__type __type;     };   template<>     struct __add_unsigned<char>     { typedef unsigned char __type; };   template<>     struct __add_unsigned<signed char>     { typedef unsigned char __type; };   template<>     struct __add_unsigned<short>     { typedef unsigned short __type; };   template<>     struct __add_unsigned<int>     { typedef unsigned int __type; };   template<>     struct __add_unsigned<long>     { typedef unsigned long __type; };   template<>     struct __add_unsigned<long long>     { typedef unsigned long long __type; };   template<>     struct __add_unsigned<bool>;   template<>     struct __add_unsigned<wchar_t>;   template<typename _Tp>     struct __remove_unsigned     {     private:       typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;     public:       typedef typename __if_type::__type __type;     };   template<>     struct __remove_unsigned<char>     { typedef signed char __type; };   template<>     struct __remove_unsigned<unsigned char>     { typedef signed char __type; };   template<>     struct __remove_unsigned<unsigned short>     { typedef short __type; };   template<>     struct __remove_unsigned<unsigned int>     { typedef int __type; };   template<>     struct __remove_unsigned<unsigned long>     { typedef long __type; };   template<>     struct __remove_unsigned<unsigned long long>     { typedef long long __type; };   template<>     struct __remove_unsigned<bool>;   template<>     struct __remove_unsigned<wchar_t>;   template<typename _Type>      bool     __is_null_pointer(_Type* __ptr)     ;   template<typename _Type>      bool     __is_null_pointer(_Type)     ;    bool   __is_null_pointer(std::nullptr_t)   ;   template<typename _Tp, bool = std::__is_integer<_Tp>::__value>     struct __promote     { typedef double __type; };   template<typename _Tp>     struct __promote<_Tp, false>     { };   template<>     struct __promote<long double>     { typedef long double __type; };   template<>     struct __promote<double>     { typedef double __type; };   template<>     struct __promote<float>     { typedef float __type; };   template<typename _Tp, typename _Up,            typename _Tp2 = typename __promote<_Tp>::__type,            typename _Up2 = typename __promote<_Up>::__type>     struct __promote_2     {       typedef __typeof__(_Tp2() + _Up2()) __type;     };   template<typename _Tp, typename _Up, typename _Vp,            typename _Tp2 = typename __promote<_Tp>::__type,            typename _Up2 = typename __promote<_Up>::__type,            typename _Vp2 = typename __promote<_Vp>::__type>     struct __promote_3     {       typedef __typeof__(_Tp2() + _Up2() + _Vp2()) __type;     };   template<typename _Tp, typename _Up, typename _Vp, typename _Wp,            typename _Tp2 = typename __promote<_Tp>::__type,            typename _Up2 = typename __promote<_Up>::__type,            typename _Vp2 = typename __promote<_Vp>::__type,            typename _Wp2 = typename __promote<_Wp>::__type>     struct __promote_4     {       typedef __typeof__(_Tp2() + _Up2() + _Vp2() + _Wp2()) __type;     }; }  }
  namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {   template<typename _Value>     struct __numeric_traits_integer     {       static const _Value __min = (((_Value)(-1) < 0) ? (_Value)1 << (sizeof(_Value) * 8 - ((_Value)(-1) < 0)) : (_Value)0);       static const _Value __max = (((_Value)(-1) < 0) ? (((((_Value)1 << ((sizeof(_Value) * 8 - ((_Value)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(_Value)0);       static const bool __is_signed = ((_Value)(-1) < 0);       static const int __digits = (sizeof(_Value) * 8 - ((_Value)(-1) < 0));     };   template<typename _Value>     const _Value __numeric_traits_integer<_Value>::__min;   template<typename _Value>     const _Value __numeric_traits_integer<_Value>::__max;   template<typename _Value>     const bool __numeric_traits_integer<_Value>::__is_signed;   template<typename _Value>     const int __numeric_traits_integer<_Value>::__digits;   template<typename _Value>     struct __numeric_traits_floating     {       static const int __max_digits10 = (2 + (std::__are_same<_Value, float>::__value ? 24 : std::__are_same<_Value, double>::__value ? 53 : 64) * 643L / 2136);       static const bool __is_signed = true;       static const int __digits10 = (std::__are_same<_Value, float>::__value ? 6 : std::__are_same<_Value, double>::__value ? 15 : 18);       static const int __max_exponent10 = (std::__are_same<_Value, float>::__value ? 38 : std::__are_same<_Value, double>::__value ? 308 : 4932);     };   template<typename _Value>     const int __numeric_traits_floating<_Value>::__max_digits10;   template<typename _Value>     const bool __numeric_traits_floating<_Value>::__is_signed;   template<typename _Value>     const int __numeric_traits_floating<_Value>::__digits10;   template<typename _Value>     const int __numeric_traits_floating<_Value>::__max_exponent10;   template<typename _Value>     struct __numeric_traits     : public __conditional_type<std::__is_integer<_Value>::__value,     __numeric_traits_integer<_Value>,     __numeric_traits_floating<_Value> >::__type     { }; }
  namespace std __attribute__ ((__visibility__ ("default"))) {   struct input_iterator_tag { };   struct output_iterator_tag { };   struct forward_iterator_tag : public input_iterator_tag { };   struct bidirectional_iterator_tag : public forward_iterator_tag { };   struct random_access_iterator_tag : public bidirectional_iterator_tag { };   template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,            typename _Pointer = _Tp*, typename _Reference = _Tp&>     struct iterator     {       typedef _Category iterator_category;       typedef _Tp value_type;       typedef _Distance difference_type;       typedef _Pointer pointer;       typedef _Reference reference;     };   template<typename _Iterator, typename = __void_t<>>     struct __iterator_traits { };   template<typename _Iterator>     struct __iterator_traits<_Iterator,         __void_t<typename _Iterator::iterator_category,           typename _Iterator::value_type,           typename _Iterator::difference_type,           typename _Iterator::pointer,           typename _Iterator::reference>>     {       typedef typename _Iterator::iterator_category iterator_category;       typedef typename _Iterator::value_type value_type;       typedef typename _Iterator::difference_type difference_type;       typedef typename _Iterator::pointer pointer;       typedef typename _Iterator::reference reference;     };   template<typename _Iterator>     struct iterator_traits     : public __iterator_traits<_Iterator> { };   template<typename _Tp>     struct iterator_traits<_Tp*>     {       typedef random_access_iterator_tag iterator_category;       typedef _Tp value_type;       typedef ptrdiff_t difference_type;       typedef _Tp* pointer;       typedef _Tp& reference;     };   template<typename _Tp>     struct iterator_traits<const _Tp*>     {       typedef random_access_iterator_tag iterator_category;       typedef _Tp value_type;       typedef ptrdiff_t difference_type;       typedef const _Tp* pointer;       typedef const _Tp& reference;     };        ;   template<typename _InIter>     using _RequireInputIter = typename       enable_if<is_convertible<typename   iterator_traits<_InIter>::iterator_category,           input_iterator_tag>::value>::type; }
  namespace std __attribute__ ((__visibility__ ("default"))) {   template <typename> struct _List_iterator;   template <typename> struct _List_const_iterator;        ;        ;   ;   ;        ;        ;        ;        ;        ;        ;        ; }
  namespace std __attribute__ ((__visibility__ ("default"))) {   class __undefined;   template<typename _Tp>     struct __get_first_arg     { using type = __undefined; };   template<template<typename, typename...> class _Template, typename _Tp,            typename... _Types>     struct __get_first_arg<_Template<_Tp, _Types...>>     { using type = _Tp; };   template<typename _Tp>     using __get_first_arg_t = typename __get_first_arg<_Tp>::type;   template<typename _Tp, typename _Up>     struct __replace_first_arg     { };   template<template<typename, typename...> class _Template, typename _Up,            typename _Tp, typename... _Types>     struct __replace_first_arg<_Template<_Tp, _Types...>, _Up>     { using type = _Template<_Up, _Types...>; };   template<typename _Tp, typename _Up>     using __replace_first_arg_t = typename __replace_first_arg<_Tp, _Up>::type;   template<typename _Tp>     using __make_not_void       = typename conditional<is_void<_Tp>::value, __undefined, _Tp>::type;   template<typename _Ptr>     struct pointer_traits     {     private:       template<typename _Tp>  using __element_type = typename _Tp::element_type;       template<typename _Tp>  using __difference_type = typename _Tp::difference_type;       template<typename _Tp, typename _Up, typename = void>  struct __rebind : __replace_first_arg<_Tp, _Up> { };       template<typename _Tp, typename _Up>  struct __rebind<_Tp, _Up, __void_t<typename _Tp::template rebind<_Up>>>  { using type = typename _Tp::template rebind<_Up>; };     public:       using pointer = _Ptr;       using element_type  = __detected_or_t<__get_first_arg_t<_Ptr>, __element_type, _Ptr>;       using difference_type  = __detected_or_t<ptrdiff_t, __difference_type, _Ptr>;       template<typename _Up>         using rebind = typename __rebind<_Ptr, _Up>::type;              static_assert(!is_same<element_type, __undefined>::value,    "pointer type defines element_type or is like SomePointer<T, Args>");     };   template<typename _Tp>     struct pointer_traits<_Tp*>     {       typedef _Tp* pointer;       typedef _Tp element_type;       typedef ptrdiff_t difference_type;       template<typename _Up>         using rebind = _Up*;            };   template<typename _Ptr, typename _Tp>     using __ptr_rebind = typename pointer_traits<_Ptr>::template rebind<_Tp>;        ;        ; }
  namespace std __attribute__ ((__visibility__ ("default"))) {   template<typename _Iterator>     class reverse_iterator     : public iterator<typename iterator_traits<_Iterator>::iterator_category,         typename iterator_traits<_Iterator>::value_type,         typename iterator_traits<_Iterator>::difference_type,         typename iterator_traits<_Iterator>::pointer,                       typename iterator_traits<_Iterator>::reference>     {     protected:       _Iterator current;       typedef iterator_traits<_Iterator> __traits_type;     public:       typedef _Iterator iterator_type;       typedef typename __traits_type::difference_type difference_type;       typedef typename __traits_type::pointer pointer;       typedef typename __traits_type::reference reference;                                     ;                                                                                                                                                                                                                                                                                                                                                     private:                ;                ;     };        ;        ;        ;        ;   template<typename _Iterator>      bool     operator<=(const reverse_iterator<_Iterator>& __x,         const reverse_iterator<_Iterator>& __y)     ;   template<typename _Iterator>      bool     operator>=(const reverse_iterator<_Iterator>& __x,         const reverse_iterator<_Iterator>& __y)     ;   template<typename _IteratorL, typename _IteratorR>      bool     operator==(const reverse_iterator<_IteratorL>& __x,         const reverse_iterator<_IteratorR>& __y)     ;   template<typename _IteratorL, typename _IteratorR>      bool     operator<(const reverse_iterator<_IteratorL>& __x,        const reverse_iterator<_IteratorR>& __y)     ;   template<typename _IteratorL, typename _IteratorR>      bool     operator!=(const reverse_iterator<_IteratorL>& __x,         const reverse_iterator<_IteratorR>& __y)     ;   template<typename _IteratorL, typename _IteratorR>      bool     operator>(const reverse_iterator<_IteratorL>& __x,        const reverse_iterator<_IteratorR>& __y)     ;   template<typename _IteratorL, typename _IteratorR>      bool     operator<=(const reverse_iterator<_IteratorL>& __x,         const reverse_iterator<_IteratorR>& __y)     ;   template<typename _IteratorL, typename _IteratorR>      bool     operator>=(const reverse_iterator<_IteratorL>& __x,         const reverse_iterator<_IteratorR>& __y)     ;   template<typename _IteratorL, typename _IteratorR>      auto     operator-(const reverse_iterator<_IteratorL>& __x,        const reverse_iterator<_IteratorR>& __y)     -> decltype(__y.base() - __x.base())     ;   template<typename _Iterator>      reverse_iterator<_Iterator>     operator+(typename reverse_iterator<_Iterator>::difference_type __n,        const reverse_iterator<_Iterator>& __x)     ;   template<typename _Iterator>      reverse_iterator<_Iterator>     __make_reverse_iterator(_Iterator __i)     ;   template<typename _Iterator>     auto     __niter_base(reverse_iterator<_Iterator> __it)     -> decltype(__make_reverse_iterator(__niter_base(__it.base())))     ;   template<typename _Iterator>     struct __is_move_iterator<reverse_iterator<_Iterator> >       : __is_move_iterator<_Iterator>     { };   template<typename _Iterator>     auto     __miter_base(reverse_iterator<_Iterator> __it)     -> decltype(__make_reverse_iterator(__miter_base(__it.base())))     ;   template<typename _Container>     class back_insert_iterator     : public iterator<output_iterator_tag, void, void, void, void>     {     protected:       _Container* container;     public:       typedef _Container container_type;       explicit       back_insert_iterator(_Container& __x)  ;       back_insert_iterator&       operator=(const typename _Container::value_type& __value)       ;       back_insert_iterator&       operator=(typename _Container::value_type&& __value)       ;       back_insert_iterator&       operator*()       ;       back_insert_iterator&       operator++()       ;       back_insert_iterator       operator++(int)       ;     };   template<typename _Container>      back_insert_iterator<_Container>     back_inserter(_Container& __x)     ;   template<typename _Container>     class front_insert_iterator     : public iterator<output_iterator_tag, void, void, void, void>     {     protected:       _Container* container;     public:       typedef _Container container_type;       explicit front_insert_iterator(_Container& __x)  ;       front_insert_iterator&       operator=(const typename _Container::value_type& __value)       ;       front_insert_iterator&       operator=(typename _Container::value_type&& __value)       ;       front_insert_iterator&       operator*()       ;       front_insert_iterator&       operator++()       ;            };        ;   template<typename _Container>     class insert_iterator     : public iterator<output_iterator_tag, void, void, void, void>     {     protected:       _Container* container;       typename _Container::iterator iter;     public:       typedef _Container container_type;                                               };        ; }
  namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {   using std::iterator_traits;   using std::iterator;   template<typename _Iterator, typename _Container>     class __normal_iterator     {     protected:       _Iterator _M_current;       typedef iterator_traits<_Iterator> __traits_type;     public:       typedef _Iterator iterator_type;       typedef typename __traits_type::iterator_category iterator_category;       typedef typename __traits_type::value_type value_type;       typedef typename __traits_type::difference_type difference_type;       typedef typename __traits_type::reference reference;       typedef typename __traits_type::pointer pointer;                       ;                                                                                         };        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;   template<typename _IteratorL, typename _IteratorR, typename _Container>      auto     operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,        const __normal_iterator<_IteratorR, _Container>& __rhs) noexcept     -> decltype(__lhs.base() - __rhs.base())     ;   template<typename _Iterator, typename _Container>      typename __normal_iterator<_Iterator, _Container>::difference_type     operator-(const __normal_iterator<_Iterator, _Container>& __lhs,        const __normal_iterator<_Iterator, _Container>& __rhs)     noexcept     ;        ; }
  namespace std __attribute__ ((__visibility__ ("default"))) {        ;   /**    * @addtogroup iterators    * @{    */  /**    *  Class template move_iterator is an iterator adapter with the same    *  behavior as the underlying iterator except that its dereference    *  operator implicitly converts the value returned by the underlying    *  iterator's dereference operator to an rvalue reference.  Some
   *  generic algorithms can be called with move iterators to replace
   *  copying with moving.
   */
  template<typename _Iterator>
    class move_iterator
    {
    protected:
      _Iterator _M_current;
      typedef iterator_traits<_Iterator> __traits_type;
      typedef typename __traits_type::reference __base_ref;
    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type value_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef _Iterator pointer;
      typedef typename conditional<is_reference<__base_ref>::value,
    typename remove_reference<__base_ref>::type&&,
    __base_ref>::type reference;
        ;
    };
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
  template<typename _IteratorL, typename _IteratorR>
     auto
    operator-(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    -> decltype(__x.base() - __y.base())
    ;
  template<typename _Iterator>
     move_iterator<_Iterator>
    operator+(typename move_iterator<_Iterator>::difference_type __n,
       const move_iterator<_Iterator>& __x)
    ;
  template<typename _Iterator>
     move_iterator<_Iterator>
    make_move_iterator(_Iterator __i)
    ;
  template<typename _Iterator, typename _ReturnType
    = typename conditional<__move_if_noexcept_cond
      <typename iterator_traits<_Iterator>::value_type>::value,
                _Iterator, move_iterator<_Iterator>>::type>
     _ReturnType
    __make_move_if_noexcept_iterator(_Iterator __i)
    ;
  template<typename _Tp, typename _ReturnType
    = typename conditional<__move_if_noexcept_cond<_Tp>::value,
      const _Tp*, move_iterator<_Tp*>>::type>
     _ReturnType
    __make_move_if_noexcept_iterator(_Tp* __i)
    ;
  template<typename _Iterator>
    auto
    __niter_base(move_iterator<_Iterator> __it)
    -> decltype(make_move_iterator(__niter_base(__it.base())))
    ;
  template<typename _Iterator>
    struct __is_move_iterator<move_iterator<_Iterator> >
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
  template<typename _Iterator>
    auto
    __miter_base(move_iterator<_Iterator> __it)
    -> decltype(__miter_base(__it.base()))
    ;
} 
/** @file debug/debug.h
 *  This file is a GNU debug extension to the Standard C++ Library.
 */
/** Macros and namespaces used by the implementation outside of debug
 *  wrappers to verify certain properties. The __glibcxx_requires_xxx
 *  macros are merely wrappers around the __glibcxx_check_xxx wrappers
 *  when we are compiling with debug mode, but disappear when we are
 *  in release mode so that there is no checking performed in, e.g.,
 *  the standard library algorithms.
*/
/**
 * @namespace std::__debug
 * @brief GNU debug code, replaces standard behavior with debug behavior.
 */
namespace std
{
  namespace __debug { }
}
/** @namespace __gnu_debug
 *  @brief GNU debug classes for public use.
*/
namespace __gnu_debug
{
  using namespace std::__debug;
}
/** @file predefined_ops.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly. @headername{algorithm}
 */
namespace __gnu_cxx
{
namespace __ops
{
  struct _Iter_less_iter
  {
    template<typename _Iterator1, typename _Iterator2>
      bool
      operator()(_Iterator1 __it1, _Iterator2 __it2) const
      ;
  };
   _Iter_less_iter
  __iter_less_iter()
  ;
  struct _Iter_less_val
  {
      ;
  };
  struct _Val_less_iter
  {
      ;
  };
  struct _Iter_equal_to_iter
  {
      ;
  };
  struct _Iter_equal_to_val
  {
      ;
  };
  template<typename _Compare>
    struct _Iter_comp_iter
    {
      _Compare _M_comp;
        ;
    };
    ;
  template<typename _Compare>
    struct _Iter_comp_val
    {
      _Compare _M_comp;
 ;
    };
    ;
    ;
  template<typename _Compare>
    struct _Val_comp_iter
    {
      _Compare _M_comp;
 ;
    };
    ;
    ;
  template<typename _Value>
    struct _Iter_equals_val
    {
      _Value& _M_value;
 ;
    };
    ;
  template<typename _Iterator1>
    struct _Iter_equals_iter
    {
 ;
    };
    ;
  template<typename _Predicate>
    struct _Iter_negate
    {
      _Predicate _M_pred;
 ;
    };
    ;
} 
} 
namespace std __attribute__ ((__visibility__ ("default")))
{
  /**
   *  @brief Swaps the contents of two iterators.
   *  @ingroup mutating_algorithms
   *  @param  __a  An iterator.
   *  @param  __b  Another iterator.
   *  @return   Nothing.
   *
   *  This function swaps the values pointed to by two iterators, not the
   *  iterators themselves.
  */
    ;
  /**
   *  @brief Swap the elements of two sequences.
   *  @ingroup mutating_algorithms
   *  @param  __first1  A forward iterator.
   *  @param  __last1   A forward iterator.
   *  @param  __first2  A forward iterator.
   *  @return   An iterator equal to @p first2+(last1-first1).
   *
   *  Swaps each element in the range @p [first1,last1) with the
   *  corresponding element in the range @p [first2,(last1-first1)).
   *  The ranges must not overlap.
  */
    ;
  /**
   *  @brief This does what you think it does.
   *  @ingroup sorting_algorithms
   *  @param  __a  A thing of arbitrary type.
   *  @param  __b  Another thing of arbitrary type.
   *  @return   The lesser of the parameters.
   *
   *  This is the simple classic generic implementation.  It will work on
   *  temporary expressions, since they are only evaluated once, unlike a
   *  preprocessor macro.
  */
    ;
  /**
   *  @brief This does what you think it does.
   *  @ingroup sorting_algorithms
   *  @param  __a  A thing of arbitrary type.
   *  @param  __b  Another thing of arbitrary type.
   *  @param  __comp  A @link comparison_functors comparison functor@endlink.
   *  @return   The greater of the parameters.
   *
   *  This will work on temporary expressions, since they are only evaluated
   *  once, unlike a preprocessor macro.
  */
    ;
    ;
    ;
    ;
  template<bool, bool, typename>
    struct __copy_move
    {
 ;
    };
  template<typename _Category>
    struct __copy_move<true, false, _Category>
    {
 ;
    };
  template<>
    struct __copy_move<false, false, random_access_iterator_tag>
    {
 ;
    };
  template<>
    struct __copy_move<true, false, random_access_iterator_tag>
    {
 ;
    };
  template<bool _IsMove>
    struct __copy_move<_IsMove, true, random_access_iterator_tag>
    {
 ;
    };
    ;
  template<typename _CharT>
    struct char_traits;
  template<typename _CharT, typename _Traits>
    class istreambuf_iterator;
  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator;
  ;
  ;
  ;
    ;
    ;
    ;
  template<bool, bool, typename>
    struct __copy_move_backward
    {
 ;
    };
  template<typename _Category>
    struct __copy_move_backward<true, false, _Category>
    {
 ;
    };
  template<>
    struct __copy_move_backward<false, false, random_access_iterator_tag>
    {
 ;
    };
  template<>
    struct __copy_move_backward<true, false, random_access_iterator_tag>
    {
 ;
    };
  template<bool _IsMove>
    struct __copy_move_backward<_IsMove, true, random_access_iterator_tag>
    {
 ;
    };
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
  template<bool _BoolType>
    struct __equal
    {
 ;
    };
  template<>
    struct __equal<true>
    {
 ;
    };
    ;
  template<typename, typename>
    struct __lc_rai
    {
 ;
 ;
    };
  template<>
    struct __lc_rai<random_access_iterator_tag, random_access_iterator_tag>
    {
 ;
 ;
    };
    ;
  template<bool _BoolType>
    struct __lexicographical_compare
    {
      ;
    };
  template<>
    struct __lexicographical_compare<true>
    {
 ;
    };
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
} 
/* Copyright (C) 1991-2019 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
 */
/* Some C libraries expect to see a wint_t here. Others (notably MinGW) will use
__WINT_TYPE__ directly; accommodate both by requiring __need_wint_t */
extern "C" {
/* XPG requires a few symbols from <sys/wait.h> being defined.  */
/* Definitions of flag bits for `waitpid' et al.    Copyright (C) 1992-2019 Free Software Foundation, Inc.    This file is part of the GNU C Library.    The GNU C Library is free software; you can redistribute it and/or    modify it under the terms of the GNU Lesser General Public    License as published by the Free Software Foundation; either    version 2.1 of the License, or (at your option) any later version.    The GNU C Library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.    You should have received a copy of the GNU Lesser General Public    License along with the GNU C Library; if not, see    <http://www.gnu.org/licenses/>.  */
typedef enum {   P_ALL,    P_PID,    P_PGID  } idtype_t; typedef float _Float32; typedef double _Float64; typedef double _Float32x; typedef long double _Float64x; typedef struct   {     int quot;      int rem;    } div_t; typedef struct   {     long int quot;      long int rem;    } ldiv_t; __extension__ typedef struct   {     long long int quot;      long long int rem;    } lldiv_t;  ;  ;  ;  ;  ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; struct __locale_struct {   struct __locale_data *__locales[13];    const unsigned short int *__ctype_b;   const int *__ctype_tolower;   const int *__ctype_toupper;   const char *__names[13]; }; typedef struct __locale_struct *__locale_t; typedef __locale_t locale_t; ; ; ; ; ; ; ; ; ; ; ;  ;  ; extern "C" { typedef __u_char u_char; typedef __u_short u_short; typedef __u_int u_int; typedef __u_long u_long; typedef __quad_t quad_t; typedef __u_quad_t u_quad_t; typedef __fsid_t fsid_t; typedef __loff_t loff_t; typedef __ino_t ino_t; typedef __ino64_t ino64_t; typedef __dev_t dev_t; typedef __gid_t gid_t; typedef __mode_t mode_t; typedef __nlink_t nlink_t; typedef __uid_t uid_t; typedef __off_t off_t; typedef __off64_t off64_t; typedef __pid_t pid_t; typedef __id_t id_t; typedef __ssize_t ssize_t; typedef __daddr_t daddr_t; typedef __caddr_t caddr_t; typedef __key_t key_t; typedef __clock_t clock_t; typedef __clockid_t clockid_t; typedef __time_t time_t; typedef __timer_t timer_t; typedef __useconds_t useconds_t; typedef __suseconds_t suseconds_t; typedef unsigned long int ulong; typedef unsigned short int ushort; typedef unsigned int uint; typedef __uint8_t u_int8_t; typedef __uint16_t u_int16_t; typedef __uint32_t u_int32_t; typedef __uint64_t u_int64_t; typedef int register_t __attribute__ ((__mode__ (__word__)));  ;  ;  ;  ;  ;  ; typedef struct {   unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))]; } __sigset_t; typedef __sigset_t sigset_t; struct timeval {   __time_t tv_sec;    __suseconds_t tv_usec;  }; struct timespec {   __time_t tv_sec;    __syscall_slong_t tv_nsec;  }; typedef long int __fd_mask; typedef struct   {     __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];   } fd_set; typedef __fd_mask fd_mask; extern "C" { ; ; } typedef __blksize_t blksize_t; typedef __blkcnt_t blkcnt_t;  typedef __fsblkcnt_t fsblkcnt_t;  typedef __fsfilcnt_t fsfilcnt_t;  typedef __blkcnt64_t blkcnt64_t;  typedef __fsblkcnt64_t fsblkcnt64_t;  typedef __fsfilcnt64_t fsfilcnt64_t;  struct __pthread_rwlock_arch_t {   unsigned int __readers;   unsigned int __writers;   unsigned int __wrphase_futex;   unsigned int __writers_futex;   unsigned int __pad3;   unsigned int __pad4;   int __cur_writer;   int __shared;   signed char __rwelision;   unsigned char __pad1[7];   unsigned long int __pad2;   unsigned int __flags; }; typedef struct __pthread_internal_list {   struct __pthread_internal_list *__prev;   struct __pthread_internal_list *__next; } __pthread_list_t; struct __pthread_mutex_s {   int __lock ;   unsigned int __count;   int __owner;   unsigned int __nusers;   int __kind;   short __spins; short __elision;   __pthread_list_t __list; }; struct __pthread_cond_s {   __extension__ union   {     __extension__ unsigned long long int __wseq;     struct     {       unsigned int __low;       unsigned int __high;     } __wseq32;   };   __extension__ union   {     __extension__ unsigned long long int __g1_start;     struct     {       unsigned int __low;       unsigned int __high;     } __g1_start32;   };   unsigned int __g_refs[2] ;   unsigned int __g_size[2];   unsigned int __g1_orig_size;   unsigned int __wrefs;   unsigned int __g_signals[2]; }; typedef unsigned long int pthread_t; typedef union {   char __size[4];   int __align; } pthread_mutexattr_t; typedef union {   char __size[4];   int __align; } pthread_condattr_t; typedef unsigned int pthread_key_t; typedef int pthread_once_t; union pthread_attr_t {   char __size[56];   long int __align; }; typedef union pthread_attr_t pthread_attr_t; typedef union {   struct __pthread_mutex_s __data;   char __size[40];   long int __align; } pthread_mutex_t; typedef union {   struct __pthread_cond_s __data;   char __size[48];   __extension__ long long int __align; } pthread_cond_t; typedef union {   struct __pthread_rwlock_arch_t __data;   char __size[56];   long int __align; } pthread_rwlock_t; typedef union {   char __size[8];   long int __align; } pthread_rwlockattr_t; typedef volatile int pthread_spinlock_t; typedef union {   char __size[32];   long int __align; } pthread_barrier_t; typedef union {   char __size[4];   int __align; } pthread_barrierattr_t; } ; ; ; ; struct random_data   {     int32_t *fptr;      int32_t *rptr;      int32_t *state;      int rand_type;      int rand_deg;      int rand_sep;      int32_t *end_ptr;    }; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; struct drand48_data   {     unsigned short int __x[3];      unsigned short int __old_x[3];      unsigned short int __c;      unsigned short int __init;      __extension__ unsigned long long int __a;    }; ; ; ; ; ; ; ; ; ;                                           ;  ;  ;                                        ; ; extern "C" { ; }                                           ;  ;  ; ; ; ; ; ; ; ;  ;  ; ; ; ; ; ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ; typedef int (*__compar_fn_t) (const void *, const void *); typedef __compar_fn_t comparison_fn_t; typedef int (*__compar_d_fn_t) (const void *, const void *, void *);  ; ; ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ; ; ; ; ; ; ; ; ; ;  ;  ;  ; ; ;  ; ; ; ; } extern "C++" { namespace std __attribute__ ((__visibility__ ("default"))) {                                }  }  extern "C++" { namespace std __attribute__ ((__visibility__ ("default"))) {   using ::div_t;   using ::ldiv_t;                                                                                            }  namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {   using ::lldiv_t;                             }  namespace std {   using ::__gnu_cxx::lldiv_t;                            }  }  /** @file bits/algorithmfwd.h  *  This is an internal header file, included by other library headers.  *  Do not attempt to use it directly. @headername{algorithm}  */namespace std __attribute__ ((__visibility__ ("default"))) {   /*     adjacent_find     all_of (C++11)     any_of (C++11)     binary_search     clamp (C++17)     copy     copy_backward     copy_if (C++11)     copy_n (C++11)     count     count_if     equal     equal_range     fill     fill_n     find     find_end     find_first_of     find_if     find_if_not (C++11)     for_each     generate     generate_n     includes     inplace_merge     is_heap (C++11)     is_heap_until (C++11)     is_partitioned (C++11)     is_sorted (C++11)     is_sorted_until (C++11)     iter_swap     lexicographical_compare     lower_bound     make_heap     max     max_element     merge     min     min_element     minmax (C++11)     minmax_element (C++11)     mismatch     next_permutation     none_of (C++11)     nth_element     partial_sort     partial_sort_copy     partition     partition_copy (C++11)     partition_point (C++11)     pop_heap     prev_permutation     push_heap     random_shuffle     remove     remove_copy     remove_copy_if     remove_if     replace     replace_copy     replace_copy_if     replace_if     reverse     reverse_copy     rotate     rotate_copy     search     search_n     set_difference     set_intersection     set_symmetric_difference     set_union     shuffle (C++11)     sort     sort_heap     stable_partition     stable_sort     swap     swap_ranges     transform     unique     unique_copy     upper_bound   */  /**    * @defgroup algorithms Algorithms    *    * Components for performing algorithmic operations. Includes    * non-modifying sequence, modifying (mutating) sequence, sorting,    * searching, merge, partition, heap, set, minima, maxima, and    * permutation operations.    */  /**    * @defgroup mutating_algorithms Mutating    * @ingroup algorithms    */  /**    * @defgroup non_mutating_algorithms Non-Mutating    * @ingroup algorithms    */  /**    * @defgroup sorting_algorithms Sorting    * @ingroup algorithms    */  /**    * @defgroup set_algorithms Set Operations    * @ingroup sorting_algorithms    *    * These algorithms are common set operations performed on sequences    * that are already sorted. The number of comparisons will be    * linear.    */  /**    * @defgroup binary_search_algorithms Binary Search    * @ingroup sorting_algorithms    *    * These algorithms are variations of a classic binary search, and    * all assume that the sequence being searched is already sorted.    *    * The number of comparisons will be logarithmic (and as few as    * possible).  The number of steps through the sequence will be    * logarithmic for random-access iterators (e.g., pointers), and    * linear otherwise.    *    * The LWG has passed Defect Report 270, which notes: <em>The    * proposed resolution reinterprets binary search. Instead of    * thinking about searching for a value in a sorted range, we view    * that as an important special case of a more general algorithm:    * searching for the partition point in a partitioned range.  We    * also add a guarantee that the old wording did not: we ensure that    * the upper bound is no earlier than the lower bound, that the pair    * returned by equal_range is a valid range, and that the first part    * of that pair is the lower bound.</em>    *    * The actual effect of the first sentence is that a comparison    * functor passed by the user doesn't necessarily need to induce a
   * strict weak ordering relation.  Rather, it partitions the range.
   */
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
    ;
  /**
   *  @brief  Search the end of a heap using comparison functor.
   *  @param  __first  Start of range.
   *  @param  __last   End of range.
   *  @param  __comp   Comparison functor to use.
   *  @return  An iterator pointing to the first element not in the heap.
   *  @ingroup heap_algorithms
   *
   *  This operation returns the last iterator i in [__first, __last) for which
   *  the range [__first, i) is a heap.  Comparisons are made using __comp.
  */
    ;
  /**
   *  @brief  Determines whether a range is a heap.
   *  @param  __first  Start of range.
   *  @param  __last   End of range.
   *  @return  True if range is a heap, false otherwise.
   *  @ingroup heap_algorithms
  */
    ;
  /**
   *  @brief  Determines whether a range is a heap using comparison functor.
   *  @param  __first  Start of range.
   *  @param  __last   End of range.
   *  @param  __comp   Comparison functor to use.
   *  @return  True if range is a heap, false otherwise.
   *  @ingroup heap_algorithms
  */
    ;
} 
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1996,1997
 * Silicon Graphics Computer Systems, Inc.
 *
/** @file exception
 *  This is a Standard C++ Library header.
 */
#pragma GCC visibility push(default)
/** @file bits/exception.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly.
 */
#pragma GCC visibility push(default)
extern "C++" {
namespace std
{
  /**
   * @defgroup exceptions Exceptions
   * @ingroup diagnostics
   *
   * Classes and functions for reporting errors via exception classes.
   * @{
   */
  /**
   *  @brief Base class for all library exceptions.
   *
   *  This is the base class for all exceptions thrown by the standard
   *  library, and by certain language expressions.  You are free to derive
   *  your own %exception classes, or use a different hierarchy, or to
   *  throw non-class data (e.g., fundamental types).
   */
  class exception
  {
  public:
    /** Returns a C-style character string describing the general cause
     *  of the current error.  */
  };
} 
}
#pragma GCC visibility pop
extern "C++" {
namespace std
{
  /** If an %exception is thrown which is not listed in a function's    *  %exception specification, one of these may be thrown.  */  class bad_exception : public exception   {   public:     bad_exception() noexcept ;     virtual ~bad_exception() noexcept;     virtual const char*     what() const noexcept;   };   typedef void (*terminate_handler) ();   typedef void (*unexpected_handler) ();   terminate_handler set_terminate(terminate_handler) noexcept;   terminate_handler get_terminate() noexcept;   /** The runtime will call this function if %exception handling must be    *  abandoned for any reason.  It can also be called by the user.  */  void terminate() noexcept __attribute__ ((__noreturn__));   unexpected_handler set_unexpected(unexpected_handler) noexcept;   unexpected_handler get_unexpected() noexcept;   /** The runtime will call this function if an %exception is thrown which    *  violates the function's %exception specification.  */
  void unexpected() __attribute__ ((__noreturn__));
  /** [18.6.4]/1:  'Returns true after completing evaluation of a    *  throw-expression until either completing initialization of the    *  exception-declaration in the matching handler or entering @c unexpected()    *  due to the throw; or after entering @c terminate() for any reason    *  other than an explicit call to @c terminate().  [Note: This includes    *  stack unwinding [15.2].  end note]'
   *
   *  2: 'When @c uncaught_exception() is true, throwing an    *  %exception can result in a call of @c terminate()    *  (15.5.1).'
   */
} 
namespace __gnu_cxx
{
  /**
   *  @brief A replacement for the standard terminate_handler which
   *  prints more information about the terminating exception (if any)
   *  on stderr.
   *
   *  @ingroup exceptions
   *
   *  Call
   *   @code
   *     std::set_terminate(__gnu_cxx::__verbose_terminate_handler)
   *   @endcode
   *  to use.  For more info, see
   *  http:
   *
   *  In 3.4 and later, this is on by default.
   */
} 
} 
#pragma GCC visibility pop
/** @file bits/exception_ptr.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{exception}
 */
#pragma GCC visibility push(default)
/** @file bits/cxxabi_init_exception.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly.
 */
#pragma GCC visibility push(default)
/*===---- stddef.h - Basic type definitions --------------------------------===
 *
 * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 * See https:
 * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 *
 *===-----------------------------------------------------------------------===
 */
namespace std
{
  class type_info;
}
namespace __cxxabiv1
{
  struct __cxa_refcounted_exception;
  extern "C"
    {
      ;
      ;
      ;
    }
} 
#pragma GCC visibility pop
/** @file typeinfo
 *  This is a Standard C++ Library header.
 */
/** @file bits/hash_bytes.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{functional}
 */
namespace std
{
} 
#pragma GCC visibility push(default)
extern "C++" {
namespace __cxxabiv1
{
  class __class_type_info;
} 
namespace std
{
  /**
   *  @brief  Part of RTTI.
   *
   *  The @c type_info class describes type information generated by
   *  an implementation.
  */
  class type_info
  {
  public:
    /** Destructor first. Being the first non-inline virtual function, this
     *  controls in which translation unit the vtable is emitted. The
     *  compiler makes use of that information to know where to emit
     *  the runtime-mandated type_info structures in the new-abi.  */
    /** Returns an @e implementation-defined byte string; this is not
     *  portable between compilers!  */
    /** Returns true if @c *this precedes @c __arg in the implementation's      *  collation order.  */                                          protected:     const char *__name;        private:             };   /**    *  @brief  Thrown during incorrect typecasting.    *  @ingroup exceptions    *    *  If you attempt an invalid @c dynamic_cast expression, an instance of    *  this class (or something derived from this class) is thrown.  */  class bad_cast : public exception   {   public:                  };   /**    *  @brief Thrown when a NULL pointer in a @c typeid expression is used.    *  @ingroup exceptions    */  class bad_typeid : public exception   {   public:                  }; }
  }
#pragma GCC visibility pop
/** @file new  *  This is a Standard C++ Library header.  *  *  The header @c new defines several functions to manage dynamic memory and  *  handling memory allocation errors;
 see  *  http:  */
extern "C++" {
 namespace std {   class type_info;   /**    * @addtogroup exceptions    * @{    */  namespace __exception_ptr   {     class exception_ptr;   }   using __exception_ptr::exception_ptr;   /** Obtain an exception_ptr to the currently handled exception. If there    *  is none, or the currently handled exception is foreign, return the null    *  value.    */     ;   void rethrow_exception(exception_ptr) __attribute__ ((__noreturn__));   namespace __exception_ptr   {     using std::rethrow_exception;     /**      *  @brief An opaque pointer to an arbitrary exception.      *  @ingroup exceptions      */    class exception_ptr     {       void* _M_exception_object;       explicit exception_ptr(void* __e) noexcept;       void _M_addref() noexcept;       void _M_release() noexcept;       void *_M_get() const noexcept __attribute__ ((__pure__));              friend void std::rethrow_exception(exception_ptr);       ;     public:       exception_ptr() noexcept;       exception_ptr(const exception_ptr&) noexcept;       exception_ptr(nullptr_t)        ;       exception_ptr(exception_ptr&& __o)        ;       exception_ptr&       operator=(const exception_ptr&) noexcept;       exception_ptr&       operator=(exception_ptr&& __o) noexcept       ;       ~exception_ptr() noexcept;       void       swap(exception_ptr&) noexcept;       explicit operator bool() const       ;       friend bool       operator==(const exception_ptr&, const exception_ptr&)  noexcept __attribute__ ((__pure__));       const class std::type_info*       __cxa_exception_type() const noexcept  __attribute__ ((__pure__));     };     bool     operator==(const exception_ptr&, const exception_ptr&)       noexcept __attribute__ ((__pure__));     bool     operator!=(const exception_ptr&, const exception_ptr&)       noexcept __attribute__ ((__pure__));      void     swap(exception_ptr& __lhs, exception_ptr& __rhs)     ;            ;   }         ; }  }
#pragma GCC visibility pop
/** @file bits/nested_exception.h  *  This is an internal header file, included by other library headers.  *  Do not attempt to use it directly. @headername{exception}
  */
#pragma GCC visibility push(default)
extern "C++" { namespace std {   /**    * @addtogroup exceptions    * @{    */  class nested_exception   {     exception_ptr _M_ptr;   public:                         [[noreturn]]     void     rethrow_nested() const     {       if (_M_ptr)  rethrow_exception(_M_ptr);       std::terminate();     }     exception_ptr     nested_ptr() const noexcept     { return _M_ptr; }   };   template<typename _Except>     struct _Nested_exception : public _Except, public nested_exception     {                   };   template<typename _Tp>     [[noreturn]]     inline void     __throw_with_nested_impl(_Tp&& __t, true_type)     {       using _Up = typename remove_reference<_Tp>::type;       throw _Nested_exception<_Up>{std::forward<_Tp>(__t)};     }   template<typename _Tp>     [[noreturn]]     inline void     __throw_with_nested_impl(_Tp&& __t, false_type)     { throw std::forward<_Tp>(__t); }   template<typename _Tp>     [[noreturn]]     inline void     throw_with_nested(_Tp&& __t)     {       using _Up = typename decay<_Tp>::type;       using _CopyConstructible  = __and_<is_copy_constructible<_Up>, is_move_constructible<_Up>>;       static_assert(_CopyConstructible::value,    "throw_with_nested argument must be CopyConstructible");       using __nest = __and_<is_class<_Up>, __bool_constant<!__is_final(_Up)>,        __not_<is_base_of<nested_exception, _Up>>>;       std::__throw_with_nested_impl(std::forward<_Tp>(__t), __nest{});     }   template<typename _Tp>     using __rethrow_if_nested_cond = typename enable_if<       __and_<is_polymorphic<_Tp>,       __or_<__not_<is_base_of<nested_exception, _Tp>>,      is_convertible<_Tp*, nested_exception*>>>::value     >::type;        ;            ; }  }  
#pragma GCC visibility pop
#pragma GCC visibility push(default)
extern "C++" { namespace std {   /**    *  @brief  Exception possibly thrown by @c new.    *  @ingroup exceptions    *    *  @c bad_alloc (or classes derived from it) is used to report allocation    *  errors from the throwing forms of @c new.  */  class bad_alloc : public exception   {   public:                            };   class bad_array_new_length : public bad_alloc   {   public:                  };   struct nothrow_t   {        };   extern const nothrow_t nothrow;   /** If you write your own error handler to be called by @c new, it must    *  be of this type.  */  typedef void (*new_handler)();       }  /** These are replaceable signatures:  *  - normal single new and delete (no arguments, throw @c bad_alloc on error)  *  - normal array new and delete (same)  *  - @c nothrow single new and delete (take a @c nothrow argument, return  *    @c NULL on error)  *  - @c nothrow array new and delete (same)  *  *  Placement new and delete signatures (take a memory address argument,  *  does nothing) may not be replaced by a user's program.
*/
                   void* operator new(std::size_t)
  __attribute__((__externally_visible__));
                   void* operator new[](std::size_t)
  __attribute__((__externally_visible__));
void operator delete(void*) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*) noexcept
  __attribute__((__externally_visible__));
                   ;
                   ;
;
;
;
;
  ;
  ;
} 
#pragma GCC visibility pop
/** @file ext/alloc_traits.h
 *  This file is a GNU extension to the Standard C++ Library.
 */
/** @file bits/alloc_traits.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{memory}
 */
/*
 * Copyright (c) 1996-1997
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */
/** @file bits/memoryfwd.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{memory}
 */
namespace std __attribute__ ((__visibility__ ("default")))
{
  /**
   * @defgroup allocators Allocators
   * @ingroup memory
   *
   * Classes encapsulating memory operations.
   *
   * @{
   */
  template<typename>
    class allocator;
  template<>
    class allocator<void>;
  template<typename, typename>
    struct uses_allocator;
} 
namespace std __attribute__ ((__visibility__ ("default")))
{
  struct __allocator_traits_base
  {
    template<typename _Tp, typename _Up, typename = void>
      struct __rebind : __replace_first_arg<_Tp, _Up> { };
    template<typename _Tp, typename _Up>
      struct __rebind<_Tp, _Up,
        __void_t<typename _Tp::template rebind<_Up>::other>>
      { using type = typename _Tp::template rebind<_Up>::other; };
  protected:
    template<typename _Tp>
      using __pointer = typename _Tp::pointer;
    template<typename _Tp>
      using __c_pointer = typename _Tp::const_pointer;
    template<typename _Tp>
      using __v_pointer = typename _Tp::void_pointer;
    template<typename _Tp>
      using __cv_pointer = typename _Tp::const_void_pointer;
    template<typename _Tp>
      using __pocca = typename _Tp::propagate_on_container_copy_assignment;
    template<typename _Tp>
      using __pocma = typename _Tp::propagate_on_container_move_assignment;
    template<typename _Tp>
      using __pocs = typename _Tp::propagate_on_container_swap;
    template<typename _Tp>
      using __equal = typename _Tp::is_always_equal;
  };
  template<typename _Alloc, typename _Up>
    using __alloc_rebind
      = typename __allocator_traits_base::template __rebind<_Alloc, _Up>::type;
  /**
   * @brief  Uniform interface to all allocator types.
   * @ingroup allocators
  */
  template<typename _Alloc>
    struct allocator_traits : __allocator_traits_base
    {
      typedef _Alloc allocator_type;
      typedef typename _Alloc::value_type value_type;
      /**
       * @brief   The allocator's pointer type.        *        * @c Alloc::pointer if that type exists, otherwise @c value_type*       */      using pointer = __detected_or_t<value_type*, __pointer, _Alloc>;     private:       template<template<typename> class _Func, typename _Tp, typename = void>  struct _Ptr  {    using type = typename pointer_traits<pointer>::template rebind<_Tp>;  };       template<template<typename> class _Func, typename _Tp>  struct _Ptr<_Func, _Tp, __void_t<_Func<_Alloc>>>  {    using type = _Func<_Alloc>;  };       template<typename _A2, typename _PtrT, typename = void>  struct _Diff  { using type = typename pointer_traits<_PtrT>::difference_type; };       template<typename _A2, typename _PtrT>  struct _Diff<_A2, _PtrT, __void_t<typename _A2::difference_type>>  { using type = typename _A2::difference_type; };       template<typename _A2, typename _DiffT, typename = void>  struct _Size : make_unsigned<_DiffT> { };       template<typename _A2, typename _DiffT>  struct _Size<_A2, _DiffT, __void_t<typename _A2::size_type>>  { using type = typename _A2::size_type; };     public:       /**        * @brief   The allocator's const pointer type.
       *
       * @c Alloc::const_pointer if that type exists, otherwise
       * <tt> pointer_traits<pointer>::rebind<const value_type> </tt>
      */
      using const_pointer = typename _Ptr<__c_pointer, const value_type>::type;
      /**
       * @brief   The allocator's void pointer type.        *        * @c Alloc::void_pointer if that type exists, otherwise        * <tt> pointer_traits<pointer>::rebind<void> </tt>       */      using void_pointer = typename _Ptr<__v_pointer, void>::type;       /**        * @brief   The allocator's const void pointer type.
       *
       * @c Alloc::const_void_pointer if that type exists, otherwise
       * <tt> pointer_traits<pointer>::rebind<const void> </tt>
      */
      using const_void_pointer = typename _Ptr<__cv_pointer, const void>::type;
      /**
       * @brief   The allocator's difference type        *        * @c Alloc::difference_type if that type exists, otherwise        * <tt> pointer_traits<pointer>::difference_type </tt>       */      using difference_type = typename _Diff<_Alloc, pointer>::type;       /**        * @brief   The allocator's size type
       *
       * @c Alloc::size_type if that type exists, otherwise
       * <tt> make_unsigned<difference_type>::type </tt>
      */
      using size_type = typename _Size<_Alloc, difference_type>::type;
      /**
       * @brief   How the allocator is propagated on copy assignment
       *
       * @c Alloc::propagate_on_container_copy_assignment if that type exists,
       * otherwise @c false_type
      */
      using propagate_on_container_copy_assignment
 = __detected_or_t<false_type, __pocca, _Alloc>;
      /**
       * @brief   How the allocator is propagated on move assignment
       *
       * @c Alloc::propagate_on_container_move_assignment if that type exists,
       * otherwise @c false_type
      */
      using propagate_on_container_move_assignment
 = __detected_or_t<false_type, __pocma, _Alloc>;
      /**
       * @brief   How the allocator is propagated on swap
       *
       * @c Alloc::propagate_on_container_swap if that type exists,
 static void destroy(_Alloc& __a, _Tp* __p)
 noexcept(noexcept(_S_destroy(__a, __p, 0)))
 ;
      /**
       *  @brief  The maximum supported allocation size
       *  @param  __a  An allocator.
       *  @return @c __a.max_size() or @c numeric_limits<size_type>::max()
       *
       *  Returns @c __a.max_size() if that expression is well-formed,
       *  otherwise returns @c numeric_limits<size_type>::max()
      */
      static size_type max_size(const _Alloc& __a) noexcept
      ;
      /**
       *  @brief  Obtain an allocator to use when copying a container.
       *  @param  __rhs  An allocator.
       *  @return @c __rhs.select_on_container_copy_construction() or @a __rhs
       *
       *  Returns @c __rhs.select_on_container_copy_construction() if that
       *  expression is well-formed, otherwise returns @a __rhs
      */
      static _Alloc
      select_on_container_copy_construction(const _Alloc& __rhs)
      ;
    };
  template<typename _Tp>
    struct allocator_traits<allocator<_Tp>>
    {
      using allocator_type = allocator<_Tp>;
      using value_type = _Tp;
      using pointer = _Tp*;
      using const_pointer = const _Tp*;
      using void_pointer = void*;
      using const_void_pointer = const void*;
      using difference_type = std::ptrdiff_t;
      using size_type = std::size_t;
      using propagate_on_container_copy_assignment = false_type;
      using propagate_on_container_move_assignment = true_type;
      using propagate_on_container_swap = false_type;
      using is_always_equal = true_type;
      template<typename _Up>
 using rebind_alloc = allocator<_Up>;
      template<typename _Up>
 using rebind_traits = allocator_traits<allocator<_Up>>;
      /**
       *  @brief  Allocate memory.
       *  @param  __a  An allocator.
       *  @param  __n  The number of objects to allocate space for.
       *
       *  Calls @c a.allocate(n)
      */
                         static pointer
      allocate(allocator_type& __a, size_type __n)
      ;
      /**
       *  @brief  Allocate memory.
       *  @param  __a  An allocator.
       *  @param  __n  The number of objects to allocate space for.
       *  @param  __hint Aid to locality.
       *  @return Memory of suitable size and alignment for @a n objects
       *          of type @c value_type
       *
       *  Returns <tt> a.allocate(n, hint) </tt>
      */
                         static pointer
      allocate(allocator_type& __a, size_type __n, const_void_pointer __hint)
      ;
      /**
       *  @brief  Deallocate memory.
       *  @param  __a  An allocator.
       *  @param  __p  Pointer to the memory to deallocate.
       *  @param  __n  The number of objects space was allocated for.
       *
       *  Calls <tt> a.deallocate(p, n) </tt>
      */
      static void
      deallocate(allocator_type& __a, pointer __p, size_type __n)
      ;
      /**
       *  @brief  Construct an object of type @a _Up
       *  @param  __a  An allocator.
       *  @param  __p  Pointer to memory of suitable size and alignment for Tp
       *  @param  __args Constructor arguments.
       *
       *  Calls <tt> __a.construct(__p, std::forward<Args>(__args)...) </tt>
      */
      template<typename _Up, typename... _Args>
 static void
 construct(allocator_type& __a, _Up* __p, _Args&&... __args)
 noexcept(noexcept(__a.construct(__p, std::forward<_Args>(__args)...)))
 ;
      /**
       *  @brief  Destroy an object of type @a _Up
       *  @param  __a  An allocator.
       *  @param  __p  Pointer to the object to destroy
       *
       *  Calls @c __a.destroy(__p).
      */
      template<typename _Up>
 static void
 destroy(allocator_type& __a, _Up* __p)
 noexcept(noexcept(__a.destroy(__p)))
 ;
      /**
       *  @brief  The maximum supported allocation size
       *  @param  __a  An allocator.
       *  @return @c __a.max_size()
      */
      static size_type
      max_size(const allocator_type& __a) noexcept
      ;
      /**
       *  @brief  Obtain an allocator to use when copying a container.
       *  @param  __rhs  An allocator.
       *  @return @c __rhs
      */
      static allocator_type
      select_on_container_copy_construction(const allocator_type& __rhs)
      ;
    };
  template<typename _Alloc>
     void
    __do_alloc_on_copy(_Alloc& __one, const _Alloc& __two, true_type)
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
  template<typename _Alloc, typename _Tp,
    typename _ValueT = __remove_cvref_t<typename _Alloc::value_type>,
    typename = void>
    struct __is_alloc_insertable_impl
    : false_type
    { };
  template<typename _Alloc, typename _Tp, typename _ValueT>
    struct __is_alloc_insertable_impl<_Alloc, _Tp, _ValueT,
      __void_t<decltype(allocator_traits<_Alloc>::construct(
     std::declval<_Alloc&>(), std::declval<_ValueT*>(),
     std::declval<_Tp>()))>>
    : true_type
    { };
  template<typename _Alloc>
    struct __is_copy_insertable
    : __is_alloc_insertable_impl<_Alloc,
     typename _Alloc::value_type const&>::type
    { };
  template<typename _Tp>
    struct __is_copy_insertable<allocator<_Tp>>
    : is_copy_constructible<_Tp>
    { };
  template<typename _Alloc>
    struct __is_move_insertable
    : __is_alloc_insertable_impl<_Alloc, typename _Alloc::value_type>::type
    { };
  template<typename _Tp>
    struct __is_move_insertable<allocator<_Tp>>
    : is_move_constructible<_Tp>
    { };
  template<typename _Alloc, typename = void>
    struct __is_allocator : false_type { };
  template<typename _Alloc>
    struct __is_allocator<_Alloc,
      __void_t<typename _Alloc::value_type,
        decltype(std::declval<_Alloc&>().allocate(size_t{}))>>
    : true_type { };
  template<typename _Alloc>
    using _RequireAllocator
      = typename enable_if<__is_allocator<_Alloc>::value, _Alloc>::type;
  template<typename _Alloc>
    using _RequireNotAllocator
      = typename enable_if<!__is_allocator<_Alloc>::value, _Alloc>::type;
} 
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{
/**
 * @brief  Uniform interface to C++98 and C++11 allocators.
 * @ingroup allocators
*/
template<typename _Alloc, typename = typename _Alloc::value_type>
  struct __alloc_traits
  : std::allocator_traits<_Alloc>
  {
    typedef _Alloc allocator_type;
    typedef std::allocator_traits<_Alloc> _Base_type;
    typedef typename _Base_type::value_type value_type;
    typedef typename _Base_type::pointer pointer;
    typedef typename _Base_type::const_pointer const_pointer;
    typedef typename _Base_type::size_type size_type;
    typedef typename _Base_type::difference_type difference_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    using _Base_type::allocate;
    using _Base_type::deallocate;
    using _Base_type::construct;
    using _Base_type::destroy;
    using _Base_type::max_size;
  private:
    template<typename _Ptr>
      using __is_custom_pointer
 = std::__and_<std::is_same<pointer, _Ptr>,
        std::__not_<std::is_pointer<_Ptr>>>;
  public:
      ;
      ;
    template<typename _Tp>
      struct rebind
      { typedef typename _Base_type::template rebind_alloc<_Tp> other; };
  };
} 
namespace std __attribute__ ((__visibility__ ("default")))
{
  /**
   * Constructs an object in existing memory by invoking an allocated
   * object's constructor with an initializer.    */       ;        ;   /**    * Destroy the object pointed to by a pointer type.    */       ;   template<bool>     struct _Destroy_aux     {         ;     };   template<>     struct _Destroy_aux<true>     {        ;     };   /**    * Destroy a range of objects.  If the value_type of the object has    * a trivial destructor, the compiler should optimize all of this    * away, otherwise the objects' destructors must be invoked.
   */
    ;
  template<bool>
    struct _Destroy_n_aux
    {
 ;
    };
  template<>
    struct _Destroy_n_aux<true>
    {
 ;
    };
  /**
   * Destroy a range of objects.  If the value_type of the object has
   * a trivial destructor, the compiler should optimize all of this
   * away, otherwise the objects' destructors must be invoked.    */       ;   /**    * Destroy a range of objects using the supplied allocator.  For    * nondefault allocators we do not optimize away invocation of     * destroy() even if _Tp has a trivial destructor.    */       ;        ; }  namespace std __attribute__ ((__visibility__ ("default"))) {   /**    *  @brief Allocates a temporary buffer.    *  @param  __len  The number of objects of type Tp.    *  @return See full description.    *    *  Reinventing the wheel, but this time with prettier spokes!    *    *  This function tries to obtain storage for @c __len adjacent Tp    *  objects.  The objects themselves are not constructed, of course.    *  A pair<> is returned containing <em>the buffer s address and    *  capacity (in the units of sizeof(_Tp)), or a pair of 0 values if    *  no storage can be obtained.</em>  Note that the capacity obtained    *  may be less than that requested if the memory is unavailable;    *  you should compare len with the .second return value.    *    * Provides the nothrow exception guarantee.    */       ;   /**    *  @brief The companion to get_temporary_buffer().    *  @param  __p  A buffer previously allocated by get_temporary_buffer.    *  @return   None.    *    *  Frees the memory pointed to by __p.    */       ;   /**    *  This class is used in two places: stl_algo.h and ext/memory,    *  where it is wrapped as the temporary_buffer class.  See    *  temporary_buffer docs for more notes.    */  template<typename _ForwardIterator, typename _Tp>     class _Temporary_buffer     {     public:       typedef _Tp value_type;       typedef value_type* pointer;       typedef pointer iterator;       typedef ptrdiff_t size_type;     protected:       size_type _M_original_len;       size_type _M_len;       pointer _M_buffer;     public:                                   /**        * Constructs a temporary buffer of a size somewhere between        * zero and the given length.        */                  private:                   };   template<bool>     struct __uninitialized_construct_buf_dispatch     {                ;     };   template<>     struct __uninitialized_construct_buf_dispatch<true>     {        ;     };        ;    }  /**  * @file bits/uniform_int_dist.h  *  This is an internal header file, included by other library headers.  *  Do not attempt to use it directly. @headername{random}  *//** @file include/limits  *  This is a Standard C++ Library header.  */namespace std __attribute__ ((__visibility__ ("default"))) {   /**    *  @brief Describes the rounding style for floating-point types.    *    *  This is used in the std::numeric_limits class.   */  enum float_round_style   {     round_indeterminate = -1,      round_toward_zero = 0,      round_to_nearest = 1,      round_toward_infinity = 2,      round_toward_neg_infinity = 3    };   /**    *  @brief Describes the denormalization for floating-point types.    *    *  These values represent the presence or absence of a variable number    *  of exponent bits.  This type is used in the std::numeric_limits class.   */  enum float_denorm_style   {     denorm_indeterminate = -1,     denorm_absent = 0,     denorm_present = 1   };   /**    *  @brief Part of std::numeric_limits.    *    *  The @c static @c const members are usable as integral constant    *  expressions.    *    *  @note This is a separate class for purposes of efficiency; you    *        should only access these members as part of an instantiation    *        of the std::numeric_limits class.   */  struct __numeric_limits_base   {     /** This will be true for all fundamental types (which have 	specializations), and false for everything else.  */    static constexpr bool is_specialized = false;     /** The number of @c radix digits that be represented without change:  for 	integer types, the number of non-sign bits in the mantissa; for 	floating types, the number of @c radix digits in the mantissa.  */    static constexpr int digits = 0;     /** The number of base 10 digits that can be represented without change. */    static constexpr int digits10 = 0;     /** The number of base 10 digits required to ensure that values which 	differ are always differentiated.  */    static constexpr int max_digits10 = 0;     /** True if the type is signed.  */    static constexpr bool is_signed = false;     /** True if the type is integer.  */    static constexpr bool is_integer = false;     /** True if the type uses an exact representation. All integer types are 	exact, but not all exact types are integer.  For example, rational and 	fixed-exponent representations are exact but not integer. */    static constexpr bool is_exact = false;     /** For integer types, specifies the base of the representation.  For 	floating types, specifies the base of the exponent representation.  */    static constexpr int radix = 0;     /** The minimum negative integer such that @c radix raised to the power of 	(one less than that integer) is a normalized floating point number.  */    static constexpr int min_exponent = 0;     /** The minimum negative integer such that 10 raised to that power is in 	the range of normalized floating point numbers.  */    static constexpr int min_exponent10 = 0;     /** The maximum positive integer such that @c radix raised to the power of 	(one less than that integer) is a representable finite floating point 	number.  */    static constexpr int max_exponent = 0;     /** The maximum positive integer such that 10 raised to that power is in 	the range of representable finite floating point numbers.  */    static constexpr int max_exponent10 = 0;     /** True if the type has a representation for positive infinity.  */    static constexpr bool has_infinity = false;     /** True if the type has a representation for a quiet (non-signaling) 	Not a Number.  */    static constexpr bool has_quiet_NaN = false;     /** True if the type has a representation for a signaling 	Not a Number.  */    static constexpr bool has_signaling_NaN = false;     /** See std::float_denorm_style for more information.  */    static constexpr float_denorm_style has_denorm = denorm_absent;     /** True if loss of accuracy is detected as a denormalization loss, 	rather than as an inexact result. */    static constexpr bool has_denorm_loss = false;     /** True if-and-only-if the type adheres to the IEC 559 standard, also 	known as IEEE 754.  (Only makes sense for floating point types.)  */    static constexpr bool is_iec559 = false;     /** True if the set of values representable by the type is 	finite.  All built-in types are bounded, this member would be 	false for arbitrary precision types. */    static constexpr bool is_bounded = false;     /** True if the type is @e modulo. A type is modulo if, for any 	operation involving +, -, or * on values of that type whose 	result would fall outside the range [min(),max()], the value 	returned differs from the true value by an integer multiple of 	max() - min() + 1. On most machines, this is false for floating 	types, true for unsigned integers, and true for signed integers. 	See PR22200 about signed integers.  */    static constexpr bool is_modulo = false;     /** True if trapping is implemented for this type.  */    static constexpr bool traps = false;     /** True if tininess is detected before rounding.  (see IEC 559)  */    static constexpr bool tinyness_before = false;     /** See std::float_round_style for more information.  This is only 	meaningful for floating types; integer types will all be 	round_toward_zero.  */    static constexpr float_round_style round_style =           round_toward_zero;   };   /**    *  @brief Properties of fundamental types.    *    *  This class allows a program to obtain information about the    *  representation of a fundamental type on a given platform.  For    *  non-fundamental types, the functions will return 0 and the data    *  members will all be @c false.   */  template<typename _Tp>     struct numeric_limits : public __numeric_limits_base     {       /** The minimum finite value, or for floating types with 	  denormalization, the minimum positive normalized value.  */             /** The maximum finite value.  */             /** A finite value x such that there is no other finite value y        *  where y < x.  */             /** The @e machine @e epsilon:  the difference between 1 and the least 	  value greater than 1 that is representable.  */             /** The maximum rounding error measurement (see LIA-1).  */             /** The representation of positive infinity, if @c has_infinity.  */             /** The representation of a quiet Not a Number, 	  if @c has_quiet_NaN. */             /** The representation of a signaling Not a Number, if 	  @c has_signaling_NaN. */             /** The minimum positive denormalized value.  For types where 	  @c has_denorm is false, this is the minimum positive normalized 	  value.  */           };   template<typename _Tp>     struct numeric_limits<const _Tp>     : public numeric_limits<_Tp> { };   template<typename _Tp>     struct numeric_limits<volatile _Tp>     : public numeric_limits<_Tp> { };   template<typename _Tp>     struct numeric_limits<const volatile _Tp>     : public numeric_limits<_Tp> { };   template<>     struct numeric_limits<bool>     {       static constexpr bool is_specialized = true;                            static constexpr int digits = 1;       static constexpr int digits10 = 0;       static constexpr int max_digits10 = 0;       static constexpr bool is_signed = false;       static constexpr bool is_integer = true;       static constexpr bool is_exact = true;       static constexpr int radix = 2;                     static constexpr int min_exponent = 0;       static constexpr int min_exponent10 = 0;       static constexpr int max_exponent = 0;       static constexpr int max_exponent10 = 0;       static constexpr bool has_infinity = false;       static constexpr bool has_quiet_NaN = false;       static constexpr bool has_signaling_NaN = false;       static constexpr float_denorm_style has_denorm        = denorm_absent;       static constexpr bool has_denorm_loss = false;                                   static constexpr bool is_iec559 = false;       static constexpr bool is_bounded = true;       static constexpr bool is_modulo = false;       static constexpr bool traps = true;       static constexpr bool tinyness_before = false;       static constexpr float_round_style round_style        = round_toward_zero;     };   template<>     struct numeric_limits<char>     {       static constexpr bool is_specialized = true;                            static constexpr int digits = (sizeof(char) * 8 - ((char)(-1) < 0));       static constexpr int digits10 = ((sizeof(char) * 8 - ((char)(-1) < 0)) * 643L / 2136);       static constexpr int max_digits10 = 0;       static constexpr bool is_signed = ((char)(-1) < 0);       static constexpr bool is_integer = true;       static constexpr bool is_exact = true;       static constexpr int radix = 2;                     static constexpr int min_exponent = 0;       static constexpr int min_exponent10 = 0;       static constexpr int max_exponent = 0;       static constexpr int max_exponent10 = 0;       static constexpr bool has_infinity = false;       static constexpr bool has_quiet_NaN = false;       static constexpr bool has_signaling_NaN = false;       static constexpr float_denorm_style has_denorm        = denorm_absent;       static constexpr bool has_denorm_loss = false;                                   static constexpr bool is_iec559 = false;       static constexpr bool is_bounded = true;       static constexpr bool is_modulo = !is_signed;       static constexpr bool traps = true;       static constexpr bool tinyness_before = false;       static constexpr float_round_style round_style        = round_toward_zero;     };   template<>     struct numeric_limits<signed char>     {       static constexpr bool is_specialized = true;                            static constexpr int digits = (sizeof(signed char) * 8 - ((signed char)(-1) < 0));       static constexpr int digits10        = ((sizeof(signed char) * 8 - ((signed char)(-1) < 0)) * 643L / 2136);       static constexpr int max_digits10 = 0;       static constexpr bool is_signed = true;       static constexpr bool is_integer = true;       static constexpr bool is_exact = true;       static constexpr int radix = 2;                     static constexpr int min_exponent = 0;       static constexpr int min_exponent10 = 0;       static constexpr int max_exponent = 0;       static constexpr int max_exponent10 = 0;       static constexpr bool has_infinity = false;       static constexpr bool has_quiet_NaN = false;       static constexpr bool has_signaling_NaN = false;       static constexpr float_denorm_style has_denorm        = denorm_absent;       static constexpr bool has_denorm_loss = false;                                   static constexpr bool is_iec559 = false;       static constexpr bool is_bounded = true;       static constexpr bool is_modulo = false;       static constexpr bool traps = true;       static constexpr bool tinyness_before = false;       static constexpr float_round_style round_style        = round_toward_zero;     };   template<>     struct numeric_limits<unsigned char>     {       static constexpr bool is_specialized = true;                            static constexpr int digits        = (sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0));       static constexpr int digits10        = ((sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0)) * 643L / 2136);       static constexpr int max_digits10 = 0;       static constexpr bool is_signed = false;       static constexpr bool is_integer = true;       static constexpr bool is_exact = true;       static constexpr int radix = 2;                     static constexpr int min_exponent = 0;       static constexpr int min_exponent10 = 0;       static constexpr int max_exponent = 0;       static constexpr int max_exponent10 = 0;       static constexpr bool has_infinity = false;       static constexpr bool has_quiet_NaN = false;       static constexpr bool has_signaling_NaN = false;       static constexpr float_denorm_style has_denorm        = denorm_absent;       static constexpr bool has_denorm_loss = false;                                   static constexpr bool is_iec559 = false;       static constexpr bool is_bounded = true;       static constexpr bool is_modulo = true;       static constexpr bool traps = true;       static constexpr bool tinyness_before = false;       static constexpr float_round_style round_style        = round_toward_zero;     };   template<>     struct numeric_limits<wchar_t>     {       static constexpr bool is_specialized = true;                            static constexpr int digits = (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0));       static constexpr int digits10        = ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) * 643L / 2136);       static constexpr int max_digits10 = 0;       static constexpr bool is_signed = ((wchar_t)(-1) < 0);       static constexpr bool is_integer = true;       static constexpr bool is_exact = true;       static constexpr int radix = 2;                     static constexpr int min_exponent = 0;       static constexpr int min_exponent10 = 0;       static constexpr int max_exponent = 0;       static constexpr int max_exponent10 = 0;       static constexpr bool has_infinity = false;       static constexpr bool has_quiet_NaN = false;       static constexpr bool has_signaling_NaN = false;       static constexpr float_denorm_style has_denorm        = denorm_absent;       static constexpr bool has_denorm_loss = false;                                   static constexpr bool is_iec559 = false;       static constexpr bool is_bounded = true;       static constexpr bool is_modulo = !is_signed;       static constexpr bool traps = true;       static constexpr bool tinyness_before = false;       static constexpr float_round_style round_style        = round_toward_zero;     };   template<>     struct numeric_limits<char16_t>     {       static constexpr bool is_specialized = true;                            static constexpr int digits = (sizeof(char16_t) * 8 - ((char16_t)(-1) < 0));       static constexpr int digits10 = ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) * 643L / 2136);       static constexpr int max_digits10 = 0;       static constexpr bool is_signed = ((char16_t)(-1) < 0);       static constexpr bool is_integer = true;       static constexpr bool is_exact = true;       static constexpr int radix = 2;                     static constexpr int min_exponent = 0;       static constexpr int min_exponent10 = 0;       static constexpr int max_exponent = 0;       static constexpr int max_exponent10 = 0;       static constexpr bool has_infinity = false;       static constexpr bool has_quiet_NaN = false;       static constexpr bool has_signaling_NaN = false;       static constexpr float_denorm_style has_denorm = denorm_absent;       static constexpr bool has_denorm_loss = false;                                   static constexpr bool is_iec559 = false;       static constexpr bool is_bounded = true;       static constexpr bool is_modulo = !is_signed;       static constexpr bool traps = true;       static constexpr bool tinyness_before = false;       static constexpr float_round_style round_style = round_toward_zero;     };   template<>     struct numeric_limits<char32_t>     {       static constexpr bool is_specialized = true;                            static constexpr int digits = (sizeof(char32_t) * 8 - ((char32_t)(-1) < 0));       static constexpr int digits10 = ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) * 643L / 2136);       static constexpr int max_digits10 = 0;       static constexpr bool is_signed = ((char32_t)(-1) < 0);       static constexpr bool is_integer = true;       static constexpr bool is_exact = true;       static constexpr int radix = 2;                     static constexpr int min_exponent = 0;       static constexpr int min_exponent10 = 0;       static constexpr int max_exponent = 0;       static constexpr int max_exponent10 = 0;       static constexpr bool has_infinity = false;       static constexpr bool has_quiet_NaN = false;       static constexpr bool has_signaling_NaN = false;       static constexpr float_denorm_style has_denorm = denorm_absent;       static constexpr bool has_denorm_loss = false;                                   static constexpr bool is_iec559 = false;       static constexpr bool is_bounded = true;       static constexpr bool is_modulo = !is_signed;       static constexpr bool traps = true;       static constexpr bool tinyness_before = false;       static constexpr float_round_style round_style = round_toward_zero;     };   template<>     struct numeric_limits<short>     {       static constexpr bool is_specialized = true;                            static constexpr int digits = (sizeof(short) * 8 - ((short)(-1) < 0));       static constexpr int digits10 = ((sizeof(short) * 8 - ((short)(-1) < 0)) * 643L / 2136);       static constexpr int max_digits10 = 0;       static constexpr bool is_signed = true;       static constexpr bool is_integer = true;       static constexpr bool is_exact = true;       static constexpr int radix = 2;                     static constexpr int min_exponent = 0;       static constexpr int min_exponent10 = 0;       static constexpr int max_exponent = 0;       static constexpr int max_exponent10 = 0;       static constexpr bool has_infinity = false;       static constexpr bool has_quiet_NaN = false;       static constexpr bool has_signaling_NaN = false;       static constexpr float_denorm_style has_denorm        = denorm_absent;       static constexpr bool has_denorm_loss = false;                                   static constexpr bool is_iec559 = false;       static constexpr bool is_bounded = true;       static constexpr bool is_modulo = false;       static constexpr bool traps = true;       static constexpr bool tinyness_before = false;       static constexpr float_round_style round_style        = round_toward_zero;     };   template<>     struct numeric_limits<unsigned short>     {       static constexpr bool is_specialized = true;                            static constexpr int digits        = (sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0));       static constexpr int digits10        = ((sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0)) * 643L / 2136);       static constexpr int max_digits10 = 0;       static constexpr bool is_signed = false;       static constexpr bool is_integer = true;       static constexpr bool is_exact = true;       static constexpr int radix = 2;                     static constexpr int min_exponent = 0;       static constexpr int min_exponent10 = 0;       static constexpr int max_exponent = 0;       static constexpr int max_exponent10 = 0;       static constexpr bool has_infinity = false;       static constexpr bool has_quiet_NaN = false;       static constexpr bool has_signaling_NaN = false;       static constexpr float_denorm_style has_denorm        = denorm_absent;       static constexpr bool has_denorm_loss = false;                                   static constexpr bool is_iec559 = false;       static constexpr bool is_bounded = true;       static constexpr bool is_modulo = true;       static constexpr bool traps = true;       static constexpr bool tinyness_before = false;       static constexpr float_round_style round_style        = round_toward_zero;     };   template<>     struct numeric_limits<int>     {       static constexpr bool is_specialized = true;                            static constexpr int digits = (sizeof(int) * 8 - ((int)(-1) < 0));       static constexpr int digits10 = ((sizeof(int) * 8 - ((int)(-1) < 0)) * 643L / 2136);       static constexpr int max_digits10 = 0;       static constexpr bool is_signed = true;       static constexpr bool is_integer = true;       static constexpr bool is_exact = true;       static constexpr int radix = 2;                     static constexpr int min_exponent = 0;       static constexpr int min_exponent10 = 0;       static constexpr int max_exponent = 0;       static constexpr int max_exponent10 = 0;       static constexpr bool has_infinity = false;       static constexpr bool has_quiet_NaN = false;       static constexpr bool has_signaling_NaN = false;       static constexpr float_denorm_style has_denorm        = denorm_absent;       static constexpr bool has_denorm_loss = false;                                   static constexpr bool is_iec559 = false;       static constexpr bool is_bounded = true;       static constexpr bool is_modulo = false;       static constexpr bool traps = true;       static constexpr bool tinyness_before = false;       static constexpr float_round_style round_style        = round_toward_zero;     };   template<>     struct numeric_limits<unsigned int>     {       static constexpr bool is_specialized = true;                            static constexpr int digits        = (sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0));       static constexpr int digits10        = ((sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0)) * 643L / 2136);       static constexpr int max_digits10 = 0;       static constexpr bool is_signed = false;       static constexpr bool is_integer = true;       static constexpr bool is_exact = true;       static constexpr int radix = 2;                     static constexpr int min_exponent = 0;       static constexpr int min_exponent10 = 0;       static constexpr int max_exponent = 0;       static constexpr int max_exponent10 = 0;       static constexpr bool has_infinity = false;       static constexpr bool has_quiet_NaN = false;       static constexpr bool has_signaling_NaN = false;       static constexpr float_denorm_style has_denorm        = denorm_absent;       static constexpr bool has_denorm_loss = false;                                   static constexpr bool is_iec559 = false;       static constexpr bool is_bounded = true;       static constexpr bool is_modulo = true;       static constexpr bool traps = true;       static constexpr bool tinyness_before = false;       static constexpr float_round_style round_style        = round_toward_zero;     };   template<>     struct numeric_limits<long>     {       static constexpr bool is_specialized = true;                            static constexpr int digits = (sizeof(long) * 8 - ((long)(-1) < 0));       static constexpr int digits10 = ((sizeof(long) * 8 - ((long)(-1) < 0)) * 643L / 2136);       static constexpr int max_digits10 = 0;       static constexpr bool is_signed = true;       static constexpr bool is_integer = true;       static constexpr bool is_exact = true;       static constexpr int radix = 2;                     static constexpr int min_exponent = 0;       static constexpr int min_exponent10 = 0;       static constexpr int max_exponent = 0;       static constexpr int max_exponent10 = 0;       static constexpr bool has_infinity = false;       static constexpr bool has_quiet_NaN = false;       static constexpr bool has_signaling_NaN = false;       static constexpr float_denorm_style has_denorm        = denorm_absent;       static constexpr bool has_denorm_loss = false;                                   static constexpr bool is_iec559 = false;       static constexpr bool is_bounded = true;       static constexpr bool is_modulo = false;       static constexpr bool traps = true;       static constexpr bool tinyness_before = false;       static constexpr float_round_style round_style        = round_toward_zero;     };   template<>     struct numeric_limits<unsigned long>     {       static constexpr bool is_specialized = true;                            static constexpr int digits        = (sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0));       static constexpr int digits10        = ((sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0)) * 643L / 2136);       static constexpr int max_digits10 = 0;       static constexpr bool is_signed = false;       static constexpr bool is_integer = true;       static constexpr bool is_exact = true;       static constexpr int radix = 2;                     static constexpr int min_exponent = 0;       static constexpr int min_exponent10 = 0;       static constexpr int max_exponent = 0;       static constexpr int max_exponent10 = 0;       static constexpr bool has_infinity = false;       static constexpr bool has_quiet_NaN = false;       static constexpr bool has_signaling_NaN = false;       static constexpr float_denorm_style has_denorm        = denorm_absent;       static constexpr bool has_denorm_loss = false;                                   static constexpr bool is_iec559 = false;       static constexpr bool is_bounded = true;       static constexpr bool is_modulo = true;       static constexpr bool traps = true;       static constexpr bool tinyness_before = false;       static constexpr float_round_style round_style        = round_toward_zero;     };   template<>     struct numeric_limits<long long>     {       static constexpr bool is_specialized = true;                            static constexpr int digits        = (sizeof(long long) * 8 - ((long long)(-1) < 0));       static constexpr int digits10        = ((sizeof(long long) * 8 - ((long long)(-1) < 0)) * 643L / 2136);       static constexpr int max_digits10 = 0;       static constexpr bool is_signed = true;       static constexpr bool is_integer = true;       static constexpr bool is_exact = true;       static constexpr int radix = 2;                     static constexpr int min_exponent = 0;       static constexpr int min_exponent10 = 0;       static constexpr int max_exponent = 0;       static constexpr int max_exponent10 = 0;       static constexpr bool has_infinity = false;       static constexpr bool has_quiet_NaN = false;       static constexpr bool has_signaling_NaN = false;       static constexpr float_denorm_style has_denorm        = denorm_absent;       static constexpr bool has_denorm_loss = false;                                   static constexpr bool is_iec559 = false;       static constexpr bool is_bounded = true;       static constexpr bool is_modulo = false;       static constexpr bool traps = true;       static constexpr bool tinyness_before = false;       static constexpr float_round_style round_style        = round_toward_zero;     };   template<>     struct numeric_limits<unsigned long long>     {       static constexpr bool is_specialized = true;                            static constexpr int digits        = (sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0));       static constexpr int digits10        = ((sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0)) * 643L / 2136);       static constexpr int max_digits10 = 0;       static constexpr bool is_signed = false;       static constexpr bool is_integer = true;       static constexpr bool is_exact = true;       static constexpr int radix = 2;                     static constexpr int min_exponent = 0;       static constexpr int min_exponent10 = 0;       static constexpr int max_exponent = 0;       static constexpr int max_exponent10 = 0;       static constexpr bool has_infinity = false;       static constexpr bool has_quiet_NaN = false;       static constexpr bool has_signaling_NaN = false;       static constexpr float_denorm_style has_denorm        = denorm_absent;       static constexpr bool has_denorm_loss = false;                                   static constexpr bool is_iec559 = false;       static constexpr bool is_bounded = true;       static constexpr bool is_modulo = true;       static constexpr bool traps = true;       static constexpr bool tinyness_before = false;       static constexpr float_round_style round_style        = round_toward_zero;     };   template<> struct numeric_limits<__int128> { static constexpr bool is_specialized = true;   static constexpr int digits = 128 - 1; static constexpr int digits10 = (128 - 1) * 643L / 2136; static constexpr bool is_signed = true; static constexpr bool is_integer = true; static constexpr bool is_exact = true; static constexpr int radix = 2;    static constexpr int max_digits10 = 0; static constexpr int min_exponent = 0; static constexpr int min_exponent10 = 0; static constexpr int max_exponent = 0; static constexpr int max_exponent10 = 0; static constexpr bool has_infinity = false; static constexpr bool has_quiet_NaN = false; static constexpr bool has_signaling_NaN = false; static constexpr float_denorm_style has_denorm = denorm_absent; static constexpr bool has_denorm_loss = false;     static constexpr bool is_iec559 = false; static constexpr bool is_bounded = true; static constexpr bool is_modulo = false; static constexpr bool traps = true; static constexpr bool tinyness_before = false; static constexpr float_round_style round_style = round_toward_zero; }; template<> struct numeric_limits<unsigned __int128> { static constexpr bool is_specialized = true;    static constexpr int max_digits10 = 0; static constexpr int digits = 128; static constexpr int digits10 = 128 * 643L / 2136; static constexpr bool is_signed = false; static constexpr bool is_integer = true; static constexpr bool is_exact = true; static constexpr int radix = 2;   static constexpr int min_exponent = 0; static constexpr int min_exponent10 = 0; static constexpr int max_exponent = 0; static constexpr int max_exponent10 = 0; static constexpr bool has_infinity = false; static constexpr bool has_quiet_NaN = false; static constexpr bool has_signaling_NaN = false; static constexpr float_denorm_style has_denorm = denorm_absent; static constexpr bool has_denorm_loss = false;     static constexpr bool is_iec559 = false; static constexpr bool is_bounded = true; static constexpr bool is_modulo = true; static constexpr bool traps = true; static constexpr bool tinyness_before = false; static constexpr float_round_style round_style = round_toward_zero; };   template<>     struct numeric_limits<float>     {       static constexpr bool is_specialized = true;                            static constexpr int digits = 24;       static constexpr int digits10 = 6;       static constexpr int max_digits10   = (2 + (24) * 643L / 2136);       static constexpr bool is_signed = true;       static constexpr bool is_integer = false;       static constexpr bool is_exact = false;       static constexpr int radix = 2;                     static constexpr int min_exponent = (-125);       static constexpr int min_exponent10 = (-37);       static constexpr int max_exponent = 128;       static constexpr int max_exponent10 = 38;       static constexpr bool has_infinity = 1;       static constexpr bool has_quiet_NaN = 1;       static constexpr bool has_signaling_NaN = has_quiet_NaN;       static constexpr float_denorm_style has_denorm  = bool(1) ? denorm_present : denorm_absent;       static constexpr bool has_denorm_loss        = false;                                   static constexpr bool is_iec559  = has_infinity && has_quiet_NaN && has_denorm == denorm_present;       static constexpr bool is_bounded = true;       static constexpr bool is_modulo = false;       static constexpr bool traps = false;       static constexpr bool tinyness_before        = false;       static constexpr float_round_style round_style        = round_to_nearest;     };   template<>     struct numeric_limits<double>     {       static constexpr bool is_specialized = true;                            static constexpr int digits = 53;       static constexpr int digits10 = 15;       static constexpr int max_digits10   = (2 + (53) * 643L / 2136);       static constexpr bool is_signed = true;       static constexpr bool is_integer = false;       static constexpr bool is_exact = false;       static constexpr int radix = 2;                     static constexpr int min_exponent = (-1021);       static constexpr int min_exponent10 = (-307);       static constexpr int max_exponent = 1024;       static constexpr int max_exponent10 = 308;       static constexpr bool has_infinity = 1;       static constexpr bool has_quiet_NaN = 1;       static constexpr bool has_signaling_NaN = has_quiet_NaN;       static constexpr float_denorm_style has_denorm  = bool(1) ? denorm_present : denorm_absent;       static constexpr bool has_denorm_loss         = false;                                   static constexpr bool is_iec559  = has_infinity && has_quiet_NaN && has_denorm == denorm_present;       static constexpr bool is_bounded = true;       static constexpr bool is_modulo = false;       static constexpr bool traps = false;       static constexpr bool tinyness_before        = false;       static constexpr float_round_style round_style        = round_to_nearest;     };   template<>     struct numeric_limits<long double>     {       static constexpr bool is_specialized = true;                            static constexpr int digits = 64;       static constexpr int digits10 = 18;       static constexpr int max_digits10   = (2 + (64) * 643L / 2136);       static constexpr bool is_signed = true;       static constexpr bool is_integer = false;       static constexpr bool is_exact = false;       static constexpr int radix = 2;                     static constexpr int min_exponent = (-16381);       static constexpr int min_exponent10 = (-4931);       static constexpr int max_exponent = 16384;       static constexpr int max_exponent10 = 4932;       static constexpr bool has_infinity = 1;       static constexpr bool has_quiet_NaN = 1;       static constexpr bool has_signaling_NaN = has_quiet_NaN;       static constexpr float_denorm_style has_denorm  = bool(1) ? denorm_present : denorm_absent;       static constexpr bool has_denorm_loss  = false;                                   static constexpr bool is_iec559  = has_infinity && has_quiet_NaN && has_denorm == denorm_present;       static constexpr bool is_bounded = true;       static constexpr bool is_modulo = false;       static constexpr bool traps = false;       static constexpr bool tinyness_before =       false;       static constexpr float_round_style round_style =             round_to_nearest;     }; }  namespace std __attribute__ ((__visibility__ ("default"))) {   namespace __detail   {     /* Determine whether number is a power of 2.  */           ;   }   /**    * @brief Uniform discrete distribution for random numbers.    * A discrete random distribution on the range @f$[min, max]@f$ with equal    * probability throughout the range.    */  template<typename _IntType = int>     class uniform_int_distribution     {       static_assert(std::is_integral<_IntType>::value,       "template argument must be an integral type");     public:       /** The type of the range of the distribution. */      typedef _IntType result_type;       /** Parameter type. */      struct param_type       {  typedef uniform_int_distribution<_IntType> distribution_type;                   private:  _IntType _M_a;  _IntType _M_b;       };     public:       /**        * @brief Constructs a uniform distribution object.        */             /**        * @brief Constructs a uniform distribution object.        */                    /**        * @brief Resets the distribution state.        *        * Does nothing for the uniform integer distribution.        */                           /**        * @brief Returns the parameter set of the distribution.        */             /**        * @brief Sets the parameter set of the distribution.        * @param __param The new parameter set of the distribution.        */             /**        * @brief Returns the inclusive lower bound of the distribution range.        */             /**        * @brief Returns the inclusive upper bound of the distribution range.        */             /**        * @brief Generating functions.        */               ;       ;         ;         ;         ;       /**        * @brief Return true if two uniform integer distributions have        *        the same parameters.        */           private:       ;       param_type _M_param;     };       }  namespace std __attribute__ ((__visibility__ ("default"))) {        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;   inline namespace _V2   {        ;        ;        ;        ;   }         ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;   enum { _S_threshold = 16 };        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;   enum { _S_chunk_size = 7 };        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;   /**    *  @brief  Checks whether a permutation of the second sequence is equal    *          to the first sequence.    *  @ingroup non_mutating_algorithms    *  @param  __first1  Start of first range.    *  @param  __last1   End of first range.    *  @param  __first2  Start of second range.    *  @return true if there exists a permutation of the elements in the range    *          [__first2, __first2 + (__last1 - __first1)), beginning with     *          ForwardIterator2 begin, such that equal(__first1, __last1, begin)    *          returns true; otherwise, returns false.   */       ;   /**    *  @brief  Checks whether a permutation of the second sequence is equal    *          to the first sequence.    *  @ingroup non_mutating_algorithms    *  @param  __first1  Start of first range.    *  @param  __last1   End of first range.    *  @param  __first2  Start of second range.    *  @param  __pred    A binary predicate.    *  @return true if there exists a permutation of the elements in    *          the range [__first2, __first2 + (__last1 - __first1)),    *          beginning with ForwardIterator2 begin, such that    *          equal(__first1, __last1, __begin, __pred) returns true;    *          otherwise, returns false.   */       ;   /**    *  @brief Generate two uniformly distributed integers using a    *         single distribution invocation.    *  @param  __b0    The upper bound for the first integer.    *  @param  __b1    The upper bound for the second integer.    *  @param  __g     A UniformRandomBitGenerator.    *  @return  A pair (i, j) with i and j uniformly distributed    *           over [0, __b0) and [0, __b1), respectively.    *    *  Requires: __b0 * __b1 <= __g.max() - __g.min().    *    *  Using uniform_int_distribution with a range that is very    *  small relative to the range of the generator ends up wasting    *  potentially expensively generated randomness, since    *  uniform_int_distribution does not store leftover randomness    *  between invocations.    *    *  If we know we want two integers in ranges that are sufficiently    *  small, we can compose the ranges, use a single distribution    *  invocation, and significantly reduce the waste.   */       ;   /**    *  @brief Shuffle the elements of a sequence using a uniform random    *         number generator.    *  @ingroup mutating_algorithms    *  @param  __first   A forward iterator.    *  @param  __last    A forward iterator.    *  @param  __g       A UniformRandomNumberGenerator (26.5.1.3).    *  @return  Nothing.    *    *  Reorders the elements in the range @p [__first,__last) using @p __g to    *  provide random numbers.   */       ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ; }  namespace std __attribute__ ((__visibility__ ("default"))) {   template<class _CharT>     struct char_traits;   template<> struct char_traits<char>;   template<> struct char_traits<wchar_t>;   template<> struct char_traits<char16_t>;   template<> struct char_traits<char32_t>; namespace __cxx11 {   template<typename _CharT, typename _Traits = char_traits<_CharT>,            typename _Alloc = allocator<_CharT> >     class basic_string; }   typedef basic_string<char> string;   typedef basic_string<wchar_t> wstring;   typedef basic_string<char16_t> u16string;   typedef basic_string<char32_t> u32string; }  typedef __builtin_va_list va_list; typedef __builtin_va_list __gnuc_va_list; typedef unsigned int wint_t; typedef struct {   int __count;   union   {     unsigned int __wch;     char __wchb[4];   } __value;  } __mbstate_t; typedef __mbstate_t mbstate_t; struct _IO_FILE; typedef struct _IO_FILE __FILE; struct _IO_FILE; typedef struct _IO_FILE FILE; extern "C" { struct tm; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ;       ;       ;  ;       ;       ;  ;       ;       ;  ;       ;       ;       ;       ;       ;  ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; } namespace std {   using ::mbstate_t; }  extern "C++" { namespace std __attribute__ ((__visibility__ ("default"))) {   using ::wint_t;                                                                                                                                                                                             }  }  namespace __gnu_cxx {          }  namespace std {          }  namespace std {                      }  namespace std __attribute__ ((__visibility__ ("default"))) {   typedef long streamoff;   typedef ptrdiff_t streamsize;    template<typename _StateT>     class fpos     {     private:       streamoff _M_off;       _StateT _M_state;     public:                                                                                                };        ;        ;   typedef fpos<mbstate_t> streampos;   typedef fpos<mbstate_t> wstreampos;   typedef fpos<mbstate_t> u16streampos;   typedef fpos<mbstate_t> u32streampos; }  namespace std __attribute__ ((__visibility__ ("default"))) {   /**    *  @defgroup io I/O    *    *  Nearly all of the I/O classes are parameterized on the type of    *  characters they read and write.  (The major exception is ios_base at    *  the top of the hierarchy.)  This is a change from pre-Standard    *  streams, which were not templates.    *    *  For ease of use and compatibility, all of the basic_* I/O-related    *  classes are given typedef names for both of the builtin character    *  widths (wide and narrow).  The typedefs are the same as the    *  pre-Standard names, for example:    *    *  @code    *     typedef basic_ifstream<char>  ifstream;    *  @endcode    *    *  Because properly forward-declaring these classes can be difficult, you    *  should not do it yourself.  Instead, include the &lt;iosfwd&gt;    *  header, which contains only declarations of all the I/O classes as    *  well as the typedefs.  Trying to forward-declare the typedefs    *  themselves (e.g., <code>class ostream;</code>) is not valid ISO C++.    *    *  For more specific declarations, see    *  https:    *    *  @{   */  class ios_base;   template<typename _CharT, typename _Traits = char_traits<_CharT> >     class basic_ios;   template<typename _CharT, typename _Traits = char_traits<_CharT> >     class basic_streambuf;   template<typename _CharT, typename _Traits = char_traits<_CharT> >     class basic_istream;   template<typename _CharT, typename _Traits = char_traits<_CharT> >     class basic_ostream;   template<typename _CharT, typename _Traits = char_traits<_CharT> >     class basic_iostream; namespace __cxx11 {   template<typename _CharT, typename _Traits = char_traits<_CharT>,      typename _Alloc = allocator<_CharT> >     class basic_stringbuf;   template<typename _CharT, typename _Traits = char_traits<_CharT>,     typename _Alloc = allocator<_CharT> >     class basic_istringstream;   template<typename _CharT, typename _Traits = char_traits<_CharT>,     typename _Alloc = allocator<_CharT> >     class basic_ostringstream;   template<typename _CharT, typename _Traits = char_traits<_CharT>,     typename _Alloc = allocator<_CharT> >     class basic_stringstream; }   template<typename _CharT, typename _Traits = char_traits<_CharT> >     class basic_filebuf;   template<typename _CharT, typename _Traits = char_traits<_CharT> >     class basic_ifstream;   template<typename _CharT, typename _Traits = char_traits<_CharT> >     class basic_ofstream;   template<typename _CharT, typename _Traits = char_traits<_CharT> >     class basic_fstream;   template<typename _CharT, typename _Traits = char_traits<_CharT> >     class istreambuf_iterator;   template<typename _CharT, typename _Traits = char_traits<_CharT> >     class ostreambuf_iterator;   typedef basic_ios<char> ios;   typedef basic_streambuf<char> streambuf;   typedef basic_istream<char> istream;   typedef basic_ostream<char> ostream;   typedef basic_iostream<char> iostream;   typedef basic_stringbuf<char> stringbuf;   typedef basic_istringstream<char> istringstream;   typedef basic_ostringstream<char> ostringstream;   typedef basic_stringstream<char> stringstream;   typedef basic_filebuf<char> filebuf;   typedef basic_ifstream<char> ifstream;   typedef basic_ofstream<char> ofstream;   typedef basic_fstream<char> fstream;   typedef basic_ios<wchar_t> wios;   typedef basic_streambuf<wchar_t> wstreambuf;   typedef basic_istream<wchar_t> wistream;   typedef basic_ostream<wchar_t> wostream;   typedef basic_iostream<wchar_t> wiostream;   typedef basic_stringbuf<wchar_t> wstringbuf;   typedef basic_istringstream<wchar_t> wistringstream;   typedef basic_ostringstream<wchar_t> wostringstream;   typedef basic_stringstream<wchar_t> wstringstream;   typedef basic_filebuf<wchar_t> wfilebuf;   typedef basic_ifstream<wchar_t> wifstream;   typedef basic_ofstream<wchar_t> wofstream;   typedef basic_fstream<wchar_t> wfstream;   /** @}  */}  /** @file include/string  *  This is a Standard C++ Library header.  *//** @file bits/char_traits.h  *  This is an internal header file, included by other library headers.  *  Do not attempt to use it directly. @headername{string}  *//** @file include/cwchar  *  This is a Standard C++ Library file.  You should @c \
#include this file
 *  in your programs, rather than any of the @a *.h implementation files.  *  *  This is the C++ version of the Standard C Library header @c wchar.h,  *  and its contents are (mostly) the same as that header, but are all  *  contained in the namespace @c std (except for names which are defined  *  as macros in C).  */namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {   /**    *  @brief  Mapping from character type to associated types.    *    *  @note This is an implementation class for the generic version    *  of char_traits.  It defines int_type, off_type, pos_type, and    *  state_type.  By default these are unsigned long, streamoff,    *  streampos, and mbstate_t.  Users who need a different set of    *  types, but who don't need to change the definitions of any function
   *  defined in char_traits, can specialize __gnu_cxx::_Char_types
   *  while leaving __gnu_cxx::char_traits alone. */
  template<typename _CharT>
    struct _Char_types
    {
      typedef unsigned long int_type;
      typedef std::streampos pos_type;
      typedef std::streamoff off_type;
      typedef std::mbstate_t state_type;
    };
  template<typename _CharT>
    struct char_traits
    {
      typedef _CharT char_type;
      typedef typename _Char_types<_CharT>::int_type int_type;
      typedef typename _Char_types<_CharT>::pos_type pos_type;
      typedef typename _Char_types<_CharT>::off_type off_type;
      typedef typename _Char_types<_CharT>::state_type state_type;
    };
} 
namespace std __attribute__ ((__visibility__ ("default")))
{
  template<class _CharT>
    struct char_traits : public __gnu_cxx::char_traits<_CharT>
    { };
  template<>
    struct char_traits<char>
    {
      typedef char char_type;
      typedef int int_type;
      typedef streampos pos_type;
      typedef streamoff off_type;
      typedef mbstate_t state_type;
  };
  template<>
    struct char_traits<wchar_t>
    {
      typedef wchar_t char_type;
      typedef wint_t int_type;
      typedef streamoff off_type;
      typedef wstreampos pos_type;
      typedef mbstate_t state_type;
  };
} 
namespace std __attribute__ ((__visibility__ ("default")))
{
  template<>
    struct char_traits<char16_t>
    {
      typedef char16_t char_type;
      typedef uint_least16_t int_type;
      typedef streamoff off_type;
      typedef u16streampos pos_type;
      typedef mbstate_t state_type;
    };
  template<>
    struct char_traits<char32_t>
    {
      typedef char32_t char_type;
      typedef uint_least32_t int_type;
      typedef streamoff off_type;
      typedef u32streampos pos_type;
      typedef mbstate_t state_type;
    };
} 
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{
  using std::size_t;
  using std::ptrdiff_t;
  template<typename _Tp>
    class new_allocator
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;
      template<typename _Tp1>
 struct rebind
 { typedef new_allocator<_Tp1> other; };
      typedef std::true_type propagate_on_container_move_assignment;
       ;
 ;
 ;
       ;
       ;
    };
} 
namespace std
{
  template<typename _Tp>
    using __allocator_base = __gnu_cxx::new_allocator<_Tp>;
}
namespace std __attribute__ ((__visibility__ ("default")))
{
  template<>
    class allocator<void>
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef void* pointer;
      typedef const void* const_pointer;
      typedef void value_type;
      template<typename _Tp1>
 struct rebind
 { typedef allocator<_Tp1> other; };
      typedef true_type propagate_on_container_move_assignment;
      typedef true_type is_always_equal;
 ;
 ;
    };
  template<typename _Tp>
    class allocator : public __allocator_base<_Tp>
    {
   public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
       ;
    };
  template<typename _Tp>
    class allocator<const volatile _Tp>
    {
    public:
      typedef _Tp value_type;
       ;
    };
  extern template class allocator<char>;
  extern template class allocator<wchar_t>;
  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_swap
    {  };
  template<typename _Alloc>
    struct __alloc_swap<_Alloc, false>
    {
    };
  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_neq
    {
    };
  template<typename _Alloc>
    struct __alloc_neq<_Alloc, false>
    {
    };
  template<typename _Tp, bool
    = __or_<is_copy_constructible<typename _Tp::value_type>,
            is_nothrow_move_constructible<typename _Tp::value_type>>::value>
    struct __shrink_to_fit_aux
    {  };
  template<typename _Tp>
    struct __shrink_to_fit_aux<_Tp, true>
    {
    };
} 
/** @file bits/localefwd.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{locale}
 */
/** @file bits/c++locale.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{locale}
 */
/** @file clocale
 *  This is a Standard C++ Library file.  You should @c \#include this file
 *  in your programs, rather than any of the @a *.h implementation files.
 *
 * See https:
 * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 *
 *===-----------------------------------------------------------------------===
 */
/* Some C libraries expect to see a wint_t here. Others (notably MinGW) will use
__WINT_TYPE__ directly; accommodate both by requiring __need_wint_t */
/* Definition of locale category symbol values.
   Copyright (C) 2001-2019 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.
   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.
   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
extern "C" {
/* These are the possibilities for the first argument to setlocale.
   The code assumes that the lowest LC_* symbol has the value zero.  */
/* Structure giving information about numeric and monetary notation.  */
struct lconv
{
  /* Numeric (non-monetary) information.  */
  char *decimal_point; /* Decimal point character.  */
  char *thousands_sep; /* Thousands separator.  */
  /* Each element is the number of digits in each group;
     elements with higher indices are farther left.
     An element with value CHAR_MAX means that no further grouping is done.
     An element with value 0 means that the previous element is used
     for all groups farther left.  */
  char *grouping;
  /* Monetary information.  */
  /* First three chars are a currency symbol from ISO 4217.
     Fourth char is the separator.  Fifth char is '\0'.  */
  char *int_curr_symbol;
  char *currency_symbol; /* Local currency symbol.  */
  char *mon_decimal_point; /* Decimal point character.  */
  char *mon_thousands_sep; /* Thousands separator.  */
  char *mon_grouping; /* Like `grouping' element (above).  */  char *positive_sign;    char *negative_sign;    char int_frac_digits;    char frac_digits;    char p_cs_precedes;   char p_sep_by_space;   char n_cs_precedes;   char n_sep_by_space;   char p_sign_posn;   char n_sign_posn;   char int_p_cs_precedes;   char int_p_sep_by_space;   char int_n_cs_precedes;   char int_n_sep_by_space;   char int_p_sign_posn;   char int_n_sign_posn; }; ; ; ; ; ; ; }
 namespace std {   using ::lconv;       }
  namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {   ; }
  namespace std __attribute__ ((__visibility__ ("default"))) {   typedef __locale_t __c_locale;     }
  extern "C" { enum {   _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),    _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),    _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),    _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),    _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),    _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),    _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),    _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),    _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),    _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),    _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),    _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))  }; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; }
 namespace std {                                        }
  namespace std {    }
  namespace std __attribute__ ((__visibility__ ("default"))) {   class locale;   ;   ;   ;   ;   ;   ;   ;   ;   ;   ;   ;   ;   ;   ;   ;   ;   class ctype_base;   template<typename _CharT>     class ctype;   template<> class ctype<char>;   template<> class ctype<wchar_t>;   template<typename _CharT>     class ctype_byname;   class codecvt_base;   template<typename _InternT, typename _ExternT, typename _StateT>     class codecvt;   template<> class codecvt<char, char, mbstate_t>;   template<> class codecvt<wchar_t, char, mbstate_t>;   template<> class codecvt<char16_t, char, mbstate_t>;   template<> class codecvt<char32_t, char, mbstate_t>;   template<typename _InternT, typename _ExternT, typename _StateT>     class codecvt_byname;   template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >     class num_get;   template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >     class num_put; namespace __cxx11 {   template<typename _CharT> class numpunct;   template<typename _CharT> class numpunct_byname; } namespace __cxx11 {   template<typename _CharT>     class collate;   template<typename _CharT>     class collate_byname; }   class time_base; namespace __cxx11 {   template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >     class time_get;   template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >     class time_get_byname; }   template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >     class time_put;   template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >     class time_put_byname;   class money_base; namespace __cxx11 {   template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >     class money_get;   template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >     class money_put; } namespace __cxx11 {   template<typename _CharT, bool _Intl = false>     class moneypunct;   template<typename _CharT, bool _Intl = false>     class moneypunct_byname; }   class messages_base; namespace __cxx11 {   template<typename _CharT>     class messages;   template<typename _CharT>     class messages_byname; } }
#pragma GCC visibility push(default)
namespace __cxxabiv1 {   class __forced_unwind   {             }; }
#pragma GCC visibility pop
namespace std __attribute__ ((__visibility__ ("default"))) {        ;        ;        ;;; }
  namespace std __attribute__ ((__visibility__ ("default"))) {   template<typename _Arg, typename _Result>     struct unary_function     {       typedef _Arg argument_type;       typedef _Result result_type;     };   template<typename _Arg1, typename _Arg2, typename _Result>     struct binary_function     {       typedef _Arg1 first_argument_type;       typedef _Arg2 second_argument_type;       typedef _Result result_type;     };   template<typename _Tp>     struct plus : public binary_function<_Tp, _Tp, _Tp>     {            };   template<typename _Tp>     struct minus : public binary_function<_Tp, _Tp, _Tp>     {            };   template<typename _Tp>     struct multiplies : public binary_function<_Tp, _Tp, _Tp>     {            };   template<typename _Tp>     struct divides : public binary_function<_Tp, _Tp, _Tp>     {            };   template<typename _Tp>     struct modulus : public binary_function<_Tp, _Tp, _Tp>     {            };   template<typename _Tp>     struct negate : public unary_function<_Tp, _Tp>     {            };   template<typename _Tp>     struct equal_to : public binary_function<_Tp, _Tp, bool>     {            };   template<typename _Tp>     struct not_equal_to : public binary_function<_Tp, _Tp, bool>     {            };   template<typename _Tp>     struct greater : public binary_function<_Tp, _Tp, bool>     {            };   template<typename _Tp>     struct less : public binary_function<_Tp, _Tp, bool>     {            };   template<typename _Tp>     struct greater_equal : public binary_function<_Tp, _Tp, bool>     {            };   template<typename _Tp>     struct less_equal : public binary_function<_Tp, _Tp, bool>     {            };   template<typename _Tp>     struct greater<_Tp*> : public binary_function<_Tp*, _Tp*, bool>     {                                 };   template<typename _Tp>     struct less<_Tp*> : public binary_function<_Tp*, _Tp*, bool>     {                                 };   template<typename _Tp>     struct greater_equal<_Tp*> : public binary_function<_Tp*, _Tp*, bool>     {                                 };   template<typename _Tp>     struct less_equal<_Tp*> : public binary_function<_Tp*, _Tp*, bool>     {                                 };   template<typename _Tp>     struct logical_and : public binary_function<_Tp, _Tp, bool>     {            };   template<typename _Tp>     struct logical_or : public binary_function<_Tp, _Tp, bool>     {            };   template<typename _Tp>     struct logical_not : public unary_function<_Tp, bool>     {            };   template<typename _Tp>     struct bit_and : public binary_function<_Tp, _Tp, _Tp>     {            };   template<typename _Tp>     struct bit_or : public binary_function<_Tp, _Tp, _Tp>     {            };   template<typename _Tp>     struct bit_xor : public binary_function<_Tp, _Tp, _Tp>     {            };   template<typename _Tp>     struct bit_not : public unary_function<_Tp, _Tp>     {            };   template<typename _Predicate>     class unary_negate     : public unary_function<typename _Predicate::argument_type, bool>     {     protected:       _Predicate _M_pred;     public:                   };        ;   template<typename _Predicate>     class binary_negate     : public binary_function<typename _Predicate::first_argument_type,         typename _Predicate::second_argument_type, bool>     {     protected:       _Predicate _M_pred;     public:                   };        ;   template<typename _Arg, typename _Result>     class pointer_to_unary_function : public unary_function<_Arg, _Result>     {     protected:       _Result (*_M_ptr)(_Arg);     public:                          };        ;   template<typename _Arg1, typename _Arg2, typename _Result>     class pointer_to_binary_function     : public binary_function<_Arg1, _Arg2, _Result>     {     protected:       _Result (*_M_ptr)(_Arg1, _Arg2);     public:                          };        ;   template<typename _Tp>     struct _Identity     : public unary_function<_Tp, _Tp>     {                   };   template<typename _Tp> struct _Identity<const _Tp> : _Identity<_Tp> { };   template<typename _Pair>     struct _Select1st     : public unary_function<_Pair, typename _Pair::first_type>     {                              ;                ;     };   template<typename _Pair>     struct _Select2nd     : public unary_function<_Pair, typename _Pair::second_type>     {                   };   template<typename _Ret, typename _Tp>     class mem_fun_t : public unary_function<_Tp*, _Ret>     {     public:                   private:       _Ret (_Tp::*_M_f)();     };   template<typename _Ret, typename _Tp>     class const_mem_fun_t : public unary_function<const _Tp*, _Ret>     {     public:                   private:       _Ret (_Tp::*_M_f)() const;     };   template<typename _Ret, typename _Tp>     class mem_fun_ref_t : public unary_function<_Tp, _Ret>     {     public:                   private:       _Ret (_Tp::*_M_f)();   };   template<typename _Ret, typename _Tp>     class const_mem_fun_ref_t : public unary_function<_Tp, _Ret>     {     public:                   private:       _Ret (_Tp::*_M_f)() const;     };   template<typename _Ret, typename _Tp, typename _Arg>     class mem_fun1_t : public binary_function<_Tp*, _Arg, _Ret>     {     public:                   private:       _Ret (_Tp::*_M_f)(_Arg);     };   template<typename _Ret, typename _Tp, typename _Arg>     class const_mem_fun1_t : public binary_function<const _Tp*, _Arg, _Ret>     {     public:                   private:       _Ret (_Tp::*_M_f)(_Arg) const;     };   template<typename _Ret, typename _Tp, typename _Arg>     class mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>     {     public:                   private:       _Ret (_Tp::*_M_f)(_Arg);     };   template<typename _Ret, typename _Tp, typename _Arg>     class const_mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>     {     public:                   private:       _Ret (_Tp::*_M_f)(_Arg) const;     };        ;        ;        ;        ;        ;        ;        ;        ; }
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
namespace std __attribute__ ((__visibility__ ("default"))) {   template<typename _Operation>     class binder1st     : public unary_function<typename _Operation::second_argument_type,        typename _Operation::result_type>     {     protected:       _Operation op;       typename _Operation::first_argument_type value;     public:                          } __attribute__ ((__deprecated__));        ;   template<typename _Operation>     class binder2nd     : public unary_function<typename _Operation::first_argument_type,        typename _Operation::result_type>     {     protected:       _Operation op;       typename _Operation::second_argument_type value;     public:                          } __attribute__ ((__deprecated__));   template<typename _Operation, typename _Tp>      binder2nd<_Operation>     bind2nd(const _Operation& __fn, const _Tp& __x)     ; }
#pragma GCC diagnostic pop
namespace std __attribute__ ((__visibility__ ("default"))) {   template<typename _Container>      auto     begin(_Container& __cont) -> decltype(__cont.begin())     ;   template<typename _Container>      auto     begin(const _Container& __cont) -> decltype(__cont.begin())     ;   template<typename _Container>      auto     end(_Container& __cont) -> decltype(__cont.end())     ;   template<typename _Container>      auto     end(const _Container& __cont) -> decltype(__cont.end())     ;   template<typename _Tp, size_t _Nm>      _Tp*     begin(_Tp (&__arr)[_Nm])     ;   template<typename _Tp, size_t _Nm>      _Tp*     end(_Tp (&__arr)[_Nm])     ; }
#pragma GCC visibility push(default)
struct sched_param {   int sched_priority; };
 extern "C" { extern int clone (int (*__fn) (void *__arg), void *__child_stack,     int __flags, void *__arg, ...) throw (); extern int unshare (int __flags) throw (); ; ; ; }
 typedef unsigned long int __cpu_mask;
 typedef struct {   __cpu_mask __bits[1024 / (8 * sizeof (__cpu_mask))]; }
 cpu_set_t;
 extern "C" { ;  ; ; }
 extern "C" { ; ; ; ; ; ; ; ; ; ; }
 struct timex {   unsigned int modes;    __syscall_slong_t offset;    __syscall_slong_t freq;    __syscall_slong_t maxerror;    __syscall_slong_t esterror;    int status;    __syscall_slong_t constant;    __syscall_slong_t precision;    __syscall_slong_t tolerance;    struct timeval time;    __syscall_slong_t tick;    __syscall_slong_t ppsfreq;    __syscall_slong_t jitter;    int shift;    __syscall_slong_t stabil;    __syscall_slong_t jitcnt;    __syscall_slong_t calcnt;    __syscall_slong_t errcnt;    __syscall_slong_t stbcnt;    int tai;    int :32; int :32; int :32; int :32;   int :32; int :32; int :32; int :32;   int :32; int :32; int :32; };
 extern "C" { ; }
 struct tm {   int tm_sec;    int tm_min;    int tm_hour;    int tm_mday;    int tm_mon;    int tm_year;    int tm_wday;    int tm_yday;    int tm_isdst;    long int tm_gmtoff;    const char *tm_zone;  };
 struct itimerspec   {     struct timespec it_interval;     struct timespec it_value;   };
 struct sigevent;
 extern "C" { ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; extern char *__tzname[2];  extern int __daylight;  extern long int __timezone;  extern char *tzname[2]; ; extern int daylight; extern long int timezone; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; extern int getdate_err; ; ; }
 typedef long int __jmp_buf[8];
 enum {   PTHREAD_CREATE_JOINABLE,   PTHREAD_CREATE_DETACHED };
 enum {   PTHREAD_MUTEX_TIMED_NP,   PTHREAD_MUTEX_RECURSIVE_NP,   PTHREAD_MUTEX_ERRORCHECK_NP,   PTHREAD_MUTEX_ADAPTIVE_NP   ,   PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_TIMED_NP,   PTHREAD_MUTEX_RECURSIVE = PTHREAD_MUTEX_RECURSIVE_NP,   PTHREAD_MUTEX_ERRORCHECK = PTHREAD_MUTEX_ERRORCHECK_NP,   PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL   , PTHREAD_MUTEX_FAST_NP = PTHREAD_MUTEX_TIMED_NP };
 enum {   PTHREAD_MUTEX_STALLED,   PTHREAD_MUTEX_STALLED_NP = PTHREAD_MUTEX_STALLED,   PTHREAD_MUTEX_ROBUST,   PTHREAD_MUTEX_ROBUST_NP = PTHREAD_MUTEX_ROBUST };
 enum {   PTHREAD_PRIO_NONE,   PTHREAD_PRIO_INHERIT,   PTHREAD_PRIO_PROTECT };
 enum {   PTHREAD_RWLOCK_PREFER_READER_NP,   PTHREAD_RWLOCK_PREFER_WRITER_NP,   PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP,   PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP };
 enum {   PTHREAD_INHERIT_SCHED,   PTHREAD_EXPLICIT_SCHED };
 enum {   PTHREAD_SCOPE_SYSTEM,   PTHREAD_SCOPE_PROCESS };
 enum {   PTHREAD_PROCESS_PRIVATE,   PTHREAD_PROCESS_SHARED };
 struct _pthread_cleanup_buffer {   void (*__routine) (void *);    void *__arg;    int __canceltype;    struct _pthread_cleanup_buffer *__prev;  };
 enum {   PTHREAD_CANCEL_ENABLE,   PTHREAD_CANCEL_DISABLE };
 enum {   PTHREAD_CANCEL_DEFERRED,   PTHREAD_CANCEL_ASYNCHRONOUS };
 extern "C" { ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; typedef struct {   struct   {     __jmp_buf __cancel_jmp_buf;     int __mask_was_saved;   } __cancel_jmp_buf[1];   void *__pad[4]; } __pthread_unwind_buf_t __attribute__ ((__aligned__)); struct __pthread_cleanup_frame {   void (*__cancel_routine) (void *);   void *__cancel_arg;   int __do_it;   int __cancel_type; }; class __pthread_cleanup_class {   void (*__cancel_routine) (void *);   void *__cancel_arg;   int __do_it;   int __cancel_type;  public:                }; struct __jmp_buf_tag; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ;  ; ; ; }
 typedef pthread_t __gthread_t;
 typedef pthread_key_t __gthread_key_t;
 typedef pthread_once_t __gthread_once_t;
 typedef pthread_mutex_t __gthread_mutex_t;
 typedef pthread_mutex_t __gthread_recursive_mutex_t;
 typedef pthread_cond_t __gthread_cond_t;
 typedef struct timespec __gthread_time_t;
#pragma GCC visibility pop
typedef int _Atomic_word;
 namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {                   }
  namespace std __attribute__ ((__visibility__ ("default"))) { namespace __cxx11 {   template<typename _CharT, typename _Traits, typename _Alloc>     class basic_string     {       typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template  rebind<_CharT>::other _Char_alloc_type;       typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;     public:       typedef _Traits traits_type;       typedef typename _Traits::char_type value_type;       typedef _Char_alloc_type allocator_type;       typedef typename _Alloc_traits::size_type size_type;       typedef typename _Alloc_traits::difference_type difference_type;       typedef typename _Alloc_traits::reference reference;       typedef typename _Alloc_traits::const_reference const_reference;       typedef typename _Alloc_traits::pointer pointer;       typedef typename _Alloc_traits::const_pointer const_pointer;       typedef __gnu_cxx::__normal_iterator<pointer, basic_string> iterator;       typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>        const_iterator;       typedef std::reverse_iterator<const_iterator> const_reverse_iterator;       typedef std::reverse_iterator<iterator> reverse_iterator;       static const size_type npos = static_cast<size_type>(-1);     protected:       typedef const_iterator __const_iterator;     private:       struct _Alloc_hider : allocator_type        {      pointer _M_p;        };       _Alloc_hider _M_dataplus;       size_type _M_string_length;       enum { _S_local_capacity = 15 / sizeof(_CharT) };       union       {  _CharT _M_local_buf[_S_local_capacity + 1];  size_type _M_allocated_capacity;       };                                                                                      ;         ;                ;       ;       ;                          private:                                                                 ;                                                             public:       /**        *  @brief  Default constructor creates an empty string.        */             /**        *  @brief  Construct an empty string using allocator @a a.        */             /**        *  @brief  Construct string with copy of value of @a __str.        *  @param  __str  Source string.        */             /**        *  @brief  Construct string as copy of a substring.        *  @param  __str  Source string.        *  @param  __pos  Index of first character to copy from.        *  @param  __a  Allocator to use.        */             /**        *  @brief  Construct string as copy of a substring.        *  @param  __str  Source string.        *  @param  __pos  Index of first character to copy from.        *  @param  __n  Number of characters to copy.        */             /**        *  @brief  Construct string as copy of a substring.        *  @param  __str  Source string.        *  @param  __pos  Index of first character to copy from.        *  @param  __n  Number of characters to copy.        *  @param  __a  Allocator to use.        */             /**        *  @brief  Construct string initialized by a character %array.        *  @param  __s  Source character %array.        *  @param  __n  Number of characters to copy.        *  @param  __a  Allocator to use (default is default allocator).        *        *  NB: @a __s must have at least @a __n characters, &apos;\\0&apos;        *  has no special meaning.        */             /**        *  @brief  Construct string as copy of a C string.        *  @param  __s  Source C string.        *  @param  __a  Allocator to use (default is default allocator).        */             /**        *  @brief  Construct string as multiple characters.        *  @param  __n  Number of characters.        *  @param  __c  Character to use.        *  @param  __a  Allocator to use (default is default allocator).        */             /**        *  @brief  Move construct string.        *  @param  __str  Source string.        *        *  The newly-created string contains the exact contents of @a __str.        *  @a __str is a valid, but unspecified string.        **/             /**        *  @brief  Construct string from an initializer %list.        *  @param  __l  std::initializer_list of characters.        *  @param  __a  Allocator to use (default is default allocator).        */                           /**        *  @brief  Construct string as copy of a range.        *  @param  __beg  Start of range.        *  @param  __end  End of range.        *  @param  __a  Allocator to use (default is default allocator).        */         ;       /**        *  @brief  Destroy the string instance.        */             /**        *  @brief  Assign the value of @a str to this string.        *  @param  __str  Source string.        */             /**        *  @brief  Copy contents of @a s into this string.        *  @param  __s  Source null-terminated string.        */             /**        *  @brief  Set value to string of length 1.        *  @param  __c  Source character.        *        *  Assigning to a character makes this string length 1 and        *  (*this)[0] == @a c.        */             /**        *  @brief  Move assign the value of @a str to this string.        *  @param  __str  Source string.        *        *  The contents of @a str are moved into this string (without copying).        *  @a str is a valid, but unspecified string.        **/             /**        *  @brief  Set value to string constructed from initializer %list.        *  @param  __l  std::initializer_list.        */             /**        *  Returns a read/write iterator that points to the first character in        *  the %string.        */             /**        *  Returns a read-only (constant) iterator that points to the first        *  character in the %string.        */             /**        *  Returns a read/write iterator that points one past the last        *  character in the %string.        */             /**        *  Returns a read-only (constant) iterator that points one past the        *  last character in the %string.        */             /**        *  Returns a read/write reverse iterator that points to the last        *  character in the %string.  Iteration is done in reverse element        *  order.        */             /**        *  Returns a read-only (constant) reverse iterator that points        *  to the last character in the %string.  Iteration is done in        *  reverse element order.        */             /**        *  Returns a read/write reverse iterator that points to one before the        *  first character in the %string.  Iteration is done in reverse        *  element order.        */             /**        *  Returns a read-only (constant) reverse iterator that points        *  to one before the first character in the %string.  Iteration        *  is done in reverse element order.        */             /**        *  Returns a read-only (constant) iterator that points to the first        *  character in the %string.        */             /**        *  Returns a read-only (constant) iterator that points one past the        *  last character in the %string.        */             /**        *  Returns a read-only (constant) reverse iterator that points        *  to the last character in the %string.  Iteration is done in        *  reverse element order.        */             /**        *  Returns a read-only (constant) reverse iterator that points        *  to one before the first character in the %string.  Iteration        *  is done in reverse element order.        */           public:                            /**        *  @brief  Resizes the %string to the specified number of characters.        *  @param  __n  Number of characters the %string should contain.        *  @param  __c  Character to fill any new elements.        *        *  This function will %resize the %string to the specified        *  number of characters.  If the number is smaller than the        *  %string's current size the %string is truncated, otherwise
       *  the %string is extended and new elements are %set to @a __c.
       */
        ;
        ;
        ;
        ;
    private:
        ;
      ;
    public:
      template<typename, typename, typename> friend class basic_stringbuf;
    };
}
    ;
  ;
  ;
    ;
    ;
    ;
    ;
    ;
  template<typename _CharT, typename _Traits, typename _Alloc>
     bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    ;
  template<typename _CharT, typename _Traits, typename _Alloc>
     bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    ;
  template<typename _CharT, typename _Traits, typename _Alloc>
     bool
    operator>=(const _CharT* __lhs,
      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    ;
  template<typename _CharT, typename _Traits, typename _Alloc>
     void
    swap(basic_string<_CharT, _Traits, _Alloc>& __lhs,
  basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept(noexcept(__lhs.swap(__rhs)))
    ;
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Alloc>& __str);
  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __is, basic_string<char>& __str);
  template<typename _CharT, typename _Traits, typename _Alloc>
     basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os,
        const basic_string<_CharT, _Traits, _Alloc>& __str)
    ;
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim);
  template<typename _CharT, typename _Traits, typename _Alloc>
     basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str)
    ;
    ;
    ;
  template<>
    basic_istream<char>&
    getline(basic_istream<char>& __in, basic_string<char>& __str,
     char __delim);
  template<>
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>& __in, basic_string<wchar_t>& __str,
     wchar_t __delim);
} 
extern "C" {
typedef struct _G_fpos_t
{
  __off_t __pos;
  __mbstate_t __state;
} __fpos_t;
typedef struct _G_fpos64_t
{
  __off64_t __pos;
  __mbstate_t __state;
} __fpos64_t;
struct _IO_FILE;
struct _IO_marker;
struct _IO_codecvt;
struct _IO_wide_data;
typedef void _IO_lock_t;
struct _IO_FILE
{
  struct _IO_FILE *_freeres_list;
  void *_freeres_buf;
  size_t __pad5;
  int _mode;
  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];
};
typedef __ssize_t cookie_read_function_t (void *__cookie, char *__buf,
                                          size_t __nbytes);
typedef __ssize_t cookie_write_function_t (void *__cookie, const char *__buf,
                                           size_t __nbytes);
typedef int cookie_seek_function_t (void *__cookie, __off64_t *__pos, int __w);
typedef int cookie_close_function_t (void *__cookie);
typedef struct _IO_cookie_io_functions_t
{
  cookie_read_function_t *read; 
  cookie_write_function_t *write; 
  cookie_seek_function_t *seek; 
  cookie_close_function_t *close; 
} cookie_io_functions_t;
typedef __gnuc_va_list va_list;
typedef __fpos_t fpos_t;
typedef __fpos64_t fpos64_t;
extern FILE *stdin; 
extern FILE *stdout; 
} 
namespace __gnu_cxx
{
} 
namespace std
{
} 
extern "C" {
;
extern char *program_invocation_name;
extern char *program_invocation_short_name;
typedef int error_t;
}
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{
    ;
    ;
} 
namespace std __attribute__ ((__visibility__ ("default")))
{
namespace __cxx11 {
}
} 
namespace std __attribute__ ((__visibility__ ("default")))
{
  template<typename _Result, typename _Arg>
    struct __hash_base
    {
      typedef _Result result_type ;
      typedef _Arg argument_type ;
    };
  template<typename _Tp>
    struct hash;
  template<typename _Tp, typename = void>
    struct __poison_hash
    {
      static constexpr bool __enable_hash_call = false;
    private:
    };
  template<typename _Tp>
    struct __poison_hash<_Tp, __void_t<decltype(hash<_Tp>()(declval<_Tp>()))>>
    {
      static constexpr bool __enable_hash_call = true;
    };
  template<typename _Tp, bool = is_enum<_Tp>::value>
    struct __hash_enum
    {
    private:
    };
  template<typename _Tp>
    struct __hash_enum<_Tp, true> : public __hash_base<size_t, _Tp>
    {
    };
  template<typename _Tp>
    struct hash : __hash_enum<_Tp>
    { };
  template<typename _Tp>
    struct hash<_Tp*> : public __hash_base<size_t, _Tp*>
    {
    };
  template<> struct hash<bool> : public __hash_base<size_t, bool> {  };
  template<> struct hash<char> : public __hash_base<size_t, char> {  };
  template<> struct hash<signed char> : public __hash_base<size_t, signed char> {  };
  template<> struct hash<unsigned char> : public __hash_base<size_t, unsigned char> {  };
  template<> struct hash<wchar_t> : public __hash_base<size_t, wchar_t> {  };
  template<> struct hash<char16_t> : public __hash_base<size_t, char16_t> {  };
  template<> struct hash<char32_t> : public __hash_base<size_t, char32_t> {  };
  template<> struct hash<short> : public __hash_base<size_t, short> {  };
  template<> struct hash<int> : public __hash_base<size_t, int> {  };
  template<> struct hash<long> : public __hash_base<size_t, long> {  };
  template<> struct hash<long long> : public __hash_base<size_t, long long> {  };
  template<> struct hash<unsigned short> : public __hash_base<size_t, unsigned short> {  };
  template<> struct hash<unsigned int> : public __hash_base<size_t, unsigned int> {  };
  template<> struct hash<unsigned long> : public __hash_base<size_t, unsigned long> {  };
  template<> struct hash<unsigned long long> : public __hash_base<size_t, unsigned long long> {  };
  template<> struct hash<__int128> : public __hash_base<size_t, __int128> {  };
  template<> struct hash<__int128 unsigned> : public __hash_base<size_t, __int128 unsigned> {  };
  struct _Hash_impl
  {
      ;
      ;
  };
  struct _Fnv_hash_impl
  {
      ;
      ;
  };
  template<>
    struct hash<float> : public __hash_base<size_t, float>
    {
    };
  template<>
    struct hash<double> : public __hash_base<size_t, double>
    {
    };
  template<>
    struct hash<long double>
    : public __hash_base<size_t, long double>
    {
    };
  template<typename _Hash>
    struct __is_fast_hash : public std::true_type
    { };
  template<>
    struct __is_fast_hash<hash<long double>> : public std::false_type
    { };
} 
namespace std __attribute__ ((__visibility__ ("default")))
{
  template<>
    struct hash<string>
    : public __hash_base<size_t, string>
    {
    };
  template<>
    struct __is_fast_hash<hash<string>> : std::false_type
    { };
  template<>
    struct hash<wstring>
    : public __hash_base<size_t, wstring>
    {
    };
  template<>
    struct __is_fast_hash<hash<wstring>> : std::false_type
    { };
  template<>
    struct hash<u16string>
    : public __hash_base<size_t, u16string>
    {
    };
  template<>
    struct __is_fast_hash<hash<u16string>> : std::false_type
    { };
  template<>
    struct hash<u32string>
    : public __hash_base<size_t, u32string>
    {
    };
  template<>
    struct __is_fast_hash<hash<u32string>> : std::false_type
    { };
} 
namespace std __attribute__ ((__visibility__ ("default")))
{
  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::npos;
    ;
    ;
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in,
        basic_string<_CharT, _Traits, _Alloc>& __str)
    ;
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __in,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    ;
  extern template class basic_string<char>;
  extern template
    basic_istream<char>&
    operator>>(basic_istream<char>&, string&);
  extern template
    basic_ostream<char>&
    operator<<(basic_ostream<char>&, const string&);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&, char);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&);
  extern template class basic_string<wchar_t>;
  extern template
    basic_istream<wchar_t>&
    operator>>(basic_istream<wchar_t>&, wstring&);
  extern template
    basic_ostream<wchar_t>&
    operator<<(basic_ostream<wchar_t>&, const wstring&);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&, wchar_t);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&);
} 
/*
Copyright (C) 2003-2019 John W. Eaton
Copyirght (C) 2009, 2010 VZLU Prague
This file is part of Octave.
Octave is free software: you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by
   version 2.1 of the License, or (at your option) any later version.
   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.
   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http:
/*
 *	ISO C99 Standard: 7.2 Diagnostics	<assert.h>
 */
/* void assert (int expression);
   If NDEBUG is defined, do nothing.
   If not, and EXPRESSION is zero, print an error message and abort.  */
/* When possible, define assert so that it does not add extra
   parentheses around EXPR.  Otherwise, those added parentheses would
   suppress warnings we'd expect to be detected by gcc's -Wparentheses.  */
/* Version 2.4 and later of GCC define a magical variable `__PRETTY_FUNCTION__'    which contains the name of the function currently being defined.    This is broken in G++ before version 2.6.    C9x has a similar variable called __func__, but prefer the GCC one since    it demangles C++ function names.  */namespace octave {   template <typename T>   class refcount   {   public:     typedef T count_type;                                           private:     count_type count;   }; } template <typename T> using octave_refcount __attribute__ ((__deprecated__)) = octave::refcount<T>; template <typename T> class Array; class dim_vector { private:   octave_idx_type *rep;                   public:       ;                      private:    public:                                                                                                                         };     /* Copyright (C) 1993-2019 John W. Eaton Copyright (C) 2008-2009 Jaroslav Hajek Copyright (C) 2009 VZLU Prague This file is part of Octave. Octave is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. Octave is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with Octave; see the file COPYING.  If not, see <https: *//** @file cassert  *  This is a Standard C++ Library file.  You should @c \
#include this file
 *  in your programs, rather than any of the @a *.h implementation files.  *  *  This is the C++ version of the Standard C Library header @c assert.h,  *  and its contents are (mostly) the same as that header, but are all  *  contained in the namespace @c std (except for names which are defined  *  as macros in C).  *//* Copyright (C) 1991-2019 Free Software Foundation, Inc.    This file is part of the GNU C Library.    The GNU C Library is free software; you can redistribute it and/or    modify it under the terms of the GNU Lesser General Public    License as published by the Free Software Foundation; either    version 2.1 of the License, or (at your option) any later version.    The GNU C Library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.    You should have received a copy of the GNU Lesser General Public    License along with the GNU C Library; if not, see    <http: /*  *	ISO C99 Standard: 7.2 Diagnostics	<assert.h>  *//* void assert (int expression);    If NDEBUG is defined, do nothing.    If not, and EXPRESSION is zero, print an error message and abort.  *//* When possible, define assert so that it does not add extra    parentheses around EXPR.  Otherwise, those added parentheses would    suppress warnings we'd expect to be detected by gcc's -Wparentheses.  *//* Version 2.4 and later of GCC define a magical variable `__PRETTY_FUNCTION__'
   which contains the name of the function currently being defined.
   This is broken in G++ before version 2.6.
   C9x has a similar variable called __func__, but prefer the GCC one since
   it demangles C++ function names.  */
extern "C" {
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
 ;
;
extern "C" {
;
;
;
;
;
;
;
;
;
;
;
;
}
;
;
;
;
;
;
;
;
;
;
;
}
extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{
} 
} 
namespace std __attribute__ ((__visibility__ ("default")))
{
  template<bool _TrivialValueTypes>
    struct __uninitialized_copy
    {
        ;
    };
  template<>
    struct __uninitialized_copy<true>
    {
        ;
    };
    ;
  template<bool _TrivialValueType>
    struct __uninitialized_fill
    {
        ;
    };
  template<>
    struct __uninitialized_fill<true>
    {
        ;
    };
    ;
    ;
    ;
    ;
  /**
   *  @brief Copies the range [first,first+n) into result.
   *  @param  __first  An input iterator.
   *  @param  __n      The number of elements to copy.
   *  @param  __result An output iterator.
   *  @return  __result + __n
   *
   *  Like copy_n(), but does not require an initialized output range.
  */
    ;
    ;
    ;
  template<typename _Tp, typename = void>
    struct __is_bitwise_relocatable
    : is_trivial<_Tp> { };
    ;
    ;
    ;
} 
/*
 *
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{memory}
 */
namespace std __attribute__ ((__visibility__ ("default")))
{
  /**
   *  This iterator class lets algorithms store their results into
   *  uninitialized memory.
  */
  template <class _OutputIterator, class _Tp>
    class raw_storage_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _OutputIterator _M_iter;
    public:
    };
} 
/** @file ext/concurrence.h
 *  This file is a GNU extension to the Standard C++ Library.
 */
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{
  enum _Lock_policy { _S_single, _S_mutex, _S_atomic };
  static const _Lock_policy __default_lock_policy =
  _S_atomic;
  class __concurrence_lock_error : public std::exception
  {
  public:
  };
  class __concurrence_unlock_error : public std::exception
  {
  public:
  };
  class __concurrence_broadcast_error : public std::exception
  {
  public:
  };
  class __concurrence_wait_error : public std::exception
  {
  public:
  };
  class __mutex
  {
  private:
    __gthread_mutex_t _M_mutex = { { 0, 0, 0, 0, 0, 0, 0, { 0, 0 } } };
  public:
  };
  class __recursive_mutex
  {
  private:
    __gthread_recursive_mutex_t _M_mutex = { { 0, 0, 0, 0, PTHREAD_MUTEX_RECURSIVE_NP, 0, 0, { 0, 0 } } };
  public:
  };
  class __scoped_lock
  {
  public:
    typedef __mutex __mutex_type;
  private:
    __mutex_type& _M_device;
  public:
  };
  class __cond
  {
  private:
    __gthread_cond_t _M_cond = { { {0}, {0}, {0, 0}, {0, 0}, 0, 0, {0, 0} } };
  public:
  };
} 
namespace std __attribute__ ((__visibility__ ("default")))
{
  struct __erased_type { };
  template<typename _Alloc, typename _Tp>
    using __is_erased_or_convertible
      = __or_<is_convertible<_Alloc, _Tp>, is_same<_Tp, __erased_type>>;
  struct allocator_arg_t { explicit allocator_arg_t() = default; };
                    constexpr allocator_arg_t allocator_arg =
    allocator_arg_t();
  template<typename _Tp, typename _Alloc, typename = __void_t<>>
    struct __uses_allocator_helper
    : false_type { };
  template<typename _Tp, typename _Alloc>
    struct __uses_allocator_helper<_Tp, _Alloc,
       __void_t<typename _Tp::allocator_type>>
    : __is_erased_or_convertible<_Alloc, typename _Tp::allocator_type>::type
    { };
  template<typename _Tp, typename _Alloc>
    struct uses_allocator
    : __uses_allocator_helper<_Tp, _Alloc>::type
    { };
  struct __uses_alloc_base { };
  struct __uses_alloc0 : __uses_alloc_base
  {
    struct _Sink {  } _M_a;
  };
  template<typename _Alloc>
    struct __uses_alloc1 : __uses_alloc_base { const _Alloc* _M_a; };
  template<typename _Alloc>
    struct __uses_alloc2 : __uses_alloc_base { const _Alloc* _M_a; };
  template<bool, typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_alloc;
  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_alloc<true, _Tp, _Alloc, _Args...>
    : conditional<
        is_constructible<_Tp, allocator_arg_t, const _Alloc&, _Args...>::value,
        __uses_alloc1<_Alloc>,
        __uses_alloc2<_Alloc>>::type
    {
      static_assert(__or_<
   is_constructible<_Tp, allocator_arg_t, const _Alloc&, _Args...>,
   is_constructible<_Tp, _Args..., const _Alloc&>>::value,
   "construction with an allocator must be possible"
   " if uses_allocator is true");
    };
  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_alloc<false, _Tp, _Alloc, _Args...>
    : __uses_alloc0 { };
  template<typename _Tp, typename _Alloc, typename... _Args>
    using __uses_alloc_t =
      __uses_alloc<uses_allocator<_Tp, _Alloc>::value, _Tp, _Alloc, _Args...>;
  template<typename _Tp, typename _Alloc, typename... _Args>
    void __uses_allocator_construct_impl(__uses_alloc1<_Alloc> __a, _Tp* __ptr,
      _Args&&... __args)
    ;
  template<typename _Tp, typename _Alloc, typename... _Args>
    void __uses_allocator_construct_impl(__uses_alloc2<_Alloc> __a, _Tp* __ptr,
      _Args&&... __args)
    ;
  template<typename _Tp, typename _Alloc, typename... _Args>
    void __uses_allocator_construct(const _Alloc& __a, _Tp* __ptr,
        _Args&&... __args)
    ;
} 
namespace std __attribute__ ((__visibility__ ("default")))
{
  struct __cow_string
  {
    union {
      const char* _M_p;
      char _M_bytes[sizeof(const char*)];
    };
    __cow_string();
  };
  typedef basic_string<char> __sso_string;
  class logic_error : public exception
  {
    __cow_string _M_msg;
  public:
  };
  class domain_error : public logic_error
  {
  public:
  };
  class invalid_argument : public logic_error
  {
  public:
  };
  class length_error : public logic_error
  {
  public:
  };
  class out_of_range : public logic_error
  {
  public:
  };
  class runtime_error : public exception
  {
    __cow_string _M_msg;
  public:
  };
  class range_error : public runtime_error
  {
  public:
  };
  class overflow_error : public runtime_error
  {
  public:
  };
  class underflow_error : public runtime_error
  {
  public:
    underflow_error& operator=(underflow_error&&) = default;
    virtual ~underflow_error() noexcept;
  };
} 
namespace std __attribute__ ((__visibility__ ("default")))
{
  template<typename _Tp, std::size_t _Nm>
    struct __array_traits
    {
      typedef _Tp _Type[_Nm];
      typedef __is_swappable<_Tp> _Is_swappable;
      typedef __is_nothrow_swappable<_Tp> _Is_nothrow_swappable;
      static constexpr _Tp&
      _S_ref(const _Type& __t, std::size_t __n) noexcept
      ;
    };
 template<typename _Tp>
   struct __array_traits<_Tp, 0>
   {
     struct _Type { };
     typedef true_type _Is_swappable;
     typedef true_type _Is_nothrow_swappable;
   };
  template<typename _Tp, std::size_t _Nm>
    struct array
    {
      typedef _Tp value_type;
      typedef value_type* pointer;
      typedef const value_type* const_pointer;
      typedef value_type& reference;
      typedef const value_type& const_reference;
      typedef value_type* iterator;
      typedef const value_type* const_iterator;
      typedef std::size_t size_type;
      typedef std::ptrdiff_t difference_type;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::__array_traits<_Tp, _Nm> _AT_Type;
      typename _AT_Type::_Type _M_elems;
                           const_pointer
      data() const noexcept
      ;
    };
  template<typename _Tp, std::size_t _Nm>
     bool
    operator==(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    ;
  template<typename _Tp, std::size_t _Nm>
     bool
    operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    ;
  template<typename _Tp, std::size_t _Nm>
     bool
    operator<(const array<_Tp, _Nm>& __a, const array<_Tp, _Nm>& __b)
    ;
  template<typename _Tp, std::size_t _Nm>
     bool
    operator>(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    ;
  template<typename _Tp, std::size_t _Nm>
     bool
    operator<=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    ;
  template<typename _Tp, std::size_t _Nm>
     bool
    operator>=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    ;
  template<typename _Tp, std::size_t _Nm>
    typename enable_if<
      std::__array_traits<_Tp, _Nm>::_Is_swappable::value
    >::type
    swap(array<_Tp, _Nm>& __one, array<_Tp, _Nm>& __two)
    noexcept(noexcept(__one.swap(__two)))
    ;
  template<typename _Tp, std::size_t _Nm>
    typename enable_if<
      !std::__array_traits<_Tp, _Nm>::_Is_swappable::value>::type
    swap(array<_Tp, _Nm>&, array<_Tp, _Nm>&) = delete;
    ;
    ;
    ;
    ;
} 
namespace std __attribute__ ((__visibility__ ("default")))
{
  template<typename _Tp>
    struct tuple_size;
  template<typename _Tp, std::size_t _Nm>
    struct tuple_size<std::array<_Tp, _Nm>>
    : public integral_constant<std::size_t, _Nm> { };
  template<std::size_t _Int, typename _Tp>
    struct tuple_element;
  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    struct tuple_element<_Int, std::array<_Tp, _Nm>>
    {
      static_assert(_Int < _Nm, "index is out of bounds");
      typedef _Tp type;
    };
  template<typename _Tp, std::size_t _Nm>
    struct __is_tuple_like_impl<std::array<_Tp, _Nm>> : true_type
    { };
} 
namespace std __attribute__ ((__visibility__ ("default")))
{
    ;
    ;
    ;
    ;
    ;
    ;
  template<typename _Callable, typename... _Args>
    constexpr typename __invoke_result<_Callable, _Args...>::type
    __invoke(_Callable&& __fn, _Args&&... __args)
    noexcept(__is_nothrow_invocable<_Callable, _Args...>::value)
    ;
} 
namespace std __attribute__ ((__visibility__ ("default")))
{
  template<typename... _Elements>
    class tuple;
  template<typename _Tp>
    struct __is_empty_non_tuple : is_empty<_Tp> { };
  template<typename _El0, typename... _El>
    struct __is_empty_non_tuple<tuple<_El0, _El...>> : false_type { };
  template<typename _Tp>
    using __empty_not_final
    = typename conditional<__is_final(_Tp), false_type,
      __is_empty_non_tuple<_Tp>>::type;
  template<std::size_t _Idx, typename _Head,
    bool = __empty_not_final<_Head>::value>
    struct _Head_base;
  template<std::size_t _Idx, typename... _Elements>
    struct _Tuple_impl;
  template<std::size_t _Idx, typename _Head, typename... _Tail>
    struct _Tuple_impl<_Idx, _Head, _Tail...>
    : public _Tuple_impl<_Idx + 1, _Tail...>,
      private _Head_base<_Idx, _Head>
    {
      template<std::size_t, typename...> friend class _Tuple_impl;
      typedef _Tuple_impl<_Idx + 1, _Tail...> _Inherited;
      typedef _Head_base<_Idx, _Head> _Base;
        ;
        ;
        ;
        ;
        ;
        ;
        ;
        ;
        ;
        ;
        ;
        ;
    protected:
    };
  template<std::size_t _Idx, typename _Head>
    struct _Tuple_impl<_Idx, _Head>
    : private _Head_base<_Idx, _Head>
    {
      template<std::size_t, typename...> friend class _Tuple_impl;
      typedef _Head_base<_Idx, _Head> _Base;
        ;
        ;
 ;
        ;
        ;
        ;
        ;
        ;
        ;
 ;
        ;
        ;
    protected:
    };
  template<bool, typename... _Elements>
  struct _TC
  {
    ;
        ;
        ;
        ;
        ;
        ;
        ;
        ;
        ;
        ;
 ;
 ;
 ;
 ;
        ;
        ;
        ;
        ;
 ;
 ;
 ;
 ;
    };
  template<typename... _Elements>
    struct tuple_size<tuple<_Elements...>>
    : public integral_constant<std::size_t, sizeof...(_Elements)> { };
  /**
   * Recursive case for tuple_element: strip off the first element in
   * the tuple and retrieve the (i-1)th element of the remaining tuple.
   */
  template<std::size_t __i, typename _Head, typename... _Tail>
    struct tuple_element<__i, tuple<_Head, _Tail...> >
    : tuple_element<__i - 1, tuple<_Tail...> > { };
  /**
   * Basis case for tuple_element: The first element is the one we're seeking.    */  template<typename _Head, typename... _Tail>     struct tuple_element<0, tuple<_Head, _Tail...> >     {       typedef _Head type;     };   template<size_t __i>     struct tuple_element<__i, tuple<>>     {       static_assert(__i < tuple_size<tuple<>>::value,    "tuple index is in range");     };        ;        ;        ;        ;        ;        ;   template<typename _Tp, typename _Up, size_t __i, size_t __size>     struct __tuple_compare     {                   };   template<typename _Tp, typename _Up, size_t __size>     struct __tuple_compare<_Tp, _Up, __size, __size>     {                   };        ;        ;        ;        ;        ;        ;        ;        ;   template<size_t, typename, typename, size_t>     struct __make_tuple_impl;   template<size_t _Idx, typename _Tuple, typename... _Tp, size_t _Nm>     struct __make_tuple_impl<_Idx, tuple<_Tp...>, _Tuple, _Nm>     : __make_tuple_impl<_Idx + 1,    tuple<_Tp..., __tuple_element_t<_Idx, _Tuple>>,    _Tuple, _Nm>     { };   template<std::size_t _Nm, typename _Tuple, typename... _Tp>     struct __make_tuple_impl<_Nm, tuple<_Tp...>, _Tuple, _Nm>     {       typedef tuple<_Tp...> __type;     };   template<typename _Tuple>     struct __do_make_tuple     : __make_tuple_impl<0, tuple<>, _Tuple, std::tuple_size<_Tuple>::value>     { };   template<typename _Tuple>     struct __make_tuple     : public __do_make_tuple<__remove_cvref_t<_Tuple>>     { };   template<typename...>     struct __combine_tuples;   template<>     struct __combine_tuples<>     {       typedef tuple<> __type;     };   template<typename... _Ts>     struct __combine_tuples<tuple<_Ts...>>     {       typedef tuple<_Ts...> __type;     };   template<typename... _T1s, typename... _T2s, typename... _Rem>     struct __combine_tuples<tuple<_T1s...>, tuple<_T2s...>, _Rem...>     {       typedef typename __combine_tuples<tuple<_T1s..., _T2s...>,      _Rem...>::__type __type;     };   template<typename... _Tpls>     struct __tuple_cat_result     {       typedef typename __combine_tuples         <typename __make_tuple<_Tpls>::__type...>::__type __type;     };   template<typename...>     struct __make_1st_indices;   template<>     struct __make_1st_indices<>     {       typedef std::_Index_tuple<> __type;     };   template<typename _Tp, typename... _Tpls>     struct __make_1st_indices<_Tp, _Tpls...>     {       typedef typename std::_Build_index_tuple<std::tuple_size<  typename std::remove_reference<_Tp>::type>::value>::__type __type;     };   template<typename _Ret, typename _Indices, typename... _Tpls>     struct __tuple_concater;   template<typename _Ret, std::size_t... _Is, typename _Tp, typename... _Tpls>     struct __tuple_concater<_Ret, std::_Index_tuple<_Is...>, _Tp, _Tpls...>     {                ;     };   template<typename _Ret>     struct __tuple_concater<_Ret, std::_Index_tuple<>>     {                ;     };        ;   template<typename... _Elements>     constexpr tuple<_Elements&...>     tie(_Elements&... __args) noexcept     ;   template<typename... _Elements>          typename enable_if<__and_<__is_swappable<_Elements>...>::value       >::type     swap(tuple<_Elements...>& __x, tuple<_Elements...>& __y)     noexcept(noexcept(__x.swap(__y)))     ;   template<typename... _Elements>     typename enable_if<!__and_<__is_swappable<_Elements>...>::value>::type     swap(tuple<_Elements...>&, tuple<_Elements...>&) = delete;   struct _Swallow_assign   {     template<class _Tp>                            const _Swallow_assign&       operator=(const _Tp&) const       ;   };                     constexpr _Swallow_assign ignore{};   template<typename... _Types, typename _Alloc>     struct uses_allocator<tuple<_Types...>, _Alloc> : true_type { };       }  namespace std __attribute__ ((__visibility__ ("default"))) {   /**    * @addtogroup pointer_abstractions    * @{    */
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
 template<typename> class auto_ptr; 
#pragma GCC diagnostic pop
  template<typename _Tp>     struct default_delete     {       constexpr default_delete() noexcept = default;       /** @brief Converting constructor.        *        * Allows conversion from a deleter for arrays of another type, @p _Up,        * only if @p _Up* is convertible to @p _Tp*.        */      template<typename _Up, typename = typename         enable_if<is_convertible<_Up*, _Tp*>::value>::type>         default_delete(const default_delete<_Up>&) noexcept ;            };   template<typename _Tp>     struct default_delete<_Tp[]>     {     public:              /** @brief Converting constructor.        *        * Allows conversion from a deleter for arrays of another type, such as        * a const-qualified version of @p _Tp.        *        * Conversions from types derived from @c _Tp are not allowed because        * it is unsafe to @c delete[] an array of derived types through a        * pointer to the base type.        */       ;              ;     };   template <typename _Tp, typename _Dp>     class __uniq_ptr_impl     {       template <typename _Up, typename _Ep, typename = void>  struct _Ptr  {    using type = _Up*;  };       template <typename _Up, typename _Ep>  struct  _Ptr<_Up, _Ep, __void_t<typename remove_reference<_Ep>::type::pointer>>  {    using type = typename remove_reference<_Ep>::type::pointer;  };     public:       using _DeleterConstraint = enable_if<         __and_<__not_<is_pointer<_Dp>>,         is_default_constructible<_Dp>>::value>;       using pointer = typename _Ptr<_Tp, _Dp>::type;       static_assert( !is_rvalue_reference<_Dp>::value,        "unique_ptr's deleter type must be a function object type"        " or an lvalue reference type" );                       ;                            const _Dp& _M_deleter() const ;     private:       tuple<pointer, _Dp> _M_t;     };   template <typename _Tp, typename _Dp = default_delete<_Tp>>     class unique_ptr     {       template <typename _Up>  using _DeleterConstraint =    typename __uniq_ptr_impl<_Tp, _Up>::_DeleterConstraint::type;       __uniq_ptr_impl<_Tp, _Dp> _M_t;     public:       using pointer = typename __uniq_ptr_impl<_Tp, _Dp>::pointer;       using element_type = _Tp;       using deleter_type = _Dp;     private:       template<typename _Up, typename _Ep>  using __safe_conversion_up = __and_<    is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>,    __not_<is_array<_Up>>         >;     public:       template<typename _Del = _Dp, typename = _DeleterConstraint<_Del>>  constexpr unique_ptr()   ;       /** Takes ownership of a pointer.        *        * @param __p  A pointer to an object of @c element_type        *        * The deleter will be value-initialized.        */      template<typename _Del = _Dp, typename = _DeleterConstraint<_Del>>  explicit  unique_ptr(pointer __p)          ;       /** Takes ownership of a pointer.        *        * @param __p  A pointer to an object of @c element_type        * @param __d  A reference to a deleter.        *        * The deleter will be initialized with @p __d        */      template<typename _Del = deleter_type,         typename = _Require<is_copy_constructible<_Del>>>  unique_ptr(pointer __p, const deleter_type& __d)  ;       /** Takes ownership of a pointer.        *        * @param __p  A pointer to an object of @c element_type        * @param __d  An rvalue reference to a (non-reference) deleter.        *        * The deleter will be initialized with @p std::move(__d)        */      template<typename _Del = deleter_type,         typename = _Require<is_move_constructible<_Del>>>  unique_ptr(pointer __p,      __enable_if_t<!is_lvalue_reference<_Del>::value,      _Del&&> __d)   ;       template<typename _Del = deleter_type,         typename _DelUnref = typename remove_reference<_Del>::type>  unique_ptr(pointer,      __enable_if_t<is_lvalue_reference<_Del>::value,      _DelUnref&&>) = delete;       template<typename _Del = _Dp, typename = _DeleterConstraint<_Del>>  constexpr unique_ptr(nullptr_t)   ;       unique_ptr(unique_ptr&& __u)  ;       /** @brief Converting constructor from another type        *        * Requires that the pointer owned by @p __u is convertible to the        * type of pointer owned by this object, @p __u does not own an array,        * and @p __u has a compatible deleter type.        */         ; 
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
      ; 
#pragma GCC diagnostic pop
             /** @brief Move assignment operator.        *        * @param __u  The object to transfer ownership from.        *        * Invokes the deleter first if this object owns a pointer.        */             /** @brief Assignment from another type.        *        * @param __u  The object to transfer ownership from, which owns a        *             convertible pointer to a non-array object.        *        * Invokes the deleter first if this object owns a pointer.        */        ;                                                               /** @brief Replace the stored pointer.        *        * @param __p  The new pointer to store.        *        * The deleter will be invoked if a pointer is already owned.        */                              };   template<typename _Tp, typename _Dp>     class unique_ptr<_Tp[], _Dp>     {       template <typename _Up>       using _DeleterConstraint =  typename __uniq_ptr_impl<_Tp, _Up>::_DeleterConstraint::type;       __uniq_ptr_impl<_Tp, _Dp> _M_t;       template<typename _Up>  using __remove_cv = typename remove_cv<_Up>::type;       template<typename _Up>  using __is_derived_Tp    = __and_< is_base_of<_Tp, _Up>,       __not_<is_same<__remove_cv<_Tp>, __remove_cv<_Up>>> >;     public:       using pointer = typename __uniq_ptr_impl<_Tp, _Dp>::pointer;       using element_type = _Tp;       using deleter_type = _Dp;       template<typename _Up, typename _Ep,                typename _UPtr = unique_ptr<_Up, _Ep>,         typename _UP_pointer = typename _UPtr::pointer,         typename _UP_element_type = typename _UPtr::element_type>  using __safe_conversion_up = __and_<           is_array<_Up>,           is_same<pointer, element_type*>,           is_same<_UP_pointer, _UP_element_type*>,           is_convertible<_UP_element_type(*)[], element_type(*)[]>         >;       template<typename _Up>         using __safe_conversion_raw = __and_<           __or_<__or_<is_same<_Up, pointer>,                       is_same<_Up, nullptr_t>>,                 __and_<is_pointer<_Up>,                        is_same<pointer, element_type*>,                        is_convertible<                          typename remove_pointer<_Up>::type(*)[],                          element_type(*)[]>                 >           >         >;          ;       /** Takes ownership of a pointer.        *        * @param __p  A pointer to an array of a type safely convertible        * to an array of @c element_type        *        * The deleter will be value-initialized.        */                ;       /** Takes ownership of a pointer.        *        * @param __p  A pointer to an array of a type safely convertible        * to an array of @c element_type        * @param __d  A reference to a deleter.        *        * The deleter will be initialized with @p __d        */      template<typename _Up, typename _Del = deleter_type,         typename = _Require<__safe_conversion_raw<_Up>,        is_copy_constructible<_Del>>>       unique_ptr(_Up __p, const deleter_type& __d)  ;       /** Takes ownership of a pointer.        *        * @param __p  A pointer to an array of a type safely convertible        * to an array of @c element_type        * @param __d  A reference to a deleter.        *        * The deleter will be initialized with @p std::move(__d)        */      template<typename _Up, typename _Del = deleter_type,         typename = _Require<__safe_conversion_raw<_Up>,        is_move_constructible<_Del>>>  unique_ptr(_Up __p,      __enable_if_t<!is_lvalue_reference<_Del>::value,      _Del&&> __d)   ;       template<typename _Up, typename _Del = deleter_type,         typename _DelUnref = typename remove_reference<_Del>::type,         typename = _Require<__safe_conversion_raw<_Up>>>  unique_ptr(_Up,      __enable_if_t<is_lvalue_reference<_Del>::value,      _DelUnref&&>) = delete;       unique_ptr(unique_ptr&& __u)  ;       template<typename _Del = _Dp, typename = _DeleterConstraint<_Del>>  constexpr unique_ptr(nullptr_t)          ;       template<typename _Up, typename _Ep, typename = _Require<         __safe_conversion_up<_Up, _Ep>,         typename conditional<is_reference<_Dp>::value,         is_same<_Ep, _Dp>,         is_convertible<_Ep, _Dp>>::type>>  unique_ptr(unique_ptr<_Up, _Ep>&& __u)   ;       ~unique_ptr()       ;       /** @brief Move assignment operator.        *        * @param __u  The object to transfer ownership from.        *        * Invokes the deleter first if this object owns a pointer.        */      unique_ptr&       operator=(unique_ptr&& __u) noexcept       ;       /** @brief Assignment from another type.        *        * @param __u  The object to transfer ownership from, which owns a        *             convertible pointer to an array object.        *        * Invokes the deleter first if this object owns a pointer.        */      template<typename _Up, typename _Ep>  typename  enable_if<__and_<__safe_conversion_up<_Up, _Ep>,                          is_assignable<deleter_type&, _Ep&&>                   >::value,                   unique_ptr&>::type  operator=(unique_ptr<_Up, _Ep>&& __u) noexcept  ;       unique_ptr&       operator=(nullptr_t) noexcept       ;                                                 /** @brief Replace the stored pointer.        *        * @param __p  The new pointer to store.        *        * The deleter will be invoked if a pointer is already owned.        */             ;                            unique_ptr& operator=(const unique_ptr&) = delete;     };   template<typename _Tp, typename _Dp>          typename enable_if<__is_swappable<_Dp>::value>::type     swap(unique_ptr<_Tp, _Dp>& __x,   unique_ptr<_Tp, _Dp>& __y) noexcept     ;   template<typename _Tp, typename _Dp>     typename enable_if<!__is_swappable<_Dp>::value>::type     swap(unique_ptr<_Tp, _Dp>&,   unique_ptr<_Tp, _Dp>&) = delete;   template<typename _Tp, typename _Dp,     typename _Up, typename _Ep>                         bool     operator==(const unique_ptr<_Tp, _Dp>& __x,         const unique_ptr<_Up, _Ep>& __y)     ;   template<typename _Tp, typename _Dp>                         bool     operator==(const unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept     ;   template<typename _Tp, typename _Dp>                         bool     operator==(nullptr_t, const unique_ptr<_Tp, _Dp>& __x) noexcept     ;   template<typename _Tp, typename _Dp,     typename _Up, typename _Ep>                         bool     operator!=(const unique_ptr<_Tp, _Dp>& __x,         const unique_ptr<_Up, _Ep>& __y)     ;   template<typename _Tp, typename _Dp>                         bool     operator!=(const unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept     ;   template<typename _Tp, typename _Dp>                         bool     operator!=(nullptr_t, const unique_ptr<_Tp, _Dp>& __x) noexcept     ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;   template<typename _Tp, typename _Dp>     struct hash<unique_ptr<_Tp, _Dp>>     : public __hash_base<size_t, unique_ptr<_Tp, _Dp>>,     private __poison_hash<typename unique_ptr<_Tp, _Dp>::pointer>     {            }; }  /** @file  *  This is an internal header file, included by other library headers.  *  Do not attempt to use it directly. @headername{memory}  *//** @file bits/shared_ptr_base.h  *  This is an internal header file, included by other library headers.  *  Do not attempt to use it directly. @headername{memory}  *//** @file bits/allocated_ptr.h  *  This is an internal header file, included by other library headers.  *  Do not attempt to use it directly. @headername{memory}  */namespace std __attribute__ ((__visibility__ ("default"))) {   template<typename _Alloc>     struct __allocated_ptr     {       using pointer = typename allocator_traits<_Alloc>::pointer;       using value_type = typename allocator_traits<_Alloc>::value_type;                      ;                                 private:       _Alloc* _M_alloc;       pointer _M_ptr;     };        ; }  namespace std __attribute__ ((__visibility__ ("default"))) {   template<typename _Res, typename... _ArgTypes>     struct _Maybe_unary_or_binary_function { };   template<typename _Res, typename _T1>     struct _Maybe_unary_or_binary_function<_Res, _T1>     : std::unary_function<_T1, _Res> { };   template<typename _Res, typename _T1, typename _T2>     struct _Maybe_unary_or_binary_function<_Res, _T1, _T2>     : std::binary_function<_T1, _T2, _Res> { };   template<typename _Signature>     struct _Mem_fn_traits;   template<typename _Res, typename _Class, typename... _ArgTypes>     struct _Mem_fn_traits_base     {       using __result_type = _Res;       using __maybe_type  = _Maybe_unary_or_binary_function<_Res, _Class*, _ArgTypes...>;       using __arity = integral_constant<size_t, sizeof...(_ArgTypes)>;     }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) > : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) > : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const > : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const > : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile > : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) volatile > : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile > : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const volatile > : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) &> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) &> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const &> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const &> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile &> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) volatile &> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile &> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const volatile &> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) &&> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) &&> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const &&> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const &&> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile &&> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) volatile &&> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile &&> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const volatile &&> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = true_type; };   template<typename _Functor, typename = __void_t<>>     struct _Maybe_get_result_type     { };   template<typename _Functor>     struct _Maybe_get_result_type<_Functor,       __void_t<typename _Functor::result_type>>     { typedef typename _Functor::result_type result_type; };   template<typename _Functor>     struct _Weak_result_type_impl     : _Maybe_get_result_type<_Functor>     { };   template<typename _Res, typename... _ArgTypes >     struct _Weak_result_type_impl<_Res(_ArgTypes...) >     { typedef _Res result_type; };   template<typename _Res, typename... _ArgTypes >     struct _Weak_result_type_impl<_Res(_ArgTypes......) >     { typedef _Res result_type; };   template<typename _Res, typename... _ArgTypes >     struct _Weak_result_type_impl<_Res(*)(_ArgTypes...) >     { typedef _Res result_type; };   template<typename _Res, typename... _ArgTypes >     struct     _Weak_result_type_impl<_Res(*)(_ArgTypes......) >     { typedef _Res result_type; };   template<typename _Functor,     bool = is_member_function_pointer<_Functor>::value>     struct _Weak_result_type_memfun     : _Weak_result_type_impl<_Functor>     { };   template<typename _MemFunPtr>     struct _Weak_result_type_memfun<_MemFunPtr, true>     {       using result_type = typename _Mem_fn_traits<_MemFunPtr>::__result_type;     };   template<typename _Func, typename _Class>     struct _Weak_result_type_memfun<_Func _Class::*, false>     { };   /**    *  Strip top-level cv-qualifiers from the function object and let    *  _Weak_result_type_memfun perform the real work.   */  template<typename _Functor>     struct _Weak_result_type     : _Weak_result_type_memfun<typename remove_cv<_Functor>::type>     { };   template<typename _Tp, typename = __void_t<>>     struct _Refwrap_base_arg1     { };   template<typename _Tp>     struct _Refwrap_base_arg1<_Tp,          __void_t<typename _Tp::argument_type>>     {       typedef typename _Tp::argument_type argument_type;     };   template<typename _Tp, typename = __void_t<>>     struct _Refwrap_base_arg2     { };   template<typename _Tp>     struct _Refwrap_base_arg2<_Tp,          __void_t<typename _Tp::first_argument_type,            typename _Tp::second_argument_type>>     {       typedef typename _Tp::first_argument_type first_argument_type;       typedef typename _Tp::second_argument_type second_argument_type;     };   /**    *  Derives from unary_function or binary_function when it    *  can. Specializations handle all of the easy cases. The primary    *  template determines what to do with a class type, which may    *  derive from both unary_function and binary_function.   */  template<typename _Tp>     struct _Reference_wrapper_base     : _Weak_result_type<_Tp>, _Refwrap_base_arg1<_Tp>, _Refwrap_base_arg2<_Tp>     { };   template<typename _Res, typename _T1 >     struct _Reference_wrapper_base<_Res(_T1) >     : unary_function<_T1, _Res>     { };   template<typename _Res, typename _T1>     struct _Reference_wrapper_base<_Res(_T1) const>     : unary_function<_T1, _Res>     { };   template<typename _Res, typename _T1>     struct _Reference_wrapper_base<_Res(_T1) volatile>     : unary_function<_T1, _Res>     { };   template<typename _Res, typename _T1>     struct _Reference_wrapper_base<_Res(_T1) const volatile>     : unary_function<_T1, _Res>     { };   template<typename _Res, typename _T1, typename _T2 >     struct _Reference_wrapper_base<_Res(_T1, _T2) >     : binary_function<_T1, _T2, _Res>     { };   template<typename _Res, typename _T1, typename _T2>     struct _Reference_wrapper_base<_Res(_T1, _T2) const>     : binary_function<_T1, _T2, _Res>     { };   template<typename _Res, typename _T1, typename _T2>     struct _Reference_wrapper_base<_Res(_T1, _T2) volatile>     : binary_function<_T1, _T2, _Res>     { };   template<typename _Res, typename _T1, typename _T2>     struct _Reference_wrapper_base<_Res(_T1, _T2) const volatile>     : binary_function<_T1, _T2, _Res>     { };   template<typename _Res, typename _T1 >     struct _Reference_wrapper_base<_Res(*)(_T1) >     : unary_function<_T1, _Res>     { };   template<typename _Res, typename _T1, typename _T2 >     struct _Reference_wrapper_base<_Res(*)(_T1, _T2) >     : binary_function<_T1, _T2, _Res>     { };   template<typename _Tp, bool = is_member_function_pointer<_Tp>::value>     struct _Reference_wrapper_base_memfun     : _Reference_wrapper_base<_Tp>     { };   template<typename _MemFunPtr>     struct _Reference_wrapper_base_memfun<_MemFunPtr, true>     : _Mem_fn_traits<_MemFunPtr>::__maybe_type     {       using result_type = typename _Mem_fn_traits<_MemFunPtr>::__result_type;     };   /**    *  @brief Primary class template for reference_wrapper.    *  @ingroup functors    *  @{    */  template<typename _Tp>     class reference_wrapper     : public _Reference_wrapper_base_memfun<typename remove_cv<_Tp>::type>     {       _Tp* _M_data;                     template<typename _Up, typename _Up2 = __remove_cvref_t<_Up>>  using __not_same    = typename enable_if<!is_same<reference_wrapper, _Up2>::value>::type;     public:       typedef _Tp type;          ;                                     ;     };        ;   template<typename _Tp>      reference_wrapper<const _Tp>     cref(const _Tp& __t) noexcept     ;   template<typename _Tp>     void ref(const _Tp&&) = delete;   template<typename _Tp>     void cref(const _Tp&&) = delete;   template<typename _Tp>      reference_wrapper<_Tp>     ref(reference_wrapper<_Tp> __t) noexcept     ;        ; }  /** @file ext/aligned_buffer.h  *  This file is a GNU extension to the Standard C++ Library.  */namespace __gnu_cxx {   template<typename _Tp>     struct __aligned_membuf     {       struct _Tp2 { _Tp _M_t; };       alignas(__alignof__(_Tp2::_M_t)) unsigned char _M_storage[sizeof(_Tp)];                                               };   template<typename _Tp>     struct __aligned_buffer     : std::aligned_storage<sizeof(_Tp), __alignof__(_Tp)>     {       typename  std::aligned_storage<sizeof(_Tp), __alignof__(_Tp)>::type _M_storage;                                               }; }  namespace std __attribute__ ((__visibility__ ("default"))) { 
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
 template<typename> class auto_ptr; 
#pragma GCC diagnostic pop
 /**    *  @brief  Exception possibly thrown by @c shared_ptr.    *  @ingroup exceptions    */  class bad_weak_ptr : public std::exception   {   public:             };       using __gnu_cxx::_Lock_policy;   using __gnu_cxx::__default_lock_policy;   using __gnu_cxx::_S_single;   using __gnu_cxx::_S_mutex;   using __gnu_cxx::_S_atomic;   template<_Lock_policy _Lp>     class _Mutex_base     {     protected:       enum { _S_need_barriers = 0 };     };   template<>     class _Mutex_base<_S_mutex>     : public __gnu_cxx::__mutex     {     protected:       enum { _S_need_barriers = 1 };     };   template<_Lock_policy _Lp = __default_lock_policy>     class _Sp_counted_base     : public _Mutex_base<_Lp>     {     public:                                                                                         private:                     _Atomic_word _M_use_count;        _Atomic_word _M_weak_count;      };                                    template<typename _Tp, _Lock_policy _Lp = __default_lock_policy>     class __shared_ptr;   template<typename _Tp, _Lock_policy _Lp = __default_lock_policy>     class __weak_ptr;   template<typename _Tp, _Lock_policy _Lp = __default_lock_policy>     class __enable_shared_from_this;   template<typename _Tp>     class shared_ptr;   template<typename _Tp>     class weak_ptr;   template<typename _Tp>     struct owner_less;   template<typename _Tp>     class enable_shared_from_this;   template<_Lock_policy _Lp = __default_lock_policy>     class __weak_count;   template<_Lock_policy _Lp = __default_lock_policy>     class __shared_count;   template<typename _Ptr, _Lock_policy _Lp>     class _Sp_counted_ptr final : public _Sp_counted_base<_Lp>     {     public:                                               private:       _Ptr _M_ptr;     };            template<int _Nm, typename _Tp,     bool __use_ebo = !__is_final(_Tp) && __is_empty(_Tp)>     struct _Sp_ebo_helper;   template<int _Nm, typename _Tp>     struct _Sp_ebo_helper<_Nm, _Tp, true> : private _Tp     {                          };   template<int _Nm, typename _Tp>     struct _Sp_ebo_helper<_Nm, _Tp, false>     {                          private:       _Tp _M_tp;     };   template<typename _Ptr, typename _Deleter, typename _Alloc, _Lock_policy _Lp>     class _Sp_counted_deleter final : public _Sp_counted_base<_Lp>     {       class _Impl : _Sp_ebo_helper<0, _Deleter>, _Sp_ebo_helper<1, _Alloc>       {  typedef _Sp_ebo_helper<0, _Deleter> _Del_base;  typedef _Sp_ebo_helper<1, _Alloc> _Alloc_base;       public:        _Ptr _M_ptr;       };     public:       using __allocator_type = __alloc_rebind<_Alloc, _Sp_counted_deleter>;                                               private:       _Impl _M_impl;     };   struct _Sp_make_shared_tag   {   private:     template<typename _Tp, typename _Alloc, _Lock_policy _Lp>       friend class _Sp_counted_ptr_inplace;             };   template<typename _Alloc>     struct _Sp_alloc_shared_tag     {       const _Alloc& _M_a;     };   template<typename _Tp, typename _Alloc, _Lock_policy _Lp>     class _Sp_counted_ptr_inplace final : public _Sp_counted_base<_Lp>     {       class _Impl : _Sp_ebo_helper<0, _Alloc>       {  typedef _Sp_ebo_helper<0, _Alloc> _A_base;       public:      __gnu_cxx::__aligned_buffer<_Tp> _M_storage;       };     public:       using __allocator_type = __alloc_rebind<_Alloc, _Sp_counted_ptr_inplace>;          ;                          private:       friend class __shared_count<_Lp>;                      _Impl _M_impl;     };   struct __sp_array_delete   {      ;   };   template<_Lock_policy _Lp>     class __shared_count     {       template<typename _Tp>  struct __not_alloc_shared_tag { using type = void; };       template<typename _Tp>  struct __not_alloc_shared_tag<_Sp_alloc_shared_tag<_Tp>> { };     public:                 ;          ;          ;          ;          ;         ; 
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
      ; 
#pragma GCC diagnostic pop
         ;                                                                                         private:       friend class __weak_count<_Lp>;       _Sp_counted_base<_Lp>* _M_pi;     };   template<_Lock_policy _Lp>     class __weak_count     {     public:                                                                                                private:       friend class __shared_count<_Lp>;       _Sp_counted_base<_Lp>* _M_pi;     };         template<typename _Yp_ptr, typename _Tp_ptr>     struct __sp_compatible_with     : false_type     { };   template<typename _Yp, typename _Tp>     struct __sp_compatible_with<_Yp*, _Tp*>     : is_convertible<_Yp*, _Tp*>::type     { };   template<typename _Up, size_t _Nm>     struct __sp_compatible_with<_Up(*)[_Nm], _Up(*)[]>     : true_type     { };   template<typename _Up, size_t _Nm>     struct __sp_compatible_with<_Up(*)[_Nm], const _Up(*)[]>     : true_type     { };   template<typename _Up, size_t _Nm>     struct __sp_compatible_with<_Up(*)[_Nm], volatile _Up(*)[]>     : true_type     { };   template<typename _Up, size_t _Nm>     struct __sp_compatible_with<_Up(*)[_Nm], const volatile _Up(*)[]>     : true_type     { };   template<typename _Up, size_t _Nm, typename _Yp, typename = void>     struct __sp_is_constructible_arrN     : false_type     { };   template<typename _Up, size_t _Nm, typename _Yp>     struct __sp_is_constructible_arrN<_Up, _Nm, _Yp, __void_t<_Yp[_Nm]>>     : is_convertible<_Yp(*)[_Nm], _Up(*)[_Nm]>::type     { };   template<typename _Up, typename _Yp, typename = void>     struct __sp_is_constructible_arr     : false_type     { };   template<typename _Up, typename _Yp>     struct __sp_is_constructible_arr<_Up, _Yp, __void_t<_Yp[]>>     : is_convertible<_Yp(*)[], _Up(*)[]>::type     { };   template<typename _Tp, typename _Yp>     struct __sp_is_constructible;   template<typename _Up, size_t _Nm, typename _Yp>     struct __sp_is_constructible<_Up[_Nm], _Yp>     : __sp_is_constructible_arrN<_Up, _Nm, _Yp>::type     { };   template<typename _Up, typename _Yp>     struct __sp_is_constructible<_Up[], _Yp>     : __sp_is_constructible_arr<_Up, _Yp>::type     { };   template<typename _Tp, typename _Yp>     struct __sp_is_constructible     : is_convertible<_Yp*, _Tp*>::type     { };   template<typename _Tp, _Lock_policy _Lp,     bool = is_array<_Tp>::value, bool = is_void<_Tp>::value>     class __shared_ptr_access     {     public:       using element_type = _Tp;                   private:            };   template<typename _Tp, _Lock_policy _Lp>     class __shared_ptr_access<_Tp, _Lp, false, true>     {     public:       using element_type = _Tp;            };   template<typename _Tp, _Lock_policy _Lp>     class __shared_ptr_access<_Tp, _Lp, true, false>     {     public:       using element_type = typename remove_extent<_Tp>::type;       [[__deprecated__("shared_ptr<T[]>::operator* is absent from C++17")]]       element_type&       operator*() const noexcept       {                                       ;  return *_M_get();       }       [[__deprecated__("shared_ptr<T[]>::operator-> is absent from C++17")]]       element_type*       operator->() const noexcept       {                                               ;  return _M_get();       }       element_type&       operator[](ptrdiff_t __i) const       {                                       ;                                                                   ;  return _M_get()[__i];       }     private:       element_type*       _M_get() const noexcept       { return static_cast<const __shared_ptr<_Tp, _Lp>*>(this)->get(); }     };   template<typename _Tp, _Lock_policy _Lp>     class __shared_ptr     : public __shared_ptr_access<_Tp, _Lp>     {     public:       using element_type = typename remove_extent<_Tp>::type;     private:       template<typename _Yp>  using _SafeConv    = typename enable_if<__sp_is_constructible<_Tp, _Yp>::value>::type;       template<typename _Yp, typename _Res = void>  using _Compatible = typename    enable_if<__sp_compatible_with<_Yp*, _Tp*>::value, _Res>::type;       template<typename _Yp>  using _Assignable = _Compatible<_Yp, __shared_ptr&>;       template<typename _Yp, typename _Del, typename _Res = void,         typename _Ptr = typename unique_ptr<_Yp, _Del>::pointer>  using _UniqCompatible = typename enable_if<__and_<    __sp_compatible_with<_Yp*, _Tp*>, is_convertible<_Ptr, element_type*>    >::value, _Res>::type;       template<typename _Yp, typename _Del>  using _UniqAssignable = _UniqCompatible<_Yp, _Del, __shared_ptr&>;     public:                 ;          ;          ;          ;          ;           ;       __shared_ptr(const __shared_ptr&) noexcept = default;       __shared_ptr& operator=(const __shared_ptr&) noexcept = default;       ~__shared_ptr() = default;          ;       __shared_ptr(__shared_ptr&& __r)        ;          ;           ;          ;     protected:          ;     public: 
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
      ; 
#pragma GCC diagnostic pop
          ; 
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
   ; 
#pragma GCC diagnostic pop
 __shared_ptr&       operator=(__shared_ptr&& __r) noexcept       ;         ;         ;                 ;         ;                ;                                            ;         ;     protected:          ;       ;              friend class __weak_ptr<_Tp, _Lp>;     private:       template<typename _Yp>  using __esft_base_t = decltype(__enable_shared_from_this_base(        std::declval<const __shared_count<_Lp>&>(),        std::declval<_Yp*>()));       template<typename _Yp, typename = void>  struct __has_esft_base  : false_type { };       template<typename _Yp>  struct __has_esft_base<_Yp, __void_t<__esft_base_t<_Yp>>>  : __not_<is_array<_Tp>> { };          ;         ;              template<typename _Tp1, _Lock_policy _Lp1> friend class __shared_ptr;       template<typename _Tp1, _Lock_policy _Lp1> friend class __weak_ptr;       ;       ;       element_type* _M_ptr;        __shared_count<_Lp> _M_refcount;      };        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;   template<typename _Tp, _Lock_policy _Lp>     class __weak_ptr     {       template<typename _Yp, typename _Res = void>  using _Compatible = typename    enable_if<__sp_compatible_with<_Yp*, _Tp*>::value, _Res>::type;       template<typename _Yp>  using _Assignable = _Compatible<_Yp, __weak_ptr&>;     public:       using element_type = typename remove_extent<_Tp>::type;                                      ;          ;                        ;                ;         ;                ;                              ;       template<typename _Tp1>  bool  owner_before(const __weak_ptr<_Tp1, _Lp>& __rhs) const noexcept  ;       void       reset() noexcept       ;       void       swap(__weak_ptr& __s) noexcept       ;     private:       void       _M_assign(_Tp* __ptr, const __shared_count<_Lp>& __refcount) noexcept       ;       template<typename _Tp1, _Lock_policy _Lp1> friend class __shared_ptr;       template<typename _Tp1, _Lock_policy _Lp1> friend class __weak_ptr;       friend class __enable_shared_from_this<_Tp, _Lp>;       friend class enable_shared_from_this<_Tp>;       element_type* _M_ptr;        __weak_count<_Lp> _M_refcount;      };   template<typename _Tp, _Lock_policy _Lp>      void     swap(__weak_ptr<_Tp, _Lp>& __a, __weak_ptr<_Tp, _Lp>& __b) noexcept     ;   template<typename _Tp, typename _Tp1>     struct _Sp_owner_less : public binary_function<_Tp, _Tp, bool>     {       bool       operator()(const _Tp& __lhs, const _Tp& __rhs) const noexcept       ;       bool       operator()(const _Tp& __lhs, const _Tp1& __rhs) const noexcept       ;       bool       operator()(const _Tp1& __lhs, const _Tp& __rhs) const noexcept       ;     };   template<>     struct _Sp_owner_less<void, void>     {       template<typename _Tp, typename _Up>  auto  operator()(const _Tp& __lhs, const _Up& __rhs) const noexcept  -> decltype(__lhs.owner_before(__rhs))  ;       using is_transparent = void;     };   template<typename _Tp, _Lock_policy _Lp>     struct owner_less<__shared_ptr<_Tp, _Lp>>     : public _Sp_owner_less<__shared_ptr<_Tp, _Lp>, __weak_ptr<_Tp, _Lp>>     { };   template<typename _Tp, _Lock_policy _Lp>     struct owner_less<__weak_ptr<_Tp, _Lp>>     : public _Sp_owner_less<__weak_ptr<_Tp, _Lp>, __shared_ptr<_Tp, _Lp>>     { };   template<typename _Tp, _Lock_policy _Lp>     class __enable_shared_from_this     {     protected:                                 public:                                 private:         ;              template<typename, _Lock_policy>  friend class __shared_ptr;       mutable __weak_ptr<_Tp, _Lp> _M_weak_this;     };        ;        ;   template<typename _Tp, _Lock_policy _Lp>     struct hash<__shared_ptr<_Tp, _Lp>>     : public __hash_base<size_t, __shared_ptr<_Tp, _Lp>>     {            }; }  namespace std __attribute__ ((__visibility__ ("default"))) {   /**    * @addtogroup pointer_abstractions    * @{    */       ;        ;        ;   /**    *  @brief  A smart pointer with reference-counted copy semantics.    *    *  The object pointed to is deleted when the last shared_ptr pointing to    *  it is destroyed or reset.   */  template<typename _Tp>     class shared_ptr : public __shared_ptr<_Tp>     {       template<typename... _Args>  using _Constructible = typename enable_if<    is_constructible<__shared_ptr<_Tp>, _Args...>::value  >::type;       template<typename _Arg>  using _Assignable = typename enable_if<    is_assignable<__shared_ptr<_Tp>&, _Arg>::value, shared_ptr&  >::type;     public:       using element_type = typename __shared_ptr<_Tp>::element_type;       /**        *  @brief  Construct an empty %shared_ptr.        *  @post   use_count()==0 && get()==0        */                    /**        *  @brief  Construct a %shared_ptr that owns the pointer @a __p.        *  @param  __p  A pointer that is convertible to element_type*.        *  @post   use_count() == 1 && get() == __p        *  @throw  std::bad_alloc, in which case @c delete @a __p is called.        */        ;       /**        *  @brief  Construct a %shared_ptr that owns the pointer @a __p        *          and the deleter @a __d.        *  @param  __p  A pointer.        *  @param  __d  A deleter.        *  @post   use_count() == 1 && get() == __p        *  @throw  std::bad_alloc, in which case @a __d(__p) is called.        *        *  Requirements: _Deleter's copy constructor and destructor must
       *  not throw
       *
       *  __shared_ptr will release __p by calling __d(__p)
       */
        ;
        ;
        ;
        ;
      friend class weak_ptr<_Tp>;
    };
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
  template<typename _Tp = void>
    struct owner_less;
  template<>
    struct owner_less<void> : _Sp_owner_less<void, void>
    { };
  template<typename _Tp>
    struct owner_less<shared_ptr<_Tp>>
    : public _Sp_owner_less<shared_ptr<_Tp>, weak_ptr<_Tp>>
    { };
  template<typename _Tp>
    struct owner_less<weak_ptr<_Tp>>
    : public _Sp_owner_less<weak_ptr<_Tp>, shared_ptr<_Tp>>
    { };
  /**
   *  @brief Base class allowing use of member function shared_from_this.
   */
  template<typename _Tp>
    class enable_shared_from_this
    {
    protected:
    public:
    private:
 ;
      template<typename, _Lock_policy>
 friend class __shared_ptr;
      mutable weak_ptr<_Tp> _M_weak_this;
    };
  /**
   *  @brief  Create an object that is owned by a shared_ptr.
   *  @param  __a     An allocator.
   *  @param  __args  Arguments for the @a _Tp object's constructor.    *  @return A shared_ptr that owns the newly created object.    *  @throw  An exception thrown from @a _Alloc::allocate or from the    *          constructor of @a _Tp.    *    *  A copy of @a __a will be used to allocate memory for the shared_ptr    *  and the new object.    */       ;        ;   template<typename _Tp>     struct hash<shared_ptr<_Tp>>     : public __hash_base<size_t, shared_ptr<_Tp>>     {            }; }  namespace std __attribute__ ((__visibility__ ("default"))) {   typedef enum memory_order     {       memory_order_relaxed,       memory_order_consume,       memory_order_acquire,       memory_order_release,       memory_order_acq_rel,       memory_order_seq_cst     } memory_order;   enum __memory_order_modifier     {       __memory_order_mask = 0x0ffff,       __memory_order_modifier_mask = 0xffff0000,       __memory_order_hle_acquire = 0x10000,       __memory_order_hle_release = 0x20000     };                            ;   template<typename _IntTp>     struct __atomic_base;   template<typename _Tp>     struct atomic;   template<typename _Tp>     struct atomic<_Tp*>;     typedef bool __atomic_flag_data_type;   extern "C" {   struct __atomic_flag_base   {     __atomic_flag_data_type _M_i;   };   }   struct atomic_flag : public __atomic_flag_base   {                                                      private:        };   template<typename _ITp>     struct __atomic_base     {       using value_type = _ITp;       using difference_type = value_type;     private:       typedef _ITp __int_type;       static constexpr int _S_alignment =  sizeof(_ITp) > alignof(_ITp) ? sizeof(_ITp) : alignof(_ITp);       alignas(_S_alignment) __int_type _M_i;     public:                                                                                                                                                                                                                                                                                                                                                                                                                      };   template<typename _PTp>     struct __atomic_base<_PTp*>     {     private:       typedef _PTp* __pointer_type;       __pointer_type _M_p;                   public:                                                                                                                                                                                                                                                                             }; }  namespace std __attribute__ ((__visibility__ ("default"))) {   struct _Sp_locker   {                            private:     unsigned char _M_key1;     unsigned char _M_key2;   };        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ; }  namespace std __attribute__ ((__visibility__ ("default"))) {   template<typename _Tp1>     struct auto_ptr_ref     {       _Tp1* _M_ptr;            } __attribute__ ((__deprecated__)); 
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
  template<typename _Tp>     class auto_ptr     {     private:       _Tp* _M_ptr;     public:       typedef _Tp element_type;                       ;                       ;                                                                        ;                ;     } __attribute__ ((__deprecated__));   template<>     class auto_ptr<void>     {     public:       typedef void element_type;     } __attribute__ ((__deprecated__));             
#pragma GCC diagnostic pop
}  namespace std __attribute__ ((__visibility__ ("default"))) {   enum class pointer_safety { relaxed, preferred, strict };    ;       }  template <typename T> class octave_int; typedef octave_int<int8_t> octave_int8; typedef octave_int<int16_t> octave_int16; typedef octave_int<int32_t> octave_int32; typedef octave_int<int64_t> octave_int64; typedef octave_int<uint8_t> octave_uint8; typedef octave_int<uint16_t> octave_uint16; typedef octave_int<uint32_t> octave_uint32; typedef octave_int<uint64_t> octave_uint64; template <typename T> class Array; template <typename T> class Sparse; class Range; class idx_vector { public:   enum idx_class_type   {     class_invalid = -1,     class_colon = 0,     class_range,     class_scalar,     class_vector,     class_mask   };   template <typename T, typename D> friend class std::unique_ptr; private:   class idx_base_rep   {   public:                                                                                octave::refcount<int> count;     bool err;   };   class idx_colon_rep : public idx_base_rep   {   public:                                                                    };   enum direct { DIRECT };   class idx_range_rep : public idx_base_rep   {   public:                                                                                                       private:     octave_idx_type start, len, step;   };   class idx_scalar_rep : public idx_base_rep   {   public:                              ;                                                                    private:     octave_idx_type data;   };   class idx_vector_rep : public idx_base_rep   {   public:                         ;                                                                                             private:     const octave_idx_type *data;     octave_idx_type len;     octave_idx_type ext;     Array<octave_idx_type> *aowner;     dim_vector orig_dims;   };   class idx_mask_rep : public idx_base_rep   {   public:                                                                                                       private:     const bool *data;     octave_idx_type len;     octave_idx_type ext;     mutable octave_idx_type lsti;     mutable octave_idx_type lste;     Array<bool> *aowner;     dim_vector orig_dims;   };             public:                        static const idx_vector colon;        ;                ;                                                                                       ;      ;      ;      ;      ;                                                          private:   idx_base_rep *rep; }; extern "C" { ; ; ; ; typedef void (*liboctave_error_handler) (const char *, ...); typedef void (*liboctave_error_with_id_handler) (const char *, const char *,                                                  ...); typedef void (*liboctave_warning_handler) (const char *, ...); typedef void (*liboctave_warning_with_id_handler) (const char *, const char *,                                                    ...); __attribute__ ((__format__(printf, 1, 2))) __attribute__ ((__noreturn__)) extern liboctave_error_handler   current_liboctave_error_handler; __attribute__ ((__format__(printf, 2, 3))) __attribute__ ((__noreturn__)) extern liboctave_error_with_id_handler   current_liboctave_error_with_id_handler; __attribute__ ((__format__(printf, 1, 2)))            extern liboctave_warning_handler current_liboctave_warning_handler; __attribute__ ((__format__(printf, 2, 3)))            extern liboctave_warning_with_id_handler   current_liboctave_warning_with_id_handler;            ;            ;            ;            ; } template <bool cond, typename T1, typename T2> class if_then_else; template <typename T1, typename T2> class if_then_else<true, T1, T2> { public:   typedef T1 result; }; template <typename T1, typename T2> class if_then_else<false, T1, T2> { public:   typedef T2 result; }; template <typename T1, typename T2> class equal_types { public:   static const bool value = false; }; template <typename T> class equal_types <T, T> { public:   static const bool value = true; }; template <template <typename> class Template, typename T> class is_instance { public:   static const bool value = false; }; template <template <typename> class Template, typename T> class is_instance <Template, Template<T>> { public:   static const bool value = true; }; template <typename T1> class is_class_type { private:   typedef char one;   typedef struct { char c[2]; } two;   template <typename T2> static one is_class_type_test (int T2::*);   template <typename T2> static two is_class_type_test (...); public:   enum { yes = sizeof (is_class_type_test<T1> (0)) == 1 };   enum { no = ! yes }; }; template <typename T> class ref_param { public:   typedef typename if_then_else<is_class_type<T>::no, T, T const&>::result type; }; template <template <typename> class TemplatedClass, typename T> class strip_template_param { public:   typedef T type; }; template <template <typename> class TemplatedClass, typename T> class strip_template_param<TemplatedClass, TemplatedClass<T>> { public:   typedef T type; }; template <template <typename> class TemplatedClass, typename T, typename S> class subst_template_param { public:   typedef S type; }; template <template <typename> class TemplatedClass, typename T, typename S> class subst_template_param<TemplatedClass, TemplatedClass<T>, S> { public:   typedef TemplatedClass<S> type; }; extern "C" {            ;            ;            ; } extern "C" { typedef float float_t; typedef double double_t; enum   {     FP_INT_UPWARD =       0,     FP_INT_DOWNWARD =       1,     FP_INT_TOWARDZERO =       2,     FP_INT_TONEARESTFROMZERO =       3,     FP_INT_TONEAREST =       4,   }; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ;  ; ;  ; ; ; ; ; ; ; ; ; ;  ; ; ; ; ; ; ; ;  ; ; ; ; ; ;  ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ;  ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ;  ; ;  ; ; ; ; ; ; ; ; ; ;  ; ; ; ; ; ; ; ;  ; ; ; ; ; ;  ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ;  ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ;  ; ;  ; ; ; ; ; ; ; ; ; ;  ; ; ; ; ; ; ; ;  ; ; ; ; ; ;  ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ;  ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ;  ; ;  ; ; ; ; ; ; ; ; ; ;  ; ; ; ; ; ; ; ;  ; ; ; ; ; ;  ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ;  ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ;  ; ;  ; ; ; ; ; ; ; ; ; ;  ; ; ; ; ; ; ; ;  ; ; ; ; ; ;  ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ;  ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ;  ; ;  ; ; ; ; ; ; ; ; ; ;  ; ; ; ; ; ; ; ;  ; ; ; ; ; ;  ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ;  ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ;  ; ;  ; ; ; ; ; ; ; ; ; ;  ; ; ; ; ; ; ; ;  ; ; ; ; ; ;  ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ;  ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; extern int signgam; enum   {     FP_NAN =       0,     FP_INFINITE =       1,     FP_ZERO =       2,     FP_SUBNORMAL =       3,     FP_NORMAL =       4   }; ; extern "C++" {   ;   ;   ; } extern "C++" {   ;   ;   ; }  extern "C++" {  ; }  extern "C++" { template<typename> struct __iseqsig_type; template<> struct __iseqsig_type<float> {    }; template<> struct __iseqsig_type<double> {    }; template<> struct __iseqsig_type<long double> {    };  ; }  } extern "C++" { namespace std __attribute__ ((__visibility__ ("default"))) {                   ;                   ;                   ;                   ;                   ;                   ;                   ;                   ;                   ;                   ;                   ;                   ;                   ;                   ;                   ;                              ;                   ;                   ;                   ;                   ;                   ;                 ;                 ;                 ;                 ;                 ;                 ;                 ;                 ;                 ;                 ;                 ;                 ;   using ::double_t;   using ::float_t;                                                                                                                                                                                                                                                                                                                                         ;              ;              ;              ;              ;              ;              ;              ;              ;              ;              ;              ;              ;              ;              ;              ;              ;              ;              ;              ;              ;              ;              ;              ;              ;              ;              ;                ;              ;              ;              ;              ;              ;              ; }  }  namespace std __attribute__ ((__visibility__ ("default"))) {   class locale   {   public:     typedef int category;     class facet;     class id;     class _Impl;     friend class facet;     friend class _Impl;     ;     ;     template<typename _Cache>       friend struct __use_cache;     static const category none = 0;     static const category ctype = 1L << 0;     static const category numeric = 1L << 1;     static const category collate = 1L << 2;     static const category time = 1L << 3;     static const category monetary = 1L << 4;     static const category messages = 1L << 5;     static const category all = (ctype | numeric | collate |         time | monetary | messages);                                        ;               ;                    ;             private:     _Impl* _M_impl;     static _Impl* _S_classic;     static _Impl* _S_global;     static const char* const* const _S_categories;     enum { _S_categories_size = 6 + 6 };     static __gthread_once_t _S_once;                              static const id* const _S_twinned_facets[];   };   class locale::facet   {   private:     friend class locale;     friend class locale::_Impl;     mutable _Atomic_word _M_refcount;     static __c_locale _S_c_locale;     static const char _S_c_name[2];     static __gthread_once_t _S_once;        protected:                                                     private:                       protected:     class __shim;    };   class locale::id   {   private:     friend class locale;     friend class locale::_Impl;     ;     ;     mutable size_t _M_index;     static _Atomic_word _S_refcount;               public:     id() ;        };   class locale::_Impl   {   public:     friend class locale;     friend class locale::facet;     ;     ;     template<typename _Cache>       friend struct __use_cache;   private:     _Atomic_word _M_refcount;     const facet** _M_facets;     size_t _M_facets_size;     const facet** _M_caches;     char** _M_names;     static const locale::id* const _S_id_ctype[];     static const locale::id* const _S_id_numeric[];     static const locale::id* const _S_id_collate[];     static const locale::id* const _S_id_time[];     static const locale::id* const _S_id_monetary[];     static const locale::id* const _S_id_messages[];     static const locale::id* const* const _S_facet_categories[];                                                                              ;            ;                  };   template<typename _CharT>     class __cxx11:: collate : public locale::facet     {     public:       typedef _CharT char_type;       typedef basic_string<_CharT> string_type;     protected:       __c_locale _M_c_locale_collate;     public:       static locale::id id;                                                    protected:                                 };   template<typename _CharT>     locale::id collate<_CharT>::id;               template<typename _CharT>     class __cxx11:: collate_byname : public collate<_CharT>     {     public:       typedef _CharT char_type;       typedef basic_string<_CharT> string_type;                   protected:            }; }  namespace std __attribute__ ((__visibility__ ("default"))) {                 ;        ;                  extern template class collate<char>;   extern template class collate_byname<char>;;;   extern template class collate<wchar_t>;   extern template class collate_byname<wchar_t>;;; }  namespace std __attribute__ ((__visibility__ ("default"))) {   enum class errc     {       address_family_not_supported = 97,       address_in_use = 98,       address_not_available = 99,       already_connected = 106,       argument_list_too_long = 7,       argument_out_of_domain = 33,       bad_address = 14,       bad_file_descriptor = 9,       bad_message = 74,       broken_pipe = 32,       connection_aborted = 103,       connection_already_in_progress = 114,       connection_refused = 111,       connection_reset = 104,       cross_device_link = 18,       destination_address_required = 89,       device_or_resource_busy = 16,       directory_not_empty = 39,       executable_format_error = 8,       file_exists = 17,       file_too_large = 27,       filename_too_long = 36,       function_not_supported = 38,       host_unreachable = 113,       identifier_removed = 43,       illegal_byte_sequence = 84,       inappropriate_io_control_operation = 25,       interrupted = 4,       invalid_argument = 22,       invalid_seek = 29,       io_error = 5,       is_a_directory = 21,       message_size = 90,       network_down = 100,       network_reset = 102,       network_unreachable = 101,       no_buffer_space = 105,       no_child_process = 10,       no_link = 67,       no_lock_available = 37,       no_message_available = 61,       no_message = 42,       no_protocol_option = 92,       no_space_on_device = 28,       no_stream_resources = 63,       no_such_device_or_address = 6,       no_such_device = 19,       no_such_file_or_directory = 2,       no_such_process = 3,       not_a_directory = 20,       not_a_socket = 88,       not_a_stream = 60,       not_connected = 107,       not_enough_memory = 12,       not_supported = 95,       operation_canceled = 125,       operation_in_progress = 115,       operation_not_permitted = 1,       operation_not_supported = 95,       operation_would_block = 11,       owner_dead = 130,       permission_denied = 13,       protocol_error = 71,       protocol_not_supported = 93,       read_only_file_system = 30,       resource_deadlock_would_occur = 35,       resource_unavailable_try_again = 11,       result_out_of_range = 34,       state_not_recoverable = 131,       stream_timeout = 62,       text_file_busy = 26,       timed_out = 110,       too_many_files_open_in_system = 23,       too_many_files_open = 24,       too_many_links = 31,       too_many_symbolic_link_levels = 40,       value_too_large = 75,       wrong_protocol_type = 91     }; }  namespace std __attribute__ ((__visibility__ ("default"))) {   class error_code;   class error_condition;   class system_error;   template<typename _Tp>     struct is_error_code_enum : public false_type { };   template<typename _Tp>     struct is_error_condition_enum : public false_type { };   template<>     struct is_error_condition_enum<errc>     : public true_type { };   inline namespace _V2 {   class error_category   {   public:                            private:        public:        public:                                 };         }       template<typename _Tp>     struct hash;   struct error_code   {                      ;                      ;                            private:     friend class hash<error_code>;     int _M_value;     const error_category* _M_cat;   };                ;      struct error_condition   {                      ;                 ;                            private:     int _M_value;     const error_category* _M_cat;   };                                           class system_error : public std::runtime_error   {   private:     error_code _M_code;   public:                                                     }; }  namespace std __attribute__ ((__visibility__ ("default"))) {   template<>     struct hash<error_code>     : public __hash_base<size_t, error_code>     {            }; }  namespace std __attribute__ ((__visibility__ ("default"))) {   enum _Ios_Fmtflags     {       _S_boolalpha = 1L << 0,       _S_dec = 1L << 1,       _S_fixed = 1L << 2,       _S_hex = 1L << 3,       _S_internal = 1L << 4,       _S_left = 1L << 5,       _S_oct = 1L << 6,       _S_right = 1L << 7,       _S_scientific = 1L << 8,       _S_showbase = 1L << 9,       _S_showpoint = 1L << 10,       _S_showpos = 1L << 11,       _S_skipws = 1L << 12,       _S_unitbuf = 1L << 13,       _S_uppercase = 1L << 14,       _S_adjustfield = _S_left | _S_right | _S_internal,       _S_basefield = _S_dec | _S_oct | _S_hex,       _S_floatfield = _S_scientific | _S_fixed,       _S_ios_fmtflags_end = 1L << 16,       _S_ios_fmtflags_max = 2147483647,       _S_ios_fmtflags_min = ~2147483647     };                               enum _Ios_Openmode     {       _S_app = 1L << 0,       _S_ate = 1L << 1,       _S_bin = 1L << 2,       _S_in = 1L << 3,       _S_out = 1L << 4,       _S_trunc = 1L << 5,       _S_ios_openmode_end = 1L << 16,       _S_ios_openmode_max = 2147483647,       _S_ios_openmode_min = ~2147483647     };        constexpr _Ios_Openmode   operator|(_Ios_Openmode __a, _Ios_Openmode __b)   ;                       enum _Ios_Iostate     {       _S_goodbit = 0,       _S_badbit = 1L << 0,       _S_eofbit = 1L << 1,       _S_failbit = 1L << 2,       _S_ios_iostate_end = 1L << 16,       _S_ios_iostate_max = 2147483647,       _S_ios_iostate_min = ~2147483647     };                               enum _Ios_Seekdir     {       _S_beg = 0,       _S_cur = 1,       _S_end = 2,       _S_ios_seekdir_end = 1L << 16     };   enum class io_errc { stream = 1 };   template <> struct is_error_code_enum<io_errc> : public true_type { };              class ios_base   {   public:     class __attribute ((__abi_tag__ ("cxx11"))) failure : public system_error     {     public:                                        };     typedef _Ios_Fmtflags fmtflags;     static const fmtflags boolalpha = _S_boolalpha;     static const fmtflags dec = _S_dec;     static const fmtflags fixed = _S_fixed;     static const fmtflags hex = _S_hex;     static const fmtflags internal = _S_internal;     static const fmtflags left = _S_left;     static const fmtflags oct = _S_oct;     static const fmtflags right = _S_right;     static const fmtflags scientific = _S_scientific;     static const fmtflags showbase = _S_showbase;     static const fmtflags showpoint = _S_showpoint;     static const fmtflags showpos = _S_showpos;     static const fmtflags skipws = _S_skipws;     static const fmtflags unitbuf = _S_unitbuf;     static const fmtflags uppercase = _S_uppercase;     static const fmtflags adjustfield = _S_adjustfield;     static const fmtflags basefield = _S_basefield;     static const fmtflags floatfield = _S_floatfield;     typedef _Ios_Iostate iostate;     static const iostate badbit = _S_badbit;     static const iostate eofbit = _S_eofbit;     static const iostate failbit = _S_failbit;     static const iostate goodbit = _S_goodbit;     typedef _Ios_Openmode openmode;     static const openmode app = _S_app;     static const openmode ate = _S_ate;     static const openmode binary = _S_bin;     static const openmode in = _S_in;     static const openmode out = _S_out;     static const openmode trunc = _S_trunc;     typedef _Ios_Seekdir seekdir;     static const seekdir beg = _S_beg;     static const seekdir cur = _S_cur;     static const seekdir end = _S_end;     typedef int io_state;     typedef int open_mode;     typedef int seek_dir;     typedef std::streampos streampos;     typedef std::streamoff streamoff;     enum event     {       erase_event,       imbue_event,       copyfmt_event     };     typedef void (*event_callback) (event __e, ios_base& __b, int __i);        protected:     streamsize _M_precision;     streamsize _M_width;     fmtflags _M_flags;     iostate _M_exception;     iostate _M_streambuf_state;     struct _Callback_list     {       _Callback_list* _M_next;       ios_base::event_callback _M_fn;       int _M_index;       _Atomic_word _M_refcount;                           };      _Callback_list* _M_callbacks;               struct _Words     {       void* _M_pword;       long _M_iword;            };     _Words _M_word_zero;     enum { _S_local_word_size = 8 };     _Words _M_local_word[_S_local_word_size];     int _M_word_size;     _Words* _M_word;          locale _M_ios_locale;        public:     class Init     {       friend class ios_base;     public:                                 private:       static _Atomic_word _S_refcount;       static bool _S_synced_with_stdio;     };                                                                                        protected:        public:             protected:             };                                                                                        ios_base&   scientific(ios_base& __base)   ;    ios_base&   hexfloat(ios_base& __base)   ;    ios_base&   defaultfloat(ios_base& __base)   ; }  namespace std __attribute__ ((__visibility__ ("default"))) {   template<typename _CharT, typename _Traits>     streamsize     __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>*,      basic_streambuf<_CharT, _Traits>*, bool&);   template<typename _CharT, typename _Traits>     class basic_streambuf     {     public:       typedef _CharT char_type;       typedef _Traits traits_type;       typedef typename traits_type::int_type int_type;       typedef typename traits_type::pos_type pos_type;       typedef typename traits_type::off_type off_type;       typedef basic_streambuf<char_type, traits_type> __streambuf_type;       friend class basic_ios<char_type, traits_type>;       friend class basic_istream<char_type, traits_type>;       friend class basic_ostream<char_type, traits_type>;       friend class istreambuf_iterator<char_type, traits_type>;       friend class ostreambuf_iterator<char_type, traits_type>;       friend streamsize       __copy_streambufs_eof<>(basic_streambuf*, basic_streambuf*, bool&);       ;       ;       ;       template<typename _CharT2, typename _Traits2>         friend basic_istream<_CharT2, _Traits2>&         operator>>(basic_istream<_CharT2, _Traits2>&, _CharT2*);       template<typename _CharT2, typename _Traits2, typename _Alloc>         friend basic_istream<_CharT2, _Traits2>&         operator>>(basic_istream<_CharT2, _Traits2>&,      basic_string<_CharT2, _Traits2, _Alloc>&);       template<typename _CharT2, typename _Traits2, typename _Alloc>         friend basic_istream<_CharT2, _Traits2>&         getline(basic_istream<_CharT2, _Traits2>&,   basic_string<_CharT2, _Traits2, _Alloc>&, _CharT2);     protected:       char_type* _M_in_beg;        char_type* _M_in_cur;        char_type* _M_in_end;        char_type* _M_out_beg;        char_type* _M_out_cur;        char_type* _M_out_end;        locale _M_buf_locale;   public:       virtual       ~basic_streambuf()       ;                                                                                                              protected:                                                                                                                                                                      public:       [[__deprecated__("stossc is deprecated, use sbumpc instead")]]       void       stossc()       {  if (this->gptr() < this->egptr())    this->gbump(1);  else    this->uflow();       }       void       __safe_gbump(streamsize __n) { _M_in_cur += __n; }       void       __safe_pbump(streamsize __n) { _M_out_cur += __n; }     protected:       basic_streambuf(const basic_streambuf&);                   };         template<>     streamsize     __copy_streambufs_eof(basic_streambuf<char>* __sbin,      basic_streambuf<char>* __sbout, bool& __ineof);   template<>     streamsize     __copy_streambufs_eof(basic_streambuf<wchar_t>* __sbin,      basic_streambuf<wchar_t>* __sbout, bool& __ineof); }  namespace std __attribute__ ((__visibility__ ("default"))) {         template<typename _CharT, typename _Traits>     streamsize     __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>* __sbin,      basic_streambuf<_CharT, _Traits>* __sbout,      bool& __ineof)     ;        ;   extern template class basic_streambuf<char>;;   extern template     streamsize     __copy_streambufs_eof(basic_streambuf<char>*,      basic_streambuf<char>*, bool&);   extern template class basic_streambuf<wchar_t>;;   extern template     streamsize     __copy_streambufs_eof(basic_streambuf<wchar_t>*,      basic_streambuf<wchar_t>*, bool&); }  typedef unsigned long int wctype_t; enum {   __ISwupper = 0,    __ISwlower = 1,    __ISwalpha = 2,    __ISwdigit = 3,    __ISwxdigit = 4,    __ISwspace = 5,    __ISwprint = 6,    __ISwgraph = 7,    __ISwblank = 8,    __ISwcntrl = 9,    __ISwpunct = 10,    __ISwalnum = 11,    _ISwupper = ((__ISwupper) < 8 ? (int) ((1UL << (__ISwupper)) << 24) : ((__ISwupper) < 16 ? (int) ((1UL << (__ISwupper)) << 8) : ((__ISwupper) < 24 ? (int) ((1UL << (__ISwupper)) >> 8) : (int) ((1UL << (__ISwupper)) >> 24)))),    _ISwlower = ((__ISwlower) < 8 ? (int) ((1UL << (__ISwlower)) << 24) : ((__ISwlower) < 16 ? (int) ((1UL << (__ISwlower)) << 8) : ((__ISwlower) < 24 ? (int) ((1UL << (__ISwlower)) >> 8) : (int) ((1UL << (__ISwlower)) >> 24)))),    _ISwalpha = ((__ISwalpha) < 8 ? (int) ((1UL << (__ISwalpha)) << 24) : ((__ISwalpha) < 16 ? (int) ((1UL << (__ISwalpha)) << 8) : ((__ISwalpha) < 24 ? (int) ((1UL << (__ISwalpha)) >> 8) : (int) ((1UL << (__ISwalpha)) >> 24)))),    _ISwdigit = ((__ISwdigit) < 8 ? (int) ((1UL << (__ISwdigit)) << 24) : ((__ISwdigit) < 16 ? (int) ((1UL << (__ISwdigit)) << 8) : ((__ISwdigit) < 24 ? (int) ((1UL << (__ISwdigit)) >> 8) : (int) ((1UL << (__ISwdigit)) >> 24)))),    _ISwxdigit = ((__ISwxdigit) < 8 ? (int) ((1UL << (__ISwxdigit)) << 24) : ((__ISwxdigit) < 16 ? (int) ((1UL << (__ISwxdigit)) << 8) : ((__ISwxdigit) < 24 ? (int) ((1UL << (__ISwxdigit)) >> 8) : (int) ((1UL << (__ISwxdigit)) >> 24)))),    _ISwspace = ((__ISwspace) < 8 ? (int) ((1UL << (__ISwspace)) << 24) : ((__ISwspace) < 16 ? (int) ((1UL << (__ISwspace)) << 8) : ((__ISwspace) < 24 ? (int) ((1UL << (__ISwspace)) >> 8) : (int) ((1UL << (__ISwspace)) >> 24)))),    _ISwprint = ((__ISwprint) < 8 ? (int) ((1UL << (__ISwprint)) << 24) : ((__ISwprint) < 16 ? (int) ((1UL << (__ISwprint)) << 8) : ((__ISwprint) < 24 ? (int) ((1UL << (__ISwprint)) >> 8) : (int) ((1UL << (__ISwprint)) >> 24)))),    _ISwgraph = ((__ISwgraph) < 8 ? (int) ((1UL << (__ISwgraph)) << 24) : ((__ISwgraph) < 16 ? (int) ((1UL << (__ISwgraph)) << 8) : ((__ISwgraph) < 24 ? (int) ((1UL << (__ISwgraph)) >> 8) : (int) ((1UL << (__ISwgraph)) >> 24)))),    _ISwblank = ((__ISwblank) < 8 ? (int) ((1UL << (__ISwblank)) << 24) : ((__ISwblank) < 16 ? (int) ((1UL << (__ISwblank)) << 8) : ((__ISwblank) < 24 ? (int) ((1UL << (__ISwblank)) >> 8) : (int) ((1UL << (__ISwblank)) >> 24)))),    _ISwcntrl = ((__ISwcntrl) < 8 ? (int) ((1UL << (__ISwcntrl)) << 24) : ((__ISwcntrl) < 16 ? (int) ((1UL << (__ISwcntrl)) << 8) : ((__ISwcntrl) < 24 ? (int) ((1UL << (__ISwcntrl)) >> 8) : (int) ((1UL << (__ISwcntrl)) >> 24)))),    _ISwpunct = ((__ISwpunct) < 8 ? (int) ((1UL << (__ISwpunct)) << 24) : ((__ISwpunct) < 16 ? (int) ((1UL << (__ISwpunct)) << 8) : ((__ISwpunct) < 24 ? (int) ((1UL << (__ISwpunct)) >> 8) : (int) ((1UL << (__ISwpunct)) >> 24)))),    _ISwalnum = ((__ISwalnum) < 8 ? (int) ((1UL << (__ISwalnum)) << 24) : ((__ISwalnum) < 16 ? (int) ((1UL << (__ISwalnum)) << 8) : ((__ISwalnum) < 24 ? (int) ((1UL << (__ISwalnum)) >> 8) : (int) ((1UL << (__ISwalnum)) >> 24))))  }; extern "C" { ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; } extern "C" { typedef const __int32_t *wctrans_t; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; } namespace std {   using ::wctrans_t;   using ::wctype_t;   using ::wint_t;                                                       }  namespace std __attribute__ ((__visibility__ ("default"))) {   struct ctype_base   {     typedef const int* __to_type;     typedef unsigned short mask;     static const mask upper = _ISupper;     static const mask lower = _ISlower;     static const mask alpha = _ISalpha;     static const mask digit = _ISdigit;     static const mask xdigit = _ISxdigit;     static const mask space = _ISspace;     static const mask print = _ISprint;     static const mask graph = _ISalpha | _ISdigit | _ISpunct;     static const mask cntrl = _IScntrl;     static const mask punct = _ISpunct;     static const mask alnum = _ISalpha | _ISdigit;     static const mask blank = _ISblank;   }; }  /** @file bits/streambuf_iterator.h  *  This is an internal header file, included by other library headers.  *  Do not attempt to use it directly. @headername{iterator}  */namespace std __attribute__ ((__visibility__ ("default"))) {   /**    * @addtogroup iterators    * @{    */  template<typename _CharT, typename _Traits>     class istreambuf_iterator     : public iterator<input_iterator_tag, _CharT, typename _Traits::off_type,         _CharT*,         _CharT>     {     public:       typedef _CharT char_type;       typedef _Traits traits_type;       typedef typename _Traits::int_type int_type;       typedef basic_streambuf<_CharT, _Traits> streambuf_type;       typedef basic_istream<_CharT, _Traits> istream_type;       ;       ;       ;       ;     private:       mutable streambuf_type* _M_sbuf;       int_type _M_c;     public:                                                                           private:                          };        ;        ;   template<typename _CharT, typename _Traits>     class ostreambuf_iterator     : public iterator<output_iterator_tag, void, void, void, void>     {     public:       typedef _CharT char_type;       typedef _Traits traits_type;       typedef basic_streambuf<_CharT, _Traits> streambuf_type;       typedef basic_ostream<_CharT, _Traits> ostream_type;       ;     private:       streambuf_type* _M_sbuf;       bool _M_failed;     public:                                                             };        ;        ;        ;        ;        ;        ; }  namespace std __attribute__ ((__visibility__ ("default"))) {   ;            template<typename _CharT, typename _Traits>     struct __pad     {            };   ;        ;        ;   /**    *  @brief  Common base for ctype facet    *    *  This template class provides implementations of the public functions    *  that forward to the protected virtual functions.    *    *  This template also provides abstract stubs for the protected virtual    *  functions.   */  template<typename _CharT>     class __ctype_abstract_base : public locale::facet, public ctype_base     {     public:       typedef _CharT char_type;       /**        *  @brief  Test char_type classification.        *        *  This function finds a mask M for @a __c and compares it to        *  mask @a __m.  It does so by returning the value of        *  ctype<char_type>::do_is().        *        *  @param __c  The char_type to compare the mask of.        *  @param __m  The mask to compare against.        *  @return  (M & __m) != 0.       */             /**        *  @brief  Return a mask array.        *        *  This function finds the mask for each char_type in the range [lo,hi)        *  and successively writes it to vec.  vec must have as many elements        *  as the char array.  It does so by returning the value of        *  ctype<char_type>::do_is().        *        *  @param __lo  Pointer to start of range.        *  @param __hi  Pointer to end of range.        *  @param __vec  Pointer to an array of mask storage.        *  @return  @a __hi.       */             /**        *  @brief  Find char_type matching a mask        *        *  This function searches for and returns the first char_type c in        *  [lo,hi) for which is(m,c) is true.  It does so by returning        *  ctype<char_type>::do_scan_is().        *        *  @param __m  The mask to compare against.        *  @param __lo  Pointer to start of range.        *  @param __hi  Pointer to end of range.        *  @return  Pointer to matching char_type if found, else @a __hi.       */             /**        *  @brief  Find char_type not matching a mask        *        *  This function searches for and returns the first char_type c in        *  [lo,hi) for which is(m,c) is false.  It does so by returning        *  ctype<char_type>::do_scan_not().        *        *  @param __m  The mask to compare against.        *  @param __lo  Pointer to first char in range.        *  @param __hi  Pointer to end of range.        *  @return  Pointer to non-matching char if found, else @a __hi.       */             /**        *  @brief  Convert to uppercase.        *        *  This function converts the argument to uppercase if possible.        *  If not possible (for example, '2'), returns the argument.  It does        *  so by returning ctype<char_type>::do_toupper().        *        *  @param __c  The char_type to convert.        *  @return  The uppercase char_type if convertible, else @a __c.       */             /**        *  @brief  Convert array to uppercase.        *        *  This function converts each char_type in the range [lo,hi) to        *  uppercase if possible.  Other elements remain untouched.  It does so        *  by returning ctype<char_type>:: do_toupper(lo, hi).        *        *  @param __lo  Pointer to start of range.        *  @param __hi  Pointer to end of range.        *  @return  @a __hi.       */             /**        *  @brief  Convert to lowercase.        *        *  This function converts the argument to lowercase if possible.  If        *  not possible (for example, '2'), returns the argument.  It does so        *  by returning ctype<char_type>::do_tolower(c).        *        *  @param __c  The char_type to convert.        *  @return  The lowercase char_type if convertible, else @a __c.       */             /**        *  @brief  Convert array to lowercase.        *        *  This function converts each char_type in the range [__lo,__hi) to        *  lowercase if possible.  Other elements remain untouched.  It does so        *  by returning ctype<char_type>:: do_tolower(__lo, __hi).        *        *  @param __lo  Pointer to start of range.        *  @param __hi  Pointer to end of range.        *  @return  @a __hi.       */             /**        *  @brief  Widen char to char_type        *        *  This function converts the char argument to char_type using the        *  simplest reasonable transformation.  It does so by returning        *  ctype<char_type>::do_widen(c).        *        *  Note: this is not what you want for codepage conversions.  See        *  codecvt for that.        *        *  @param __c  The char to convert.        *  @return  The converted char_type.       */             /**        *  @brief  Widen array to char_type        *        *  This function converts each char in the input to char_type using the        *  simplest reasonable transformation.  It does so by returning        *  ctype<char_type>::do_widen(c).        *        *  Note: this is not what you want for codepage conversions.  See        *  codecvt for that.        *        *  @param __lo  Pointer to start of range.        *  @param __hi  Pointer to end of range.        *  @param __to  Pointer to the destination array.        *  @return  @a __hi.       */             /**        *  @brief  Narrow char_type to char        *        *  This function converts the char_type to char using the simplest        *  reasonable transformation.  If the conversion fails, dfault is        *  returned instead.  It does so by returning        *  ctype<char_type>::do_narrow(__c).        *        *  Note: this is not what you want for codepage conversions.  See        *  codecvt for that.        *        *  @param __c  The char_type to convert.        *  @param __dfault  Char to return if conversion fails.        *  @return  The converted char.       */             /**        *  @brief  Narrow array to char array        *        *  This function converts each char_type in the input to char using the        *  simplest reasonable transformation and writes the results to the        *  destination array.  For any char_type in the input that cannot be        *  converted, @a dfault is used instead.  It does so by returning        *  ctype<char_type>::do_narrow(__lo, __hi, __dfault, __to).        *        *  Note: this is not what you want for codepage conversions.  See        *  codecvt for that.        *        *  @param __lo  Pointer to start of range.        *  @param __hi  Pointer to end of range.        *  @param __dfault  Char to use if conversion fails.        *  @param __to  Pointer to the destination array.        *  @return  @a __hi.       */           protected:                     /**        *  @brief  Test char_type classification.        *        *  This function finds a mask M for @a c and compares it to mask @a m.        *        *  do_is() is a hook for a derived facet to change the behavior of        *  classifying.  do_is() must always return the same result for the        *  same input.        *        *  @param __c  The char_type to find the mask of.        *  @param __m  The mask to compare against.        *  @return  (M & __m) != 0.       */             /**        *  @brief  Return a mask array.        *        *  This function finds the mask for each char_type in the range [lo,hi)        *  and successively writes it to vec.  vec must have as many elements        *  as the input.        *        *  do_is() is a hook for a derived facet to change the behavior of        *  classifying.  do_is() must always return the same result for the        *  same input.        *        *  @param __lo  Pointer to start of range.        *  @param __hi  Pointer to end of range.        *  @param __vec  Pointer to an array of mask storage.        *  @return  @a __hi.       */             /**        *  @brief  Find char_type matching mask        *        *  This function searches for and returns the first char_type c in        *  [__lo,__hi) for which is(__m,c) is true.        *        *  do_scan_is() is a hook for a derived facet to change the behavior of        *  match searching.  do_is() must always return the same result for the        *  same input.        *        *  @param __m  The mask to compare against.        *  @param __lo  Pointer to start of range.        *  @param __hi  Pointer to end of range.        *  @return  Pointer to a matching char_type if found, else @a __hi.       */             /**        *  @brief  Find char_type not matching mask        *        *  This function searches for and returns a pointer to the first        *  char_type c of [lo,hi) for which is(m,c) is false.        *        *  do_scan_is() is a hook for a derived facet to change the behavior of        *  match searching.  do_is() must always return the same result for the        *  same input.        *        *  @param __m  The mask to compare against.        *  @param __lo  Pointer to start of range.        *  @param __hi  Pointer to end of range.        *  @return  Pointer to a non-matching char_type if found, else @a __hi.       */             /**        *  @brief  Convert to uppercase.        *        *  This virtual function converts the char_type argument to uppercase        *  if possible.  If not possible (for example, '2'), returns the        *  argument.        *        *  do_toupper() is a hook for a derived facet to change the behavior of        *  uppercasing.  do_toupper() must always return the same result for        *  the same input.        *        *  @param __c  The char_type to convert.        *  @return  The uppercase char_type if convertible, else @a __c.       */             /**        *  @brief  Convert array to uppercase.        *        *  This virtual function converts each char_type in the range [__lo,__hi)        *  to uppercase if possible.  Other elements remain untouched.        *        *  do_toupper() is a hook for a derived facet to change the behavior of        *  uppercasing.  do_toupper() must always return the same result for        *  the same input.        *        *  @param __lo  Pointer to start of range.        *  @param __hi  Pointer to end of range.        *  @return  @a __hi.       */             /**        *  @brief  Convert to lowercase.        *        *  This virtual function converts the argument to lowercase if        *  possible.  If not possible (for example, '2'), returns the argument.        *        *  do_tolower() is a hook for a derived facet to change the behavior of        *  lowercasing.  do_tolower() must always return the same result for        *  the same input.        *        *  @param __c  The char_type to convert.        *  @return  The lowercase char_type if convertible, else @a __c.       */             /**        *  @brief  Convert array to lowercase.        *        *  This virtual function converts each char_type in the range [__lo,__hi)        *  to lowercase if possible.  Other elements remain untouched.        *        *  do_tolower() is a hook for a derived facet to change the behavior of        *  lowercasing.  do_tolower() must always return the same result for        *  the same input.        *        *  @param __lo  Pointer to start of range.        *  @param __hi  Pointer to end of range.        *  @return  @a __hi.       */             /**        *  @brief  Widen char        *        *  This virtual function converts the char to char_type using the        *  simplest reasonable transformation.        *        *  do_widen() is a hook for a derived facet to change the behavior of        *  widening.  do_widen() must always return the same result for the        *  same input.        *        *  Note: this is not what you want for codepage conversions.  See        *  codecvt for that.        *        *  @param __c  The char to convert.        *  @return  The converted char_type       */             /**        *  @brief  Widen char array        *        *  This function converts each char in the input to char_type using the        *  simplest reasonable transformation.        *        *  do_widen() is a hook for a derived facet to change the behavior of        *  widening.  do_widen() must always return the same result for the        *  same input.        *        *  Note: this is not what you want for codepage conversions.  See        *  codecvt for that.        *        *  @param __lo  Pointer to start range.        *  @param __hi  Pointer to end of range.        *  @param __to  Pointer to the destination array.        *  @return  @a __hi.       */             /**        *  @brief  Narrow char_type to char        *        *  This virtual function converts the argument to char using the        *  simplest reasonable transformation.  If the conversion fails, dfault        *  is returned instead.        *        *  do_narrow() is a hook for a derived facet to change the behavior of        *  narrowing.  do_narrow() must always return the same result for the        *  same input.        *        *  Note: this is not what you want for codepage conversions.  See        *  codecvt for that.        *        *  @param __c  The char_type to convert.        *  @param __dfault  Char to return if conversion fails.        *  @return  The converted char.       */             /**        *  @brief  Narrow char_type array to char        *        *  This virtual function converts each char_type in the range        *  [__lo,__hi) to char using the simplest reasonable        *  transformation and writes the results to the destination        *  array.  For any element in the input that cannot be        *  converted, @a __dfault is used instead.        *        *  do_narrow() is a hook for a derived facet to change the behavior of        *  narrowing.  do_narrow() must always return the same result for the        *  same input.        *        *  Note: this is not what you want for codepage conversions.  See        *  codecvt for that.        *        *  @param __lo  Pointer to start of range.        *  @param __hi  Pointer to end of range.        *  @param __dfault  Char to use if conversion fails.        *  @param __to  Pointer to the destination array.        *  @return  @a __hi.       */           };   /**    *  @brief  Primary class template ctype facet.    *  @ingroup locales    *    *  This template class defines classification and conversion functions for    *  character sets.  It wraps cctype functionality.  Ctype gets used by    *  streams for many I/O operations.    *    *  This template provides the protected virtual functions the developer    *  will have to replace in a derived class or specialization to make a    *  working facet.  The public functions that access them are defined in    *  __ctype_abstract_base, to allow for implementation flexibility.  See    *  ctype<wchar_t> for an example.  The functions are documented in    *  __ctype_abstract_base.    *    *  Note: implementations are provided for all the protected virtual    *  functions, but will likely not be useful.   */  template<typename _CharT>     class ctype : public __ctype_abstract_base<_CharT>     {     public:       typedef _CharT char_type;       typedef typename __ctype_abstract_base<_CharT>::mask mask;       static locale::id id;           protected:                                                                                                };   template<typename _CharT>     locale::id ctype<_CharT>::id;   /**    *  @brief  The ctype<char> specialization.    *  @ingroup locales    *    *  This class defines classification and conversion functions for    *  the char type.  It gets used by char streams for many I/O    *  operations.  The char specialization provides a number of    *  optimizations as well.   */  template<>     class ctype<char> : public locale::facet, public ctype_base     {     public:       typedef char char_type;     protected:       __c_locale _M_c_locale_ctype;       bool _M_del;       __to_type _M_toupper;       __to_type _M_tolower;       const mask* _M_table;       mutable char _M_widen_ok;       mutable char _M_widen[1 + static_cast<unsigned char>(-1)];       mutable char _M_narrow[1 + static_cast<unsigned char>(-1)];       mutable char _M_narrow_ok;      public:       static locale::id id;       static const size_t table_size = 1 + static_cast<unsigned char>(-1);                                                                                                                     protected:                                                                    private:                   };   template<>     class ctype<wchar_t> : public __ctype_abstract_base<wchar_t>     {     public:       typedef wchar_t char_type;       typedef wctype_t __wmask_type;     protected:       __c_locale _M_c_locale_ctype;       bool _M_narrow_ok;       char _M_narrow[128];       wint_t _M_widen[1 + static_cast<unsigned char>(-1)];       mask _M_bit[16];       __wmask_type _M_wmask[16];     public:       static locale::id id;                   protected:                                                                                                              };   template<typename _CharT>     class ctype_byname : public ctype<_CharT>     {     public:       typedef typename ctype<_CharT>::mask mask;                   protected:            };   template<>     class ctype_byname<char> : public ctype<char>     {     public:                   protected:            };   template<>     class ctype_byname<wchar_t> : public ctype<wchar_t>     {     public:                   protected:            }; }  namespace std __attribute__ ((__visibility__ ("default"))) {             }  namespace std __attribute__ ((__visibility__ ("default"))) {   class __num_base   {   public:     enum       {  _S_ominus,  _S_oplus,  _S_ox,  _S_oX,  _S_odigits,  _S_odigits_end = _S_odigits + 16,  _S_oudigits = _S_odigits_end,  _S_oudigits_end = _S_oudigits + 16,  _S_oe = _S_odigits + 14,   _S_oE = _S_oudigits + 14,   _S_oend = _S_oudigits_end       };     static const char* _S_atoms_out;     static const char* _S_atoms_in;     enum     {       _S_iminus,       _S_iplus,       _S_ix,       _S_iX,       _S_izero,       _S_ie = _S_izero + 14,       _S_iE = _S_izero + 20,       _S_iend = 26     };        };   template<typename _CharT>     struct __numpunct_cache : public locale::facet     {       const char* _M_grouping;       size_t _M_grouping_size;       bool _M_use_grouping;       const _CharT* _M_truename;       size_t _M_truename_size;       const _CharT* _M_falsename;       size_t _M_falsename_size;       _CharT _M_decimal_point;       _CharT _M_thousands_sep;       _CharT _M_atoms_out[__num_base::_S_oend];       _CharT _M_atoms_in[__num_base::_S_iend];       bool _M_allocated;                          private:                   };    namespace __cxx11 {   /**    *  @brief  Primary class template numpunct.    *  @ingroup locales    *    *  This facet stores several pieces of information related to printing and    *  scanning numbers, such as the decimal point character.  It takes a    *  template parameter specifying the char type.  The numpunct facet is    *  used by streams for many I/O operations involving numbers.    *    *  The numpunct template uses protected virtual functions to provide the    *  actual results.  The public accessors forward the call to the virtual    *  functions.  These virtual functions are hooks for developers to    *  implement the behavior they require from a numpunct facet.   */  template<typename _CharT>     class numpunct : public locale::facet     {     public:       typedef _CharT char_type;       typedef basic_string<_CharT> string_type;       typedef __numpunct_cache<_CharT> __cache_type;     protected:       __cache_type* _M_data;     public:       static locale::id id;       /**        *  @brief  Numpunct constructor.        *        *  @param  __refs  Refcount to pass to the base class.        */             /**        *  @brief  Internal constructor.  Not for general use.        *        *  This is a constructor for use by the library itself to set up the        *  predefined locale facets.        *        *  @param  __cache  __numpunct_cache object.        *  @param  __refs  Refcount to pass to the base class.        */             /**        *  @brief  Internal constructor.  Not for general use.        *        *  This is a constructor for use by the library itself to set up new        *  locales.        *        *  @param  __cloc  The C locale.        *  @param  __refs  Refcount to pass to the base class.        */             /**        *  @brief  Return decimal point character.        *        *  This function returns a char_type to use as a decimal point.  It        *  does so by returning returning        *  numpunct<char_type>::do_decimal_point().        *        *  @return  @a char_type representing a decimal point.       */             /**        *  @brief  Return thousands separator character.        *        *  This function returns a char_type to use as a thousands        *  separator.  It does so by returning returning        *  numpunct<char_type>::do_thousands_sep().        *        *  @return  char_type representing a thousands separator.       */             /**        *  @brief  Return grouping specification.        *        *  This function returns a string representing groupings for the        *  integer part of a number.  Groupings indicate where thousands        *  separators should be inserted in the integer part of a number.        *        *  Each char in the return string is interpret as an integer        *  rather than a character.  These numbers represent the number        *  of digits in a group.  The first char in the string        *  represents the number of digits in the least significant        *  group.  If a char is negative, it indicates an unlimited        *  number of digits for the group.  If more chars from the        *  string are required to group a number, the last char is used        *  repeatedly.        *        *  For example, if the grouping() returns "\003\002" and is        *  applied to the number 123456789, this corresponds to        *  12,34,56,789.  Note that if the string was "32", this would        *  put more than 50 digits into the least significant group if        *  the character set is ASCII.        *        *  The string is returned by calling        *  numpunct<char_type>::do_grouping().        *        *  @return  string representing grouping specification.       */             /**        *  @brief  Return string representation of bool true.        *        *  This function returns a string_type containing the text        *  representation for true bool variables.  It does so by calling        *  numpunct<char_type>::do_truename().        *        *  @return  string_type representing printed form of true.       */             /**        *  @brief  Return string representation of bool false.        *        *  This function returns a string_type containing the text        *  representation for false bool variables.  It does so by calling        *  numpunct<char_type>::do_falsename().        *        *  @return  string_type representing printed form of false.       */           protected:              /**        *  @brief  Return decimal point character.        *        *  Returns a char_type to use as a decimal point.  This function is a        *  hook for derived classes to change the value returned.        *        *  @return  @a char_type representing a decimal point.       */             /**        *  @brief  Return thousands separator character.        *        *  Returns a char_type to use as a thousands separator.  This function        *  is a hook for derived classes to change the value returned.        *        *  @return  @a char_type representing a thousands separator.       */             /**        *  @brief  Return grouping specification.        *        *  Returns a string representing groupings for the integer part of a        *  number.  This function is a hook for derived classes to change the        *  value returned.  @see grouping() for details.        *        *  @return  String representing grouping specification.       */             /**        *  @brief  Return string representation of bool true.        *        *  Returns a string_type containing the text representation for true        *  bool variables.  This function is a hook for derived classes to        *  change the value returned.        *        *  @return  string_type representing printed form of true.       */             /**        *  @brief  Return string representation of bool false.        *        *  Returns a string_type containing the text representation for false        *  bool variables.  This function is a hook for derived classes to        *  change the value returned.        *        *  @return  string_type representing printed form of false.       */                  };   template<typename _CharT>     locale::id numpunct<_CharT>::id;               template<typename _CharT>     class numpunct_byname : public numpunct<_CharT>     {     public:       typedef _CharT char_type;       typedef basic_string<_CharT> string_type;                   protected:            }; }   /**    *  @brief  Primary class template num_get.    *  @ingroup locales    *    *  This facet encapsulates the code to parse and return a number    *  from a string.  It is used by the istream numeric extraction    *  operators.    *    *  The num_get template uses protected virtual functions to provide the    *  actual results.  The public accessors forward the call to the virtual    *  functions.  These virtual functions are hooks for developers to    *  implement the behavior they require from the num_get facet.   */  template<typename _CharT, typename _InIter>     class num_get : public locale::facet     {     public:       typedef _CharT char_type;       typedef _InIter iter_type;       static locale::id id;       /**        *  @brief  Constructor performs initialization.        *        *  This is the constructor provided by the standard.        *        *  @param __refs  Passed to the base facet class.       */             /**        *  @brief  Numeric parsing.        *        *  Parses the input stream into the bool @a v.  It does so by calling        *  num_get::do_get().        *        *  If ios_base::boolalpha is set, attempts to read        *  ctype<CharT>::truename() or ctype<CharT>::falsename().  Sets        *  @a v to true or false if successful.  Sets err to        *  ios_base::failbit if reading the string fails.  Sets err to        *  ios_base::eofbit if the stream is emptied.        *        *  If ios_base::boolalpha is not set, proceeds as with reading a long,        *  except if the value is 1, sets @a v to true, if the value is 0, sets        *  @a v to false, and otherwise set err to ios_base::failbit.        *        *  @param  __in  Start of input stream.        *  @param  __end  End of input stream.        *  @param  __io  Source of locale and flags.        *  @param  __err  Error flags to set.        *  @param  __v  Value to format and insert.        *  @return  Iterator after reading.       */             /**        *  @brief  Numeric parsing.        *        *  Parses the input stream into the integral variable @a v.  It does so        *  by calling num_get::do_get().        *        *  Parsing is affected by the flag settings in @a io.        *        *  The basic parse is affected by the value of io.flags() &        *  ios_base::basefield.  If equal to ios_base::oct, parses like the        *  scanf %o specifier.  Else if equal to ios_base::hex, parses like %X        *  specifier.  Else if basefield equal to 0, parses like the %i        *  specifier.  Otherwise, parses like %d for signed and %u for unsigned        *  types.  The matching type length modifier is also used.        *        *  Digit grouping is interpreted according to        *  numpunct::grouping() and numpunct::thousands_sep().  If the        *  pattern of digit groups isn't consistent, sets err to
       *  ios_base::failbit.
       *
       *  If parsing the string yields a valid value for @a v, @a v is set.
       *  Otherwise, sets err to ios_base::failbit and leaves @a v unaltered.
       *  Sets err to ios_base::eofbit if the stream is emptied.
       *
       *  @param  __in  Start of input stream.
       *  @param  __end  End of input stream.
       *  @param  __io  Source of locale and flags.
       *  @param  __err  Error flags to set.
       *  @param  __v  Value to format and insert.
       *  @return  Iterator after reading.
      */
    protected:
      ;
 ;
 ;
    };
  template<typename _CharT, typename _InIter>
    locale::id num_get<_CharT, _InIter>::id;
  template<typename _CharT, typename _OutIter>
    class num_put : public locale::facet
    {
    public:
      typedef _CharT char_type;
      typedef _OutIter iter_type;
      static locale::id id;
    protected:
      ;
      ;
    };
  template <typename _CharT, typename _OutIter>
    locale::id num_put<_CharT, _OutIter>::id;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
} 
/** @file bits/locale_facets.tcc
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{locale}
 */
namespace std __attribute__ ((__visibility__ ("default")))
{
  template<typename _Facet>
    struct __use_cache
    {
    };
  template<typename _CharT>
    struct __use_cache<__numpunct_cache<_CharT> >
    {
    };
    ;
    ;
  extern template class __cxx11:: numpunct<char>;
  extern template class __cxx11:: numpunct_byname<char>;
  extern template class num_get<char>;
  extern template class num_put<char>;
  extern template class ctype_byname<char>;;;;;;;;;
  extern template class __cxx11:: numpunct<wchar_t>;
  extern template class __cxx11:: numpunct_byname<wchar_t>;
  extern template class num_get<wchar_t>;
  extern template class num_put<wchar_t>;
  extern template class ctype_byname<wchar_t>;;;;;;;;;
} 
namespace std __attribute__ ((__visibility__ ("default")))
{
    ;
  template<typename _CharT, typename _Traits>
    class basic_ios : public ios_base
    {
    public:
      typedef _CharT char_type;
    };
} 
namespace std __attribute__ ((__visibility__ ("default")))
{
  extern template class basic_ios<char>;
  extern template class basic_ios<wchar_t>;
} 
/** @file include/ostream
 *  This is a Standard C++ Library header.
 */
namespace std __attribute__ ((__visibility__ ("default")))
{
  /**
   *  @brief  Template class basic_ostream.
   *  @ingroup io
   *
   *  @tparam _CharT  Type of character stream.
   *  @tparam _Traits  Traits for character type, defaults to
   *                   char_traits<_CharT>.
   *
   *  This is the base class for all output streams.  It provides text
   *  formatting of all builtin types, and communicates with any class
   *  derived from basic_streambuf to do the actual output.
  */
  template<typename _CharT, typename _Traits>
    class basic_ostream : virtual public basic_ios<_CharT, _Traits>
    {
    public:
      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
             __num_put_type;
      typedef ctype<_CharT> __ctype_type;
      /**
       *  @brief  Base constructor.
       *
       *  This ctor is almost never called by the user directly, rather from
       *  derived classes' initialization lists, which pass a pointer to        *  their own stream buffer.       */      explicit       basic_ostream(__streambuf_type* __sb)       ;       virtual       ~basic_ostream() ;       class sentry;       friend class sentry;       __ostream_type&       operator<<(__ostream_type& (*__pf)(__ostream_type&))       ;       __ostream_type&       operator<<(__ios_type& (*__pf)(__ios_type&))       ;       __ostream_type&       operator<<(ios_base& (*__pf) (ios_base&))       ;       __ostream_type&       operator<<(long __n)       ;       __ostream_type&       operator<<(unsigned long __n)       ;       __ostream_type&       operator<<(bool __n)       ;       __ostream_type&       operator<<(short __n);                                                                                                                             protected:                                                        ;     };   template <typename _CharT, typename _Traits>     class basic_ostream<_CharT, _Traits>::sentry     {       bool _M_ok;       basic_ostream<_CharT, _Traits>& _M_os;     public:        
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#pragma GCC diagnostic pop
 /**        *  @brief  Quick status checking.        *  @return  The sentry state.        *        *  For ease of use, sentries may be converted to booleans.  The        *  return value is that of the sentry state (true == okay).       */           };   /**    *  @brief  Character inserters    *  @param  __out  An output stream.    *  @param  __c  A character.    *  @return  out    *    *  Behaves like one of the formatted arithmetic inserters described in    *  std::basic_ostream.  After constructing a sentry object with good    *  status, this function inserts a single character and any required    *  padding (as determined by [22.2.2.2.2]).  @c __out.width(0) is then    *  called.    *    *  If @p __c is of type @c char and the character type of the stream is not    *  @c char, the character is widened before insertion.   */       ;        ;        ;        ;        ;   /**    *  @brief  String inserters    *  @param  __out  An output stream.    *  @param  __s  A character string.    *  @return  out    *  @pre  @p __s must be a non-NULL pointer    *    *  Behaves like one of the formatted arithmetic inserters described in    *  std::basic_ostream.  After constructing a sentry object with good    *  status, this function inserts @c traits::length(__s) characters starting    *  at @p __s, widened if necessary, followed by any required padding (as    *  determined by [22.2.2.2.2]).  @c __out.width(0) is then called.   */       ;   ;        ;        ;        ;   /**    *  @brief  Write a newline and flush the stream.    *    *  This manipulator is often mistakenly used when a simple newline is    *  desired, leading to poor buffering performance.  See    *  https:    *  for more on this subject.   */       ;   /**    *  @brief  Write a null character into the output sequence.    *    *  <em>Null character</em> is @c CharT() by definition.  For CharT    *  of @c char, this correctly writes the ASCII @c NUL character    *  string terminator.   */       ;   /**    *  @brief  Flushes the output stream.    *    *  This manipulator simply calls the stream's @c flush() member function.
  */
    ;
  ;
  template<typename _Tp, typename = void>
    struct __is_convertible_to_basic_ostream_impl
    {
      using __ostream_type = void;
    };
  template<typename _Tp>
    using __do_is_convertible_to_basic_ostream_impl =
    decltype(__is_convertible_to_basic_ostream_test
      (declval<typename remove_reference<_Tp>::type*>()));
  template<typename _Tp>
    struct __is_convertible_to_basic_ostream_impl
    <_Tp,
     __void_t<__do_is_convertible_to_basic_ostream_impl<_Tp>>>
    {
      using __ostream_type =
 __do_is_convertible_to_basic_ostream_impl<_Tp>;
    };
  template<typename _Tp>
    struct __is_convertible_to_basic_ostream
    : __is_convertible_to_basic_ostream_impl<_Tp>
    {
    public:
      using type = __not_<is_void<
        typename __is_convertible_to_basic_ostream_impl<_Tp>::__ostream_type>>;
      constexpr static bool value = type::value;
    };
  template<typename _Ostream, typename _Tp, typename = void>
    struct __is_insertable : false_type {};
  template<typename _Ostream, typename _Tp>
    struct __is_insertable<_Ostream, _Tp,
      __void_t<decltype(declval<_Ostream&>()
          << declval<const _Tp&>())>>
        : true_type {};
  template<typename _Ostream>
    using __rvalue_ostream_type =
      typename __is_convertible_to_basic_ostream<
 _Ostream>::__ostream_type;
    ;
} 
namespace std __attribute__ ((__visibility__ ("default")))
{
    ;
  extern template class basic_ostream<char>;;;;;;;;;;;;;;;;;;
  extern template class basic_ostream<wchar_t>;;;;;;;;;;;;;;;;
} 
namespace std __attribute__ ((__visibility__ ("default")))
{
  template<typename _CharT, typename _Traits>
    class basic_istream : virtual public basic_ios<_CharT, _Traits>
    {
    public:
      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      operator bool() const
      ;
    };
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c);
  template<class _Traits>
     basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char& __c)
    ;
  template<class _Traits>
     basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char& __c)
    ;
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s);
  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __in, char* __s);
  template<class _Traits>
     basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char* __s)
    ;
  template<class _Traits>
     basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char* __s)
    ;
  template<typename _CharT, typename _Traits>
    class basic_iostream
    : public basic_istream<_CharT, _Traits>,
      public basic_ostream<_CharT, _Traits>
    {
    public:
      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
    protected:
    };
  ;
  ;
  template<typename _Tp, typename = void>
    struct __is_convertible_to_basic_istream_impl
    {
      using __istream_type = void;
    };
  template<typename _Tp>
    using __do_is_convertible_to_basic_istream_impl =
    decltype(__is_convertible_to_basic_istream_test
      (declval<typename remove_reference<_Tp>::type*>()));
  template<typename _Tp>
    struct __is_convertible_to_basic_istream_impl
    <_Tp,
     __void_t<__do_is_convertible_to_basic_istream_impl<_Tp>>>
    {
      using __istream_type =
 __do_is_convertible_to_basic_istream_impl<_Tp>;
    };
  template<typename _Tp>
    struct __is_convertible_to_basic_istream
    : __is_convertible_to_basic_istream_impl<_Tp>
    {
    public:
      using type = __not_<is_void<
        typename __is_convertible_to_basic_istream_impl<_Tp>::__istream_type>>;
      constexpr static bool value = type::value;
    };
  template<typename _Istream, typename _Tp, typename = void>
    struct __is_extractable : false_type {};
  template<typename _Istream, typename _Tp>
    struct __is_extractable<_Istream, _Tp,
       __void_t<decltype(declval<_Istream&>()
           >> declval<_Tp>())>>
    : true_type {};
  template<typename _Istream>
    using __rvalue_istream_type =
      typename __is_convertible_to_basic_istream<
 _Istream>::__istream_type;
    ;
} 
namespace std __attribute__ ((__visibility__ ("default")))
{
namespace __cxx11 {
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_stringbuf : public basic_streambuf<_CharT, _Traits>
    {
      struct __xfer_bufptrs;
    public:
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;
      typedef basic_streambuf<char_type, traits_type> __streambuf_type;
      typedef basic_string<char_type, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
    protected:
      ios_base::openmode _M_mode;
      __string_type _M_string;
    public:
    protected:
    private:
      struct __xfer_bufptrs
      {
 basic_stringbuf* _M_to;
 off_type _M_goff[3];
 off_type _M_poff[3];
      };
    };
  /**
   *  @brief  Controlling input for std::string.
   *  @ingroup io
   *
   *  @tparam _CharT  Type of character stream.
   *  @tparam _Traits  Traits for character type, defaults to
   *                   char_traits<_CharT>.
   *  @tparam _Alloc  Allocator type, defaults to allocator<_CharT>.
   *
   *  This class supports reading from objects of type std::basic_string,
   *  using the inherited functions from std::basic_istream.  To control
   *  the associated sequence, an instance of std::basic_stringbuf is used,
   *  which this page refers to as @c sb.
  */
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_istringstream : public basic_istream<_CharT, _Traits>
    {
    public:
      /**
       *  @brief  Default constructor starts with an empty string buffer.
       *
       *  Initializes @c sb using @c in, and passes @c &sb to the base
       *  class initializer.  Does not allocate any buffer.
       *
       *  That's a lie.  We initialize the base class with NULL, because the        *  string class does its own memory management.       */                                                                                        };   template <typename _CharT, typename _Traits, typename _Alloc>     class basic_ostringstream : public basic_ostream<_CharT, _Traits>     {     public:       typedef _CharT char_type;       typedef _Traits traits_type;       typedef _Alloc allocator_type;       typedef typename traits_type::int_type int_type;       typedef typename traits_type::pos_type pos_type;       typedef typename traits_type::off_type off_type;       typedef basic_string<_CharT, _Traits, _Alloc> __string_type;       typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;       typedef basic_ostream<char_type, traits_type> __ostream_type;     private:       __stringbuf_type _M_stringbuf;     public:                                                                                         };   template <typename _CharT, typename _Traits, typename _Alloc>     class basic_stringstream : public basic_iostream<_CharT, _Traits>     {     public:       typedef _CharT char_type;       typedef _Traits traits_type;       typedef _Alloc allocator_type;       typedef typename traits_type::int_type int_type;       typedef typename traits_type::pos_type pos_type;       typedef typename traits_type::off_type off_type;       typedef basic_string<_CharT, _Traits, _Alloc> __string_type;       typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;       typedef basic_iostream<char_type, traits_type> __iostream_type;     private:       __stringbuf_type _M_stringbuf;     public:                                                                                         };        ;        ;        ;        ; } }  namespace std __attribute__ ((__visibility__ ("default"))) {                        extern template class basic_stringbuf<char>;   extern template class basic_istringstream<char>;   extern template class basic_ostringstream<char>;   extern template class basic_stringstream<char>;   extern template class basic_stringbuf<wchar_t>;   extern template class basic_istringstream<wchar_t>;   extern template class basic_ostringstream<wchar_t>;   extern template class basic_stringstream<wchar_t>; }  namespace std __attribute__ ((__visibility__ ("default"))) {   template<typename _Tp> class complex;   template<> class complex<float>;   template<> class complex<double>;   template<> class complex<long double>;   ;   ;   ;   ;   ;   ;   ;   ;   ;   ;   ;   ;   ;   ;   ;   ;   ;   ;   ;   template<typename _Tp>     struct complex     {       typedef _Tp value_type;                       ;                                                                                                                                                                                                                                                     ;       ;       ;       ;       ;            private:       _Tp _M_real;       _Tp _M_imag;     };                                ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;                ;        ;                ;   template<bool>     struct _Norm_helper     {                ;     };   template<>     struct _Norm_helper<true>     {                ;     };        ;        ;        ;        ;                ;        ;                ;        ;                ;        ;                ;        ;        ;                ;        ;                ;        ;                ;        ;                ;        ;                ;        ;        ;        ;        ;                    ;        ;   template<>     struct complex<float>     {       typedef float value_type;       typedef __complex__ float _ComplexT;                                                                                                                                                                                                                                                                                   ;         ;         ;         ;         ;            private:       _ComplexT _M_value;     };   template<>     struct complex<double>     {       typedef double value_type;       typedef __complex__ double _ComplexT;                                                                                                                                                                                                                                                                                   ;         ;         ;         ;         ;            private:       _ComplexT _M_value;     };   template<>     struct complex<long double>     {       typedef long double value_type;       typedef __complex__ long double _ComplexT;                                                                                                                                                                                                                                                                                   ;         ;         ;         ;         ;            private:       _ComplexT _M_value;     };;;;;;;;;;;;; }  namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {   template<typename _Tp, typename _Up>     struct __promote_2<std::complex<_Tp>, _Up>     {     public:       typedef std::complex<typename __promote_2<_Tp, _Up>::__type> __type;     };   template<typename _Tp, typename _Up>     struct __promote_2<_Tp, std::complex<_Up> >     {     public:       typedef std::complex<typename __promote_2<_Tp, _Up>::__type> __type;     };   template<typename _Tp, typename _Up>     struct __promote_2<std::complex<_Tp>, std::complex<_Up> >     {     public:       typedef std::complex<typename __promote_2<_Tp, _Up>::__type> __type;     }; }  namespace std __attribute__ ((__visibility__ ("default"))) {   ;   ;   ;   ;   ;   ;   ;        ;                    ;        ;                    ;        ;                    ;        ;                    ;        ;                    ;        ;                    ;        ;        ;        ;        ;        ;        ;        ;        ;   ;        ;                    ;        ;        ; }  typedef std::complex<double> Complex; typedef std::complex<float> FloatComplex;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ; extern "C" { typedef __sig_atomic_t sig_atomic_t; union sigval {   int sival_int;   void *sival_ptr; }; typedef union sigval __sigval_t; typedef struct   {     int si_signo;      int si_errno;      int si_code;      int __pad0;      union       {  int _pad[((128 / sizeof (int)) - 4)];  struct    {      __pid_t si_pid;       __uid_t si_uid;     } _kill;  struct    {      int si_tid;       int si_overrun;       __sigval_t si_sigval;     } _timer;  struct    {      __pid_t si_pid;       __uid_t si_uid;       __sigval_t si_sigval;     } _rt;  struct    {      __pid_t si_pid;       __uid_t si_uid;       int si_status;       __clock_t si_utime;      __clock_t si_stime;    } _sigchld;  struct    {      void *si_addr;       short int si_addr_lsb;       union        {   struct     {       void *_lower;       void *_upper;     } _addr_bnd;   __uint32_t _pkey;        } _bounds;    } _sigfault;  struct    {      long int si_band;       int si_fd;    } _sigpoll;  struct    {      void *_call_addr;       int _syscall;       unsigned int _arch;     } _sigsys;       } _sifields;   } siginfo_t ; enum {   SI_ASYNCNL = -60,    SI_DETHREAD = -7,    SI_TKILL,    SI_SIGIO,    SI_ASYNCIO,    SI_MESGQ,    SI_TIMER,    SI_QUEUE,    SI_USER,    SI_KERNEL = 0x80  }; enum {   ILL_ILLOPC = 1,    ILL_ILLOPN,    ILL_ILLADR,    ILL_ILLTRP,    ILL_PRVOPC,    ILL_PRVREG,    ILL_COPROC,    ILL_BADSTK,    ILL_BADIADDR  }; enum {   FPE_INTDIV = 1,    FPE_INTOVF,    FPE_FLTDIV,    FPE_FLTOVF,    FPE_FLTUND,    FPE_FLTRES,    FPE_FLTINV,    FPE_FLTSUB,    FPE_FLTUNK = 14,    FPE_CONDTRAP  }; enum {   SEGV_MAPERR = 1,    SEGV_ACCERR,    SEGV_BNDERR,    SEGV_PKUERR,    SEGV_ACCADI,    SEGV_ADIDERR,    SEGV_ADIPERR  }; enum {   BUS_ADRALN = 1,    BUS_ADRERR,    BUS_OBJERR,    BUS_MCEERR_AR,    BUS_MCEERR_AO  }; enum {   TRAP_BRKPT = 1,    TRAP_TRACE,    TRAP_BRANCH,    TRAP_HWBKPT,    TRAP_UNK  }; enum {   CLD_EXITED = 1,    CLD_KILLED,    CLD_DUMPED,    CLD_TRAPPED,    CLD_STOPPED,    CLD_CONTINUED  }; enum {   POLL_IN = 1,    POLL_OUT,    POLL_MSG,    POLL_ERR,    POLL_PRI,    POLL_HUP  }; typedef __sigval_t sigval_t; typedef struct sigevent   {     __sigval_t sigev_value;     int sigev_signo;     int sigev_notify;     union       {  int _pad[((64 / sizeof (int)) - 4)];  __pid_t _tid;  struct    {      void (*_function) (__sigval_t);       pthread_attr_t *_attribute;     } _sigev_thread;       } _sigev_un;   } sigevent_t; enum {   SIGEV_SIGNAL = 0,    SIGEV_NONE,    SIGEV_THREAD,    SIGEV_THREAD_ID = 4  }; typedef void (*__sighandler_t) (int); ; ; ; ; ; ; ; ; ; ; ; ; ; ; typedef __sighandler_t sighandler_t; typedef __sighandler_t sig_t; ; ; ; ; ; ; ; ; struct sigaction   {     union       {  __sighandler_t sa_handler;  void (*sa_sigaction) (int, siginfo_t *, void *);       }     __sigaction_handler;     __sigset_t sa_mask;     int sa_flags;     void (*sa_restorer) (void);   }; ; ; ; ; ; ; ; ; extern const char *const _sys_siglist[(64 + 1)]; extern const char *const sys_siglist[(64 + 1)]; struct _fpx_sw_bytes {   __uint32_t magic1;   __uint32_t extended_size;   __uint64_t xstate_bv;   __uint32_t xstate_size;   __uint32_t __glibc_reserved1[7]; }; struct _fpreg {   unsigned short significand[4];   unsigned short exponent; }; struct _fpxreg {   unsigned short significand[4];   unsigned short exponent;   unsigned short __glibc_reserved1[3]; }; struct _xmmreg {   __uint32_t element[4]; }; struct _fpstate {   __uint16_t cwd;   __uint16_t swd;   __uint16_t ftw;   __uint16_t fop;   __uint64_t rip;   __uint64_t rdp;   __uint32_t mxcsr;   __uint32_t mxcr_mask;   struct _fpxreg _st[8];   struct _xmmreg _xmm[16];   __uint32_t __glibc_reserved1[24]; }; struct sigcontext {   __uint64_t r8;   __uint64_t r9;   __uint64_t r10;   __uint64_t r11;   __uint64_t r12;   __uint64_t r13;   __uint64_t r14;   __uint64_t r15;   __uint64_t rdi;   __uint64_t rsi;   __uint64_t rbp;   __uint64_t rbx;   __uint64_t rdx;   __uint64_t rax;   __uint64_t rcx;   __uint64_t rsp;   __uint64_t rip;   __uint64_t eflags;   unsigned short cs;   unsigned short gs;   unsigned short fs;   unsigned short __pad0;   __uint64_t err;   __uint64_t trapno;   __uint64_t oldmask;   __uint64_t cr2;   __extension__ union     {       struct _fpstate * fpstate;       __uint64_t __fpstate_word;     };   __uint64_t __reserved1 [8]; }; struct _xsave_hdr {   __uint64_t xstate_bv;   __uint64_t __glibc_reserved1[2];   __uint64_t __glibc_reserved2[5]; }; struct _ymmh_state {   __uint32_t ymmh_space[64]; }; struct _xstate {   struct _fpstate fpstate;   struct _xsave_hdr xstate_hdr;   struct _ymmh_state ymmh; }; ; typedef struct   {     void *ss_sp;     int ss_flags;     size_t ss_size;   } stack_t; __extension__ typedef long long int greg_t; typedef greg_t gregset_t[23]; enum {   REG_R8 = 0,   REG_R9,   REG_R10,   REG_R11,   REG_R12,   REG_R13,   REG_R14,   REG_R15,   REG_RDI,   REG_RSI,   REG_RBP,   REG_RBX,   REG_RDX,   REG_RAX,   REG_RCX,   REG_RSP,   REG_RIP,   REG_EFL,   REG_CSGSFS,    REG_ERR,   REG_TRAPNO,   REG_OLDMASK,   REG_CR2 }; struct _libc_fpxreg {   unsigned short int significand[4];   unsigned short int exponent;   unsigned short int __glibc_reserved1[3]; }; struct _libc_xmmreg {   __uint32_t element[4]; }; struct _libc_fpstate {   __uint16_t cwd;   __uint16_t swd;   __uint16_t ftw;   __uint16_t fop;   __uint64_t rip;   __uint64_t rdp;   __uint32_t mxcsr;   __uint32_t mxcr_mask;   struct _libc_fpxreg _st[8];   struct _libc_xmmreg _xmm[16];   __uint32_t __glibc_reserved1[24]; }; typedef struct _libc_fpstate *fpregset_t; typedef struct   {     gregset_t gregs;     fpregset_t fpregs;     __extension__ unsigned long long __reserved1 [8]; } mcontext_t; typedef struct ucontext_t   {     unsigned long int uc_flags;     struct ucontext_t *uc_link;     stack_t uc_stack;     mcontext_t uc_mcontext;     sigset_t uc_sigmask;     struct _libc_fpstate __fpregs_mem;     __extension__ unsigned long long int __ssp[4];   } ucontext_t; ; enum {   SS_ONSTACK = 1,   SS_DISABLE }; ; struct sigstack   {     void *ss_sp;      int ss_onstack;    }; ; ; ; ; ; ; ; ; ; ; ; } namespace std {   using ::sig_atomic_t;       }  extern "C" { namespace octave {   class   execution_exception   {   public:                                      private:     std::string m_stack_trace;   };   class   exit_exception   {   public:                                 private:     int m_exit_status;     bool m_safe_to_return;   };   class   interrupt_exception   {   }; } enum octave_exception {   octave_no_exception = 0,   octave_exec_exception = 1,   octave_alloc_exception = 3,   octave_quit_exception = 4 };            extern sig_atomic_t octave_interrupt_state;            extern sig_atomic_t octave_exception_state; __attribute__ ((__deprecated__))            extern sig_atomic_t octave_exit_exception_status; __attribute__ ((__deprecated__))            extern sig_atomic_t octave_exit_exception_safe_to_return;            extern volatile sig_atomic_t octave_signal_caught;            ; ; ; ; ;            ; ;   ;; } extern void (*octave_signal_hook) (void); extern void (*octave_interrupt_hook) (void); extern void (*octave_bad_alloc_hook) (void);  ;                ;                 enum sortmode { UNSORTED = 0, ASCENDING, DESCENDING }; template <typename T> class octave_sort { public:   typedef bool (*compare_fcn_type) (typename ref_param<T>::type,                                     typename ref_param<T>::type);                                                          private:   static const int MAX_MERGE_PENDING = 85;   static const int MIN_GALLOP = 7;   static const int MERGESTATE_TEMP_SIZE = 1024;   struct s_slice   {     octave_idx_type base, len;   };   struct MergeState   {                                        octave_idx_type min_gallop;     T *a;      octave_idx_type *ia;     octave_idx_type alloced;     octave_idx_type n;     struct s_slice pending[MAX_MERGE_PENDING];   };   compare_fcn_type compare;   MergeState *ms;   ;   ;   ;   ;   ;   ;   ;   ;   ;   ;   ;   ;   ;   ;   ;      ;   ;   ;      ;   ;   ;   ;   ;   ;   ; }; template <typename T> class vec_index { public:   T vec;   octave_idx_type indx; }; template <typename T> class Array { protected:   class ArrayRep   {   public:     T *data;     octave_idx_type len;     octave::refcount<int> count;                ;                                 private:        }; public:      typedef T element_type;   typedef T value_type;   typedef octave_idx_type size_type;   typedef typename ref_param<T>::type crefT;   typedef bool (*compare_fcn_type) (typename ref_param<T>::type,                                     typename ref_param<T>::type); protected:   dim_vector dimensions;   typename Array<T>::ArrayRep *rep;   T *slice_data;   octave_idx_type slice_len;    private:    protected:    public:               ;       ;    public:                                                                                                                                                                                                                                                                                                Array<T> index (const Array<idx_vector>& ia, bool resize_ok,                   const T& rfv) const;   Array<T> index (const Array<idx_vector>& ia, bool resize_ok) const   ;   void assign (const idx_vector& i, const Array<T>& rhs, const T& rfv);   void assign (const idx_vector& i, const Array<T>& rhs)   ;   void assign (const idx_vector& i, const idx_vector& j, const Array<T>& rhs,                const T& rfv);   void assign (const idx_vector& i, const idx_vector& j, const Array<T>& rhs)   ;   void assign (const Array<idx_vector>& ia, const Array<T>& rhs, const T& rfv);   void assign (const Array<idx_vector>& ia, const Array<T>& rhs)   ;   void delete_elements (const idx_vector& i);   void delete_elements (int dim, const idx_vector& i);                                                                  ;      ;      ;      ;      ;      ;               template <typename U> friend class Array;                private:    };  template <typename ArrayClass> class NoAlias : public ArrayClass {   typedef typename ArrayClass::element_type T; public:        ;     ;     ;             }; ; namespace octave {   class index_exception : public execution_exception   {   public:                                                private:     std::string index;   protected:          octave_idx_type nd;     octave_idx_type dim;     std::string var;   };                                                   }                          struct permute_vector {   octave_idx_type pidx;   octave_idx_type iidx; };  /* Copyright (C) 1993-2019 John W. Eaton Copyright (C) 2010 VZLU Prague This file is part of Octave. Octave is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. Octave is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with Octave; see the file COPYING.  If not, see <https: *//* Copyright (C) 1993-2019 John W. Eaton Copyright (C) 2009 Jaroslav Hajek Copyright (C) 2009 VZLU Prague This file is part of Octave. Octave is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. Octave is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with Octave; see the file COPYING.  If not, see <https: *//** @file include/cmath  *  This is a Standard C++ Library file.  You should @c \
#include this file
 *  in your programs, rather than any of the @a *.h implementation files.  *  *  This is the C++ version of the Standard C Library header @c math.h,  *  and its contents are (mostly) the same as that header, but are all  *  contained in the namespace @c std (except for names which are defined  *  as macros in C).  *//* Copyright (C) 2012-2019 Jordi Gutiérrez Hermoso This file is part of Octave. Octave is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. Octave is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with Octave; see the file COPYING.  If not, see <https: */    /* Copyright (C) 2009-2019 Jaroslav Hajek Copyright (C) 2009 VZLU Prague This file is part of Octave. Octave is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. Octave is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with Octave; see the file COPYING.  If not, see <https: *//* Copyright (C) 1993-2019 John W. Eaton Copyright (C) 2009 Jaroslav Hajek Copyright (C) 2009 VZLU Prague This file is part of Octave. Octave is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. Octave is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with Octave; see the file COPYING.  If not, see <https: *//* Copyright (C) 2008-2019 Jaroslav Hajek This file is part of Octave. Octave is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. Octave is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with Octave; see the file COPYING.  If not, see <https: */ ;  ; /* Copyright (C) 2004-2019 John W. Eaton Copyright (C) 2008-2009 Jaroslav Hajek This file is part of Octave. Octave is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. Octave is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with Octave; see the file COPYING.  If not, see <https: *//** @file include/cmath  *  This is a Standard C++ Library file.  You should @c \
#include this file
 *  in your programs, rather than any of the @a *.h implementation files.  *  *  This is the C++ version of the Standard C Library header @c math.h,  *  and its contents are (mostly) the same as that header, but are all  *  contained in the namespace @c std (except for names which are defined  *  as macros in C).  *//** @file include/cstdlib  *  This is a Standard C++ Library file.  You should @c \
#include this file
 *  in your programs, rather than any of the @a *.h implementation files.  *  *  This is the C++ version of the Standard C Library header @c stdlib.h,  *  and its contents are (mostly) the same as that header, but are all  *  contained in the namespace @c std (except for names which are defined  *  as macros in C).  *//* Copyright (C) 1996-2019 John W. Eaton Copyright (C) 2010 VZLU Prague This file is part of Octave. Octave is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. Octave is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with Octave; see the file COPYING.  If not, see <https: *//** @file include/cmath  *  This is a Standard C++ Library file.  You should @c \
#include this file
 *  in your programs, rather than any of the @a *.h implementation files.  *  *  This is the C++ version of the Standard C Library header @c math.h,  *  and its contents are (mostly) the same as that header, but are all  *  contained in the namespace @c std (except for names which are defined  *  as macros in C).  *//* Copyright (C) 1996-2019 John W. Eaton This file is part of Octave. Octave is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. Octave is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with Octave; see the file COPYING.  If not, see <https: *//** @file include/cmath  *  This is a Standard C++ Library file.  You should @c \
#include this file
 *  in your programs, rather than any of the @a *.h implementation files.  *  *  This is the C++ version of the Standard C Library header @c math.h,  *  and its contents are (mostly) the same as that header, but are all  *  contained in the namespace @c std (except for names which are defined  *  as macros in C).  */extern "C" { /*  Octave's idea of infinity.  */
typedef union
{
  double value;
  unsigned int word[2];
} lo_ieee_double;
typedef union
{
  float value;
  unsigned int word;
} lo_ieee_float;
;
  ;
  ;
  ;
;
;
;
;
;
;
  ;
  ;
  ;
  ;
;
;
;
;
  ;
}
namespace octave
{
  template <typename T>
  struct numeric_limits
  {
  };
  template <>
  struct numeric_limits<double>
  {
    static double Inf (void) ;
  };
  template <>
  struct numeric_limits<float>
  {
  };
}
namespace octave
{
  namespace math
  {
    ;
    ;
    ;
    ;
    ;
    ;
    ;
  }
}
;
template <typename T> class octave_int;
typedef octave_int<int8_t> octave_int8;
typedef octave_int<int16_t> octave_int16;
typedef octave_int<int32_t> octave_int32;
typedef octave_int<int64_t> octave_int64;
typedef octave_int<uint8_t> octave_uint8;
typedef octave_int<uint16_t> octave_uint16;
;
;
;
;
template <typename T>
class
MArray : public Array<T>
{
protected:
public:
    ;
};
/* Version 2.4 and later of GCC define a magical variable `__PRETTY_FUNCTION__'    which contains the name of the function currently being defined.    This is broken in G++ before version 2.6.    C9x has a similar variable called __func__, but prefer the GCC one since    it demangles C++ function names.  */class idx_vector; class PermMatrix; template <typename T> class Sparse { public:   typedef T element_type; protected:   class SparseRep   {   public:     T *d;     octave_idx_type *r;     octave_idx_type *c;     octave_idx_type nzmx;     octave_idx_type nrows;     octave_idx_type ncols;     octave::refcount<int> count;                                                                                                  private:        };    public:   typename Sparse<T>::SparseRep *rep;   dim_vector dimensions; private:    public:                            ;    public:                                                                                                                                                                                                                                                                                                                           ;      ;      ;                  ;      ;      ;       }; ; template <typename T> class MSparse : public Sparse<T> { public:                       ;                                                ;      ; };  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ; class Matrix; class ComplexMatrix; class FloatMatrix; class FloatComplexMatrix; class SparseMatrix; class SparseComplexMatrix; class MatrixType { public:   enum matrix_type   {     Unknown = 0,     Full,     Diagonal,     Permuted_Diagonal,     Upper,     Lower,     Permuted_Upper,     Permuted_Lower,     Banded,     Hermitian,     Banded_Hermitian,     Tridiagonal,     Tridiagonal_Hermitian,     Rectangular   };                     ;                                                                                                                                                 private:      matrix_type typ;   double sp_bandden;   double bandden;   octave_idx_type upper_band;   octave_idx_type lower_band;   bool dense;   bool full;   octave_idx_type nperm;   octave_idx_type *perm; }; class Matrix; class ComplexMatrix; class FloatMatrix; class FloatComplexMatrix; class boolMatrix; class charMatrix; class NDArray; class ComplexNDArray; class FloatNDArray; class FloatComplexNDArray; class boolNDArray; class charNDArray; class ColumnVector; class ComplexColumnVector; class FloatColumnVector; class FloatComplexColumnVector; class RowVector; class ComplexRowVector; class FloatRowVector; class FloatComplexRowVector; class DiagMatrix; class ComplexDiagMatrix; class FloatDiagMatrix; class FloatComplexDiagMatrix; class PermMatrix; template <typename T> class aepbalance; template <typename T> class gepbalance; template <typename T> class chol; class EIG; template <typename T> class gsvd; template <typename T> class hess; template <typename T> class schur; template <typename T> class svd; template <typename T> class lu; template <typename T> class qr; template <typename T> class qrp; typedef bool (*b_d_Mapper)(double); typedef bool (*b_c_Mapper)(const Complex&); typedef double (*d_d_Mapper)(double); typedef double (*d_c_Mapper)(const Complex&); typedef Complex (*c_c_Mapper)(const Complex&); typedef bool (*b_f_Mapper)(float); typedef bool (*b_fc_Mapper)(const FloatComplex&); typedef float (*f_f_Mapper)(float); typedef float (*f_fc_Mapper)(const FloatComplex&); typedef FloatComplex (*fc_fc_Mapper)(const FloatComplex&); enum blas_trans_type {   blas_no_trans = 'N',   blas_trans = 'T',   blas_conj_trans = 'C' };   /* Copyright (C) 1996-2019 John W. Eaton Copyright (C) 2008-2009 Jaroslav Hajek Copyright (C) 2009 VZLU Prague, a.s. This file is part of Octave. Octave is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. Octave is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with Octave; see the file COPYING.  If not, see <https: */class boolMatrix; class boolNDArray; class boolNDArray : public Array<bool> { public:   typedef boolMatrix matrix_type;                                                                };                                   ; ; class boolMatrix : public boolNDArray { public:                                           };             /* Copyright (C) 1995-2019 John W. Eaton Copyright (C) 2010 VZLU Prague This file is part of Octave. Octave is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. Octave is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with Octave; see the file COPYING.  If not, see <https: *//* Copyright (C) 2003-2019 John W. Eaton This file is part of Octave. Octave is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. Octave is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with Octave; see the file COPYING.  If not, see <https: *//* Copyright (C) 1996-2019 John W. Eaton This file is part of Octave. Octave is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. Octave is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with Octave; see the file COPYING.  If not, see <https: *//*  *  * Copyright (c) 1994  * Hewlett-Packard Company  *  * Permission to use, copy, modify, distribute and sell this software  * and its documentation for any purpose is hereby granted without fee,  * provided that the above copyright notice appear in all copies and  * that both that copyright notice and this permission notice appear  * in supporting documentation.  Hewlett-Packard Company makes no  * representations about the suitability of this software for any  * purpose.  It is provided "as is" without express or implied warranty.  *  *  * Copyright (c) 1996,1997  * Silicon Graphics Computer Systems, Inc.  *  * Permission to use, copy, modify, distribute and sell this software  * and its documentation for any purpose is hereby granted without fee,  * provided that the above copyright notice appear in all copies and  * that both that copyright notice and this permission notice appear  * in supporting documentation.  Silicon Graphics makes no  * representations about the suitability of this software for any  * purpose.  It is provided "as is" without express or implied warranty.  *//** @file include/list  *  This is a Standard C++ Library header.  *//*  *  * Copyright (c) 1994  * Hewlett-Packard Company  *  * Permission to use, copy, modify, distribute and sell this software  * and its documentation for any purpose is hereby granted without fee,  * provided that the above copyright notice appear in all copies and  * that both that copyright notice and this permission notice appear  * in supporting documentation.  Hewlett-Packard Company makes no  * representations about the suitability of this software for any  * purpose.  It is provided "as is" without express or implied warranty.  *  *  * Copyright (c) 1996,1997  * Silicon Graphics Computer Systems, Inc.  *  * Permission to use, copy, modify, distribute and sell this software  * and its documentation for any purpose is hereby granted without fee,  * provided that the above copyright notice appear in all copies and  * that both that copyright notice and this permission notice appear  * in supporting documentation.  Silicon Graphics makes no  * representations about the suitability of this software for any  * purpose.  It is provided "as is" without express or implied warranty.  *//** @file bits/stl_list.h  *  This is an internal header file, included by other library headers.  *  Do not attempt to use it directly. @headername{list}  */namespace std __attribute__ ((__visibility__ ("default"))) {   namespace __detail   {     struct _List_node_base     {       _List_node_base* _M_next;       _List_node_base* _M_prev;                                        };     struct _List_node_header : public _List_node_base     {       std::size_t _M_size;                                 private:            };   }    template<typename _Tp>     struct _List_node : public __detail::_List_node_base     {       __gnu_cxx::__aligned_membuf<_Tp> _M_storage;                   };   /**    *  @brief A list::iterator.    *    *  All the functions are op overloads.   */  template<typename _Tp>     struct _List_iterator     {       typedef _List_iterator<_Tp> _Self;       typedef _List_node<_Tp> _Node;       typedef ptrdiff_t difference_type;       typedef std::bidirectional_iterator_tag iterator_category;       typedef _Tp value_type;       typedef _Tp* pointer;       typedef _Tp& reference;                                                                                    __detail::_List_node_base* _M_node;     };   /**    *  @brief A list::const_iterator.    *    *  All the functions are op overloads.   */  template<typename _Tp>     struct _List_const_iterator     {       typedef _List_const_iterator<_Tp> _Self;       typedef const _List_node<_Tp> _Node;       typedef _List_iterator<_Tp> iterator;       typedef ptrdiff_t difference_type;       typedef std::bidirectional_iterator_tag iterator_category;       typedef _Tp value_type;       typedef const _Tp* pointer;       typedef const _Tp& reference;                                                                                           const __detail::_List_node_base* _M_node;     }; namespace __cxx11 {   template<typename _Tp, typename _Alloc>     class _List_base     {     protected:       typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template  rebind<_Tp>::other _Tp_alloc_type;       typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tp_alloc_traits;       typedef typename _Tp_alloc_traits::template  rebind<_List_node<_Tp> >::other _Node_alloc_type;       typedef __gnu_cxx::__alloc_traits<_Node_alloc_type> _Node_alloc_traits;              struct _List_impl       : public _Node_alloc_type       {  __detail::_List_node_header _M_node;                 };       _List_impl _M_impl;                                          size_t _M_node_count() const ;       typename _Node_alloc_traits::pointer       _M_get_node()       ;       void       _M_put_node(typename _Node_alloc_traits::pointer __p) noexcept       ;   public:       typedef _Alloc allocator_type;       _Node_alloc_type&       _M_get_Node_allocator() noexcept       ;       const _Node_alloc_type&       _M_get_Node_allocator() const noexcept       ;       _List_base() = default;       _List_base(const _Node_alloc_type& __a)        ;                                                             };   template<typename _Tp, typename _Alloc = std::allocator<_Tp> >     class list : protected _List_base<_Tp, _Alloc>     {       static_assert(is_same<typename remove_cv<_Tp>::type, _Tp>::value,    "std::list must have a non-const, non-volatile value_type");       typedef _List_base<_Tp, _Alloc> _Base;       typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;       typedef typename _Base::_Tp_alloc_traits _Tp_alloc_traits;       typedef typename _Base::_Node_alloc_type _Node_alloc_type;       typedef typename _Base::_Node_alloc_traits _Node_alloc_traits;     public:       typedef _Tp value_type;       typedef typename _Tp_alloc_traits::pointer pointer;       typedef typename _Tp_alloc_traits::const_pointer const_pointer;       typedef typename _Tp_alloc_traits::reference reference;       typedef typename _Tp_alloc_traits::const_reference const_reference;       typedef _List_iterator<_Tp> iterator;       typedef _List_const_iterator<_Tp> const_iterator;       typedef std::reverse_iterator<const_iterator> const_reverse_iterator;       typedef std::reverse_iterator<iterator> reverse_iterator;       typedef size_t size_type;       typedef ptrdiff_t difference_type;       typedef _Alloc allocator_type;     protected:       typedef _List_node<_Tp> _Node;       using _Base::_M_impl;       using _Base::_M_put_node;       using _Base::_M_get_node;       using _Base::_M_get_Node_allocator;       /**        *  @param  __args  An instance of user data.        *        *  Allocates space for a new node and constructs a copy of        *  @a __args in it.        */        ;                   public:       /**        *  @brief  Creates a %list with no elements.        */             /**        *  @brief  Creates a %list with no elements.        *  @param  __a  An allocator object.        */             /**        *  @brief  Creates a %list with default constructed elements.        *  @param  __n  The number of elements to initially create.        *  @param  __a  An allocator object.        *        *  This constructor fills the %list with @a __n default        *  constructed elements.        */             /**        *  @brief  Creates a %list with copies of an exemplar element.        *  @param  __n  The number of elements to initially create.        *  @param  __value  An element to copy.        *  @param  __a  An allocator object.        *        *  This constructor fills the %list with @a __n copies of @a __value.        */             /**        *  @brief  %List copy constructor.        *  @param  __x  A %list of identical element and allocator types.        *        *  The newly-created %list uses a copy of the allocation object used        *  by @a __x (unless the allocator traits dictate a different object).        */             /**        *  @brief  %List move constructor.        *        *  The newly-created %list contains the exact contents of the moved        *  instance. The contents of the moved instance are a valid, but        *  unspecified %list.        */             /**        *  @brief  Builds a %list from an initializer_list        *  @param  __l  An initializer_list of value_type.        *  @param  __a  An allocator object.        *        *  Create a %list consisting of copies of the elements in the        *  initializer_list @a __l.  This is linear in __l.size().        */                  private:              list(list&& __x, const allocator_type& __a, false_type)        ;     public:       list(list&& __x, const allocator_type& __a)       noexcept(_Node_alloc_traits::_S_always_equal())        ;       /**        *  @brief  Builds a %list from a range.        *  @param  __first  An input iterator.        *  @param  __last  An input iterator.        *  @param  __a  An allocator object.        *        *  Create a %list consisting of copies of the elements from        *  [@a __first,@a __last).  This is linear in N (where N is        *  distance(@a __first,@a __last)).        */         ;       /**        *  No explicit dtor needed as the _Base dtor takes care of        *  things.  The _Base dtor only erases the elements, and note        *  that if the elements themselves are pointers, the pointed-to        *  memory is not touched in any way.  Managing the pointer is        *  the user's responsibility.
       */
 ;
 ;
 ;
      ;
      ;
    private:
      typedef void __remove_return_type;
    public:
      ;
      ;
      ;
 ;
      ;
    protected:
 ;
 ;
 ;
      ;
       ;
    };
}
  /**
   *  @param  __x  A %list.
   *  @param  __y  A %list of the same type as @a __x.
   *  @return  True iff @a __x is lexicographically less than @a __y.
   *
   *  This is a total ordering relation.  It is linear in the size of the
   *  lists.  The elements must be comparable with @c <.
   *
   *  See std::lexicographical_compare() for how the determination is made.
  */
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
} 
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */
/** @file bits/list.tcc
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{list}
 */
namespace std __attribute__ ((__visibility__ ("default")))
{
} 
class
string_vector : public Array<std::string>
{
public:
  ;
};
class
charNDArray : public Array<char>
{
public:
  typedef charMatrix matrix_type;
};
class
charMatrix : public charNDArray
{
  friend class ComplexMatrix;
public:
};
/*
Copyright (C) 1994-2019 John W. Eaton
This file is part of Octave.
Octave is free software: you can redistribute it and/or modify it
   If not, and EXPRESSION is zero, print an error message and abort.  */
/* When possible, define assert so that it does not add extra
   parentheses around EXPR.  Otherwise, those added parentheses would
   suppress warnings we'd expect to be detected by gcc's -Wparentheses.  */
/* Version 2.4 and later of GCC define a magical variable `__PRETTY_FUNCTION__'    which contains the name of the function currently being defined.    This is broken in G++ before version 2.6.    C9x has a similar variable called __func__, but prefer the GCC one since    it demangles C++ function names.  */template <typename T> class DiagArray2 : protected Array<T> { protected:   octave_idx_type d1, d2; public:   using typename Array<T>::element_type;                       ;                                                                                                                private:    }; template <typename T> class MDiagArray2; ; ; ; ; ; ; ; ; template <typename T> class MDiagArray2 : public DiagArray2<T> { public:                    ;                                                       }; template <typename T> class intNDArray; class NDArray : public MArray<double> { public:                    ;     ;     ;                                                                                                                                                   friend class ComplexNDArray;                         };                                                                                                     class Matrix : public NDArray { public:   typedef ColumnVector column_vector_type;   typedef RowVector row_vector_type;   typedef ColumnVector real_column_vector_type;   typedef RowVector real_row_vector_type;   typedef Matrix real_matrix_type;   typedef ComplexMatrix complex_matrix_type;   typedef DiagMatrix real_diag_matrix_type;   typedef ComplexDiagMatrix complex_diag_matrix_type;   typedef double real_elt_type;   typedef Complex complex_elt_type;   typedef void (*solve_singularity_handler) (double rcon);                       ;     ;                                                                                       friend class ComplexMatrix;                      private:       public:                                                    private:          public:                                                                                                                                                                                                                   };                                                                                   ; class ComplexNDArray : public MArray<Complex> { public:                 ;     ;                                                                                                                                                    };                                                                                                    class ComplexMatrix : public ComplexNDArray { public:   typedef ComplexColumnVector column_vector_type;   typedef ComplexRowVector row_vector_type;   typedef ColumnVector real_column_vector_type;   typedef RowVector real_row_vector_type;   typedef Matrix real_matrix_type;   typedef ComplexMatrix complex_matrix_type;   typedef DiagMatrix real_diag_matrix_type;   typedef ComplexDiagMatrix complex_diag_matrix_type;   typedef double real_elt_type;   typedef Complex complex_elt_type;   typedef void (*solve_singularity_handler) (double rcon);                       ;     ;                                                                                                                                                                   private:       public:                                                    private:          public:                                                                                                                                                                                                                                     };                                                                                      template <typename T> class intNDArray; class FloatNDArray : public MArray<float> { public:                 ;     ;     ;                                                                                                                                                   friend class FloatComplexNDArray;                         };                                                                                                     class FloatMatrix : public FloatNDArray { public:   typedef FloatColumnVector column_vector_type;   typedef FloatRowVector row_vector_type;   typedef FloatColumnVector real_column_vector_type;   typedef FloatRowVector real_row_vector_type;   typedef FloatMatrix real_matrix_type;   typedef FloatComplexMatrix complex_matrix_type;   typedef FloatDiagMatrix real_diag_matrix_type;   typedef FloatComplexDiagMatrix complex_diag_matrix_type;   typedef float real_elt_type;   typedef FloatComplex complex_elt_type;   typedef void (*solve_singularity_handler) (float rcon);                       ;     ;                                                                                       friend class FloatComplexMatrix;                      private:       public:                                                    private:          public:                                                                                                                                                                                                             };                                                                                   ; class FloatComplexNDArray : public MArray<FloatComplex> { public:                 ;     ;                                                                                                                                                       };                                                                                                    class FloatComplexMatrix : public FloatComplexNDArray { public:   typedef FloatComplexColumnVector column_vector_type;   typedef FloatComplexRowVector row_vector_type;   typedef FloatColumnVector real_column_vector_type;   typedef FloatRowVector real_row_vector_type;   typedef FloatMatrix real_matrix_type;   typedef FloatComplexMatrix complex_matrix_type;   typedef FloatDiagMatrix real_diag_matrix_type;   typedef FloatComplexDiagMatrix complex_diag_matrix_type;   typedef float real_elt_type;   typedef FloatComplex complex_elt_type;   typedef void (*solve_singularity_handler) (float rcon);                       ;     ;                                                                                                                                                                   private:       public:                                                    private:          public:                                                                                                                                                                                                                                        };                                                                                      class ColumnVector : public MArray<double> { public:                                                                                     };                                               class ComplexColumnVector : public MArray<Complex> {   friend class ComplexMatrix;   friend class ComplexRowVector; public:                                                                                                                      };                                             class FloatColumnVector : public MArray<float> { public:                                                                                     };                                               class FloatComplexColumnVector : public MArray<FloatComplex> {   friend class FloatComplexMatrix;   friend class FloatComplexRowVector; public:                                                                                                                      };                                             class RowVector : public MArray<double> { public:                                                                               };                                                           class ComplexRowVector : public MArray<Complex> {   friend class ComplexColumnVector; public:                                                                                                       };                                                           class FloatRowVector : public MArray<float> { public:                                                                               };                                                           class FloatComplexRowVector : public MArray<FloatComplex> {   friend class FloatComplexColumnVector; public:                                                                                                       };                                                           class DiagMatrix : public MDiagArray2<double> { public:   typedef Matrix full_matrix_type;                    ;                                                                                  };                                                     class ComplexDiagMatrix : public MDiagArray2<Complex> { public:   typedef ComplexMatrix full_matrix_type;   typedef double real_elt_type;   typedef Complex complex_elt_type;   typedef Complex element_type;                                ;                                                                                                       };                                                                 class FloatDiagMatrix : public MDiagArray2<float> { public:   typedef FloatMatrix full_matrix_type;                    ;                                                                                  };                                                     class FloatComplexDiagMatrix : public MDiagArray2<FloatComplex> { public:   typedef FloatComplexMatrix full_matrix_type;   typedef float real_elt_type;   typedef FloatComplex complex_elt_type;   typedef FloatComplex element_type;                                ;                                                                                                       };                                                                 class PermMatrix : protected Array<octave_idx_type> { public:                                                                                           private:          };  class SparseBoolMatrix; class SparseMatrix; class SparseBoolMatrix : public Sparse<bool> { public:   typedef boolMatrix dense_matrix_type;                              ;                                                                      };             class PermMatrix; class DiagMatrix; class SparseComplexMatrix; class SparseBoolMatrix; class SparseMatrix : public MSparse<double> { public:   typedef Matrix dense_matrix_type;   typedef void (*solve_singularity_handler) (double rcond);                                                                                                       private:       public:                      private:                                                                            public:                                                                                                                                                                                                                            };                                                                              class PermMatrix; class DiagMatrix; class ComplexDiagMatrix; class SparseMatrix; class SparseBoolMatrix; class SparseComplexMatrix : public MSparse<Complex> { public:   typedef ComplexMatrix dense_matrix_type;   typedef void (*solve_singularity_handler) (double rcond);                                                                                                                 private:       public:                      private:                                                                            public:                                                                                                                                                                                                                };                                                                                                class NDArray; template <typename T> class intNDArray : public MArray<T> { public:   using typename MArray<T>::element_type;                 ;     ;     ;                                                                                              }; ; ; typedef intNDArray<octave_int8> int8NDArray;                                                                                                    typedef intNDArray<octave_int16> int16NDArray;                                                                                                    typedef intNDArray<octave_int32> int32NDArray;                                                                                                    typedef intNDArray<octave_int64> int64NDArray;                                                                                                    typedef intNDArray<octave_uint8> uint8NDArray;                                                                                                    typedef intNDArray<octave_uint16> uint16NDArray;                                                                                                    typedef intNDArray<octave_uint32> uint32NDArray;                                                                                                    typedef intNDArray<octave_uint64> uint64NDArray;                                                                                                    namespace octave {   namespace math   {     template <typename MT>     class aepbalance     {     public:       typedef typename MT::real_column_vector_type VT;                                                                    protected:       MT balanced_mat;       VT scale;       octave_idx_type ilo;       octave_idx_type ihi;       char job;     };   } } namespace octave {   namespace math   {     template <typename T>     class     gepbalance     {     public:       typedef typename T::real_matrix_type RT;                                                                    private:       T balanced_mat;       T balanced_mat2;       RT balancing_mat;       RT balancing_mat2;            };   } } namespace octave {   namespace math   {     template <typename T>     class     chol     {     public:       typedef typename T::column_vector_type VT;       typedef typename T::real_elt_type COND_T;                                                                                                       private:       T chol_mat;       COND_T xrcond;       bool is_upper;            };     ;   } } namespace octave {   namespace math   {     template <typename T>     class     hess     {     public:                                                             private:       T hess_mat;       T unitary_hess_mat;            };     ;   } } namespace octave {   namespace math   {     template <typename T>     class     schur     {     public:                                                                    protected:     private:       T schur_mat;       T unitary_mat;            };     ;   } } namespace std __attribute__ ((__visibility__ ("default"))) {   template<typename _Tp, typename _Alloc>     struct _Vector_base     {       typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template  rebind<_Tp>::other _Tp_alloc_type;       typedef typename __gnu_cxx::__alloc_traits<_Tp_alloc_type>::pointer         pointer;       struct _Vector_impl_data       {  pointer _M_start;  pointer _M_finish;  pointer _M_end_of_storage;               };       struct _Vector_impl  : public _Tp_alloc_type, public _Vector_impl_data       {                 };     public:       typedef _Alloc allocator_type;       _Tp_alloc_type&       _M_get_Tp_allocator() noexcept       ;       const _Tp_alloc_type&       _M_get_Tp_allocator() const noexcept       ;       allocator_type       get_allocator() const noexcept       ;       _Vector_base() = default;       _Vector_base(const allocator_type& __a)  ;       _Vector_base(size_t __n)        ;       _Vector_base(size_t __n, const allocator_type& __a)        ;       _Vector_base(_Vector_base&&) = default;       _Vector_base(_Tp_alloc_type&& __a)  ;       _Vector_base(_Vector_base&& __x, const allocator_type& __a)        ;       _Vector_base(const allocator_type& __a, _Vector_base&& __x)        ;       ~_Vector_base() noexcept       ;     public:       _Vector_impl _M_impl;       pointer       _M_allocate(size_t __n)       ;       void       _M_deallocate(pointer __p, size_t __n)       ;     protected:       void       _M_create_storage(size_t __n)       ;     };   /**    *  @brief A standard container which offers fixed time access to    *  individual elements in any order.    *    *  @ingroup sequences    *    *  @tparam _Tp  Type of element.    *  @tparam _Alloc  Allocator type, defaults to allocator<_Tp>.    *    *  Meets the requirements of a <a href="tables.html#65">container</a>, a    *  <a href="tables.html#66">reversible container</a>, and a    *  <a href="tables.html#67">sequence</a>, including the    *  <a href="tables.html#68">optional sequence requirements</a> with the    *  %exception of @c push_front and @c pop_front.    *    *  In some terminology a %vector can be described as a dynamic    *  C-style array, it offers fast and efficient access to individual    *  elements in any order and saves the user from worrying about    *  memory and size allocation.  Subscripting ( @c [] ) access is    *  also provided as with C-style arrays.   */  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >     class vector : protected _Vector_base<_Tp, _Alloc>     {       static_assert(is_same<typename remove_cv<_Tp>::type, _Tp>::value,    "std::vector must have a non-const, non-volatile value_type");       typedef _Vector_base<_Tp, _Alloc> _Base;       typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;       typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Alloc_traits;     public:       typedef _Tp value_type;       typedef typename _Base::pointer pointer;       typedef typename _Alloc_traits::const_pointer const_pointer;       typedef typename _Alloc_traits::reference reference;       typedef typename _Alloc_traits::const_reference const_reference;       typedef __gnu_cxx::__normal_iterator<pointer, vector> iterator;       typedef __gnu_cxx::__normal_iterator<const_pointer, vector>       const_iterator;       typedef std::reverse_iterator<const_iterator> const_reverse_iterator;       typedef std::reverse_iterator<iterator> reverse_iterator;       typedef size_t size_type;       typedef ptrdiff_t difference_type;       typedef _Alloc allocator_type;     private:       static constexpr bool       _S_nothrow_relocate(true_type)       ;                                        protected:       using _Base::_M_allocate;       using _Base::_M_deallocate;       using _Base::_M_impl;       using _Base::_M_get_Tp_allocator;     public:                                                      private:                   public:                        ;                                            ;              using _Base::get_allocator;                                                                                                                                                                                  protected:            public:                                                                             ;                ;                                     ;                                 protected:         ;         ;         ;                       ;         ;       ;       ;                ;         ;       ;       ;                            struct _Temporary_value       {       ;           private:    vector* _M_this;  typename aligned_storage<sizeof(_Tp), alignof(_Tp)>::type __buf;       };       ;       ;              ;                                                      private:                       ;         ;     };   /**    *  @brief  Vector equality comparison.    *  @param  __x  A %vector.    *  @param  __y  A %vector of the same type as @a __x.    *  @return  True iff the size and elements of the vectors are equal.    *    *  This is an equivalence relation.  It is linear in the size of the    *  vectors.  Vectors are considered equivalent if their sizes are equal,    *  and if corresponding elements compare equal.   */       ;   /**    *  @brief  Vector ordering relation.    *  @param  __x  A %vector.    *  @param  __y  A %vector of the same type as @a __x.    *  @return  True iff @a __x is lexicographically less than @a __y.    *    *  This is a total ordering relation.  It is linear in the size of the    *  vectors.  The elements must be comparable with @c <.    *    *  See std::lexicographical_compare() for how the determination is made.   */       ;        ;        ;        ;        ;        ; }  /*  *  * Copyright (c) 1994  * Hewlett-Packard Company  *  * Permission to use, copy, modify, distribute and sell this software  * and its documentation for any purpose is hereby granted without fee,  * provided that the above copyright notice appear in all copies and  * that both that copyright notice and this permission notice appear  * in supporting documentation.  Hewlett-Packard Company makes no  * representations about the suitability of this software for any  * purpose.  It is provided "as is" without express or implied warranty.  *  *  * Copyright (c) 1996-1999  * Silicon Graphics Computer Systems, Inc.  *  * Permission to use, copy, modify, distribute and sell this software  * and its documentation for any purpose is hereby granted without fee,  * provided that the above copyright notice appear in all copies and  * that both that copyright notice and this permission notice appear  * in supporting documentation.  Silicon Graphics makes no  * representations about the suitability of this software for any  * purpose.  It is provided "as is" without express or implied warranty.  *//** @file bits/stl_bvector.h  *  This is an internal header file, included by other library headers.  *  Do not attempt to use it directly. @headername{vector}  */namespace std __attribute__ ((__visibility__ ("default"))) {   typedef unsigned long _Bit_type;   enum { _S_word_bit = int(8 * sizeof(_Bit_type)) };   struct _Bit_reference   {     _Bit_type * _M_p;     _Bit_type _M_mask;                                                };               struct _Bit_iterator_base   : public std::iterator<std::random_access_iterator_tag, bool>   {     _Bit_type * _M_p;     unsigned int _M_offset;                                                     };       struct _Bit_iterator : public _Bit_iterator_base   {     typedef _Bit_reference reference;     typedef _Bit_reference* pointer;     typedef _Bit_iterator iterator;                                                                    };       struct _Bit_const_iterator : public _Bit_iterator_base   {     typedef bool reference;     typedef bool const_reference;     typedef const bool* pointer;     typedef _Bit_const_iterator const_iterator;                                                                         };               template<typename _Alloc>     struct _Bvector_base     {       typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template         rebind<_Bit_type>::other _Bit_alloc_type;       typedef typename __gnu_cxx::__alloc_traits<_Bit_alloc_type>  _Bit_alloc_traits;       typedef typename _Bit_alloc_traits::pointer _Bit_pointer;       struct _Bvector_impl_data       {  _Bit_iterator _M_start;  _Bit_iterator _M_finish;  _Bit_pointer _M_end_of_storage;               };       struct _Bvector_impl  : public _Bit_alloc_type, public _Bvector_impl_data  {  public:                   };     public:       typedef _Alloc allocator_type;                                                      protected:       _Bvector_impl _M_impl;                                 }; }  namespace std __attribute__ ((__visibility__ ("default"))) {   /**    *  @brief  A specialization of vector for booleans which offers fixed time    *  access to individual elements in any order.    *    *  @ingroup sequences    *    *  @tparam _Alloc  Allocator type.    *    *  Note that vector<bool> does not actually meet the requirements for being    *  a container.  This is because the reference and pointer types are not    *  really references and pointers to bool.  See DR96 for details.  @see    *  vector for function documentation.    *    *  In some terminology a %vector can be described as a dynamic    *  C-style array, it offers fast and efficient access to individual    *  elements in any order and saves the user from worrying about    *  memory and size allocation.  Subscripting ( @c [] ) access is    *  also provided as with C-style arrays.   */  template<typename _Alloc>     class vector<bool, _Alloc> : protected _Bvector_base<_Alloc>     {       typedef _Bvector_base<_Alloc> _Base;       typedef typename _Base::_Bit_pointer _Bit_pointer;       typedef typename _Base::_Bit_alloc_traits _Bit_alloc_traits;       friend struct std::hash<vector>;     public:       typedef bool value_type;       typedef size_t size_type;       typedef ptrdiff_t difference_type;       typedef _Bit_reference reference;       typedef bool const_reference;       typedef _Bit_reference* pointer;       typedef const bool* const_pointer;       typedef _Bit_iterator iterator;       typedef _Bit_const_iterator const_iterator;       typedef std::reverse_iterator<const_iterator> const_reverse_iterator;       typedef std::reverse_iterator<iterator> reverse_iterator;       typedef _Alloc allocator_type;            protected:       using _Base::_M_allocate;       using _Base::_M_deallocate;       using _Base::_S_nword;       using _Base::_M_get_Bit_allocator;     public:                                                                         ;                                            ;                                                                                                                                          protected:            public:                                                                                             ;                                                                        ;         ;     protected:                                            ;         ;         ;         ;                ;         ;         ;         ;                ;       ;                                      }; }  namespace std __attribute__ ((__visibility__ ("default"))) {   template<typename _Alloc>     struct hash<std::vector<bool, _Alloc>>     : public __hash_base<size_t, std::vector<bool, _Alloc>>     {            }; } namespace std __attribute__ ((__visibility__ ("default"))) {                                                                            }  namespace std __attribute__ ((__visibility__ ("default"))) {    }  namespace octave {   namespace math   {     template <typename T>     class     svd     {     public:       typedef typename T::real_diag_matrix_type DM_T;       enum class Type       {         std,         economy,         sigma_only       };       enum class Driver       {         GESVD,         GESDD       };                                                             private:       typedef typename T::element_type P;       typedef typename DM_T::element_type DM_P;       svd::Type m_type;       svd::Driver m_driver;       T left_sm;       DM_T sigma;       T right_sm;                   };   } } class Matrix; class EIG {   friend class Matrix;   friend class ComplexMatrix; public:                                                 private:   ComplexColumnVector lambda;   ComplexMatrix v;   ComplexMatrix w;                         }; namespace octave {   namespace math   {     template <typename T>     class     gsvd     {     public:       enum class Type       {         std,         economy,         sigma_only       };                                                                                  private:       typedef typename T::value_type P;       typedef typename T::real_matrix_type real_matrix;       gsvd::Type type;       typename T::real_diag_matrix_type sigmaA, sigmaB;       T left_smA, left_smB;       T right_sm, R;            };   } } class ColumnVector; class PermMatrix; namespace octave {   namespace math   {     template <typename T>     class     lu     {     public:       typedef typename T::column_vector_type VT;       typedef typename T::element_type ELT_T;                                                                                                                                   protected:              T a_fact;       T l_fact;       Array<octave_f77_int_type> ipvt;     };   } } template <typename T> class Array; namespace octave {   namespace math   {     template <typename T>     class     qr     {     public:       typedef typename T::element_type ELT_T;       typedef typename T::row_vector_type RV_T;       typedef typename T::column_vector_type CV_T;       enum type       {         std,         raw,         economy       };                                                                                                                                                 protected:       T q;       T r;            };        } }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 namespace std __attribute__ ((__visibility__ ("default"))) {   enum _Rb_tree_color { _S_red = false, _S_black = true };   struct _Rb_tree_node_base   {     typedef _Rb_tree_node_base* _Base_ptr;     typedef const _Rb_tree_node_base* _Const_Base_ptr;     _Rb_tree_color _M_color;     _Base_ptr _M_parent;     _Base_ptr _M_left;     _Base_ptr _M_right;                       };   template<typename _Key_compare>     struct _Rb_tree_key_compare     {       _Key_compare _M_key_compare;                                 };   struct _Rb_tree_header   {     _Rb_tree_node_base _M_header;     size_t _M_node_count;                        };   template<typename _Val>     struct _Rb_tree_node : public _Rb_tree_node_base     {       typedef _Rb_tree_node<_Val>* _Link_type;       __gnu_cxx::__aligned_membuf<_Val> _M_storage;                   };               template<typename _Tp>     struct _Rb_tree_iterator     {       typedef _Tp value_type;       typedef _Tp& reference;       typedef _Tp* pointer;       typedef bidirectional_iterator_tag iterator_category;       typedef ptrdiff_t difference_type;       typedef _Rb_tree_iterator<_Tp> _Self;       typedef _Rb_tree_node_base::_Base_ptr _Base_ptr;       typedef _Rb_tree_node<_Tp>* _Link_type;                                                                             _Base_ptr _M_node;   };   template<typename _Tp>     struct _Rb_tree_const_iterator     {       typedef _Tp value_type;       typedef const _Tp& reference;       typedef const _Tp* pointer;       typedef _Rb_tree_iterator<_Tp> iterator;       typedef bidirectional_iterator_tag iterator_category;       typedef ptrdiff_t difference_type;       typedef _Rb_tree_const_iterator<_Tp> _Self;       typedef _Rb_tree_node_base::_Const_Base_ptr _Base_ptr;       typedef const _Rb_tree_node<_Tp>* _Link_type;                                                                                           _Base_ptr _M_node;     };         template<typename _Key, typename _Val, typename _KeyOfValue,     typename _Compare, typename _Alloc = allocator<_Val> >     class _Rb_tree     {       typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template  rebind<_Rb_tree_node<_Val> >::other _Node_allocator;       typedef __gnu_cxx::__alloc_traits<_Node_allocator> _Alloc_traits;     protected:       typedef _Rb_tree_node_base* _Base_ptr;       typedef const _Rb_tree_node_base* _Const_Base_ptr;       typedef _Rb_tree_node<_Val>* _Link_type;       typedef const _Rb_tree_node<_Val>* _Const_Link_type;     private:       struct _Reuse_or_alloc_node       {            ;       private:    _Base_ptr _M_root;  _Base_ptr _M_nodes;  _Rb_tree& _M_t;       };       struct _Alloc_node       {        ;       private:  _Rb_tree& _M_t;       };     public:       typedef _Key key_type;       typedef _Val value_type;       typedef value_type* pointer;       typedef const value_type* const_pointer;       typedef value_type& reference;       typedef const value_type& const_reference;       typedef size_t size_type;       typedef ptrdiff_t difference_type;       typedef _Alloc allocator_type;                          protected:                       ;         ;                       ;     protected:       template<typename _Key_compare,         bool  = __is_pod(_Key_compare)>  struct _Rb_tree_impl  : public _Node_allocator  , public _Rb_tree_key_compare<_Key_compare>  , public _Rb_tree_header  {    typedef _Rb_tree_key_compare<_Key_compare> _Base_key_compare;                          };       _Rb_tree_impl<_Compare> _M_impl;     protected:                                                                                                                                                               public:       typedef _Rb_tree_iterator<value_type> iterator;       typedef _Rb_tree_const_iterator<value_type> const_iterator;       typedef std::reverse_iterator<iterator> reverse_iterator;       typedef std::reverse_iterator<const_iterator> const_reverse_iterator;                                 private:       ;              ;       ;                     ;         ;                                               public:                                                      private:                   public:                                                                                                                                          ;       ;       ;         ;       ;         ;       ;       ;       ;       ;       template<typename _Iter>  using __same_value_type    = is_same<value_type, typename iterator_traits<_Iter>::value_type>;         ;         ;         ;         ;     private:                   public:                                                                                                                              ;       ;     private:                                                                           };        ;                                                                                                                                  }  /*  *  * Copyright (c) 1994  * Hewlett-Packard Company  *  * Permission to use, copy, modify, distribute and sell this software  * and its documentation for any purpose is hereby granted without fee,  * provided that the above copyright notice appear in all copies and  * that both that copyright notice and this permission notice appear  * in supporting documentation.  Hewlett-Packard Company makes no  * representations about the suitability of this software for any  * purpose.  It is provided "as is" without express or implied warranty.  *  *  * Copyright (c) 1996,1997  * Silicon Graphics Computer Systems, Inc.  *  * Permission to use, copy, modify, distribute and sell this software  * and its documentation for any purpose is hereby granted without fee,  * provided that the above copyright notice appear in all copies and  * that both that copyright notice and this permission notice appear  * in supporting documentation.  Silicon Graphics makes no  * representations about the suitability of this software for any  * purpose.  It is provided "as is" without express or implied warranty.  *//** @file bits/stl_set.h  *  This is an internal header file, included by other library headers.  *  Do not attempt to use it directly. @headername{set}  */namespace std __attribute__ ((__visibility__ ("default"))) {   template<typename _Key, typename _Compare, typename _Alloc>     class multiset;   /**    *  @brief A standard container made up of unique keys, which can be    *  retrieved in logarithmic time.    *    *  @ingroup associative_containers    *    *  @tparam _Key  Type of key objects.    *  @tparam _Compare  Comparison function object type, defaults to less<_Key>.    *  @tparam _Alloc  Allocator type, defaults to allocator<_Key>.    *    *  Meets the requirements of a <a href="tables.html#65">container</a>, a    *  <a href="tables.html#66">reversible container</a>, and an    *  <a href="tables.html#69">associative container</a> (using unique keys).    *    *  Sets support bidirectional iterators.    *    *  The private tree data is declared exactly the same way for set and    *  multiset; the distinction is made entirely in how the tree functions are    *  called (*_unique versus *_equal, same as the standard).   */  template<typename _Key, typename _Compare = std::less<_Key>,     typename _Alloc = std::allocator<_Key> >     class set     {       static_assert(is_same<typename remove_cv<_Key>::type, _Key>::value,    "std::set must have a non-const, non-volatile value_type");     public:       typedef _Key key_type;       typedef _Key value_type;       typedef _Compare key_compare;       typedef _Compare value_compare;       typedef _Alloc allocator_type;     private:       typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template  rebind<_Key>::other _Key_alloc_type;       typedef _Rb_tree<key_type, value_type, _Identity<value_type>,          key_compare, _Key_alloc_type> _Rep_type;       _Rep_type _M_t;        typedef __gnu_cxx::__alloc_traits<_Key_alloc_type> _Alloc_traits;     public:       typedef typename _Alloc_traits::pointer pointer;       typedef typename _Alloc_traits::const_pointer const_pointer;       typedef typename _Alloc_traits::reference reference;       typedef typename _Alloc_traits::const_reference const_reference;       typedef typename _Rep_type::const_iterator iterator;       typedef typename _Rep_type::const_iterator const_iterator;       typedef typename _Rep_type::const_reverse_iterator reverse_iterator;       typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;       typedef typename _Rep_type::size_type size_type;       typedef typename _Rep_type::difference_type difference_type;       /**        *  @brief  Default constructor creates no elements.        */             /**        *  @brief  Creates a %set with no elements.        *  @param  __comp  Comparator to use.        *  @param  __a  An allocator object.        */             /**        *  @brief  Builds a %set from a range.        *  @param  __first  An input iterator.        *  @param  __last  An input iterator.        *        *  Create a %set consisting of copies of the elements from        *  [__first,__last).  This is linear in N if the range is        *  already sorted, and NlogN otherwise (where N is        *  distance(__first,__last)).        */         ;       /**        *  @brief  Builds a %set from a range.        *  @param  __first  An input iterator.        *  @param  __last  An input iterator.        *  @param  __comp  A comparison functor.        *  @param  __a  An allocator object.        *        *  Create a %set consisting of copies of the elements from        *  [__first,__last).  This is linear in N if the range is        *  already sorted, and NlogN otherwise (where N is        *  distance(__first,__last)).        */         ;       /**        *  @brief  %Set copy constructor.        *        *  Whether the allocator is copied depends on the allocator traits.        */            /**        *  @brief %Set move constructor        *        *  The newly-created %set contains the exact contents of the moved        *  instance. The moved instance is a valid, but unspecified, %set.        */             /**        *  @brief  Builds a %set from an initializer_list.        *  @param  __l  An initializer_list.        *  @param  __comp  A comparison functor.        *  @param  __a  An allocator object.        *        *  Create a %set consisting of copies of the elements in the list.        *  This is linear in N if the list is already sorted, and NlogN        *  otherwise (where N is @a __l.size()).        */                                            ;       /**        *  The dtor only erases the elements, and note that if the elements        *  themselves are pointers, the pointed-to memory is not touched in any        *  way. Managing the pointer is the user's responsibility.
       */
 ;
 ;
 ;
      ;
      ;
    };
  template <typename _Key, typename _Compare = std::less<_Key>,
     typename _Alloc = std::allocator<_Key> >
    class multiset
    {
      static_assert(is_same<typename remove_cv<_Key>::type, _Key>::value,
   "std::multiset must have a non-const, non-volatile value_type");
    public:
      typedef _Key key_type;
      typedef _Key value_type;
      typedef _Compare key_compare;
      typedef _Compare value_compare;
      typedef _Alloc allocator_type;
      ;
      ;
    };
    ;
    ;
    ;
    ;
    ;
    ;
    ;
} 
namespace std
{
  using ::clock_t;
  using ::time_t;
  using ::tm;
} 
namespace octave
{
  namespace sys
  {
    class base_tm;
    class
    time
    {
    public:
    private:
      time_t ot_unix_time;
      long ot_usec;
    };
    class
    base_tm
    {
    public:
    protected:
      int m_usec;
      int m_sec;
      int m_min;
      int m_hour;
      int m_mday;
      int m_mon;
      int m_year;
      int m_wday;
      int m_yday;
      int m_isdst;
      long m_gmtoff;
      std::string m_zone;
    };
    class
    strptime : public base_tm
    {
    public:
    private:
      int nchars;
    };
    class
    cpu_time
    {
    public:
      friend class resource_usage;
      long m_nvcsw;
      long m_nivcsw;
    };
  }
}
namespace std __attribute__ ((__visibility__ ("default")))
{
  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    class multimap;
  template <typename _Key, typename _Tp, typename _Compare = std::less<_Key>,
     typename _Alloc = std::allocator<std::pair<const _Key, _Tp> > >
    class map
    {
    public:
      typedef _Key key_type;
      typedef _Tp mapped_type;
      typedef std::pair<const _Key, _Tp> value_type;
      typedef _Compare key_compare;
      typedef _Alloc allocator_type;
    private:
    public:
      class value_compare
      : public std::binary_function<value_type, value_type, bool>
      {
 friend class map<_Key, _Tp, _Compare, _Alloc>;
      protected:
 _Compare comp;
      public:
      };
    private:
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
 rebind<value_type>::other _Pair_alloc_type;
      typedef _Rb_tree<key_type, value_type, _Select1st<value_type>,
         key_compare, _Pair_alloc_type> _Rep_type;
      _Rep_type _M_t;
      typedef __gnu_cxx::__alloc_traits<_Pair_alloc_type> _Alloc_traits;
    public:
      typedef typename _Alloc_traits::pointer pointer;
      typedef typename _Alloc_traits::const_pointer const_pointer;
      typedef typename _Alloc_traits::reference reference;
      typedef typename _Alloc_traits::const_reference const_reference;
      typedef typename _Rep_type::iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;
      typedef typename _Rep_type::reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
      ;
      ;
    };
    ;
    ;
    ;
    ;
    ;
    ;
    ;
} 
namespace std __attribute__ ((__visibility__ ("default")))
{
  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    class map;
  template <typename _Key, typename _Tp,
     typename _Compare = std::less<_Key>,
     typename _Alloc = std::allocator<std::pair<const _Key, _Tp> > >
    class multimap
    {
    public:
      typedef _Key key_type;
      typedef _Tp mapped_type;
      typedef std::pair<const _Key, _Tp> value_type;
      typedef _Compare key_compare;
      typedef _Alloc allocator_type;
    private:
    public:
      class value_compare
      : public std::binary_function<value_type, value_type, bool>
      {
 friend class multimap<_Key, _Tp, _Compare, _Alloc>;
      protected:
 _Compare comp;
      public:
      };
    private:
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
 rebind<value_type>::other _Pair_alloc_type;
      typedef _Rb_tree<key_type, value_type, _Select1st<value_type>,
         key_compare, _Pair_alloc_type> _Rep_type;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
      ;
      ;
  };
    ;
    ;
    ;
    ;
    ;
    ;
    ;
} 
class
Range
{
public:
private:
  double rng_base;
  double rng_limit;
  double rng_inc;
  octave_idx_type rng_numel;
  mutable Matrix cache;
protected:
};
namespace octave
{
  namespace mach_info
  {
    enum float_format
    {
      flt_fmt_unknown = 0,
      flt_fmt_ieee_little_endian = 1,
      flt_fmt_ieee_big_endian = 2,
    };
  }
}
class oct_mach_info
{
public:
  typedef octave::mach_info::float_format float_format;
};
class
oct_data_conv
{
public:
  enum data_type
  {
    dt_int8 = 0,
    dt_uint8 = 1,
    dt_int16 = 2,
    dt_uint16 = 3,
    dt_int32 = 4,
    dt_uint = 17,
    dt_long = 18,
    dt_ulong = 19,
    dt_longlong = 20,
    dt_ulonglong = 21,
    dt_float = 22,
    dt_unknown = 23 
  };
};
enum save_type
{
  LS_U_CHAR = 0,
  LS_U_SHORT = 1,
  LS_U_INT = 2,
  LS_CHAR = 3,
  LS_SHORT = 4,
  LS_INT = 5,
  LS_FLOAT = 6,
  LS_DOUBLE = 7,
  LS_U_LONG = 8,
  LS_LONG = 9
};
;
namespace octave
{
  class type_info;
}
class Cell;
class float_format;
class mxArray;
class octave_map;
class octave_scalar_map;
class octave_function;
class octave_user_function;
class octave_fcn_handle;
class octave_fcn_inline;
/* Macros for printing `intmax_t' and `uintmax_t'.  */
/* Macros for printing `intptr_t' and `uintptr_t'.  */
/* Macros for scanning format specifiers.  */
/* Signed decimal notation.  */
/* Signed decimal notation.  */
/* Unsigned decimal notation.  */
/* Octal notation.  */
/* Hexadecimal notation.  */
/* Macros for scanning `intmax_t' and `uintmax_t'.  */
/* Macros for scaning `intptr_t' and `uintptr_t'.  */
extern "C" {
/* We have to define the `uintmax_t' type using `ldiv_t'.  */
typedef struct
  {
    long int quot; /* Quotient.  */
    long int rem; /* Remainder.  */
  } imaxdiv_t;
/* Compute absolute value of N.  */
;
/* Return the `imaxdiv_t' representation of the value of NUMER over DENOM. */; ; ; ; ; } namespace std {   using ::imaxdiv_t;                   }  namespace std __attribute__ ((__visibility__ ("default"))) {      template<typename _Tp, typename _Ref, typename _Ptr>     struct _Deque_iterator     {     private:       template<typename _Up>  using __ptr_to = typename pointer_traits<_Ptr>::template rebind<_Up>;       template<typename _CvTp>  using __iter = _Deque_iterator<_Tp, _CvTp&, __ptr_to<_CvTp>>;     public:       typedef __iter<_Tp> iterator;       typedef __iter<const _Tp> const_iterator;       typedef __ptr_to<_Tp> _Elt_pointer;       typedef __ptr_to<_Elt_pointer> _Map_pointer;              typedef std::random_access_iterator_tag iterator_category;       typedef _Tp value_type;       typedef _Ptr pointer;       typedef _Ref reference;       typedef size_t size_type;       typedef ptrdiff_t difference_type;       typedef _Deque_iterator _Self;       _Elt_pointer _M_cur;       _Elt_pointer _M_first;       _Elt_pointer _M_last;       _Map_pointer _M_node;                       ;                                                                                                              };        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;   ;   ;        ;   ;        ;   ;        ;   ;        ;   template<typename _Tp, typename _Alloc>     class _Deque_base     {     protected:       typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template  rebind<_Tp>::other _Tp_alloc_type;       typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Alloc_traits;       typedef typename _Alloc_traits::pointer _Ptr;       typedef typename _Alloc_traits::const_pointer _Ptr_const;       typedef typename _Alloc_traits::template rebind<_Ptr>::other  _Map_alloc_type;       typedef __gnu_cxx::__alloc_traits<_Map_alloc_type> _Map_alloc_traits;     public:       typedef _Alloc allocator_type;              typedef _Deque_iterator<_Tp, _Tp&, _Ptr> iterator;       typedef _Deque_iterator<_Tp, const _Tp&, _Ptr_const> const_iterator;                                                                    protected:       typedef typename iterator::_Map_pointer _Map_pointer;       struct _Deque_impl       : public _Tp_alloc_type       {  _Map_pointer _M_map;  size_t _M_map_size;  iterator _M_start;  iterator _M_finish;        _Deque_impl(_Tp_alloc_type&& __a)   ;  void _M_swap_data(_Deque_impl& __x) noexcept  ;       };       _Tp_alloc_type&       _M_get_Tp_allocator() noexcept       ;       const _Tp_alloc_type&       _M_get_Tp_allocator() const noexcept       ;       _Map_alloc_type       _M_get_map_allocator() const noexcept       ;       _Ptr       _M_allocate_node()       ;       void       _M_deallocate_node(_Ptr __p) noexcept       ;       _Map_pointer       _M_allocate_map(size_t __n)       ;       void       _M_deallocate_map(_Map_pointer __p, size_t __n) noexcept       ;     protected:       void _M_initialize_map(size_t);       void _M_create_nodes(_Map_pointer __nstart, _Map_pointer __nfinish);       void _M_destroy_nodes(_Map_pointer __nstart,        _Map_pointer __nfinish) noexcept;       enum { _S_initial_map_size = 8 };       _Deque_impl _M_impl;     private:       _Deque_impl       _M_move_impl()       ;     };               template<typename _Tp, typename _Alloc = std::allocator<_Tp> >     class deque : protected _Deque_base<_Tp, _Alloc>     {       static_assert(is_same<typename remove_cv<_Tp>::type, _Tp>::value,    "std::deque must have a non-const, non-volatile value_type");       typedef _Deque_base<_Tp, _Alloc> _Base;       typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;       typedef typename _Base::_Alloc_traits _Alloc_traits;       typedef typename _Base::_Map_pointer _Map_pointer;     public:       typedef _Tp value_type;       typedef typename _Alloc_traits::pointer pointer;       typedef typename _Alloc_traits::const_pointer const_pointer;       typedef typename _Alloc_traits::reference reference;       typedef typename _Alloc_traits::const_reference const_reference;       typedef typename _Base::iterator iterator;       typedef typename _Base::const_iterator const_iterator;       typedef std::reverse_iterator<const_iterator> const_reverse_iterator;       typedef std::reverse_iterator<iterator> reverse_iterator;       typedef size_t size_type;       typedef ptrdiff_t difference_type;       typedef _Alloc allocator_type;     protected:       static size_t _S_buffer_size() noexcept       ;       using _Base::_M_initialize_map;       using _Base::_M_create_nodes;       using _Base::_M_destroy_nodes;       using _Base::_M_allocate_node;       using _Base::_M_deallocate_node;       using _Base::_M_allocate_map;       using _Base::_M_deallocate_map;       using _Base::_M_get_Tp_allocator;       using _Base::_M_impl;     public:       deque()  ;                                                                  ;                                            ;                                                                                                                                                                                  protected:            public:                                                               ;                     ;                     ;                                     ;                                 protected:         ;                       ;       ;       ;                       ;         ;       ;         ;              ;       ;                       ;         ;       ;       ;              ;              ;                ;                                                                                    /**        *  @brief Memory-handling helpers for the major %map.        *        *  Makes sure the _M_map has space for new nodes.  Does not        *  actually add the nodes.  Can invalidate _M_map pointers.        *  (And consequently, %deque iterators.)        */                                                ;                   };        ;        ;        ;        ;        ;        ;        ;   template<class _Tp>     struct __is_bitwise_relocatable<std::deque<_Tp>>     : true_type { }; }  namespace std __attribute__ ((__visibility__ ("default"))) {                                                                                             ;        ;        ;        ;        ; }  namespace std __attribute__ ((__visibility__ ("default"))) {   template<typename _Tp, typename _Sequence = deque<_Tp> >     class stack     {       ;       ;       template<typename _Alloc>  using _Uses = typename    enable_if<uses_allocator<_Sequence, _Alloc>::value>::type;     public:       typedef typename _Sequence::value_type value_type;       typedef typename _Sequence::reference reference;       typedef typename _Sequence::const_reference const_reference;       typedef typename _Sequence::size_type size_type;       typedef _Sequence container_type;     protected:       _Sequence c;     public:         ;                       ;         ;         ;         ;         ;                                                                      ;                   };        ;        ;        ;        ;        ;        ;        ;   template<typename _Tp, typename _Seq, typename _Alloc>     struct uses_allocator<stack<_Tp, _Seq>, _Alloc>     : public uses_allocator<_Seq, _Alloc>::type { }; }  namespace std __attribute__ ((__visibility__ ("default"))) {   class bad_function_call : public std::exception   {   public:             };   template<typename _Tp>     struct __is_location_invariant     : is_trivially_copyable<_Tp>::type     { };   class _Undefined_class;   union _Nocopy_types   {     void* _M_object;     const void* _M_const_object;     void (*_M_function_pointer)();     void (_Undefined_class::*_M_member_pointer)();   };   union [[gnu::may_alias]] _Any_data   {     void* _M_access() { return &_M_pod_data[0]; }     const void* _M_access() const { return &_M_pod_data[0]; }     template<typename _Tp>       _Tp&       _M_access()       { return *static_cast<_Tp*>(_M_access()); }     template<typename _Tp>       const _Tp&       _M_access() const       { return *static_cast<const _Tp*>(_M_access()); }     _Nocopy_types _M_unused;     char _M_pod_data[sizeof(_Nocopy_types)];   };   enum _Manager_operation   {     __get_type_info,     __get_functor_ptr,     __clone_functor,     __destroy_functor   };   template<typename _Tp>     struct _Simple_type_wrapper     {              _Tp __value;     };   template<typename _Tp>     struct __is_location_invariant<_Simple_type_wrapper<_Tp> >     : __is_location_invariant<_Tp>     { };   template<typename _Signature>     class function;   class _Function_base   {   public:     static const size_t _M_max_size = sizeof(_Nocopy_types);     static const size_t _M_max_align = __alignof__(_Nocopy_types);     template<typename _Functor>       class _Base_manager       {       protected:  static const bool __stored_locally =  (__is_location_invariant<_Functor>::value   && sizeof(_Functor) <= _M_max_size   && __alignof__(_Functor) <= _M_max_align   && (_M_max_align % __alignof__(_Functor) == 0));  typedef integral_constant<bool, __stored_locally> _Local_storage;                 public:          ;      ;      ;      ;       private:           };                    typedef bool (*_Manager_type)(_Any_data&, const _Any_data&,       _Manager_operation);     _Any_data _M_functor;     _Manager_type _M_manager;   };   template<typename _Signature, typename _Functor>     class _Function_handler;   template<typename _Res, typename _Functor, typename... _ArgTypes>     class _Function_handler<_Res(_ArgTypes...), _Functor>     : public _Function_base::_Base_manager<_Functor>     {       typedef _Function_base::_Base_manager<_Functor> _Base;     public:            };   template<typename _Functor, typename... _ArgTypes>     class _Function_handler<void(_ArgTypes...), _Functor>     : public _Function_base::_Base_manager<_Functor>     {       typedef _Function_base::_Base_manager<_Functor> _Base;      public:            };   template<typename _Class, typename _Member, typename _Res,     typename... _ArgTypes>     class _Function_handler<_Res(_ArgTypes...), _Member _Class::*>     : public _Function_handler<void(_ArgTypes...), _Member _Class::*>     {       typedef _Function_handler<void(_ArgTypes...), _Member _Class::*>  _Base;      public:            };   template<typename _Class, typename _Member, typename... _ArgTypes>     class _Function_handler<void(_ArgTypes...), _Member _Class::*>     : public _Function_base::_Base_manager<    _Simple_type_wrapper< _Member _Class::* > >     {       typedef _Member _Class::* _Functor;       typedef _Simple_type_wrapper<_Functor> _Wrapper;       typedef _Function_base::_Base_manager<_Wrapper> _Base;     public:                   };   template<typename _From, typename _To>     using __check_func_return_type       = __or_<is_void<_To>, is_same<_From, _To>, is_convertible<_From, _To>>;   template<typename _Res, typename... _ArgTypes>     class function<_Res(_ArgTypes...)>     : public _Maybe_unary_or_binary_function<_Res, _ArgTypes...>,       private _Function_base     {       template<typename _Func,         typename _Res2 = typename result_of<_Func&(_ArgTypes...)>::type>  struct _Callable : __check_func_return_type<_Res2, _Res> { };       template<typename _Tp>  struct _Callable<function, _Tp> : false_type { };       template<typename _Cond, typename _Tp>  using _Requires = typename enable_if<_Cond::value, _Tp>::type;     public:       typedef _Res result_type;       /**        *  @brief Default construct creates an empty function call wrapper.        *  @post @c !(bool)*this        */             /**        *  @brief Creates an empty function call wrapper.        *  @post @c !(bool)*this        */             /**        *  @brief %Function copy constructor.        *  @param __x A %function object with identical call signature.        *  @post @c bool(*this) == bool(__x)        *        *  The newly-created %function contains a copy of the target of @a        *  __x (if it has one).        */             /**        *  @brief %Function move constructor.        *  @param __x A %function object rvalue with identical call signature.        *        *  The newly-created %function contains the target of @a __x        *  (if it has one).        */             /**        *  @brief Builds a %function that targets a copy of the incoming        *  function object.        *  @param __f A %function object that is callable with parameters of        *  type @c T1, @c T2, ..., @c TN and returns a value convertible        *  to @c Res.        *        *  The newly-created %function object will target a copy of        *  @a __f. If @a __f is @c reference_wrapper<F>, then this function        *  object will contain a reference to the function object @c        *  __f.get(). If @a __f is a NULL function pointer or NULL        *  pointer-to-member, the newly-created object will be empty.        *        *  If @a __f is a non-NULL function pointer or an object of type @c        *  reference_wrapper<F>, this function will not throw.        */      ;       /**        *  @brief %Function assignment operator.        *  @param __x A %function with identical call signature.        *  @post @c (bool)*this == (bool)x        *  @returns @c *this        *        *  The target of @a __x is copied to @c *this. If @a __x has no        *  target, then @c *this will be empty.        *        *  If @a __x targets a function pointer or a reference to a function        *  object, then this operation will not throw an %exception.        */             /**        *  @brief %Function move-assignment operator.        *  @param __x A %function rvalue with identical call signature.        *  @returns @c *this        *        *  The target of @a __x is moved to @c *this. If @a __x has no        *  target, then @c *this will be empty.        *        *  If @a __x targets a function pointer or a reference to a function        *  object, then this operation will not throw an %exception.        */             /**        *  @brief %Function assignment to zero.        *  @post @c !(bool)*this        *  @returns @c *this        *        *  The target of @c *this is deallocated, leaving it empty.        */             /**        *  @brief %Function assignment to a new target.        *  @param __f A %function object that is callable with parameters of        *  type @c T1, @c T2, ..., @c TN and returns a value convertible        *  to @c Res.        *  @return @c *this        *        *  This  %function object wrapper will target a copy of @a        *  __f. If @a __f is @c reference_wrapper<F>, then this function        *  object will contain a reference to the function object @c        *  __f.get(). If @a __f is a NULL function pointer or NULL        *  pointer-to-member, @c this object will be empty.        *        *  If @a __f is a non-NULL function pointer or an object of type @c        *  reference_wrapper<F>, this function will not throw.        */        ;         ;       /**        *  @brief Swap the targets of two %function objects.        *  @param __x A %function with identical call signature.        *        *  Swap the targets of @c this function object and @a __f. This        *  function will not throw an %exception.        */             /**        *  @brief Determine if the %function wrapper has a target.        *        *  @return @c true when this %function object contains a target,        *  or @c false when it is empty.        *        *  This function will not throw an %exception.        */      explicit operator bool() const noexcept       ;       /**        *  @brief Invokes the function targeted by @c *this.        *  @returns the result of the target.        *  @throws bad_function_call when @c !(bool)*this        *        *  The function call operator invokes the target function object        *  stored by @c this.        */      _Res operator()(_ArgTypes... __args) const;       /**        *  @brief Determine the type of the target of this function object        *  wrapper.        *        *  @returns the type identifier of the target function object, or        *  @c typeid(void) if @c !(bool)*this.        *        *  This function will not throw an %exception.        */      const type_info& target_type() const noexcept;       /**        *  @brief Access the stored target function object.        *        *  @return Returns a pointer to the stored target function object,        *  if @c typeid(_Functor).equals(target_type()); otherwise, a NULL        *  pointer.        *        * This function does not throw exceptions.        *        * @{        */      template<typename _Functor> _Functor* target() noexcept;       template<typename _Functor> const _Functor* target() const noexcept;     private:       using _Invoker_type = _Res (*)(const _Any_data&, _ArgTypes&&...);       _Invoker_type _M_invoker;   };                     /**    *  @brief Compares a polymorphic function object wrapper against 0    *  (the NULL pointer).    *  @returns @c true if the wrapper has no target, @c false otherwise    *    *  This function will not throw an %exception.    */  template<typename _Res, typename... _Args>      bool     operator==(const function<_Res(_Args...)>& __f, nullptr_t) noexcept     ;   template<typename _Res, typename... _Args>      bool     operator==(nullptr_t, const function<_Res(_Args...)>& __f) noexcept     ;   /**    *  @brief Compares a polymorphic function object wrapper against 0    *  (the NULL pointer).    *  @returns @c false if the wrapper has no target, @c true otherwise    *    *  This function will not throw an %exception.    */  template<typename _Res, typename... _Args>      bool     operator!=(const function<_Res(_Args...)>& __f, nullptr_t) noexcept     ;   template<typename _Res, typename... _Args>      bool     operator!=(nullptr_t, const function<_Res(_Args...)>& __f) noexcept     ;   /**    *  @brief Swap the targets of two polymorphic function object wrappers.    *    *  This function will not throw an %exception.    */  template<typename _Res, typename... _Args>      void     swap(function<_Res(_Args...)>& __x, function<_Res(_Args...)>& __y) noexcept     ; }  namespace std __attribute__ ((__visibility__ ("default"))) {   template<typename _MemFunPtr,     bool __is_mem_fn = is_member_function_pointer<_MemFunPtr>::value>     class _Mem_fn_base     : public _Mem_fn_traits<_MemFunPtr>::__maybe_type     {       using _Traits = _Mem_fn_traits<_MemFunPtr>;       using _Arity = typename _Traits::__arity;       using _Varargs = typename _Traits::__vararg;       template<typename _Func, typename... _BoundArgs>  friend struct _Bind_check_arity;       _MemFunPtr _M_pmf;     public:       using result_type = typename _Traits::__result_type;       explicit constexpr       _Mem_fn_base(_MemFunPtr __pmf)  ;       template<typename... _Args>  auto  operator()(_Args&&... __args) const  noexcept(noexcept(        std::__invoke(_M_pmf, std::forward<_Args>(__args)...)))  -> decltype(std::__invoke(_M_pmf, std::forward<_Args>(__args)...))  ;     };   template<typename _MemObjPtr>     class _Mem_fn_base<_MemObjPtr, false>     {       using _Arity = integral_constant<size_t, 0>;       using _Varargs = false_type;       template<typename _Func, typename... _BoundArgs>  friend struct _Bind_check_arity;       _MemObjPtr _M_pm;     public:       explicit constexpr       _Mem_fn_base(_MemObjPtr __pm)  ;       template<typename _Tp>  auto  operator()(_Tp&& __obj) const  noexcept(noexcept(std::__invoke(_M_pm, std::forward<_Tp>(__obj))))  -> decltype(std::__invoke(_M_pm, std::forward<_Tp>(__obj)))  ;     };   template<typename _MemberPointer>     struct _Mem_fn;    template<typename _Res, typename _Class>     struct _Mem_fn<_Res _Class::*>     : _Mem_fn_base<_Res _Class::*>     {       using _Mem_fn_base<_Res _Class::*>::_Mem_fn_base;     };   /**    *  @brief Returns a function object that forwards to the member    *  pointer @a pm.    *  @ingroup functors    */  template<typename _Tp, typename _Class>      _Mem_fn<_Tp _Class::*>     mem_fn(_Tp _Class::* __pm) noexcept     ;   /**    *  @brief Determines if the given type _Tp is a function object that    *  should be treated as a subexpression when evaluating calls to    *  function objects returned by bind().    *    *  C++11 [func.bind.isbind].    *  @ingroup binders    */  template<typename _Tp>     struct is_bind_expression     : public false_type { };   /**    *  @brief Determines if the given type _Tp is a placeholder in a    *  bind() expression and, if so, which placeholder it is.    *    *  C++11 [func.bind.isplace].    *  @ingroup binders    */  template<typename _Tp>     struct is_placeholder     : public integral_constant<int, 0>     { };   /** @brief The type of placeholder objects defined by libstdc++.    *  @ingroup binders    */  template<int _Num> struct _Placeholder { };   /** @namespace std::placeholders    *  @brief ISO C++11 entities sub-namespace for functional.    *  @ingroup binders    */  namespace placeholders   {   /* Define a large number of placeholders. There is no way to    * simplify this with variadic templates, because we're introducing
   * unique names for each.
   */
    extern const _Placeholder<1> _1;
    extern const _Placeholder<2> _2;
    extern const _Placeholder<27> _27;
    extern const _Placeholder<28> _28;
    extern const _Placeholder<29> _29;
  }
  template<int _Num>
    struct is_placeholder<_Placeholder<_Num> >
    : public integral_constant<int, _Num>
    { };
  template<int _Num>
    struct is_placeholder<const _Placeholder<_Num> >
    : public integral_constant<int, _Num>
    { };
  template<std::size_t __i, typename _Tuple>
    using _Safe_tuple_element_t
      = typename enable_if<(__i < tuple_size<_Tuple>::value),
      tuple_element<__i, _Tuple>>::type::type;
  template<typename _Arg,
    bool _IsBindExp = is_bind_expression<_Arg>::value,
    bool _IsPlaceholder = (is_placeholder<_Arg>::value > 0)>
    class _Mu;
  template<typename _Tp>
    class _Mu<reference_wrapper<_Tp>, false, false>
    {
    public:
      template<typename _CVRef, typename _Tuple>
 _Tp&
 operator()(_CVRef& __arg, _Tuple&) const volatile
 ;
    };
  template<typename _Arg>
    class _Mu<_Arg, true, false>
    {
    public:
      template<typename _CVArg, typename... _Args>
 auto
 operator()(_CVArg& __arg,
     tuple<_Args...>& __tuple) const volatile
 -> decltype(__arg(declval<_Args>()...))
 ;
    private:
      template<typename _CVArg, typename... _Args, std::size_t... _Indexes>
 auto
 __call(_CVArg& __arg, tuple<_Args...>& __tuple,
        const _Index_tuple<_Indexes...>&) const volatile
 -> decltype(__arg(declval<_Args>()...))
 ;
    };
  template<typename _Arg>
    class _Mu<_Arg, false, true>
    {
    public:
      template<typename _Tuple>
 _Safe_tuple_element_t<(is_placeholder<_Arg>::value - 1), _Tuple>&&
 operator()(const volatile _Arg&, _Tuple& __tuple) const volatile
 ;
    };
  template<typename _Arg>
    class _Mu<_Arg, false, false>
    {
    public:
      template<typename _CVArg, typename _Tuple>
 _CVArg&&
 operator()(_CVArg&& __arg, _Tuple&) const volatile
 ;
    };
  template<std::size_t _Ind, typename... _Tp>
     auto
    __volget(volatile tuple<_Tp...>& __tuple)
    -> __tuple_element_t<_Ind, tuple<_Tp...>> volatile&
    ;
    ;
  template<typename _Signature>
    struct _Bind;
   template<typename _Functor, typename... _Bound_args>
    class _Bind<_Functor(_Bound_args...)>
    : public _Weak_result_type<_Functor>
    {
      typedef typename _Build_index_tuple<sizeof...(_Bound_args)>::__type
 _Bound_indexes;
      _Functor _M_f;
      tuple<_Bound_args...> _M_bound_args;
 ;
 ;
 ;
 ;
    };
  template<typename _Result, typename _Signature>
    struct _Bind_result;
  template<typename _Result, typename _Functor, typename... _Bound_args>
    class _Bind_result<_Result, _Functor(_Bound_args...)>
    {
      typedef typename _Build_index_tuple<sizeof...(_Bound_args)>::__type
 _Bound_indexes;
      _Functor _M_f;
      tuple<_Bound_args...> _M_bound_args;
      template<typename _Res>
 ;
    public:
      typedef _Result result_type;
 ;
 ;
 ;
 ;
 ;
 ;
    };
  template<typename _Signature>
    struct is_bind_expression<_Bind<_Signature> >
    : public true_type { };
  template<typename _Result, typename _Signature>
    struct is_bind_expression<const _Bind_result<_Result, _Signature>>
    : public true_type { };
  template<typename _Result, typename _Signature>
    struct is_bind_expression<volatile _Bind_result<_Result, _Signature>>
    : public true_type { };
  template<typename _Result, typename _Signature>
    struct is_bind_expression<const volatile _Bind_result<_Result, _Signature>>
    : public true_type { };
  template<typename _Func, typename... _BoundArgs>
    struct _Bind_check_arity { };
  template<bool _SocketLike, typename _Func, typename... _BoundArgs>
    struct _Bind_helper
    : _Bind_check_arity<typename decay<_Func>::type, _BoundArgs...>
    {
      typedef typename decay<_Func>::type __func_type;
      typedef _Bind<__func_type(typename decay<_BoundArgs>::type...)> type;
    };
  template<typename _Func, typename... _BoundArgs>
    struct _Bind_helper<true, _Func, _BoundArgs...>
    { };
    ;
  template<typename _Result, typename _Func, typename... _BoundArgs>
    struct _Bindres_helper
    : _Bind_check_arity<typename decay<_Func>::type, _BoundArgs...>
    {
      typedef typename decay<_Func>::type __functor_type;
      typedef _Bind_result<_Result,
      __functor_type(typename decay<_BoundArgs>::type...)>
 type;
    };
    ;
} 
namespace octave
{
  class
  action_container
  {
  public:
    class elem
    {
    public:
      friend class action_container;
    };
    class fcn_elem : public elem
    {
    public:
    private:
      std::function<void (void)> m_fcn;
    };
    template <typename T>
    class restore_var_elem : public elem
    {
    public:
    private:
      T *e_ptr, e_val;
    };
    template <typename T>
    class delete_ptr_elem : public elem
    {
    public:
    private:
      T *e_ptr;
    };
    ;
    ;
    ;
    ;
    ;
    ;
    ;
  protected:
  };
}
__attribute__ ((__deprecated__))
typedef octave::action_container action_container;
namespace octave
{
  class
  unwind_protect : public action_container
  {
  public:
  protected:
    std::stack<elem *> lifo;
  };
  class
  unwind_protect_safe : public unwind_protect
  {
  private:
  public:
  };
}
class octave_map;
class octave_value_list;
namespace octave
{
  class execution_exception;
}
extern bool Vdebug_on_error;
extern bool Vdebug_on_caught;
extern bool Vdebug_on_warning;
extern int error_state;
extern int warning_state;
extern int buffer_error_messages;
extern int in_try_catch;
extern bool discard_error_messages;
extern bool discard_warning_messages;
class octave_fcn_inline;
class octave_value_list;
enum builtin_type_t
{
  btyp_double,
  btyp_float,
  btyp_complex,
  btyp_float_complex,
  btyp_int8,
  btyp_int16,
  btyp_int32,
  btyp_int64,
  btyp_uint8,
  btyp_uint16,
  btyp_uint32,
  btyp_uint64,
  btyp_bool,
  btyp_char,
  btyp_struct,
  btyp_cell,
  btyp_func_handle,
  btyp_unknown,
  btyp_num_types = btyp_unknown
};
extern std::string
btyp_class_name [btyp_num_types];
template <typename T>
struct class_to_btyp
{
  static const builtin_type_t btyp = btyp_unknown;
};
template <> struct class_to_btyp<double> { static const builtin_type_t btyp = btyp_double; };
template <> struct class_to_btyp<float> { static const builtin_type_t btyp = btyp_float; };
template <> struct class_to_btyp<Complex> { static const builtin_type_t btyp = btyp_complex; };
template <> struct class_to_btyp<FloatComplex> { static const builtin_type_t btyp = btyp_float_complex; };
template <> struct class_to_btyp<octave_int8> { static const builtin_type_t btyp = btyp_int8; };
template <> struct class_to_btyp<octave_int16> { static const builtin_type_t btyp = btyp_int16; };
template <> struct class_to_btyp<octave_int32> { static const builtin_type_t btyp = btyp_int32; };
template <> struct class_to_btyp<octave_int64> { static const builtin_type_t btyp = btyp_int64; };
template <> struct class_to_btyp<octave_uint8> { static const builtin_type_t btyp = btyp_uint8; };
template <> struct class_to_btyp<octave_uint16> { static const builtin_type_t btyp = btyp_uint16; };
template <> struct class_to_btyp<octave_uint32> { static const builtin_type_t btyp = btyp_uint32; };
template <> struct class_to_btyp<octave_uint64> { static const builtin_type_t btyp = btyp_uint64; };
template <> struct class_to_btyp<bool> { static const builtin_type_t btyp = btyp_bool; };
template <> struct class_to_btyp<char> { static const builtin_type_t btyp = btyp_char; };
class
octave_base_value
{
public:
  typedef octave_base_value * (*type_conv_fcn) (const octave_base_value&);
  class type_conv_info
  {
  public:
  private:
    type_conv_fcn _fcn;
    int _type_id;
  };
  friend class octave_value;
  enum unary_mapper_t
  {
    umap_unknown,
    num_unary_mappers = umap_unknown
  };
protected:
  octave::refcount<octave_idx_type> count;
private:
  static int curr_print_indent_level;
  static bool beginning_of_line;
  public:         private: static int t_id; static const std::string t_name; static const std::string c_name;
};
extern bool Vsparse_auto_mutate;
class
octave_value
{
public:
  enum unary_op
  {
    op_not, 
    op_uplus, 
    op_uminus, 
    op_transpose, 
    op_hermitian, 
    op_incr,
    op_decr,
    op_div_eq,
    op_ldiv_eq,
    op_pow_eq,
    op_el_mul_eq,
    op_el_div_eq,
    op_el_ldiv_eq,
    op_el_pow_eq,
    op_el_and_eq,
    op_el_or_eq,
    num_assign_ops,
    unknown_assign_op
  };
  Array<octave_value> data;
  string_vector names;
};
;
class string_vector;
class
octave_fields
{
  class fields_rep : public std::map<std::string, octave_idx_type>
  {
  public:
    octave::refcount<int> count;
  private:
  };
  fields_rep *rep;
public:
  typedef std::map<std::string, octave_idx_type>::const_iterator const_iterator;
  typedef const_iterator iterator;
};
class
octave_scalar_map
{
public:
  typedef octave_fields::const_iterator const_iterator;
  typedef const_iterator iterator;
private:
  octave_fields xkeys;
  std::vector<Cell> xvals;
  dim_vector dimensions;
};
class string_vector;
namespace octave
{
  class type_info
  {
  public:
    typedef octave_value (*unary_class_op_fcn) (const octave_value&);
    typedef octave_value (*unary_op_fcn) (const octave_base_value&);
    typedef void (*non_const_unary_op_fcn) (octave_base_value&);
    typedef octave_value (*binary_class_op_fcn)
    (const octave_value&, const octave_value&);
    typedef octave_value (*binary_op_fcn)
    (const octave_base_value&, const octave_base_value&);
    typedef octave_value (*cat_op_fcn)
    (octave_base_value&, const octave_base_value&,
     const Array<octave_idx_type>& ra_idx);
    typedef octave_value (*assign_op_fcn)
    (octave_base_value&, const octave_value_list&, const octave_base_value&);
    typedef octave_value (*assignany_op_fcn)
    (octave_base_value&, const octave_value_list&, const octave_value&);
  private:
    int num_types;
    Array<std::string> types;
    Array<octave_value *> vals;
    Array<void *> unary_class_ops;
    Array<void *> unary_ops;
    Array<void *> non_const_unary_ops;
    Array<void *> binary_class_ops;
    Array<void *> binary_ops;
    Array<void *> compound_binary_class_ops;
    Array<void *> compound_binary_ops;
    Array<void *> cat_ops;
    Array<void *> assign_ops;
    Array<void *> assignany_ops;
    Array<int> pref_assign_conv;
    Array<void *> widening_ops;
  };
}
namespace octave_value_typeinfo
{
  typedef octave::type_info::unary_class_op_fcn unary_class_op_fcn;
  typedef octave::type_info::unary_op_fcn unary_op_fcn;
  typedef octave::type_info::non_const_unary_op_fcn non_const_unary_op_fcn;
  typedef octave::type_info::binary_class_op_fcn binary_class_op_fcn;
  typedef octave::type_info::binary_op_fcn binary_op_fcn;
  typedef octave::type_info::cat_op_fcn cat_op_fcn;
  typedef octave::type_info::assign_op_fcn assign_op_fcn;
  typedef octave::type_info::assignany_op_fcn assignany_op_fcn;
}
/*
Copyright (C) 1993-2019 John W. Eaton
Copyright (C) 2009 VZLU Prague
This file is part of Octave.
Octave is free software: you can redistribute it and/or modify it
*/
/** @file include/fstream
 *  This is a Standard C++ Library header.
 */
/** @file bits/codecvt.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{locale}
 */
namespace std __attribute__ ((__visibility__ ("default")))
{
  class codecvt_base
  {
  public:
    enum result
    {
      ok,
      partial,
      error,
      noconv
    };
  };
  /**
   *  @brief  Common base for codecvt functions.
   *
   *  This template class provides implementations of the public functions
   *  that forward to the protected virtual functions.
   *
   *  This template also provides abstract stubs for the protected virtual
   *  functions.
  */
  template<typename _InternT, typename _ExternT, typename _StateT>
    class __codecvt_abstract_base
    : public locale::facet, public codecvt_base
    {
    public:
      typedef codecvt_base::result result;
      typedef _InternT intern_type;
      typedef _ExternT extern_type;
      typedef _StateT state_type;
      /**
       *  @brief  Convert from internal to external character set.
       *
       *  Converts input string of intern_type to output string of
       *  extern_type.  This is analogous to wcsrtombs.  It does this by
       *  calling codecvt::do_out.
       *
       *  The source and destination character sets are determined by the
       *  facet's locale, internal and external types.        *        *  The characters in [from,from_end) are converted and written to        *  [to,to_end).  from_next and to_next are set to point to the        *  character following the last successfully converted character,        *  respectively.  If the result needed no conversion, from_next and        *  to_next are not affected.        *        *  The @a state argument should be initialized if the input is at the        *  beginning and carried from a previous call if continuing        *  conversion.  There are no guarantees about how @a state is used.        *        *  The result returned is a member of codecvt_base::result.  If        *  all the input is converted, returns codecvt_base::ok.  If no        *  conversion is necessary, returns codecvt_base::noconv.  If        *  the input ends early or there is insufficient space in the        *  output, returns codecvt_base::partial.  Otherwise the        *  conversion failed and codecvt_base::error is returned.        *        *  @param  __state  Persistent conversion state data.        *  @param  __from  Start of input.        *  @param  __from_end  End of input.        *  @param  __from_next  Returns start of unconverted data.        *  @param  __to  Start of output buffer.        *  @param  __to_end  End of output buffer.        *  @param  __to_next  Returns start of unused output area.        *  @return  codecvt_base::result.       */                                                     protected:                                                                    };    template<typename _InternT, typename _ExternT, typename _StateT>     class codecvt     : public __codecvt_abstract_base<_InternT, _ExternT, _StateT>     {     public:       typedef codecvt_base::result result;       typedef _InternT intern_type;       typedef _ExternT extern_type;       typedef _StateT state_type;     protected:       __c_locale _M_c_locale_codecvt;     public:       static locale::id id;                   protected:                                                             };   template<typename _InternT, typename _ExternT, typename _StateT>     locale::id codecvt<_InternT, _ExternT, _StateT>::id;   template<>     class codecvt<char, char, mbstate_t>     : public __codecvt_abstract_base<char, char, mbstate_t>     {       friend class messages<char>;     public:       typedef char intern_type;       typedef char extern_type;       typedef mbstate_t state_type;     protected:       __c_locale _M_c_locale_codecvt;     public:       static locale::id id;                   protected:                                                           };   template<>     class codecvt<wchar_t, char, mbstate_t>     : public __codecvt_abstract_base<wchar_t, char, mbstate_t>     {       friend class messages<wchar_t>;     public:       typedef wchar_t intern_type;       typedef char extern_type;       typedef mbstate_t state_type;     protected:       __c_locale _M_c_locale_codecvt;     public:       static locale::id id;                   protected:                                                             };   template<>     class codecvt<char16_t, char, mbstate_t>     : public __codecvt_abstract_base<char16_t, char, mbstate_t>     {     public:       typedef char16_t intern_type;       typedef char extern_type;       typedef mbstate_t state_type;     public:       static locale::id id;            protected:                                                             };   template<>     class codecvt<char32_t, char, mbstate_t>     : public __codecvt_abstract_base<char32_t, char, mbstate_t>     {     public:       typedef char32_t intern_type;       typedef char extern_type;       typedef mbstate_t state_type;     public:       static locale::id id;            protected:                                                             };   template<typename _InternT, typename _ExternT, typename _StateT>     class codecvt_byname : public codecvt<_InternT, _ExternT, _StateT>     {     public:                   protected:            };   template<>     class codecvt_byname<char16_t, char, mbstate_t>     : public codecvt<char16_t, char, mbstate_t>     {     public:                   protected:            };   template<>     class codecvt_byname<char32_t, char, mbstate_t>     : public codecvt<char32_t, char, mbstate_t>     {     public:                   protected:            };   extern template class codecvt_byname<char, char, mbstate_t>;;;   extern template class codecvt_byname<wchar_t, char, mbstate_t>;;;   extern template class codecvt_byname<char16_t, char, mbstate_t>;   extern template class codecvt_byname<char32_t, char, mbstate_t>; }  namespace std __attribute__ ((__visibility__ ("default"))) {   typedef __gthread_mutex_t __c_lock;   typedef FILE __c_file; }  namespace std __attribute__ ((__visibility__ ("default"))) {   template<typename _CharT>     class __basic_file;   template<>     class __basic_file<char>     {       __c_file* _M_cfile;       bool _M_cfile_created;     public:                                                                                                                                          }; }  namespace std __attribute__ ((__visibility__ ("default"))) {   template<typename _CharT, typename _Traits>     class basic_filebuf : public basic_streambuf<_CharT, _Traits>     {       template<typename _Tp>  using __chk_state = __and_<is_copy_assignable<_Tp>,        is_copy_constructible<_Tp>,        is_default_constructible<_Tp>>;       static_assert(__chk_state<typename _Traits::state_type>::value,       "state_type must be CopyAssignable, CopyConstructible"       " and DefaultConstructible");       static_assert(is_same<typename _Traits::pos_type,        fpos<typename _Traits::state_type>>::value,       "pos_type must be fpos<state_type>");     public:       typedef _CharT char_type;       typedef _Traits traits_type;       typedef typename traits_type::int_type int_type;       typedef typename traits_type::pos_type pos_type;       typedef typename traits_type::off_type off_type;       typedef basic_streambuf<char_type, traits_type> __streambuf_type;       typedef basic_filebuf<char_type, traits_type> __filebuf_type;       typedef __basic_file<char> __file_type;       typedef typename traits_type::state_type __state_type;       typedef codecvt<char_type, char, __state_type> __codecvt_type;       friend class ios_base;      protected:       __c_lock _M_lock;       __file_type _M_file;       ios_base::openmode _M_mode;       __state_type _M_state_beg;       __state_type _M_state_cur;       __state_type _M_state_last;       char_type* _M_buf;       size_t _M_buf_size;       bool _M_buf_allocated;       bool _M_reading;       bool _M_writing;       char_type _M_pback;       char_type* _M_pback_cur_save;       char_type* _M_pback_end_save;       bool _M_pback_init;       const __codecvt_type* _M_codecvt;       char* _M_ext_buf;       streamsize _M_ext_buf_size;       const char* _M_ext_next;       char* _M_ext_end;                   public:                                                                                  protected:                                                                                                                                   };   template<typename _CharT, typename _Traits>     class basic_ifstream : public basic_istream<_CharT, _Traits>     {     public:       typedef _CharT char_type;       typedef _Traits traits_type;       typedef typename traits_type::int_type int_type;       typedef typename traits_type::pos_type pos_type;       typedef typename traits_type::off_type off_type;       typedef basic_filebuf<char_type, traits_type> __filebuf_type;       typedef basic_istream<char_type, traits_type> __istream_type;     private:       __filebuf_type _M_filebuf;     public:                                                                                                              };   template<typename _CharT, typename _Traits>     class basic_ofstream : public basic_ostream<_CharT,_Traits>     {     public:       typedef _CharT char_type;       typedef _Traits traits_type;       typedef typename traits_type::int_type int_type;       typedef typename traits_type::pos_type pos_type;       typedef typename traits_type::off_type off_type;       typedef basic_filebuf<char_type, traits_type> __filebuf_type;       typedef basic_ostream<char_type, traits_type> __ostream_type;     private:       __filebuf_type _M_filebuf;     public:                                                                                                              };   template<typename _CharT, typename _Traits>     class basic_fstream : public basic_iostream<_CharT, _Traits>     {     public:       typedef _CharT char_type;       typedef _Traits traits_type;       typedef typename traits_type::int_type int_type;       typedef typename traits_type::pos_type pos_type;       typedef typename traits_type::off_type off_type;       typedef basic_filebuf<char_type, traits_type> __filebuf_type;       typedef basic_ios<char_type, traits_type> __ios_type;       typedef basic_iostream<char_type, traits_type> __iostream_type;     private:       __filebuf_type _M_filebuf;     public:                                                                                                              };        ;        ;        ;        ; }  namespace std __attribute__ ((__visibility__ ("default"))) {                                                                        extern template class basic_filebuf<char>;   extern template class basic_ifstream<char>;   extern template class basic_ofstream<char>;   extern template class basic_fstream<char>;   extern template class basic_filebuf<wchar_t>;   extern template class basic_ifstream<wchar_t>;   extern template class basic_ofstream<wchar_t>;   extern template class basic_fstream<wchar_t>; }  class octave_value; class octave_value_list; class oprocstream; namespace octave {   class interpreter;   class   pager_buf : public std::stringbuf   {   public:                  protected:        private:     size_t diary_skip;   };   class   pager_stream : public std::ostream   {   public:                                           private:     pager_buf *pb;   };   class   diary_buf : public std::stringbuf   {   public:        protected:        };   class   diary_stream : public std::ostream   {   public:          diary_stream (const diary_stream&) = delete;     diary_stream& operator = (const diary_stream&) = delete;     ~diary_stream (void);     std::ostream& stream (void);     void reset (void);   private:     diary_buf *db;   };      class output_system   {   public:                                                                                                                                                                                       private:     interpreter& m_interpreter;     pager_stream m_pager_stream;     diary_stream m_diary_stream;     oprocstream *m_external_pager = nullptr;     std::ofstream m_external_diary_file;     std::string m_diary_file_name;     std::string m_PAGER;     std::string m_PAGER_FLAGS;     bool m_page_output_immediately;     bool m_page_screen_output;     bool m_write_to_diary_file;     bool m_really_flush_to_pager;     bool m_flushing_output_to_pager;             };       } __attribute__ ((__deprecated__)) typedef octave::diary_buf octave_diary_buf; __attribute__ ((__deprecated__)) typedef octave::diary_stream octave_diary_stream; __attribute__ ((__deprecated__)) typedef octave::pager_buf octave_pager_buf; __attribute__ ((__deprecated__)) typedef octave::pager_stream octave_pager_stream;  class octave_value; class octave_value_list; class string_vector; namespace octave {                                                                                     }                             class octave_function; class octave_user_function; class octave_value; class octave_value_list; class octave_builtin; class string_vector; namespace octave {   class tree_identifier; }             extern void maybe_missing_function_hook (const std::string& name); __attribute__ ((__deprecated__)) extern void mlock (void); __attribute__ ((__deprecated__)) extern void munlock (const std::string&); __attribute__ ((__deprecated__)) extern bool mislocked (const std::string&);           __attribute__ ((__deprecated__)) extern string_vector get_struct_elts (const std::string& text); extern "C" int octave_value_list_create(octave_value_list* list, int n); 