namespace std { inline namespace __1 { } }
typedef __signed char int8_t;
typedef short int16_t;
typedef int int32_t;
typedef long long int64_t;
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned int uint32_t;
typedef unsigned long long uint64_t;
typedef int8_t int_least8_t;
typedef int16_t int_least16_t;
typedef int32_t int_least32_t;
typedef int64_t int_least64_t;
typedef uint8_t uint_least8_t;
typedef uint16_t uint_least16_t;
typedef uint32_t uint_least32_t;
typedef uint64_t uint_least64_t;
typedef int8_t int_fast8_t;
typedef int16_t int_fast16_t;
typedef int32_t int_fast32_t;
typedef int64_t int_fast64_t;
typedef uint8_t uint_fast8_t;
typedef uint16_t uint_fast16_t;
typedef uint32_t uint_fast32_t;
typedef uint64_t uint_fast64_t;
typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef short __int16_t;
typedef unsigned short __uint16_t;
typedef int __int32_t;
typedef unsigned int __uint32_t;
typedef long long __int64_t;
typedef unsigned long long __uint64_t;
typedef long __darwin_intptr_t;
typedef unsigned int __darwin_natural_t;
typedef int __darwin_ct_rune_t;
typedef union {
 char __mbstate8[128];
 long long _mbstateL;
} __mbstate_t;
typedef __mbstate_t __darwin_mbstate_t;
typedef long int __darwin_ptrdiff_t;
typedef long unsigned int __darwin_size_t;
typedef __builtin_va_list __darwin_va_list;
typedef int __darwin_wchar_t;
typedef __darwin_wchar_t __darwin_rune_t;
typedef int __darwin_wint_t;
typedef unsigned long __darwin_clock_t;
typedef __uint32_t __darwin_socklen_t;
typedef long __darwin_ssize_t;
typedef long __darwin_time_t;
typedef __int64_t __darwin_blkcnt_t;
typedef __int32_t __darwin_blksize_t;
typedef __int32_t __darwin_dev_t;
typedef unsigned int __darwin_fsblkcnt_t;
typedef unsigned int __darwin_fsfilcnt_t;
typedef __uint32_t __darwin_gid_t;
typedef __uint32_t __darwin_id_t;
typedef __uint64_t __darwin_ino64_t;
typedef __darwin_ino64_t __darwin_ino_t;
typedef __darwin_natural_t __darwin_mach_port_name_t;
typedef __darwin_mach_port_name_t __darwin_mach_port_t;
typedef __uint16_t __darwin_mode_t;
typedef __int64_t __darwin_off_t;
typedef __int32_t __darwin_pid_t;
typedef __uint32_t __darwin_sigset_t;
typedef __int32_t __darwin_suseconds_t;
typedef __uint32_t __darwin_uid_t;
typedef __uint32_t __darwin_useconds_t;
typedef unsigned char __darwin_uuid_t[16];
typedef char __darwin_uuid_string_t[37];
struct __darwin_pthread_handler_rec {
 void (*__routine)(void *);
 void *__arg;
 struct __darwin_pthread_handler_rec *__next;
};
struct _opaque_pthread_attr_t {
 long __sig;
 char __opaque[56];
};
struct _opaque_pthread_cond_t {
 long __sig;
 char __opaque[40];
};
struct _opaque_pthread_condattr_t {
 long __sig;
 char __opaque[8];
};
struct _opaque_pthread_mutex_t {
 long __sig;
 char __opaque[56];
};
struct _opaque_pthread_mutexattr_t {
 long __sig;
 char __opaque[8];
};
struct _opaque_pthread_once_t {
 long __sig;
 char __opaque[8];
};
struct _opaque_pthread_rwlock_t {
 long __sig;
 char __opaque[192];
};
struct _opaque_pthread_rwlockattr_t {
 long __sig;
 char __opaque[16];
};
struct _opaque_pthread_t {
 long __sig;
 struct __darwin_pthread_handler_rec *__cleanup_stack;
 char __opaque[8176];
};
typedef struct _opaque_pthread_attr_t __darwin_pthread_attr_t;
typedef struct _opaque_pthread_cond_t __darwin_pthread_cond_t;
typedef struct _opaque_pthread_condattr_t __darwin_pthread_condattr_t;
typedef unsigned long __darwin_pthread_key_t;
typedef struct _opaque_pthread_mutex_t __darwin_pthread_mutex_t;
typedef struct _opaque_pthread_mutexattr_t __darwin_pthread_mutexattr_t;
typedef struct _opaque_pthread_once_t __darwin_pthread_once_t;
typedef struct _opaque_pthread_rwlock_t __darwin_pthread_rwlock_t;
typedef struct _opaque_pthread_rwlockattr_t __darwin_pthread_rwlockattr_t;
typedef struct _opaque_pthread_t *__darwin_pthread_t;
typedef unsigned char u_int8_t;
typedef unsigned short u_int16_t;
typedef unsigned int u_int32_t;
typedef unsigned long long u_int64_t;
typedef int64_t register_t;
typedef unsigned long uintptr_t;
typedef u_int64_t user_addr_t;
typedef u_int64_t user_size_t;
typedef int64_t user_ssize_t;
typedef int64_t user_long_t;
typedef u_int64_t user_ulong_t;
typedef int64_t user_time_t;
typedef int64_t user_off_t;
typedef u_int64_t syscall_arg_t;
typedef __darwin_intptr_t intptr_t;
typedef long int intmax_t;
typedef long unsigned int uintmax_t;
namespace std { inline namespace __1 {
using::int8_t;
using::int16_t;
using::int32_t;
using::int64_t;
using::uint8_t;
using::uint16_t;
using::uint32_t;
using::uint64_t;
using::int_least8_t;
using::int_least16_t;
using::int_least32_t;
using::int_least64_t;
using::uint_least8_t;
using::uint_least16_t;
using::uint_least32_t;
using::uint_least64_t;
using::int_fast8_t;
using::int_fast16_t;
using::int_fast32_t;
using::int_fast64_t;
using::uint_fast8_t;
using::uint_fast16_t;
using::uint_fast32_t;
using::uint_fast64_t;
using::intptr_t;
using::uintptr_t;
using::intmax_t;
using::uintmax_t;
} }
;
typedef int64_t octave_idx_type;
typedef int32_t octave_f77_int_type;
typedef int __darwin_nl_item;
typedef int __darwin_wctrans_t;
typedef __uint32_t __darwin_wctype_t;
typedef enum {
 P_ALL,
 P_PID,
 P_PGID
} idtype_t;
typedef __darwin_pid_t pid_t;
typedef __darwin_id_t id_t;
typedef int sig_atomic_t;
struct __darwin_i386_thread_state
{
    unsigned int __eax;
    unsigned int __ebx;
    unsigned int __ecx;
    unsigned int __edx;
    unsigned int __edi;
    unsigned int __esi;
    unsigned int __ebp;
    unsigned int __esp;
    unsigned int __ss;
    unsigned int __eflags;
    unsigned int __eip;
    unsigned int __cs;
    unsigned int __ds;
    unsigned int __es;
    unsigned int __fs;
    unsigned int __gs;
};
struct __darwin_fp_control
{
    unsigned short __invalid :1,
        __denorm :1,
    __zdiv :1,
    __ovrfl :1,
    __undfl :1,
    __precis :1,
      :2,
    __pc :2,
    __rc :2,
      :1,
      :3;
};
typedef struct __darwin_fp_control __darwin_fp_control_t;
struct __darwin_fp_status
{
    unsigned short __invalid :1,
        __denorm :1,
    __zdiv :1,
    __ovrfl :1,
    __undfl :1,
    __precis :1,
    __stkflt :1,
    __errsumm :1,
    __c0 :1,
    __c1 :1,
    __c2 :1,
    __tos :3,
    __c3 :1,
    __busy :1;
};
typedef struct __darwin_fp_status __darwin_fp_status_t;
struct __darwin_mmst_reg
{
 char __mmst_reg[10];
 char __mmst_rsrv[6];
};
struct __darwin_xmm_reg
{
 char __xmm_reg[16];
};
struct __darwin_ymm_reg
{
 char __ymm_reg[32];
};
struct __darwin_zmm_reg
{
 char __zmm_reg[64];
};
struct __darwin_opmask_reg
{
 char __opmask_reg[8];
};
struct __darwin_i386_float_state
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw;
 struct __darwin_fp_status __fpu_fsw;
 __uint8_t __fpu_ftw;
 __uint8_t __fpu_rsrv1;
 __uint16_t __fpu_fop;
 __uint32_t __fpu_ip;
 __uint16_t __fpu_cs;
 __uint16_t __fpu_rsrv2;
 __uint32_t __fpu_dp;
 __uint16_t __fpu_ds;
 __uint16_t __fpu_rsrv3;
 __uint32_t __fpu_mxcsr;
 __uint32_t __fpu_mxcsrmask;
 struct __darwin_mmst_reg __fpu_stmm0;
 struct __darwin_mmst_reg __fpu_stmm1;
 struct __darwin_mmst_reg __fpu_stmm2;
 struct __darwin_mmst_reg __fpu_stmm3;
 struct __darwin_mmst_reg __fpu_stmm4;
 struct __darwin_mmst_reg __fpu_stmm5;
 struct __darwin_mmst_reg __fpu_stmm6;
 struct __darwin_mmst_reg __fpu_stmm7;
 struct __darwin_xmm_reg __fpu_xmm0;
 struct __darwin_xmm_reg __fpu_xmm1;
 struct __darwin_xmm_reg __fpu_xmm2;
 struct __darwin_xmm_reg __fpu_xmm3;
 struct __darwin_xmm_reg __fpu_xmm4;
 struct __darwin_xmm_reg __fpu_xmm5;
 struct __darwin_xmm_reg __fpu_xmm6;
 struct __darwin_xmm_reg __fpu_xmm7;
 char __fpu_rsrv4[14*16];
 int __fpu_reserved1;
};
struct __darwin_i386_avx_state
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw;
 struct __darwin_fp_status __fpu_fsw;
 __uint8_t __fpu_ftw;
 __uint8_t __fpu_rsrv1;
 __uint16_t __fpu_fop;
 __uint32_t __fpu_ip;
 __uint16_t __fpu_cs;
 __uint16_t __fpu_rsrv2;
 __uint32_t __fpu_dp;
 __uint16_t __fpu_ds;
 __uint16_t __fpu_rsrv3;
 __uint32_t __fpu_mxcsr;
 __uint32_t __fpu_mxcsrmask;
 struct __darwin_mmst_reg __fpu_stmm0;
 struct __darwin_mmst_reg __fpu_stmm1;
 struct __darwin_mmst_reg __fpu_stmm2;
 struct __darwin_mmst_reg __fpu_stmm3;
 struct __darwin_mmst_reg __fpu_stmm4;
 struct __darwin_mmst_reg __fpu_stmm5;
 struct __darwin_mmst_reg __fpu_stmm6;
 struct __darwin_mmst_reg __fpu_stmm7;
 struct __darwin_xmm_reg __fpu_xmm0;
 struct __darwin_xmm_reg __fpu_xmm1;
 struct __darwin_xmm_reg __fpu_xmm2;
 struct __darwin_xmm_reg __fpu_xmm3;
 struct __darwin_xmm_reg __fpu_xmm4;
 struct __darwin_xmm_reg __fpu_xmm5;
 struct __darwin_xmm_reg __fpu_xmm6;
 struct __darwin_xmm_reg __fpu_xmm7;
 char __fpu_rsrv4[14*16];
 int __fpu_reserved1;
 char __avx_reserved1[64];
 struct __darwin_xmm_reg __fpu_ymmh0;
 struct __darwin_xmm_reg __fpu_ymmh1;
 struct __darwin_xmm_reg __fpu_ymmh2;
 struct __darwin_xmm_reg __fpu_ymmh3;
 struct __darwin_xmm_reg __fpu_ymmh4;
 struct __darwin_xmm_reg __fpu_ymmh5;
 struct __darwin_xmm_reg __fpu_ymmh6;
 struct __darwin_xmm_reg __fpu_ymmh7;
};
struct __darwin_i386_avx512_state
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw;
 struct __darwin_fp_status __fpu_fsw;
 __uint8_t __fpu_ftw;
 __uint8_t __fpu_rsrv1;
 __uint16_t __fpu_fop;
 __uint32_t __fpu_ip;
 __uint16_t __fpu_cs;
 __uint16_t __fpu_rsrv2;
 __uint32_t __fpu_dp;
 __uint16_t __fpu_ds;
 __uint16_t __fpu_rsrv3;
 __uint32_t __fpu_mxcsr;
 __uint32_t __fpu_mxcsrmask;
 struct __darwin_mmst_reg __fpu_stmm0;
 struct __darwin_mmst_reg __fpu_stmm1;
 struct __darwin_mmst_reg __fpu_stmm2;
 struct __darwin_mmst_reg __fpu_stmm3;
 struct __darwin_mmst_reg __fpu_stmm4;
 struct __darwin_mmst_reg __fpu_stmm5;
 struct __darwin_mmst_reg __fpu_stmm6;
 struct __darwin_mmst_reg __fpu_stmm7;
 struct __darwin_xmm_reg __fpu_xmm0;
 struct __darwin_xmm_reg __fpu_xmm1;
 struct __darwin_xmm_reg __fpu_xmm2;
 struct __darwin_xmm_reg __fpu_xmm3;
 struct __darwin_xmm_reg __fpu_xmm4;
 struct __darwin_xmm_reg __fpu_xmm5;
 struct __darwin_xmm_reg __fpu_xmm6;
 struct __darwin_xmm_reg __fpu_xmm7;
 char __fpu_rsrv4[14*16];
 int __fpu_reserved1;
 char __avx_reserved1[64];
 struct __darwin_xmm_reg __fpu_ymmh0;
 struct __darwin_xmm_reg __fpu_ymmh1;
 struct __darwin_xmm_reg __fpu_ymmh2;
 struct __darwin_xmm_reg __fpu_ymmh3;
 struct __darwin_xmm_reg __fpu_ymmh4;
 struct __darwin_xmm_reg __fpu_ymmh5;
 struct __darwin_xmm_reg __fpu_ymmh6;
 struct __darwin_xmm_reg __fpu_ymmh7;
 struct __darwin_opmask_reg __fpu_k0;
 struct __darwin_opmask_reg __fpu_k1;
 struct __darwin_opmask_reg __fpu_k2;
 struct __darwin_opmask_reg __fpu_k3;
 struct __darwin_opmask_reg __fpu_k4;
 struct __darwin_opmask_reg __fpu_k5;
 struct __darwin_opmask_reg __fpu_k6;
 struct __darwin_opmask_reg __fpu_k7;
 struct __darwin_ymm_reg __fpu_zmmh0;
 struct __darwin_ymm_reg __fpu_zmmh1;
 struct __darwin_ymm_reg __fpu_zmmh2;
 struct __darwin_ymm_reg __fpu_zmmh3;
 struct __darwin_ymm_reg __fpu_zmmh4;
 struct __darwin_ymm_reg __fpu_zmmh5;
 struct __darwin_ymm_reg __fpu_zmmh6;
 struct __darwin_ymm_reg __fpu_zmmh7;
};
struct __darwin_i386_exception_state
{
 __uint16_t __trapno;
 __uint16_t __cpu;
 __uint32_t __err;
 __uint32_t __faultvaddr;
};
struct __darwin_x86_debug_state32
{
 unsigned int __dr0;
 unsigned int __dr1;
 unsigned int __dr2;
 unsigned int __dr3;
 unsigned int __dr4;
 unsigned int __dr5;
 unsigned int __dr6;
 unsigned int __dr7;
};
struct __x86_pagein_state
{
 int __pagein_error;
};
struct __darwin_x86_thread_state64
{
 __uint64_t __rax;
 __uint64_t __rbx;
 __uint64_t __rcx;
 __uint64_t __rdx;
 __uint64_t __rdi;
 __uint64_t __rsi;
 __uint64_t __rbp;
 __uint64_t __rsp;
 __uint64_t __r8;
 __uint64_t __r9;
 __uint64_t __r10;
 __uint64_t __r11;
 __uint64_t __r12;
 __uint64_t __r13;
 __uint64_t __r14;
 __uint64_t __r15;
 __uint64_t __rip;
 __uint64_t __rflags;
 __uint64_t __cs;
 __uint64_t __fs;
 __uint64_t __gs;
};
struct __darwin_x86_thread_full_state64
{
 struct __darwin_x86_thread_state64 __ss64;
 __uint64_t __ds;
 __uint64_t __es;
 __uint64_t __ss;
 __uint64_t __gsbase;
};
struct __darwin_x86_float_state64
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw;
 struct __darwin_fp_status __fpu_fsw;
 __uint8_t __fpu_ftw;
 __uint8_t __fpu_rsrv1;
 __uint16_t __fpu_fop;
 __uint32_t __fpu_ip;
 __uint16_t __fpu_cs;
 __uint16_t __fpu_rsrv2;
 __uint32_t __fpu_dp;
 __uint16_t __fpu_ds;
 __uint16_t __fpu_rsrv3;
 __uint32_t __fpu_mxcsr;
 __uint32_t __fpu_mxcsrmask;
 struct __darwin_mmst_reg __fpu_stmm0;
 struct __darwin_mmst_reg __fpu_stmm1;
 struct __darwin_mmst_reg __fpu_stmm2;
 struct __darwin_mmst_reg __fpu_stmm3;
 struct __darwin_mmst_reg __fpu_stmm4;
 struct __darwin_mmst_reg __fpu_stmm5;
 struct __darwin_mmst_reg __fpu_stmm6;
 struct __darwin_mmst_reg __fpu_stmm7;
 struct __darwin_xmm_reg __fpu_xmm0;
 struct __darwin_xmm_reg __fpu_xmm1;
 struct __darwin_xmm_reg __fpu_xmm2;
 struct __darwin_xmm_reg __fpu_xmm3;
 struct __darwin_xmm_reg __fpu_xmm4;
 struct __darwin_xmm_reg __fpu_xmm5;
 struct __darwin_xmm_reg __fpu_xmm6;
 struct __darwin_xmm_reg __fpu_xmm7;
 struct __darwin_xmm_reg __fpu_xmm8;
 struct __darwin_xmm_reg __fpu_xmm9;
 struct __darwin_xmm_reg __fpu_xmm10;
 struct __darwin_xmm_reg __fpu_xmm11;
 struct __darwin_xmm_reg __fpu_xmm12;
 struct __darwin_xmm_reg __fpu_xmm13;
 struct __darwin_xmm_reg __fpu_xmm14;
 struct __darwin_xmm_reg __fpu_xmm15;
 char __fpu_rsrv4[6*16];
 int __fpu_reserved1;
};
struct __darwin_x86_avx_state64
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw;
 struct __darwin_fp_status __fpu_fsw;
 __uint8_t __fpu_ftw;
 __uint8_t __fpu_rsrv1;
 __uint16_t __fpu_fop;
 __uint32_t __fpu_ip;
 __uint16_t __fpu_cs;
 __uint16_t __fpu_rsrv2;
 __uint32_t __fpu_dp;
 __uint16_t __fpu_ds;
 __uint16_t __fpu_rsrv3;
 __uint32_t __fpu_mxcsr;
 __uint32_t __fpu_mxcsrmask;
 struct __darwin_mmst_reg __fpu_stmm0;
 struct __darwin_mmst_reg __fpu_stmm1;
 struct __darwin_mmst_reg __fpu_stmm2;
 struct __darwin_mmst_reg __fpu_stmm3;
 struct __darwin_mmst_reg __fpu_stmm4;
 struct __darwin_mmst_reg __fpu_stmm5;
 struct __darwin_mmst_reg __fpu_stmm6;
 struct __darwin_mmst_reg __fpu_stmm7;
 struct __darwin_xmm_reg __fpu_xmm0;
 struct __darwin_xmm_reg __fpu_xmm1;
 struct __darwin_xmm_reg __fpu_xmm2;
 struct __darwin_xmm_reg __fpu_xmm3;
 struct __darwin_xmm_reg __fpu_xmm4;
 struct __darwin_xmm_reg __fpu_xmm5;
 struct __darwin_xmm_reg __fpu_xmm6;
 struct __darwin_xmm_reg __fpu_xmm7;
 struct __darwin_xmm_reg __fpu_xmm8;
 struct __darwin_xmm_reg __fpu_xmm9;
 struct __darwin_xmm_reg __fpu_xmm10;
 struct __darwin_xmm_reg __fpu_xmm11;
 struct __darwin_xmm_reg __fpu_xmm12;
 struct __darwin_xmm_reg __fpu_xmm13;
 struct __darwin_xmm_reg __fpu_xmm14;
 struct __darwin_xmm_reg __fpu_xmm15;
 char __fpu_rsrv4[6*16];
 int __fpu_reserved1;
 char __avx_reserved1[64];
 struct __darwin_xmm_reg __fpu_ymmh0;
 struct __darwin_xmm_reg __fpu_ymmh1;
 struct __darwin_xmm_reg __fpu_ymmh2;
 struct __darwin_xmm_reg __fpu_ymmh3;
 struct __darwin_xmm_reg __fpu_ymmh4;
 struct __darwin_xmm_reg __fpu_ymmh5;
 struct __darwin_xmm_reg __fpu_ymmh6;
 struct __darwin_xmm_reg __fpu_ymmh7;
 struct __darwin_xmm_reg __fpu_ymmh8;
 struct __darwin_xmm_reg __fpu_ymmh9;
 struct __darwin_xmm_reg __fpu_ymmh10;
 struct __darwin_xmm_reg __fpu_ymmh11;
 struct __darwin_xmm_reg __fpu_ymmh12;
 struct __darwin_xmm_reg __fpu_ymmh13;
 struct __darwin_xmm_reg __fpu_ymmh14;
 struct __darwin_xmm_reg __fpu_ymmh15;
};
struct __darwin_x86_avx512_state64
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw;
 struct __darwin_fp_status __fpu_fsw;
 __uint8_t __fpu_ftw;
 __uint8_t __fpu_rsrv1;
 __uint16_t __fpu_fop;
 __uint32_t __fpu_ip;
 __uint16_t __fpu_cs;
 __uint16_t __fpu_rsrv2;
 __uint32_t __fpu_dp;
 __uint16_t __fpu_ds;
 __uint16_t __fpu_rsrv3;
 __uint32_t __fpu_mxcsr;
 __uint32_t __fpu_mxcsrmask;
 struct __darwin_mmst_reg __fpu_stmm0;
 struct __darwin_mmst_reg __fpu_stmm1;
 struct __darwin_mmst_reg __fpu_stmm2;
 struct __darwin_mmst_reg __fpu_stmm3;
 struct __darwin_mmst_reg __fpu_stmm4;
 struct __darwin_mmst_reg __fpu_stmm5;
 struct __darwin_mmst_reg __fpu_stmm6;
 struct __darwin_mmst_reg __fpu_stmm7;
 struct __darwin_xmm_reg __fpu_xmm0;
 struct __darwin_xmm_reg __fpu_xmm1;
 struct __darwin_xmm_reg __fpu_xmm2;
 struct __darwin_xmm_reg __fpu_xmm3;
 struct __darwin_xmm_reg __fpu_xmm4;
 struct __darwin_xmm_reg __fpu_xmm5;
 struct __darwin_xmm_reg __fpu_xmm6;
 struct __darwin_xmm_reg __fpu_xmm7;
 struct __darwin_xmm_reg __fpu_xmm8;
 struct __darwin_xmm_reg __fpu_xmm9;
 struct __darwin_xmm_reg __fpu_xmm10;
 struct __darwin_xmm_reg __fpu_xmm11;
 struct __darwin_xmm_reg __fpu_xmm12;
 struct __darwin_xmm_reg __fpu_xmm13;
 struct __darwin_xmm_reg __fpu_xmm14;
 struct __darwin_xmm_reg __fpu_xmm15;
 char __fpu_rsrv4[6*16];
 int __fpu_reserved1;
 char __avx_reserved1[64];
 struct __darwin_xmm_reg __fpu_ymmh0;
 struct __darwin_xmm_reg __fpu_ymmh1;
 struct __darwin_xmm_reg __fpu_ymmh2;
 struct __darwin_xmm_reg __fpu_ymmh3;
 struct __darwin_xmm_reg __fpu_ymmh4;
 struct __darwin_xmm_reg __fpu_ymmh5;
 struct __darwin_xmm_reg __fpu_ymmh6;
 struct __darwin_xmm_reg __fpu_ymmh7;
 struct __darwin_xmm_reg __fpu_ymmh8;
 struct __darwin_xmm_reg __fpu_ymmh9;
 struct __darwin_xmm_reg __fpu_ymmh10;
 struct __darwin_xmm_reg __fpu_ymmh11;
 struct __darwin_xmm_reg __fpu_ymmh12;
 struct __darwin_xmm_reg __fpu_ymmh13;
 struct __darwin_xmm_reg __fpu_ymmh14;
 struct __darwin_xmm_reg __fpu_ymmh15;
 struct __darwin_opmask_reg __fpu_k0;
 struct __darwin_opmask_reg __fpu_k1;
 struct __darwin_opmask_reg __fpu_k2;
 struct __darwin_opmask_reg __fpu_k3;
 struct __darwin_opmask_reg __fpu_k4;
 struct __darwin_opmask_reg __fpu_k5;
 struct __darwin_opmask_reg __fpu_k6;
 struct __darwin_opmask_reg __fpu_k7;
 struct __darwin_ymm_reg __fpu_zmmh0;
 struct __darwin_ymm_reg __fpu_zmmh1;
 struct __darwin_ymm_reg __fpu_zmmh2;
 struct __darwin_ymm_reg __fpu_zmmh3;
 struct __darwin_ymm_reg __fpu_zmmh4;
 struct __darwin_ymm_reg __fpu_zmmh5;
 struct __darwin_ymm_reg __fpu_zmmh6;
 struct __darwin_ymm_reg __fpu_zmmh7;
 struct __darwin_ymm_reg __fpu_zmmh8;
 struct __darwin_ymm_reg __fpu_zmmh9;
 struct __darwin_ymm_reg __fpu_zmmh10;
 struct __darwin_ymm_reg __fpu_zmmh11;
 struct __darwin_ymm_reg __fpu_zmmh12;
 struct __darwin_ymm_reg __fpu_zmmh13;
 struct __darwin_ymm_reg __fpu_zmmh14;
 struct __darwin_ymm_reg __fpu_zmmh15;
 struct __darwin_zmm_reg __fpu_zmm16;
 struct __darwin_zmm_reg __fpu_zmm17;
 struct __darwin_zmm_reg __fpu_zmm18;
 struct __darwin_zmm_reg __fpu_zmm19;
 struct __darwin_zmm_reg __fpu_zmm20;
 struct __darwin_zmm_reg __fpu_zmm21;
 struct __darwin_zmm_reg __fpu_zmm22;
 struct __darwin_zmm_reg __fpu_zmm23;
 struct __darwin_zmm_reg __fpu_zmm24;
 struct __darwin_zmm_reg __fpu_zmm25;
 struct __darwin_zmm_reg __fpu_zmm26;
 struct __darwin_zmm_reg __fpu_zmm27;
 struct __darwin_zmm_reg __fpu_zmm28;
 struct __darwin_zmm_reg __fpu_zmm29;
 struct __darwin_zmm_reg __fpu_zmm30;
 struct __darwin_zmm_reg __fpu_zmm31;
};
struct __darwin_x86_exception_state64
{
    __uint16_t __trapno;
    __uint16_t __cpu;
    __uint32_t __err;
    __uint64_t __faultvaddr;
};
struct __darwin_x86_debug_state64
{
 __uint64_t __dr0;
 __uint64_t __dr1;
 __uint64_t __dr2;
 __uint64_t __dr3;
 __uint64_t __dr4;
 __uint64_t __dr5;
 __uint64_t __dr6;
 __uint64_t __dr7;
};
struct __darwin_x86_cpmu_state64
{
 __uint64_t __ctrs[16];
};
struct __darwin_mcontext32
{
 struct __darwin_i386_exception_state __es;
 struct __darwin_i386_thread_state __ss;
 struct __darwin_i386_float_state __fs;
};
struct __darwin_mcontext_avx32
{
 struct __darwin_i386_exception_state __es;
 struct __darwin_i386_thread_state __ss;
 struct __darwin_i386_avx_state __fs;
};
struct __darwin_mcontext_avx512_32
{
 struct __darwin_i386_exception_state __es;
 struct __darwin_i386_thread_state __ss;
 struct __darwin_i386_avx512_state __fs;
};
struct __darwin_mcontext64
{
 struct __darwin_x86_exception_state64 __es;
 struct __darwin_x86_thread_state64 __ss;
 struct __darwin_x86_float_state64 __fs;
};
struct __darwin_mcontext64_full
{
 struct __darwin_x86_exception_state64 __es;
 struct __darwin_x86_thread_full_state64 __ss;
 struct __darwin_x86_float_state64 __fs;
};
struct __darwin_mcontext_avx64
{
 struct __darwin_x86_exception_state64 __es;
 struct __darwin_x86_thread_state64 __ss;
 struct __darwin_x86_avx_state64 __fs;
};
struct __darwin_mcontext_avx64_full
{
 struct __darwin_x86_exception_state64 __es;
 struct __darwin_x86_thread_full_state64 __ss;
 struct __darwin_x86_avx_state64 __fs;
};
struct __darwin_mcontext_avx512_64
{
 struct __darwin_x86_exception_state64 __es;
 struct __darwin_x86_thread_state64 __ss;
 struct __darwin_x86_avx512_state64 __fs;
};
struct __darwin_mcontext_avx512_64_full
{
 struct __darwin_x86_exception_state64 __es;
 struct __darwin_x86_thread_full_state64 __ss;
 struct __darwin_x86_avx512_state64 __fs;
};
typedef struct __darwin_mcontext64 *mcontext_t;
typedef __darwin_pthread_attr_t pthread_attr_t;
struct __darwin_sigaltstack
{
 void *ss_sp;
 __darwin_size_t ss_size;
 int ss_flags;
};
typedef struct __darwin_sigaltstack stack_t;
struct __darwin_ucontext
{
 int uc_onstack;
 __darwin_sigset_t uc_sigmask;
 struct __darwin_sigaltstack uc_stack;
 struct __darwin_ucontext *uc_link;
 __darwin_size_t uc_mcsize;
 struct __darwin_mcontext64 *uc_mcontext;
};
typedef struct __darwin_ucontext ucontext_t;
typedef __darwin_sigset_t sigset_t;
typedef __darwin_size_t size_t;
typedef __darwin_uid_t uid_t;
union sigval {
 int sival_int;
 void *sival_ptr;
};
struct sigevent {
 int sigev_notify;
 int sigev_signo;
 union sigval sigev_value;
 void (*sigev_notify_function)(union sigval);
 pthread_attr_t *sigev_notify_attributes;
};
typedef struct __siginfo {
 int si_signo;
 int si_errno;
 int si_code;
 pid_t si_pid;
 uid_t si_uid;
 int si_status;
 void *si_addr;
 union sigval si_value;
 long si_band;
 unsigned long __pad[7];
} siginfo_t;
union __sigaction_u {
 void (*__sa_handler)(int);
 void (*__sa_sigaction)(int, struct __siginfo *,
     void *);
};
struct __sigaction {
 union __sigaction_u __sigaction_u;
 void (*sa_tramp)(void *, int, int, siginfo_t *, void *);
 sigset_t sa_mask;
 int sa_flags;
};
struct sigaction {
 union __sigaction_u __sigaction_u;
 sigset_t sa_mask;
 int sa_flags;
};
typedef void (*sig_t)(int);
struct sigvec {
 void (*sv_handler)(int);
 int sv_mask;
 int sv_flags;
};
struct sigstack {
 char *ss_sp;
 int ss_onstack;
};
extern "C" {
    ;
}
struct timeval
{
 __darwin_time_t tv_sec;
 __darwin_suseconds_t tv_usec;
};
typedef __uint64_t rlim_t;
struct rusage {
 struct timeval ru_utime;
 struct timeval ru_stime;
 long ru_maxrss;
 long ru_ixrss;
 long ru_idrss;
 long ru_isrss;
 long ru_minflt;
 long ru_majflt;
 long ru_nswap;
 long ru_inblock;
 long ru_oublock;
 long ru_msgsnd;
 long ru_msgrcv;
 long ru_nsignals;
 long ru_nvcsw;
 long ru_nivcsw;
};
typedef void *rusage_info_t;
struct rusage_info_v0 {
 uint8_t ri_uuid[16];
 uint64_t ri_user_time;
 uint64_t ri_system_time;
 uint64_t ri_pkg_idle_wkups;
 uint64_t ri_interrupt_wkups;
 uint64_t ri_pageins;
 uint64_t ri_wired_size;
 uint64_t ri_resident_size;
 uint64_t ri_phys_footprint;
 uint64_t ri_proc_start_abstime;
 uint64_t ri_proc_exit_abstime;
};
struct rusage_info_v1 {
 uint8_t ri_uuid[16];
 uint64_t ri_user_time;
 uint64_t ri_system_time;
 uint64_t ri_pkg_idle_wkups;
 uint64_t ri_interrupt_wkups;
 uint64_t ri_pageins;
 uint64_t ri_wired_size;
 uint64_t ri_resident_size;
 uint64_t ri_phys_footprint;
 uint64_t ri_proc_start_abstime;
 uint64_t ri_proc_exit_abstime;
 uint64_t ri_child_user_time;
 uint64_t ri_child_system_time;
 uint64_t ri_child_pkg_idle_wkups;
 uint64_t ri_child_interrupt_wkups;
 uint64_t ri_child_pageins;
 uint64_t ri_child_elapsed_abstime;
};
struct rusage_info_v2 {
 uint8_t ri_uuid[16];
 uint64_t ri_user_time;
 uint64_t ri_system_time;
 uint64_t ri_pkg_idle_wkups;
 uint64_t ri_interrupt_wkups;
 uint64_t ri_pageins;
 uint64_t ri_wired_size;
 uint64_t ri_resident_size;
 uint64_t ri_phys_footprint;
 uint64_t ri_proc_start_abstime;
 uint64_t ri_proc_exit_abstime;
 uint64_t ri_child_user_time;
 uint64_t ri_child_system_time;
 uint64_t ri_child_pkg_idle_wkups;
 uint64_t ri_child_interrupt_wkups;
 uint64_t ri_child_pageins;
 uint64_t ri_child_elapsed_abstime;
 uint64_t ri_diskio_bytesread;
 uint64_t ri_diskio_byteswritten;
};
struct rusage_info_v3 {
 uint8_t ri_uuid[16];
 uint64_t ri_user_time;
 uint64_t ri_system_time;
 uint64_t ri_pkg_idle_wkups;
 uint64_t ri_interrupt_wkups;
 uint64_t ri_pageins;
 uint64_t ri_wired_size;
 uint64_t ri_resident_size;
 uint64_t ri_phys_footprint;
 uint64_t ri_proc_start_abstime;
 uint64_t ri_proc_exit_abstime;
 uint64_t ri_child_user_time;
 uint64_t ri_child_system_time;
 uint64_t ri_child_pkg_idle_wkups;
 uint64_t ri_child_interrupt_wkups;
 uint64_t ri_child_pageins;
 uint64_t ri_child_elapsed_abstime;
 uint64_t ri_diskio_bytesread;
 uint64_t ri_diskio_byteswritten;
 uint64_t ri_cpu_time_qos_default;
 uint64_t ri_cpu_time_qos_maintenance;
 uint64_t ri_cpu_time_qos_background;
 uint64_t ri_cpu_time_qos_utility;
 uint64_t ri_cpu_time_qos_legacy;
 uint64_t ri_cpu_time_qos_user_initiated;
 uint64_t ri_cpu_time_qos_user_interactive;
 uint64_t ri_billed_system_time;
 uint64_t ri_serviced_system_time;
};
struct rusage_info_v4 {
 uint8_t ri_uuid[16];
 uint64_t ri_user_time;
 uint64_t ri_system_time;
 uint64_t ri_pkg_idle_wkups;
 uint64_t ri_interrupt_wkups;
 uint64_t ri_pageins;
 uint64_t ri_wired_size;
 uint64_t ri_resident_size;
 uint64_t ri_phys_footprint;
 uint64_t ri_proc_start_abstime;
 uint64_t ri_proc_exit_abstime;
 uint64_t ri_child_user_time;
 uint64_t ri_child_system_time;
 uint64_t ri_child_pkg_idle_wkups;
 uint64_t ri_child_interrupt_wkups;
 uint64_t ri_child_pageins;
 uint64_t ri_child_elapsed_abstime;
 uint64_t ri_diskio_bytesread;
 uint64_t ri_diskio_byteswritten;
 uint64_t ri_cpu_time_qos_default;
 uint64_t ri_cpu_time_qos_maintenance;
 uint64_t ri_cpu_time_qos_background;
 uint64_t ri_cpu_time_qos_utility;
 uint64_t ri_cpu_time_qos_legacy;
 uint64_t ri_cpu_time_qos_user_initiated;
 uint64_t ri_cpu_time_qos_user_interactive;
 uint64_t ri_billed_system_time;
 uint64_t ri_serviced_system_time;
 uint64_t ri_logical_writes;
 uint64_t ri_lifetime_max_phys_footprint;
 uint64_t ri_instructions;
 uint64_t ri_cycles;
 uint64_t ri_billed_energy;
 uint64_t ri_serviced_energy;
 uint64_t ri_interval_max_phys_footprint;
 uint64_t ri_runnable_time;
};
typedef struct rusage_info_v4 rusage_info_current;
struct rlimit {
 rlim_t rlim_cur;
 rlim_t rlim_max;
};
struct proc_rlimit_control_wakeupmon {
 uint32_t wm_flags;
 int32_t wm_rate;
};
extern "C" {
;
;
;
;
;
;
;
}
union wait {
 int w_status;
 struct {
  unsigned int w_Termsig:7,
      w_Coredump:1,
      w_Retcode:8,
      w_Filler:16;
 } w_T;
 struct {
  unsigned int w_Stopval:8,
      w_Stopsig:8,
      w_Filler:16;
 } w_S;
};
extern "C" {
;
;
;
;
;
}
extern "C" {
;
}
typedef __darwin_ct_rune_t ct_rune_t;
typedef __darwin_rune_t rune_t;
typedef struct {
 int quot;
 int rem;
} div_t;
typedef struct {
 long quot;
 long rem;
} ldiv_t;
typedef struct {
 long long quot;
 long long rem;
} lldiv_t;
extern int __mb_cur_max;
extern "C" {
;
;
;
;
;
;
}
extern "C" {
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
typedef __darwin_dev_t dev_t;
typedef __darwin_mode_t mode_t;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
extern char *suboptarg;
}
extern "C++" {
  ;
  ;
  ;
  ;
}
extern "C" {
;
}
typedef long int ptrdiff_t;
typedef long unsigned int rsize_t;
typedef long double max_align_t;
namespace std
{
    typedef decltype(nullptr) nullptr_t;
}
namespace std { inline namespace __1 {
using ::ptrdiff_t;
using ::size_t;
using ::max_align_t;
} }
namespace std
{
template<class _Ep>
class __attribute__ ((__type_visibility__("default"))) initializer_list
{
    const _Ep* __begin_;
    size_t __size_;
public:
    typedef _Ep value_type;
    typedef const _Ep& reference;
    typedef const _Ep& const_reference;
    typedef size_t size_type;
    typedef const _Ep* iterator;
    typedef const _Ep* const_iterator;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    initializer_list() ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t size() const noexcept ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const _Ep* begin() const noexcept ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const _Ep* end() const noexcept ;
};
template<class _Ep>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
const _Ep*
begin(initializer_list<_Ep> __il) noexcept
;
template<class _Ep>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
const _Ep*
end(initializer_list<_Ep> __il) noexcept
;
}
namespace std { inline namespace __1 {
template <class _T1, class _T2> struct __attribute__ ((__type_visibility__("default"))) pair;
template <class _Tp> class __attribute__ ((__type_visibility__("default"))) reference_wrapper;
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) hash;
template <class>
struct __void_t { typedef void type; };
template <class _Tp>
struct __identity { typedef _Tp type; };
template <class _Tp, bool>
struct __attribute__ ((__type_visibility__("default"))) __dependent_type : public _Tp {};
template <bool _Bp, class _If, class _Then>
    struct __attribute__ ((__type_visibility__("default"))) conditional {typedef _If type;};
template <class _If, class _Then>
    struct __attribute__ ((__type_visibility__("default"))) conditional<false, _If, _Then> {typedef _Then type;};
template <bool, class _Tp> struct __attribute__ ((__type_visibility__("default"))) __lazy_enable_if {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) __lazy_enable_if<true, _Tp> {typedef typename _Tp::type type;};
template <bool, class _Tp = void> struct __attribute__ ((__type_visibility__("default"))) enable_if {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) enable_if<true, _Tp> {typedef _Tp type;};
template <class _Tp>
__attribute__((__no_sanitize__("cfi"))) __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_Tp*
addressof(_Tp& __x) noexcept
;
template <class _Tp> _Tp* addressof(const _Tp&&) noexcept = delete;
struct __two {char __lx[2];};
template <class _Tp, _Tp __v>
struct __attribute__ ((__type_visibility__("default"))) integral_constant
{
    static constexpr const _Tp value = __v;
    typedef _Tp value_type;
    typedef integral_constant type;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        constexpr operator value_type() const noexcept ;
};
template <class _Tp, _Tp __v>
constexpr const _Tp integral_constant<_Tp, __v>::value;
typedef integral_constant<bool,(true)> true_type;
typedef integral_constant<bool,(false)> false_type;
template <bool _Last, class ..._Preds>
struct __lazy_and_impl;
template <class ..._Preds>
struct __lazy_and_impl<false, _Preds...> : false_type {};
template <>
struct __lazy_and_impl<true> : true_type {};
template <class _Pred>
struct __lazy_and_impl<true, _Pred> : integral_constant<bool, _Pred::type::value> {};
template <class _Hp, class ..._Tp>
struct __lazy_and_impl<true, _Hp, _Tp...> : __lazy_and_impl<_Hp::type::value, _Tp...> {};
template <class _P1, class ..._Pr>
struct __lazy_and : __lazy_and_impl<_P1::type::value, _Pr...> {};
template <bool _List, class ..._Preds>
struct __lazy_or_impl;
template <class ..._Preds>
struct __lazy_or_impl<true, _Preds...> : true_type {};
template <>
struct __lazy_or_impl<false> : false_type {};
template <class _Hp, class ..._Tp>
struct __lazy_or_impl<false, _Hp, _Tp...>
        : __lazy_or_impl<_Hp::type::value, _Tp...> {};
template <class _P1, class ..._Pr>
struct __lazy_or : __lazy_or_impl<_P1::type::value, _Pr...> {};
template <class _Pred>
struct __lazy_not : integral_constant<bool, !_Pred::type::value> {};
template<class...> struct __and_;
template<> struct __and_<> : true_type {};
template<class _B0> struct __and_<_B0> : _B0 {};
template<class _B0, class _B1>
struct __and_<_B0, _B1> : conditional<_B0::value, _B1, _B0>::type {};
template<class _B0, class _B1, class _B2, class... _Bn>
struct __and_<_B0, _B1, _B2, _Bn...>
        : conditional<_B0::value, __and_<_B1, _B2, _Bn...>, _B0>::type {};
template<class...> struct __or_;
template<> struct __or_<> : false_type {};
template<class _B0> struct __or_<_B0> : _B0 {};
template<class _B0, class _B1>
struct __or_<_B0, _B1> : conditional<_B0::value, _B0, _B1>::type {};
template<class _B0, class _B1, class _B2, class... _Bn>
struct __or_<_B0, _B1, _B2, _Bn...>
        : conditional<_B0::value, _B0, __or_<_B1, _B2, _Bn...> >::type {};
template<class _Tp>
struct __not_ : conditional<_Tp::value, false_type, true_type>::type {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_const : public false_type {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_const<_Tp const> : public true_type {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_volatile : public false_type {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_volatile<_Tp volatile> : public true_type {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_const {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_const<const _Tp> {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_volatile {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_volatile<volatile _Tp> {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_cv
{typedef typename remove_volatile<typename remove_const<_Tp>::type>::type type;};
template <class _Tp> struct __libcpp_is_void : public false_type {};
template <> struct __libcpp_is_void<void> : public true_type {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_void
    : public __libcpp_is_void<typename remove_cv<_Tp>::type> {};
template <class _Tp> struct __is_nullptr_t_impl : public false_type {};
template <> struct __is_nullptr_t_impl<nullptr_t> : public true_type {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) __is_nullptr_t
    : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};
template <class _Tp> struct __libcpp_is_integral : public false_type {};
template <> struct __libcpp_is_integral<bool> : public true_type {};
template <> struct __libcpp_is_integral<char> : public true_type {};
template <> struct __libcpp_is_integral<signed char> : public true_type {};
template <> struct __libcpp_is_integral<unsigned char> : public true_type {};
template <> struct __libcpp_is_integral<wchar_t> : public true_type {};
template <> struct __libcpp_is_integral<char16_t> : public true_type {};
template <> struct __libcpp_is_integral<char32_t> : public true_type {};
template <> struct __libcpp_is_integral<short> : public true_type {};
template <> struct __libcpp_is_integral<unsigned short> : public true_type {};
template <> struct __libcpp_is_integral<int> : public true_type {};
template <> struct __libcpp_is_integral<unsigned int> : public true_type {};
template <> struct __libcpp_is_integral<long> : public true_type {};
template <> struct __libcpp_is_integral<unsigned long> : public true_type {};
template <> struct __libcpp_is_integral<long long> : public true_type {};
template <> struct __libcpp_is_integral<unsigned long long> : public true_type {};
template <> struct __libcpp_is_integral<__int128_t> : public true_type {};
template <> struct __libcpp_is_integral<__uint128_t> : public true_type {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_integral
    : public __libcpp_is_integral<typename remove_cv<_Tp>::type> {};
template <class _Tp> struct __libcpp_is_floating_point : public false_type {};
template <> struct __libcpp_is_floating_point<float> : public true_type {};
template <> struct __libcpp_is_floating_point<double> : public true_type {};
template <> struct __libcpp_is_floating_point<long double> : public true_type {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_floating_point
    : public __libcpp_is_floating_point<typename remove_cv<_Tp>::type> {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_array
    : public false_type {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_array<_Tp[]>
    : public true_type {};
template <class _Tp, size_t _Np> struct __attribute__ ((__type_visibility__("default"))) is_array<_Tp[_Np]>
    : public true_type {};
template <class _Tp> struct __libcpp_is_pointer : public false_type {};
template <class _Tp> struct __libcpp_is_pointer<_Tp*> : public true_type {};
template <class _Tp> struct __libcpp_remove_objc_qualifiers { typedef _Tp type; };
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_pointer
    : public __libcpp_is_pointer<typename __libcpp_remove_objc_qualifiers<typename remove_cv<_Tp>::type>::type> {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_lvalue_reference : public false_type {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_lvalue_reference<_Tp&> : public true_type {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_rvalue_reference : public false_type {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_rvalue_reference<_Tp&&> : public true_type {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_reference : public false_type {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_reference<_Tp&> : public true_type {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_reference<_Tp&&> : public true_type {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_union
    : public integral_constant<bool, __is_union(_Tp)> {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_class
    : public integral_constant<bool, __is_class(_Tp)> {};
template <class _Tp, class _Up> struct __attribute__ ((__type_visibility__("default"))) is_same : public false_type {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_same<_Tp, _Tp> : public true_type {};
namespace __libcpp_is_function_imp
{
struct __dummy_type {};
template <class _Tp> char __test(_Tp*);
template <class _Tp> char __test(__dummy_type);
template <class _Tp> __two __test(...);
template <class _Tp> _Tp& __source(int);
template <class _Tp> __dummy_type __source(...);
}
template <class _Tp, bool = is_class<_Tp>::value ||
                            is_union<_Tp>::value ||
                            is_void<_Tp>::value ||
                            is_reference<_Tp>::value ||
                            __is_nullptr_t<_Tp>::value >
struct __libcpp_is_function
    : public integral_constant<bool, sizeof(__libcpp_is_function_imp::__test<_Tp>(__libcpp_is_function_imp::__source<_Tp>(0))) == 1>
    {};
template <class _Tp> struct __libcpp_is_function<_Tp, true> : public false_type {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_function
    : public __libcpp_is_function<_Tp> {};
template <class _MP, bool _IsMemberFunctionPtr, bool _IsMemberObjectPtr>
struct __member_pointer_traits_imp
{
};
template <class _Tp> struct __libcpp_is_member_function_pointer
    : public false_type {};
template <class _Ret, class _Class>
struct __libcpp_is_member_function_pointer<_Ret _Class::*>
    : public is_function<_Ret> {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_member_function_pointer
    : public __libcpp_is_member_function_pointer<typename remove_cv<_Tp>::type>::type {};
template <class _Tp> struct __libcpp_is_member_pointer : public false_type {};
template <class _Tp, class _Up> struct __libcpp_is_member_pointer<_Tp _Up::*> : public true_type {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_member_pointer
    : public __libcpp_is_member_pointer<typename remove_cv<_Tp>::type> {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_member_object_pointer
    : public integral_constant<bool, is_member_pointer<_Tp>::value &&
                                    !is_member_function_pointer<_Tp>::value> {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_enum
    : public integral_constant<bool, __is_enum(_Tp)> {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_arithmetic
    : public integral_constant<bool, is_integral<_Tp>::value ||
                                     is_floating_point<_Tp>::value> {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_fundamental
    : public integral_constant<bool, is_void<_Tp>::value ||
                                     __is_nullptr_t<_Tp>::value ||
                                     is_arithmetic<_Tp>::value> {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_scalar
    : public integral_constant<bool, is_arithmetic<_Tp>::value ||
                                     is_member_pointer<_Tp>::value ||
                                     is_pointer<_Tp>::value ||
                                     __is_nullptr_t<_Tp>::value ||
                                     is_enum<_Tp>::value > {};
template <> struct __attribute__ ((__type_visibility__("default"))) is_scalar<nullptr_t> : public true_type {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_object
    : public integral_constant<bool, is_scalar<_Tp>::value ||
                                     is_array<_Tp>::value ||
                                     is_union<_Tp>::value ||
                                     is_class<_Tp>::value > {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_compound
    : public integral_constant<bool, !is_fundamental<_Tp>::value> {};
struct __is_referenceable_impl {
    template <class _Tp> static _Tp& __test(int);
    template <class _Tp> static __two __test(...);
};
template <class _Tp>
struct __is_referenceable : integral_constant<bool,
    !is_same<decltype(__is_referenceable_impl::__test<_Tp>(0)), __two>::value> {};
template <class _Tp, bool = is_reference<_Tp>::value ||
                            is_function<_Tp>::value ||
                            is_const<_Tp>::value >
struct __add_const {typedef _Tp type;};
template <class _Tp>
struct __add_const<_Tp, false> {typedef const _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) add_const
    {typedef typename __add_const<_Tp>::type type;};
template <class _Tp, bool = is_reference<_Tp>::value ||
                            is_function<_Tp>::value ||
                            is_volatile<_Tp>::value >
struct __add_volatile {typedef _Tp type;};
template <class _Tp>
struct __add_volatile<_Tp, false> {typedef volatile _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) add_volatile
    {typedef typename __add_volatile<_Tp>::type type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) add_cv
    {typedef typename add_const<typename add_volatile<_Tp>::type>::type type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_reference {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_reference<_Tp&> {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_reference<_Tp&&> {typedef _Tp type;};
template <class _Tp, bool = __is_referenceable<_Tp>::value> struct __add_lvalue_reference_impl { typedef _Tp type; };
template <class _Tp > struct __add_lvalue_reference_impl<_Tp, true> { typedef _Tp& type; };
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) add_lvalue_reference
{typedef typename __add_lvalue_reference_impl<_Tp>::type type;};
template <class _Tp, bool = __is_referenceable<_Tp>::value> struct __add_rvalue_reference_impl { typedef _Tp type; };
template <class _Tp > struct __add_rvalue_reference_impl<_Tp, true> { typedef _Tp&& type; };
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) add_rvalue_reference
{typedef typename __add_rvalue_reference_impl<_Tp>::type type;};
template <class _Tp> _Tp&& __declval(int);
template <class _Tp> _Tp __declval(long);
template <class _Tp>
decltype(std::__1::__declval<_Tp>(0))
declval() noexcept;
template <class _Tp>
struct __uncvref {
    typedef typename remove_cv<typename remove_reference<_Tp>::type>::type type;
};
template <class _Tp>
struct __unconstref {
    typedef typename remove_const<typename remove_reference<_Tp>::type>::type type;
};
template <class _Tp>
using __uncvref_t = typename __uncvref<_Tp>::type;
template <class _Tp, class _Up>
struct __is_same_uncvref : is_same<typename __uncvref<_Tp>::type,
                                   typename __uncvref<_Up>::type> {};
struct __any
{
    __any(...);
};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_pointer {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_pointer<_Tp*> {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_pointer<_Tp* const> {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_pointer<_Tp* volatile> {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_pointer<_Tp* const volatile> {typedef _Tp type;};
template <class _Tp,
        bool = __is_referenceable<_Tp>::value ||
                is_same<typename remove_cv<_Tp>::type, void>::value>
struct __add_pointer_impl
    {typedef typename remove_reference<_Tp>::type* type;};
template <class _Tp> struct __add_pointer_impl<_Tp, false>
    {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) add_pointer
    {typedef typename __add_pointer_impl<_Tp>::type type;};
template <class _Tp, bool = is_integral<_Tp>::value>
struct __libcpp_is_signed_impl : public integral_constant<bool,(_Tp(-1) < _Tp(0))> {};
template <class _Tp>
struct __libcpp_is_signed_impl<_Tp, false> : public true_type {};
template <class _Tp, bool = is_arithmetic<_Tp>::value>
struct __libcpp_is_signed : public __libcpp_is_signed_impl<_Tp> {};
template <class _Tp> struct __libcpp_is_signed<_Tp, false> : public false_type {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_signed : public __libcpp_is_signed<_Tp> {};
template <class _Tp, bool = is_integral<_Tp>::value>
struct __libcpp_is_unsigned_impl : public integral_constant<bool,(_Tp(0) < _Tp(-1))> {};
template <class _Tp>
struct __libcpp_is_unsigned_impl<_Tp, false> : public false_type {};
template <class _Tp, bool = is_arithmetic<_Tp>::value>
struct __libcpp_is_unsigned : public __libcpp_is_unsigned_impl<_Tp> {};
template <class _Tp> struct __libcpp_is_unsigned<_Tp, false> : public false_type {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_unsigned : public __libcpp_is_unsigned<_Tp> {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) rank
    : public integral_constant<size_t, 0> {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) rank<_Tp[]>
    : public integral_constant<size_t, rank<_Tp>::value + 1> {};
template <class _Tp, size_t _Np> struct __attribute__ ((__type_visibility__("default"))) rank<_Tp[_Np]>
    : public integral_constant<size_t, rank<_Tp>::value + 1> {};
template <class _Tp, unsigned _Ip = 0> struct __attribute__ ((__type_visibility__("default"))) extent
    : public integral_constant<size_t, 0> {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) extent<_Tp[], 0>
    : public integral_constant<size_t, 0> {};
template <class _Tp, unsigned _Ip> struct __attribute__ ((__type_visibility__("default"))) extent<_Tp[], _Ip>
    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};
template <class _Tp, size_t _Np> struct __attribute__ ((__type_visibility__("default"))) extent<_Tp[_Np], 0>
    : public integral_constant<size_t, _Np> {};
template <class _Tp, size_t _Np, unsigned _Ip> struct __attribute__ ((__type_visibility__("default"))) extent<_Tp[_Np], _Ip>
    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_extent
    {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_extent<_Tp[]>
    {typedef _Tp type;};
template <class _Tp, size_t _Np> struct __attribute__ ((__type_visibility__("default"))) remove_extent<_Tp[_Np]>
    {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_all_extents
    {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_all_extents<_Tp[]>
    {typedef typename remove_all_extents<_Tp>::type type;};
template <class _Tp, size_t _Np> struct __attribute__ ((__type_visibility__("default"))) remove_all_extents<_Tp[_Np]>
    {typedef typename remove_all_extents<_Tp>::type type;};
template <class _Up, bool>
struct __decay {
    typedef typename remove_cv<_Up>::type type;
};
template <class _Up>
struct __decay<_Up, true> {
public:
    typedef typename conditional
                     <
                         is_array<_Up>::value,
                         typename remove_extent<_Up>::type*,
                         typename conditional
                         <
                              is_function<_Up>::value,
                              typename add_pointer<_Up>::type,
                              typename remove_cv<_Up>::type
                         >::type
                     >::type type;
};
template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) decay
{
private:
    typedef typename remove_reference<_Tp>::type _Up;
public:
    typedef typename __decay<_Up, __is_referenceable<_Up>::value>::type type;
};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_abstract
    : public integral_constant<bool, __is_abstract(_Tp)> {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default")))
__libcpp_is_final : public integral_constant<bool, __is_final(_Tp)> {};
template <class _Bp, class _Dp>
struct __attribute__ ((__type_visibility__("default"))) is_base_of
    : public integral_constant<bool, __is_base_of(_Bp, _Dp)> {};
template <class _T1, class _T2> struct __attribute__ ((__type_visibility__("default"))) is_convertible
    : public integral_constant<bool, __is_convertible_to(_T1, _T2) &&
                                     !is_abstract<_T2>::value> {};
template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_empty
    : public integral_constant<bool, __is_empty(_Tp)> {};
template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_polymorphic
    : public integral_constant<bool, __is_polymorphic(_Tp)> {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) has_virtual_destructor
    : public integral_constant<bool, __has_virtual_destructor(_Tp)> {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) alignment_of
    : public integral_constant<size_t, alignof(_Tp)> {};
template <class _Hp, class _Tp>
struct __type_list
{
    typedef _Hp _Head;
    typedef _Tp _Tail;
};
struct __nat
{
    __nat() = delete;
    __nat(const __nat&) = delete;
    __nat& operator=(const __nat&) = delete;
    ~__nat() = delete;
};
template <class _Tp>
struct __align_type
{
    static const size_t value = __alignof(_Tp);
    typedef _Tp type;
};
struct __struct_double {long double __lx;};
struct __struct_double4 {double __lx[4];};
typedef
    __type_list<__align_type<unsigned char>,
    __type_list<__align_type<unsigned short>,
    __type_list<__align_type<unsigned int>,
    __type_list<__align_type<unsigned long>,
    __type_list<__align_type<unsigned long long>,
    __type_list<__align_type<double>,
    __type_list<__align_type<long double>,
    __type_list<__align_type<__struct_double>,
    __type_list<__align_type<__struct_double4>,
    __type_list<__align_type<int*>,
    __nat
    > > > > > > > > > > __all_types;
template <class _TL, size_t _Align> struct __find_pod;
template <class _Hp, size_t _Align>
struct __find_pod<__type_list<_Hp, __nat>, _Align>
{
    typedef typename conditional<
                             _Align == _Hp::value,
                             typename _Hp::type,
                             void
                         >::type type;
};
template <class _Hp, class _Tp, size_t _Align>
struct __find_pod<__type_list<_Hp, _Tp>, _Align>
{
    typedef typename conditional<
                             _Align == _Hp::value,
                             typename _Hp::type,
                             typename __find_pod<_Tp, _Align>::type
                         >::type type;
};
template <class _TL, size_t _Len> struct __find_max_align;
template <class _Hp, size_t _Len>
struct __find_max_align<__type_list<_Hp, __nat>, _Len> : public integral_constant<size_t, _Hp::value> {};
template <size_t _Len, size_t _A1, size_t _A2>
struct __select_align
{
private:
    static const size_t __min = _A2 < _A1 ? _A2 : _A1;
    static const size_t __max = _A1 < _A2 ? _A2 : _A1;
public:
    static const size_t value = _Len < __max ? __min : __max;
};
template <class _Hp, class _Tp, size_t _Len>
struct __find_max_align<__type_list<_Hp, _Tp>, _Len>
    : public integral_constant<size_t, __select_align<_Len, _Hp::value, __find_max_align<_Tp, _Len>::value>::value> {};
template <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>
struct __attribute__ ((__type_visibility__("default"))) aligned_storage
{
    typedef typename __find_pod<__all_types, _Align>::type _Aligner;
    static_assert(!is_void<_Aligner>::value, "");
    union type
    {
        _Aligner __align;
        unsigned char __data[(_Len + _Align - 1)/_Align * _Align];
    };
};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x1>{ struct alignas(0x1) type { unsigned char __lx[(_Len + 0x1 - 1)/0x1 * 0x1]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x2>{ struct alignas(0x2) type { unsigned char __lx[(_Len + 0x2 - 1)/0x2 * 0x2]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x4>{ struct alignas(0x4) type { unsigned char __lx[(_Len + 0x4 - 1)/0x4 * 0x4]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x8>{ struct alignas(0x8) type { unsigned char __lx[(_Len + 0x8 - 1)/0x8 * 0x8]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x10>{ struct alignas(0x10) type { unsigned char __lx[(_Len + 0x10 - 1)/0x10 * 0x10]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x20>{ struct alignas(0x20) type { unsigned char __lx[(_Len + 0x20 - 1)/0x20 * 0x20]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x40>{ struct alignas(0x40) type { unsigned char __lx[(_Len + 0x40 - 1)/0x40 * 0x40]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x80>{ struct alignas(0x80) type { unsigned char __lx[(_Len + 0x80 - 1)/0x80 * 0x80]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x100>{ struct alignas(0x100) type { unsigned char __lx[(_Len + 0x100 - 1)/0x100 * 0x100]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x200>{ struct alignas(0x200) type { unsigned char __lx[(_Len + 0x200 - 1)/0x200 * 0x200]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x400>{ struct alignas(0x400) type { unsigned char __lx[(_Len + 0x400 - 1)/0x400 * 0x400]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x800>{ struct alignas(0x800) type { unsigned char __lx[(_Len + 0x800 - 1)/0x800 * 0x800]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x1000>{ struct alignas(0x1000) type { unsigned char __lx[(_Len + 0x1000 - 1)/0x1000 * 0x1000]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x2000>{ struct alignas(0x2000) type { unsigned char __lx[(_Len + 0x2000 - 1)/0x2000 * 0x2000]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x4000>{ struct alignas(0x4000) type { unsigned char __lx[(_Len + 0x4000 - 1)/0x4000 * 0x4000]; };};
template <size_t _I0, size_t ..._In>
struct __static_max;
template <size_t _I0>
struct __static_max<_I0>
{
    static const size_t value = _I0;
};
template <size_t _I0, size_t _I1, size_t ..._In>
struct __static_max<_I0, _I1, _In...>
{
    static const size_t value = _I0 >= _I1 ? __static_max<_I0, _In...>::value :
                                             __static_max<_I1, _In...>::value;
};
template <size_t _Len, class _Type0, class ..._Types>
struct aligned_union
{
    static const size_t alignment_value = __static_max<__alignof(_Type0),
                                                       __alignof(_Types)...>::value;
    static const size_t __len = __static_max<_Len, sizeof(_Type0),
                                             sizeof(_Types)...>::value;
    typedef typename aligned_storage<__len, alignment_value>::type type;
};
template <class _Tp>
struct __numeric_type
{
   static void __test(...);
   static float __test(float);
   static double __test(char);
   static double __test(int);
   static double __test(unsigned);
   static double __test(long);
   static double __test(unsigned long);
   static double __test(long long);
   static double __test(unsigned long long);
   static double __test(double);
   static long double __test(long double);
   typedef decltype(__test(declval<_Tp>())) type;
   static const bool value = !is_same<type, void>::value;
};
template <>
struct __numeric_type<void>
{
   static const bool value = true;
};
template <class _A1, class _A2 = void, class _A3 = void,
          bool = __numeric_type<_A1>::value &&
                 __numeric_type<_A2>::value &&
                 __numeric_type<_A3>::value>
class __promote_imp
{
public:
    static const bool value = false;
};
template <class _A1, class _A2, class _A3>
class __promote_imp<_A1, _A2, _A3, true>
{
private:
    typedef typename __promote_imp<_A1>::type __type1;
    typedef typename __promote_imp<_A2>::type __type2;
    typedef typename __promote_imp<_A3>::type __type3;
public:
    typedef decltype(__type1() + __type2() + __type3()) type;
    static const bool value = true;
};
template <class _A1, class _A2>
class __promote_imp<_A1, _A2, void, true>
{
private:
    typedef typename __promote_imp<_A1>::type __type1;
    typedef typename __promote_imp<_A2>::type __type2;
public:
    typedef decltype(__type1() + __type2()) type;
    static const bool value = true;
};
template <class _A1>
class __promote_imp<_A1, void, void, true>
{
public:
    typedef typename __numeric_type<_A1>::type type;
    static const bool value = true;
};
template <class _A1, class _A2 = void, class _A3 = void>
class __promote : public __promote_imp<_A1, _A2, _A3> {};
typedef
    __type_list<signed char,
    __type_list<signed short,
    __type_list<signed int,
    __type_list<signed long,
    __type_list<signed long long,
    __type_list<__int128_t,
    __nat
    >
    > > > > > __signed_types;
typedef
    __type_list<unsigned char,
    __type_list<unsigned short,
    __type_list<unsigned int,
    __type_list<unsigned long,
    __type_list<unsigned long long,
    __type_list<__uint128_t,
    __nat
    >
    > > > > > __unsigned_types;
template <class _TypeList, size_t _Size, bool = _Size <= sizeof(typename _TypeList::_Head)> struct __find_first;
template <class _Hp, class _Tp, size_t _Size>
struct __find_first<__type_list<_Hp, _Tp>, _Size, true>
{
    typedef _Hp type;
};
template <class _Hp, class _Tp, size_t _Size>
struct __find_first<__type_list<_Hp, _Tp>, _Size, false>
{
    typedef typename __find_first<_Tp, _Size>::type type;
};
template <class _Tp, class _Up, bool = is_const<typename remove_reference<_Tp>::type>::value,
                             bool = is_volatile<typename remove_reference<_Tp>::type>::value>
struct __apply_cv
{
    typedef _Up type;
};
template <class _Tp, class _Up>
struct __apply_cv<_Tp, _Up, true, false>
{
    typedef const _Up type;
};
template <class _Tp, class _Up>
struct __apply_cv<_Tp, _Up, false, true>
{
    typedef volatile _Up type;
};
template <class _Tp, class _Up>
struct __apply_cv<_Tp, _Up, true, true>
{
    typedef const volatile _Up type;
};
template <class _Tp, class _Up>
struct __apply_cv<_Tp&, _Up, false, false>
{
    typedef _Up& type;
};
template <class _Tp, class _Up>
struct __apply_cv<_Tp&, _Up, true, false>
{
    typedef const _Up& type;
};
template <class _Tp, class _Up>
struct __apply_cv<_Tp&, _Up, false, true>
{
    typedef volatile _Up& type;
};
template <class _Tp, class _Up>
struct __apply_cv<_Tp&, _Up, true, true>
{
    typedef const volatile _Up& type;
};
template <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>
struct __make_signed {};
template <class _Tp>
struct __make_signed<_Tp, true>
{
    typedef typename __find_first<__signed_types, sizeof(_Tp)>::type type;
};
template <> struct __make_signed<bool, true> {};
template <> struct __make_signed< signed short, true> {typedef short type;};
template <> struct __make_signed<unsigned short, true> {typedef short type;};
template <> struct __make_signed< signed int, true> {typedef int type;};
template <> struct __make_signed<unsigned int, true> {typedef int type;};
template <> struct __make_signed< signed long, true> {typedef long type;};
template <> struct __make_signed<unsigned long, true> {typedef long type;};
template <> struct __make_signed< signed long long, true> {typedef long long type;};
template <> struct __make_signed<unsigned long long, true> {typedef long long type;};
template <> struct __make_signed<__int128_t, true> {typedef __int128_t type;};
template <> struct __make_signed<__uint128_t, true> {typedef __int128_t type;};
template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) make_signed
{
    typedef typename __apply_cv<_Tp, typename __make_signed<typename remove_cv<_Tp>::type>::type>::type type;
};
template <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>
struct __make_unsigned {};
template <class _Tp>
struct __make_unsigned<_Tp, true>
{
    typedef typename __find_first<__unsigned_types, sizeof(_Tp)>::type type;
};
template <> struct __make_unsigned<bool, true> {};
template <> struct __make_unsigned< signed short, true> {typedef unsigned short type;};
template <> struct __make_unsigned<unsigned short, true> {typedef unsigned short type;};
template <> struct __make_unsigned< signed int, true> {typedef unsigned int type;};
template <> struct __make_unsigned<unsigned int, true> {typedef unsigned int type;};
template <> struct __make_unsigned< signed long, true> {typedef unsigned long type;};
template <> struct __make_unsigned<unsigned long, true> {typedef unsigned long type;};
template <> struct __make_unsigned< signed long long, true> {typedef unsigned long long type;};
template <> struct __make_unsigned<unsigned long long, true> {typedef unsigned long long type;};
template <> struct __make_unsigned<__int128_t, true> {typedef __uint128_t type;};
template <> struct __make_unsigned<__uint128_t, true> {typedef __uint128_t type;};
template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) make_unsigned
{
    typedef typename __apply_cv<_Tp, typename __make_unsigned<typename remove_cv<_Tp>::type>::type>::type type;
};
template <class ..._Tp>
struct __attribute__ ((__type_visibility__("default"))) common_type {};
template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) common_type<_Tp>
    : public common_type<_Tp, _Tp> {};
template <class _Tp, class _Up, class = void>
struct __common_type2_imp {};
template <class _Tp, class _Up>
struct __common_type2_imp<_Tp, _Up,
    typename __void_t<decltype(
        true ? std::__1::declval<_Tp>() : std::__1::declval<_Up>()
    )>::type>
{
    typedef typename decay<decltype(
        true ? std::__1::declval<_Tp>() : std::__1::declval<_Up>()
    )>::type type;
};
template <class _Tp, class _Up,
          class _DTp = typename decay<_Tp>::type,
          class _DUp = typename decay<_Up>::type>
using __common_type2 =
  typename conditional<
    is_same<_Tp, _DTp>::value && is_same<_Up, _DUp>::value,
    __common_type2_imp<_Tp, _Up>,
    common_type<_DTp, _DUp>
  >::type;
template <class _Tp, class _Up>
struct __attribute__ ((__type_visibility__("default"))) common_type<_Tp, _Up>
    : __common_type2<_Tp, _Up> {};
template <class ...Tp> struct __common_types;
template <class, class = void>
struct __common_type_impl {};
template <class _Tp, class _Up>
struct __common_type_impl<
    __common_types<_Tp, _Up>,
    typename __void_t<typename common_type<_Tp, _Up>::type>::type>
{
  typedef typename common_type<_Tp, _Up>::type type;
};
template <class _Tp, class _Up, class ..._Vp>
struct __common_type_impl<__common_types<_Tp, _Up, _Vp...>,
    typename __void_t<typename common_type<_Tp, _Up>::type>::type>
  : __common_type_impl<
      __common_types<typename common_type<_Tp, _Up>::type, _Vp...> >
{
};
template <class _Tp, class _Up, class ..._Vp>
struct __attribute__ ((__type_visibility__("default"))) common_type<_Tp, _Up, _Vp...>
    : __common_type_impl<__common_types<_Tp, _Up, _Vp...> > {};
template<typename, typename _Tp> struct __select_2nd { typedef _Tp type; };
template <class _Tp, class _Arg>
typename __select_2nd<decltype((std::__1::declval<_Tp>() = std::__1::declval<_Arg>())), true_type>::type
__is_assignable_test(int);
template <class, class>
false_type __is_assignable_test(...);
template <class _Tp, class _Arg, bool = is_void<_Tp>::value || is_void<_Arg>::value>
struct __is_assignable_imp
    : public decltype((std::__1::__is_assignable_test<_Tp, _Arg>(0))) {};
template <class _Tp, class _Arg>
struct __is_assignable_imp<_Tp, _Arg, true>
    : public false_type
{
};
template <class _Tp, class _Arg>
struct is_assignable
    : public __is_assignable_imp<_Tp, _Arg> {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_copy_assignable
    : public is_assignable<typename add_lvalue_reference<_Tp>::type,
                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_move_assignable
    : public is_assignable<typename add_lvalue_reference<_Tp>::type,
                           typename add_rvalue_reference<_Tp>::type> {};
template <class>
struct __is_destructible_apply { typedef int type; };
template <typename _Tp>
struct __is_destructor_wellformed {
    template <typename _Tp1>
    static char __test (
        typename __is_destructible_apply<decltype(std::__1::declval<_Tp1&>().~_Tp1())>::type
    );
    template <typename _Tp1>
    static __two __test (...);
    static const bool value = sizeof(__test<_Tp>(12)) == sizeof(char);
};
template <class _Tp, bool>
struct __destructible_imp;
template <class _Tp>
struct __destructible_imp<_Tp, false>
   : public std::__1::integral_constant<bool,
        __is_destructor_wellformed<typename std::__1::remove_all_extents<_Tp>::type>::value> {};
template <class _Tp>
struct __destructible_imp<_Tp, true>
    : public std::__1::true_type {};
template <class _Tp, bool>
struct __destructible_false;
template <class _Tp>
struct __destructible_false<_Tp, false> : public __destructible_imp<_Tp, std::__1::is_reference<_Tp>::value> {};
template <class _Tp>
struct __destructible_false<_Tp, true> : public std::__1::false_type {};
template <class _Tp>
struct is_destructible
    : public __destructible_false<_Tp, std::__1::is_function<_Tp>::value> {};
template <class _Tp>
struct is_destructible<_Tp[]>
    : public std::__1::false_type {};
template <>
struct is_destructible<void>
    : public std::__1::false_type {};
template <class _Tp>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
typename remove_reference<_Tp>::type&&
move(_Tp&& __t) noexcept
;
template <class _Tp>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
_Tp&&
forward(typename remove_reference<_Tp>::type& __t) noexcept
;
template <class _Tp>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
_Tp&&
forward(typename remove_reference<_Tp>::type&& __t) noexcept
;
template <class _Tp>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename decay<_Tp>::type
__decay_copy(_Tp&& __t)
;
template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...), true, false>
{
    typedef _Class _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};
template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...), true, false>
{
    typedef _Class _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};
template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const, true, false>
{
    typedef _Class const _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};
template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const, true, false>
{
    typedef _Class const _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};
template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile, true, false>
{
    typedef _Class volatile _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};
template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile, true, false>
{
    typedef _Class volatile _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};
template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile, true, false>
{
    typedef _Class const volatile _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};
template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile, true, false>
{
    typedef _Class const volatile _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};
template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &, true, false>
{
    typedef _Class& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};
template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) &, true, false>
{
    typedef _Class& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};
template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&, true, false>
{
    typedef _Class const& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};
template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const&, true, false>
{
    typedef _Class const& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};
template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&, true, false>
{
    typedef _Class volatile& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};
template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile&, true, false>
{
    typedef _Class volatile& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};
template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&, true, false>
{
    typedef _Class const volatile& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};
template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile&, true, false>
{
    typedef _Class const volatile& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};
template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &&, true, false>
{
    typedef _Class&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};
template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) &&, true, false>
{
    typedef _Class&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};
template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&&, true, false>
{
    typedef _Class const&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};
template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const&&, true, false>
{
    typedef _Class const&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};
template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&&, true, false>
{
    typedef _Class volatile&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};
template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile&&, true, false>
{
    typedef _Class volatile&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};
template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&&, true, false>
{
    typedef _Class const volatile&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};
template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile&&, true, false>
{
    typedef _Class const volatile&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};
template <class _Rp, class _Class>
struct __member_pointer_traits_imp<_Rp _Class::*, false, true>
{
    typedef _Class _ClassType;
    typedef _Rp _ReturnType;
};
template <class _MP>
struct __member_pointer_traits
    : public __member_pointer_traits_imp<typename remove_cv<_MP>::type,
                    is_member_function_pointer<_MP>::value,
                    is_member_object_pointer<_MP>::value>
{
};
template <class _DecayedFp>
struct __member_pointer_class_type {};
template <class _Ret, class _ClassType>
struct __member_pointer_class_type<_Ret _ClassType::*> {
  typedef _ClassType type;
};
template <class _Callable> class result_of;
namespace __is_construct
{
struct __nat {};
}
template <class _Tp, class ..._Args>
struct __attribute__ ((__type_visibility__("default"))) is_constructible
    : public integral_constant<bool, __is_constructible(_Tp, _Args...)>
    {};
template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_default_constructible
    : public is_constructible<_Tp>
    {};
template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_copy_constructible
    : public is_constructible<_Tp,
                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};
template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_move_constructible
    : public is_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>
    {};
template <class _Tp, class... _Args>
struct __attribute__ ((__type_visibility__("default"))) is_trivially_constructible
    : integral_constant<bool, __is_trivially_constructible(_Tp, _Args...)>
{
};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_default_constructible
    : public is_trivially_constructible<_Tp>
    {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_copy_constructible
    : public is_trivially_constructible<_Tp, typename add_lvalue_reference<const _Tp>::type>
    {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_move_constructible
    : public is_trivially_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>
    {};
template <class _Tp, class _Arg>
struct is_trivially_assignable
    : integral_constant<bool, __is_trivially_assignable(_Tp, _Arg)>
{
};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_copy_assignable
    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,
                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_move_assignable
    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,
                                     typename add_rvalue_reference<_Tp>::type>
    {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_destructible
    : public integral_constant<bool, is_destructible<_Tp>::value && __has_trivial_destructor(_Tp)> {};
template <bool, bool, class _Tp, class... _Args> struct __libcpp_is_nothrow_constructible;
template <class _Tp, class... _Args>
struct __libcpp_is_nothrow_constructible<true, false, _Tp, _Args...>
    : public integral_constant<bool, noexcept(_Tp(declval<_Args>()...))>
{
};
template <class _Tp>
void __implicit_conversion_to(_Tp) noexcept ;
template <class _Tp, class _Arg>
struct __libcpp_is_nothrow_constructible<true, true, _Tp, _Arg>
    : public integral_constant<bool, noexcept(__implicit_conversion_to<_Tp>(declval<_Arg>()))>
{
};
template <class _Tp, bool _IsReference, class... _Args>
struct __libcpp_is_nothrow_constructible<false, _IsReference, _Tp, _Args...>
    : public false_type
{
};
template <class _Tp, class... _Args>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_constructible
    : __libcpp_is_nothrow_constructible<is_constructible<_Tp, _Args...>::value, is_reference<_Tp>::value, _Tp, _Args...>
{
};
template <class _Tp, size_t _Ns>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_constructible<_Tp[_Ns]>
    : __libcpp_is_nothrow_constructible<is_constructible<_Tp>::value, is_reference<_Tp>::value, _Tp>
{
};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_nothrow_default_constructible
    : public is_nothrow_constructible<_Tp>
    {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_nothrow_copy_constructible
    : public is_nothrow_constructible<_Tp,
                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_nothrow_move_constructible
    : public is_nothrow_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>
    {};
template <bool, class _Tp, class _Arg> struct __libcpp_is_nothrow_assignable;
template <class _Tp, class _Arg>
struct __libcpp_is_nothrow_assignable<false, _Tp, _Arg>
    : public false_type
{
};
template <class _Tp, class _Arg>
struct __libcpp_is_nothrow_assignable<true, _Tp, _Arg>
    : public integral_constant<bool, noexcept(std::__1::declval<_Tp>() = std::__1::declval<_Arg>()) >
{
};
template <class _Tp, class _Arg>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_assignable
    : public __libcpp_is_nothrow_assignable<is_assignable<_Tp, _Arg>::value, _Tp, _Arg>
{
};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_nothrow_copy_assignable
    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,
                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_nothrow_move_assignable
    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,
                                     typename add_rvalue_reference<_Tp>::type>
    {};
template <bool, class _Tp> struct __libcpp_is_nothrow_destructible;
template <class _Tp>
struct __libcpp_is_nothrow_destructible<false, _Tp>
    : public false_type
{
};
template <class _Tp>
struct __libcpp_is_nothrow_destructible<true, _Tp>
    : public integral_constant<bool, noexcept(std::__1::declval<_Tp>().~_Tp()) >
{
};
template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_destructible
    : public __libcpp_is_nothrow_destructible<is_destructible<_Tp>::value, _Tp>
{
};
template <class _Tp, size_t _Ns>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_destructible<_Tp[_Ns]>
    : public is_nothrow_destructible<_Tp>
{
};
template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_destructible<_Tp&>
    : public true_type
{
};
template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_destructible<_Tp&&>
    : public true_type
{
};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_pod
    : public integral_constant<bool, __is_pod(_Tp)> {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_literal_type
    : public integral_constant<bool, __is_literal(_Tp)>
    {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_standard_layout
    : public integral_constant<bool, __is_standard_layout(_Tp)>
    {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_copyable
    : public integral_constant<bool, __is_trivially_copyable(_Tp)>
    {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivial
    : public integral_constant<bool, __is_trivial(_Tp)>
    {};
template <class _Tp> struct __is_reference_wrapper_impl : public false_type {};
template <class _Tp> struct __is_reference_wrapper_impl<reference_wrapper<_Tp> > : public true_type {};
template <class _Tp> struct __is_reference_wrapper
    : public __is_reference_wrapper_impl<typename remove_cv<_Tp>::type> {};
template <class _Fp, class _A0,
         class _DecayFp = typename decay<_Fp>::type,
         class _DecayA0 = typename decay<_A0>::type,
         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
using __enable_if_bullet1 = typename enable_if
    <
        is_member_function_pointer<_DecayFp>::value
        && is_base_of<_ClassT, _DecayA0>::value
    >::type;
template <class _Fp, class _A0,
         class _DecayFp = typename decay<_Fp>::type,
         class _DecayA0 = typename decay<_A0>::type>
using __enable_if_bullet2 = typename enable_if
    <
        is_member_function_pointer<_DecayFp>::value
        && __is_reference_wrapper<_DecayA0>::value
    >::type;
template <class _Fp, class _A0,
         class _DecayFp = typename decay<_Fp>::type,
         class _DecayA0 = typename decay<_A0>::type,
         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
using __enable_if_bullet3 = typename enable_if
    <
        is_member_function_pointer<_DecayFp>::value
        && !is_base_of<_ClassT, _DecayA0>::value
        && !__is_reference_wrapper<_DecayA0>::value
    >::type;
template <class _Fp, class _A0,
         class _DecayFp = typename decay<_Fp>::type,
         class _DecayA0 = typename decay<_A0>::type,
         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
using __enable_if_bullet4 = typename enable_if
    <
        is_member_object_pointer<_DecayFp>::value
        && is_base_of<_ClassT, _DecayA0>::value
    >::type;
template <class _Fp, class _A0,
         class _DecayFp = typename decay<_Fp>::type,
         class _DecayA0 = typename decay<_A0>::type>
using __enable_if_bullet5 = typename enable_if
    <
        is_member_object_pointer<_DecayFp>::value
        && __is_reference_wrapper<_DecayA0>::value
    >::type;
template <class _Fp, class _A0,
         class _DecayFp = typename decay<_Fp>::type,
         class _DecayA0 = typename decay<_A0>::type,
         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
using __enable_if_bullet6 = typename enable_if
    <
        is_member_object_pointer<_DecayFp>::value
        && !is_base_of<_ClassT, _DecayA0>::value
        && !__is_reference_wrapper<_DecayA0>::value
    >::type;
template <class ..._Args>
auto __invoke(__any, _Args&& ...__args) -> __nat;
template <class ..._Args>
auto __invoke_constexpr(__any, _Args&& ...__args) -> __nat;
template <class _Fp, class _A0, class ..._Args,
          class = __enable_if_bullet1<_Fp, _A0>>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
auto
__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
noexcept(noexcept((std::__1::forward<_A0>(__a0).*__f)(std::__1::forward<_Args>(__args)...))) -> decltype((std::__1::forward<_A0>(__a0).*__f)(std::__1::forward<_Args>(__args)...)) ;
template <class _Fp, class _A0, class ..._Args,
          class = __enable_if_bullet1<_Fp, _A0>>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr auto
__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
noexcept(noexcept((std::__1::forward<_A0>(__a0).*__f)(std::__1::forward<_Args>(__args)...))) -> decltype((std::__1::forward<_A0>(__a0).*__f)(std::__1::forward<_Args>(__args)...)) ;
template <class _Fp, class _A0, class ..._Args,
          class = __enable_if_bullet2<_Fp, _A0>>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
auto
__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
noexcept(noexcept((__a0.get().*__f)(std::__1::forward<_Args>(__args)...))) -> decltype((__a0.get().*__f)(std::__1::forward<_Args>(__args)...)) ;
template <class _Fp, class _A0, class ..._Args,
          class = __enable_if_bullet2<_Fp, _A0>>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr auto
__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
noexcept(noexcept((__a0.get().*__f)(std::__1::forward<_Args>(__args)...))) -> decltype((__a0.get().*__f)(std::__1::forward<_Args>(__args)...)) ;
template <class _Fp, class _A0, class ..._Args,
          class = __enable_if_bullet3<_Fp, _A0>>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
auto
__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
noexcept(noexcept(((*std::__1::forward<_A0>(__a0)).*__f)(std::__1::forward<_Args>(__args)...))) -> decltype(((*std::__1::forward<_A0>(__a0)).*__f)(std::__1::forward<_Args>(__args)...)) ;
template <class _Fp, class _A0, class ..._Args,
          class = __enable_if_bullet3<_Fp, _A0>>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr auto
__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
noexcept(noexcept(((*std::__1::forward<_A0>(__a0)).*__f)(std::__1::forward<_Args>(__args)...))) -> decltype(((*std::__1::forward<_A0>(__a0)).*__f)(std::__1::forward<_Args>(__args)...)) ;
template <class _Fp, class _A0,
          class = __enable_if_bullet4<_Fp, _A0>>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
auto
__invoke(_Fp&& __f, _A0&& __a0)
noexcept(noexcept(std::__1::forward<_A0>(__a0).*__f)) -> decltype(std::__1::forward<_A0>(__a0).*__f) ;
template <class _Fp, class _A0,
          class = __enable_if_bullet4<_Fp, _A0>>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr auto
__invoke_constexpr(_Fp&& __f, _A0&& __a0)
noexcept(noexcept(std::__1::forward<_A0>(__a0).*__f)) -> decltype(std::__1::forward<_A0>(__a0).*__f) ;
template <class _Fp, class _A0,
          class = __enable_if_bullet5<_Fp, _A0>>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
auto
__invoke(_Fp&& __f, _A0&& __a0)
noexcept(noexcept(__a0.get().*__f)) -> decltype(__a0.get().*__f) ;
template <class _Fp, class _A0,
          class = __enable_if_bullet5<_Fp, _A0>>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr auto
__invoke_constexpr(_Fp&& __f, _A0&& __a0)
noexcept(noexcept(__a0.get().*__f)) -> decltype(__a0.get().*__f) ;
template <class _Fp, class _A0,
          class = __enable_if_bullet6<_Fp, _A0>>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
auto
__invoke(_Fp&& __f, _A0&& __a0)
noexcept(noexcept((*std::__1::forward<_A0>(__a0)).*__f)) -> decltype((*std::__1::forward<_A0>(__a0)).*__f) ;
template <class _Fp, class _A0,
          class = __enable_if_bullet6<_Fp, _A0>>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr auto
__invoke_constexpr(_Fp&& __f, _A0&& __a0)
noexcept(noexcept((*std::__1::forward<_A0>(__a0)).*__f)) -> decltype((*std::__1::forward<_A0>(__a0)).*__f) ;
template <class _Fp, class ..._Args>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
auto
__invoke(_Fp&& __f, _Args&& ...__args)
noexcept(noexcept(std::__1::forward<_Fp>(__f)(std::__1::forward<_Args>(__args)...))) -> decltype(std::__1::forward<_Fp>(__f)(std::__1::forward<_Args>(__args)...)) ;
template <class _Fp, class ..._Args>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr auto
__invoke_constexpr(_Fp&& __f, _Args&& ...__args)
noexcept(noexcept(std::__1::forward<_Fp>(__f)(std::__1::forward<_Args>(__args)...))) -> decltype(std::__1::forward<_Fp>(__f)(std::__1::forward<_Args>(__args)...)) ;
template <class _Ret, class _Fp, class ..._Args>
struct __invokable_r
{
    using _Result = decltype(
        std::__1::__invoke(std::__1::declval<_Fp>(), std::__1::declval<_Args>()...));
    using type =
        typename conditional<
            !is_same<_Result, __nat>::value,
            typename conditional<
                is_void<_Ret>::value,
                true_type,
                is_convertible<_Result, _Ret>
            >::type,
            false_type
        >::type;
    static const bool value = type::value;
};
template <class _Fp, class ..._Args>
using __invokable = __invokable_r<void, _Fp, _Args...>;
template <bool _IsInvokable, bool _IsCVVoid, class _Ret, class _Fp, class ..._Args>
struct __nothrow_invokable_r_imp {
  static const bool value = false;
};
template <class _Ret, class _Fp, class ..._Args>
struct __nothrow_invokable_r_imp<true, false, _Ret, _Fp, _Args...>
{
    typedef __nothrow_invokable_r_imp _ThisT;
    template <class _Tp>
    static void __test_noexcept(_Tp) noexcept;
    static const bool value = noexcept(_ThisT::__test_noexcept<_Ret>(
        std::__1::__invoke(std::__1::declval<_Fp>(), std::__1::declval<_Args>()...)));
};
template <class _Ret, class _Fp, class ..._Args>
struct __nothrow_invokable_r_imp<true, true, _Ret, _Fp, _Args...>
{
    static const bool value = noexcept(
        std::__1::__invoke(std::__1::declval<_Fp>(), std::__1::declval<_Args>()...));
};
template <class _Ret, class _Fp, class ..._Args>
using __nothrow_invokable_r =
    __nothrow_invokable_r_imp<
            __invokable_r<_Ret, _Fp, _Args...>::value,
            is_void<_Ret>::value,
            _Ret, _Fp, _Args...
    >;
template <class _Fp, class ..._Args>
using __nothrow_invokable =
    __nothrow_invokable_r_imp<
            __invokable<_Fp, _Args...>::value,
            true, void, _Fp, _Args...
    >;
template <class _Fp, class ..._Args>
struct __invoke_of
    : public enable_if<
        __invokable<_Fp, _Args...>::value,
        typename __invokable_r<void, _Fp, _Args...>::_Result>
{
};
template <class _Fp, class ..._Args>
class __attribute__ ((__type_visibility__("default"))) result_of<_Fp(_Args...)>
    : public __invoke_of<_Fp, _Args...>
{
};
template <class _Tp> struct __is_swappable;
template <class _Tp> struct __is_nothrow_swappable;
template <class _Tp>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    is_move_constructible<_Tp>::value &&
    is_move_assignable<_Tp>::value
>::type
swap(_Tp& __x, _Tp& __y) noexcept(is_nothrow_move_constructible<_Tp>::value && is_nothrow_move_assignable<_Tp>::value)
;
template<class _Tp, size_t _Np>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if<
    __is_swappable<_Tp>::value
>::type
swap(_Tp (&__a)[_Np], _Tp (&__b)[_Np]) noexcept(__is_nothrow_swappable<_Tp>::value);
template <class _ForwardIterator1, class _ForwardIterator2>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
               noexcept(noexcept(swap(*std::__1::declval<_ForwardIterator1>(), *std::__1::declval<_ForwardIterator2>())))
;
namespace __detail
{
template <class _Tp, class _Up = _Tp,
          bool _NotVoid = !is_void<_Tp>::value && !is_void<_Up>::value>
struct __swappable_with
{
    template <class _LHS, class _RHS>
    static decltype(swap(std::__1::declval<_LHS>(), std::__1::declval<_RHS>()))
    __test_swap(int);
    template <class, class>
    static __nat __test_swap(long);
    typedef decltype((__test_swap<_Tp, _Up>(0))) __swap1;
    typedef decltype((__test_swap<_Up, _Tp>(0))) __swap2;
    static const bool value = !is_same<__swap1, __nat>::value
                           && !is_same<__swap2, __nat>::value;
};
template <class _Tp, class _Up>
struct __swappable_with<_Tp, _Up, false> : false_type {};
template <class _Tp, class _Up = _Tp, bool _Swappable = __swappable_with<_Tp, _Up>::value>
struct __nothrow_swappable_with {
  static const bool value =
      noexcept(swap(std::__1::declval<_Tp>(), std::__1::declval<_Up>()))
  && noexcept(swap(std::__1::declval<_Up>(), std::__1::declval<_Tp>()));
};
template <class _Tp, class _Up>
struct __nothrow_swappable_with<_Tp, _Up, false> : false_type {};
}
template <class _Tp>
struct __is_swappable
    : public integral_constant<bool, __detail::__swappable_with<_Tp&>::value>
{
};
template <class _Tp>
struct __is_nothrow_swappable
    : public integral_constant<bool, __detail::__nothrow_swappable_with<_Tp&>::value>
{
};
template <class _Tp>
struct underlying_type
{
    typedef __underlying_type(_Tp) type;
};
template <class _Tp, bool = is_enum<_Tp>::value>
struct __sfinae_underlying_type
{
    typedef typename underlying_type<_Tp>::type type;
    typedef decltype(((type)1) + 0) __promoted_type;
};
template <class _Tp>
struct __sfinae_underlying_type<_Tp, false> {};
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
int __convert_to_integral(int __val) ;
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
unsigned __convert_to_integral(unsigned __val) ;
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
long __convert_to_integral(long __val) ;
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
unsigned long __convert_to_integral(unsigned long __val) ;
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
long long __convert_to_integral(long long __val) ;
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
unsigned long long __convert_to_integral(unsigned long long __val) ;
template<typename _Fp>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
typename enable_if<is_floating_point<_Fp>::value, long long>::type
 __convert_to_integral(_Fp __val) ;
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
__int128_t __convert_to_integral(__int128_t __val) ;
 ;
template <class _Tp>
struct __has_operator_addressof_member_imp
{
    ;
    ;
    static const bool value = decltype(__test<_Tp>(0))::value;
};
template <class _Tp>
struct __has_operator_addressof_free_imp
{
    ;
    ;
    static const bool value = decltype(__test<_Tp>(0))::value;
};
template <class _Tp>
struct __has_operator_addressof
    : public integral_constant<bool, __has_operator_addressof_member_imp<_Tp>::value
                                  || __has_operator_addressof_free_imp<_Tp>::value>
{};
struct __extract_key_fail_tag {};
struct __extract_key_self_tag {};
struct __extract_key_first_tag {};
template <class _ValTy, class _Key,
          class _RawValTy = typename __unconstref<_ValTy>::type>
struct __can_extract_key
    : conditional<is_same<_RawValTy, _Key>::value, __extract_key_self_tag,
                  __extract_key_fail_tag>::type {};
template <class _Pair, class _Key, class _First, class _Second>
struct __can_extract_key<_Pair, _Key, pair<_First, _Second>>
    : conditional<is_same<typename remove_const<_First>::type, _Key>::value,
                  __extract_key_first_tag, __extract_key_fail_tag>::type {};
template <class _ValTy, class _Key, class _ContainerValueTy,
          class _RawValTy = typename __unconstref<_ValTy>::type>
struct __can_extract_map_key
    : integral_constant<bool, is_same<_RawValTy, _Key>::value> {};
template <class _ValTy, class _Key, class _RawValTy>
struct __can_extract_map_key<_ValTy, _Key, _Key, _RawValTy>
    : false_type {};
} }
extern "C" {
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
}
extern "C" {
;
}
extern "C" {
;
;
;
}
extern "C" {
;
;
;
;
;
}
typedef int errno_t;
extern "C" {
;
}
typedef __darwin_ssize_t ssize_t;
extern "C" {
;
;
;
;
;
;
;
;
;
;
;
;
}
extern "C" {
 ;
 ;
 ;
 ;
 ;
;
;
;
}
extern "C" {
;
;
;
;
;
}
extern "C++" {
  ;
  ;
  ;
  ;
  ;
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __attribute__ ((__enable_if__(true, "")))
      char* strpbrk( char* __s1, const char* __s2) ;
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
char* __libcpp_strrchr(const char* __s, int __c) ;
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __attribute__ ((__enable_if__(true, "")))
const char* strrchr(const char* __s, int __c) ;
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __attribute__ ((__enable_if__(true, "")))
      char* strrchr( char* __s, int __c) ;
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void* __libcpp_memchr(const void* __s, int __c, size_t __n) ;
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __attribute__ ((__enable_if__(true, "")))
const void* memchr(const void* __s, int __c, size_t __n) ;
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __attribute__ ((__enable_if__(true, "")))
      void* memchr( void* __s, int __c, size_t __n) ;
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
char* __libcpp_strstr(const char* __s1, const char* __s2) ;
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __attribute__ ((__enable_if__(true, "")))
const char* strstr(const char* __s1, const char* __s2) ;
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __attribute__ ((__enable_if__(true, "")))
      char* strstr( char* __s1, const char* __s2) ;
}
namespace std { inline namespace __1 {
using ::size_t;
} }
namespace std { inline namespace __1 {
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) tuple_size;
template <class _Tp, class...>
using __enable_if_tuple_size_imp = _Tp;
template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) tuple_size<__enable_if_tuple_size_imp<
    const _Tp,
    typename enable_if<!is_volatile<_Tp>::value>::type,
    integral_constant<size_t, sizeof(tuple_size<_Tp>)>>>
    : public integral_constant<size_t, tuple_size<_Tp>::value> {};
template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) tuple_size<__enable_if_tuple_size_imp<
    volatile _Tp,
    typename enable_if<!is_const<_Tp>::value>::type,
    integral_constant<size_t, sizeof(tuple_size<_Tp>)>>>
    : public integral_constant<size_t, tuple_size<_Tp>::value> {};
template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) tuple_size<__enable_if_tuple_size_imp<
    const volatile _Tp,
    integral_constant<size_t, sizeof(tuple_size<_Tp>)>>>
    : public integral_constant<size_t, tuple_size<_Tp>::value> {};
template <size_t _Ip, class _Tp> class __attribute__ ((__type_visibility__("default"))) tuple_element;
template <size_t _Ip, class _Tp>
class __attribute__ ((__type_visibility__("default"))) tuple_element<_Ip, const _Tp>
{
public:
    typedef typename add_const<typename tuple_element<_Ip, _Tp>::type>::type type;
};
template <size_t _Ip, class _Tp>
class __attribute__ ((__type_visibility__("default"))) tuple_element<_Ip, volatile _Tp>
{
public:
    typedef typename add_volatile<typename tuple_element<_Ip, _Tp>::type>::type type;
};
template <size_t _Ip, class _Tp>
class __attribute__ ((__type_visibility__("default"))) tuple_element<_Ip, const volatile _Tp>
{
public:
    typedef typename add_cv<typename tuple_element<_Ip, _Tp>::type>::type type;
};
template <class _Tp> struct __tuple_like : false_type {};
template <class _Tp> struct __tuple_like<const _Tp> : public __tuple_like<_Tp> {};
template <class _Tp> struct __tuple_like<volatile _Tp> : public __tuple_like<_Tp> {};
template <class _Tp> struct __tuple_like<const volatile _Tp> : public __tuple_like<_Tp> {};
template <size_t...> struct __tuple_indices {};
template <class _IdxType, _IdxType... _Values>
struct __integer_sequence {
  template <template <class _OIdxType, _OIdxType...> class _ToIndexSeq, class _ToIndexType>
  using __convert = _ToIndexSeq<_ToIndexType, _Values...>;
  template <size_t _Sp>
  using __to_tuple_indices = __tuple_indices<(_Values + _Sp)...>;
};
template <size_t _Ep, size_t _Sp>
using __make_indices_imp =
    typename __make_integer_seq<__integer_sequence, size_t, _Ep - _Sp>::template
    __to_tuple_indices<_Sp>;
template <size_t _Ep, size_t _Sp = 0>
struct __make_tuple_indices
{
    static_assert(_Sp <= _Ep, "__make_tuple_indices input error");
    typedef __make_indices_imp<_Ep, _Sp> type;
};
template <class ..._Tp> class __attribute__ ((__type_visibility__("default"))) tuple;
template <class... _Tp> struct __tuple_like<tuple<_Tp...> > : true_type {};
template <class ..._Tp>
struct __attribute__ ((__type_visibility__("default"))) tuple_size<tuple<_Tp...> >
    : public integral_constant<size_t, sizeof...(_Tp)>
{
};
template <size_t _Ip, class ..._Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename tuple_element<_Ip, tuple<_Tp...> >::type&
get(tuple<_Tp...>&) noexcept;
template <size_t _Ip, class ..._Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
const typename tuple_element<_Ip, tuple<_Tp...> >::type&
get(const tuple<_Tp...>&) noexcept;
template <size_t _Ip, class ..._Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename tuple_element<_Ip, tuple<_Tp...> >::type&&
get(tuple<_Tp...>&&) noexcept;
template <size_t _Ip, class ..._Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
const typename tuple_element<_Ip, tuple<_Tp...> >::type&&
get(const tuple<_Tp...>&&) noexcept;
template <class _T1, class _T2> struct __tuple_like<pair<_T1, _T2> > : true_type {};
template <size_t _Ip, class _T1, class _T2>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename tuple_element<_Ip, pair<_T1, _T2> >::type&
get(pair<_T1, _T2>&) noexcept;
template <size_t _Ip, class _T1, class _T2>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
const typename tuple_element<_Ip, pair<_T1, _T2> >::type&
get(const pair<_T1, _T2>&) noexcept;
template <size_t _Ip, class _T1, class _T2>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename tuple_element<_Ip, pair<_T1, _T2> >::type&&
get(pair<_T1, _T2>&&) noexcept;
template <size_t _Ip, class _T1, class _T2>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
const typename tuple_element<_Ip, pair<_T1, _T2> >::type&&
get(const pair<_T1, _T2>&&) noexcept;
template <class _Tp, size_t _Size> struct __attribute__ ((__type_visibility__("default"))) array;
template <class _Tp, size_t _Size> struct __tuple_like<array<_Tp, _Size> > : true_type {};
template <size_t _Ip, class _Tp, size_t _Size>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_Tp&
get(array<_Tp, _Size>&) noexcept;
template <size_t _Ip, class _Tp, size_t _Size>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
const _Tp&
get(const array<_Tp, _Size>&) noexcept;
template <size_t _Ip, class _Tp, size_t _Size>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_Tp&&
get(array<_Tp, _Size>&&) noexcept;
template <size_t _Ip, class _Tp, size_t _Size>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
const _Tp&&
get(const array<_Tp, _Size>&&) noexcept;
template <class ..._Tp> struct __tuple_types {};
template <size_t _Ip, class ..._Types>
class __attribute__ ((__type_visibility__("default"))) tuple_element<_Ip, __tuple_types<_Types...>>
{
public:
    static_assert(_Ip < sizeof...(_Types), "tuple_element index out of range");
    typedef __type_pack_element<_Ip, _Types...> type;
};
template <class ..._Tp>
struct __attribute__ ((__type_visibility__("default"))) tuple_size<__tuple_types<_Tp...> >
    : public integral_constant<size_t, sizeof...(_Tp)>
{
};
template <class... _Tp> struct __tuple_like<__tuple_types<_Tp...> > : true_type {};
template <bool _ApplyLV, bool _ApplyConst, bool _ApplyVolatile>
struct __apply_cv_mf;
template <>
struct __apply_cv_mf<false, false, false> {
  template <class _Tp> using __apply = _Tp;
};
template <>
struct __apply_cv_mf<false, true, false> {
  template <class _Tp> using __apply = const _Tp;
};
template <>
struct __apply_cv_mf<false, false, true> {
  template <class _Tp> using __apply = volatile _Tp;
};
template <>
struct __apply_cv_mf<false, true, true> {
  template <class _Tp> using __apply = const volatile _Tp;
};
template <>
struct __apply_cv_mf<true, false, false> {
  template <class _Tp> using __apply = _Tp&;
};
template <>
struct __apply_cv_mf<true, true, false> {
  template <class _Tp> using __apply = const _Tp&;
};
template <>
struct __apply_cv_mf<true, false, true> {
  template <class _Tp> using __apply = volatile _Tp&;
};
template <>
struct __apply_cv_mf<true, true, true> {
  template <class _Tp> using __apply = const volatile _Tp&;
};
template <class _Tp, class _RawTp = typename remove_reference<_Tp>::type>
using __apply_cv_t = __apply_cv_mf<
    is_lvalue_reference<_Tp>::value,
    is_const<_RawTp>::value,
    is_volatile<_RawTp>::value>;
template <class _TupleTypes, class _TupleIndices>
struct __make_tuple_types_flat;
template <template <class...> class _Tuple, class ..._Types, size_t ..._Idx>
struct __make_tuple_types_flat<_Tuple<_Types...>, __tuple_indices<_Idx...>> {
  template <class _Tp, class _ApplyFn = __apply_cv_t<_Tp>>
  using __apply_quals = __tuple_types<
      typename _ApplyFn::template __apply<__type_pack_element<_Idx, _Types...>>...
    >;
};
template <class _Vt, size_t _Np, size_t ..._Idx>
struct __make_tuple_types_flat<array<_Vt, _Np>, __tuple_indices<_Idx...>> {
  template <size_t>
  using __value_type = _Vt;
  template <class _Tp, class _ApplyFn = __apply_cv_t<_Tp>>
  using __apply_quals = __tuple_types<
      typename _ApplyFn::template __apply<__value_type<_Idx>>...
    >;
};
template <class _Tp, size_t _Ep = tuple_size<typename remove_reference<_Tp>::type>::value,
          size_t _Sp = 0,
          bool _SameSize = (_Ep == tuple_size<typename remove_reference<_Tp>::type>::value)>
struct __make_tuple_types
{
    static_assert(_Sp <= _Ep, "__make_tuple_types input error");
    using _RawTp = typename remove_cv<typename remove_reference<_Tp>::type>::type;
    using _Maker = __make_tuple_types_flat<_RawTp, typename __make_tuple_indices<_Ep, _Sp>::type>;
    using type = typename _Maker::template __apply_quals<_Tp>;
};
template <class ..._Types, size_t _Ep>
struct __make_tuple_types<tuple<_Types...>, _Ep, 0, true> {
  typedef __tuple_types<_Types...> type;
};
template <class ..._Types, size_t _Ep>
struct __make_tuple_types<__tuple_types<_Types...>, _Ep, 0, true> {
  typedef __tuple_types<_Types...> type;
};
template <bool ..._Preds>
struct __all_dummy;
template <bool ..._Pred>
using __all = is_same<__all_dummy<_Pred...>, __all_dummy<((void)_Pred, true)...>>;
struct __tuple_sfinae_base {
  template <template <class, class...> class _Trait,
            class ..._LArgs, class ..._RArgs>
  static auto __do_test(__tuple_types<_LArgs...>, __tuple_types<_RArgs...>)
    -> __all<typename enable_if<_Trait<_LArgs, _RArgs>::value, bool>::type{true}...>;
  template <template <class...> class>
  static auto __do_test(...) -> false_type;
  template <class _FromArgs, class _ToArgs>
  using __constructible = decltype(__do_test<is_constructible>(_ToArgs{}, _FromArgs{}));
  template <class _FromArgs, class _ToArgs>
  using __convertible = decltype(__do_test<is_convertible>(_FromArgs{}, _ToArgs{}));
  template <class _FromArgs, class _ToArgs>
  using __assignable = decltype(__do_test<is_assignable>(_ToArgs{}, _FromArgs{}));
};
template <class _Tp, class _Up, bool = __tuple_like<typename remove_reference<_Tp>::type>::value,
                                bool = __tuple_like<_Up>::value>
struct __tuple_convertible
    : public false_type {};
template <class _Tp, class _Up>
struct __tuple_convertible<_Tp, _Up, true, true>
    : public __tuple_sfinae_base::__convertible<
      typename __make_tuple_types<_Tp>::type
    , typename __make_tuple_types<_Up>::type
    >
{};
template <class _Tp, class _Up, bool = __tuple_like<typename remove_reference<_Tp>::type>::value,
                                bool = __tuple_like<_Up>::value>
struct __tuple_constructible
    : public false_type {};
template <class _Tp, class _Up>
struct __tuple_constructible<_Tp, _Up, true, true>
    : public __tuple_sfinae_base::__constructible<
      typename __make_tuple_types<_Tp>::type
    , typename __make_tuple_types<_Up>::type
    >
{};
template <class _Tp, class _Up, bool = __tuple_like<typename remove_reference<_Tp>::type>::value,
                                bool = __tuple_like<_Up>::value>
struct __tuple_assignable
    : public false_type {};
template <class _Tp, class _Up>
struct __tuple_assignable<_Tp, _Up, true, true>
    : public __tuple_sfinae_base::__assignable<
      typename __make_tuple_types<_Tp>::type
    , typename __make_tuple_types<_Up&>::type
    >
{};
template <size_t _Ip, class ..._Tp>
class __attribute__ ((__type_visibility__("default"))) tuple_element<_Ip, tuple<_Tp...> >
{
public:
    typedef typename tuple_element<_Ip, __tuple_types<_Tp...> >::type type;
};
template <bool _IsTuple, class _SizeTrait, size_t _Expected>
struct __tuple_like_with_size_imp : false_type {};
template <class _SizeTrait, size_t _Expected>
struct __tuple_like_with_size_imp<true, _SizeTrait, _Expected>
    : integral_constant<bool, _SizeTrait::value == _Expected> {};
template <class _Tuple, size_t _ExpectedSize,
          class _RawTuple = typename __uncvref<_Tuple>::type>
using __tuple_like_with_size = __tuple_like_with_size_imp<
                                   __tuple_like<_RawTuple>::value,
                                   tuple_size<_RawTuple>, _ExpectedSize
                              >;
struct __attribute__ ((__visibility__("default"))) __check_tuple_constructor_fail {
    template <class ...>
    static constexpr bool __enable_default() ;
    template <class ...>
    static constexpr bool __enable_explicit() ;
    template <class ...>
    static constexpr bool __enable_implicit() ;
    template <class ...>
    static constexpr bool __enable_assign() ;
};
} }
class __attribute__ ((__visibility__("default"))) __libcpp_debug_exception;
namespace std { inline namespace __1 {
struct __attribute__ ((__type_visibility__("default"))) __libcpp_debug_info {
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
  __libcpp_debug_info() ;
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
  __libcpp_debug_info(const char* __f, int __l, const char* __p, const char* __m) ;
  const char* __file_;
  int __line_;
  const char* __pred_;
  const char* __msg_;
};
typedef void(*__libcpp_debug_function_type)(__libcpp_debug_info const&);
extern __attribute__((__visibility__("default"))) __libcpp_debug_function_type __libcpp_debug_function;
[[noreturn]] __attribute__ ((__visibility__("default")))
void __libcpp_abort_debug_function(__libcpp_debug_info const&);
 [[noreturn]] __attribute__ ((__visibility__("default")))
void __libcpp_throw_debug_function(__libcpp_debug_info const&);
__attribute__ ((__visibility__("default")))
bool __libcpp_set_debug_function(__libcpp_debug_function_type __func);
} }
namespace std { inline namespace __1 {
namespace rel_ops
{
template<class _Tp>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator!=(const _Tp& __x, const _Tp& __y)
;
template<class _Tp>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator> (const _Tp& __x, const _Tp& __y)
;
template<class _Tp>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator<=(const _Tp& __x, const _Tp& __y)
;
template<class _Tp>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator>=(const _Tp& __x, const _Tp& __y)
;
}
template <class _ForwardIterator1, class _ForwardIterator2>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_ForwardIterator2
swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2)
;
template<class _Tp, size_t _Np>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if<
    __is_swappable<_Tp>::value
>::type
swap(_Tp (&__a)[_Np], _Tp (&__b)[_Np]) noexcept(__is_nothrow_swappable<_Tp>::value)
;
template <class _Tp>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename conditional
<
    !is_nothrow_move_constructible<_Tp>::value && is_copy_constructible<_Tp>::value,
    const _Tp&,
    _Tp&&
>::type
move_if_noexcept(_Tp& __x) noexcept
;
struct __attribute__ ((__type_visibility__("default"))) piecewise_construct_t { };
 constexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();
template <class _T1, class _T2>
struct __attribute__ ((__type_visibility__("default"))) pair
{
    typedef _T1 first_type;
    typedef _T2 second_type;
    _T1 first;
    _T2 second;
    pair(pair const&) = default;
    pair(pair&&) = default;
    template <bool _Val>
    using _EnableB = typename enable_if<_Val, bool>::type;
    struct _CheckArgs {
      template <class _U1, class _U2>
      static constexpr bool __enable_default() ;
      template <class _U1, class _U2>
      static constexpr bool __enable_explicit() ;
      template <class _U1, class _U2>
      static constexpr bool __enable_implicit() ;
    };
    template <bool _MaybeEnable>
    using _CheckArgsDep = typename conditional<
      _MaybeEnable, _CheckArgs, __check_tuple_constructor_fail>::type;
    struct _CheckTupleLikeConstructor {
        template <class _Tuple>
        static constexpr bool __enable_implicit() ;
        template <class _Tuple>
        static constexpr bool __enable_explicit() ;
        template <class _Tuple>
        static constexpr bool __enable_assign() ;
    };
    template <class _Tuple>
    using _CheckTLC = typename conditional<
        __tuple_like_with_size<_Tuple, 2>::value
            && !is_same<typename decay<_Tuple>::type, pair>::value,
        _CheckTupleLikeConstructor,
        __check_tuple_constructor_fail
    >::type;
    template<bool _Dummy = true, _EnableB<
            _CheckArgsDep<_Dummy>::template __enable_default<_T1, _T2>()
    > = false>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    pair() noexcept(is_nothrow_default_constructible<first_type>::value && is_nothrow_default_constructible<second_type>::value) ;
    template <bool _Dummy = true, _EnableB<
             _CheckArgsDep<_Dummy>::template __enable_explicit<_T1 const&, _T2 const&>()
    > = false>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit pair(_T1 const& __t1, _T2 const& __t2)
        noexcept(is_nothrow_copy_constructible<first_type>::value && is_nothrow_copy_constructible<second_type>::value) ;
    template<bool _Dummy = true, _EnableB<
            _CheckArgsDep<_Dummy>::template __enable_implicit<_T1 const&, _T2 const&>()
    > = false>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair(_T1 const& __t1, _T2 const& __t2)
        noexcept(is_nothrow_copy_constructible<first_type>::value && is_nothrow_copy_constructible<second_type>::value) ;
    template<class _U1, class _U2, _EnableB<
             _CheckArgs::template __enable_explicit<_U1, _U2>()
    > = false>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit pair(_U1&& __u1, _U2&& __u2)
        noexcept((is_nothrow_constructible<first_type, _U1>::value && is_nothrow_constructible<second_type, _U2>::value)) ;
    template<class _U1, class _U2, _EnableB<
            _CheckArgs::template __enable_implicit<_U1, _U2>()
    > = false>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair(_U1&& __u1, _U2&& __u2)
        noexcept((is_nothrow_constructible<first_type, _U1>::value && is_nothrow_constructible<second_type, _U2>::value)) ;
    template<class _U1, class _U2, _EnableB<
            _CheckArgs::template __enable_explicit<_U1 const&, _U2 const&>()
    > = false>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit pair(pair<_U1, _U2> const& __p)
        noexcept((is_nothrow_constructible<first_type, _U1 const&>::value && is_nothrow_constructible<second_type, _U2 const&>::value)) ;
    template<class _U1, class _U2, _EnableB<
            _CheckArgs::template __enable_implicit<_U1 const&, _U2 const&>()
    > = false>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair(pair<_U1, _U2> const& __p)
        noexcept((is_nothrow_constructible<first_type, _U1 const&>::value && is_nothrow_constructible<second_type, _U2 const&>::value)) ;
    template<class _U1, class _U2, _EnableB<
            _CheckArgs::template __enable_explicit<_U1, _U2>()
    > = false>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit pair(pair<_U1, _U2>&&__p)
        noexcept((is_nothrow_constructible<first_type, _U1&&>::value && is_nothrow_constructible<second_type, _U2&&>::value)) ;
    template<class _U1, class _U2, _EnableB<
            _CheckArgs::template __enable_implicit<_U1, _U2>()
    > = false>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair(pair<_U1, _U2>&& __p)
        noexcept((is_nothrow_constructible<first_type, _U1&&>::value && is_nothrow_constructible<second_type, _U2&&>::value)) ;
    template<class _Tuple, _EnableB<
            _CheckTLC<_Tuple>::template __enable_explicit<_Tuple>()
    > = false>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit pair(_Tuple&& __p) ;
    template<class _Tuple, _EnableB<
            _CheckTLC<_Tuple>::template __enable_implicit<_Tuple>()
    > = false>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair(_Tuple&& __p) ;
    template <class... _Args1, class... _Args2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair(piecewise_construct_t __pc,
         tuple<_Args1...> __first_args, tuple<_Args2...> __second_args)
        noexcept((is_nothrow_constructible<first_type, _Args1...>::value && is_nothrow_constructible<second_type, _Args2...>::value)) ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair& operator=(typename conditional<
                        is_copy_assignable<first_type>::value &&
                        is_copy_assignable<second_type>::value,
                    pair, __nat>::type const& __p)
        noexcept(is_nothrow_copy_assignable<first_type>::value && is_nothrow_copy_assignable<second_type>::value)
    ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair& operator=(typename conditional<
                        is_move_assignable<first_type>::value &&
                        is_move_assignable<second_type>::value,
                    pair, __nat>::type&& __p)
        noexcept(is_nothrow_move_assignable<first_type>::value && is_nothrow_move_assignable<second_type>::value)
    ;
    template <class _Tuple, _EnableB<
            _CheckTLC<_Tuple>::template __enable_assign<_Tuple>()
     > = false>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair& operator=(_Tuple&& __p) ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void
    swap(pair& __p) noexcept(__is_nothrow_swappable<first_type>::value && __is_nothrow_swappable<second_type>::value)
    ;
private:
    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        pair(piecewise_construct_t,
             tuple<_Args1...>& __first_args, tuple<_Args2...>& __second_args,
             __tuple_indices<_I1...>, __tuple_indices<_I2...>);
};
template <class _T1, class _T2>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator==(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
;
template <class _T1, class _T2>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator!=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
;
template <class _T1, class _T2>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator< (const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
;
template <class _T1, class _T2>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator> (const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
;
template <class _T1, class _T2>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator>=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
;
template <class _T1, class _T2>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator<=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
;
template <class _T1, class _T2>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_swappable<_T1>::value &&
    __is_swappable<_T2>::value,
    void
>::type
swap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)
                     noexcept((__is_nothrow_swappable<_T1>::value && __is_nothrow_swappable<_T2>::value))
;
template <class _Tp>
struct __unwrap_reference { typedef _Tp type; };
template <class _Tp>
struct __unwrap_reference<reference_wrapper<_Tp> > { typedef _Tp& type; };
template <class _Tp>
struct __unwrap_ref_decay
    : __unwrap_reference<typename decay<_Tp>::type>
{ };
template <class _T1, class _T2>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
pair<typename __unwrap_ref_decay<_T1>::type, typename __unwrap_ref_decay<_T2>::type>
make_pair(_T1&& __t1, _T2&& __t2)
;
template <class _T1, class _T2>
  struct __attribute__ ((__type_visibility__("default"))) tuple_size<pair<_T1, _T2> >
    : public integral_constant<size_t, 2> {};
template <size_t _Ip, class _T1, class _T2>
class __attribute__ ((__type_visibility__("default"))) tuple_element<_Ip, pair<_T1, _T2> >
{
    static_assert(_Ip < 2, "Index out of bounds in std::tuple_element<std::pair<T1, T2>>");
};
template <class _T1, class _T2>
class __attribute__ ((__type_visibility__("default"))) tuple_element<0, pair<_T1, _T2> >
{
public:
    typedef _T1 type;
};
template <class _T1, class _T2>
class __attribute__ ((__type_visibility__("default"))) tuple_element<1, pair<_T1, _T2> >
{
public:
    typedef _T2 type;
};
template <size_t _Ip> struct __get_pair;
template <>
struct __get_pair<0>
{
    template <class _T1, class _T2>
    static
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _T1&
    get(pair<_T1, _T2>& __p) noexcept ;
    template <class _T1, class _T2>
    static
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const _T1&
    get(const pair<_T1, _T2>& __p) noexcept ;
    template <class _T1, class _T2>
    static
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _T1&&
    get(pair<_T1, _T2>&& __p) noexcept ;
    template <class _T1, class _T2>
    static
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const _T1&&
    get(const pair<_T1, _T2>&& __p) noexcept ;
};
template <>
struct __get_pair<1>
{
    template <class _T1, class _T2>
    static
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _T2&
    get(pair<_T1, _T2>& __p) noexcept ;
    template <class _T1, class _T2>
    static
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const _T2&
    get(const pair<_T1, _T2>& __p) noexcept ;
    template <class _T1, class _T2>
    static
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _T2&&
    get(pair<_T1, _T2>&& __p) noexcept ;
    template <class _T1, class _T2>
    static
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const _T2&&
    get(const pair<_T1, _T2>&& __p) noexcept ;
};
template <size_t _Ip, class _T1, class _T2>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename tuple_element<_Ip, pair<_T1, _T2> >::type&
get(pair<_T1, _T2>& __p) noexcept
;
template <size_t _Ip, class _T1, class _T2>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
const typename tuple_element<_Ip, pair<_T1, _T2> >::type&
get(const pair<_T1, _T2>& __p) noexcept
;
template <size_t _Ip, class _T1, class _T2>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename tuple_element<_Ip, pair<_T1, _T2> >::type&&
get(pair<_T1, _T2>&& __p) noexcept
;
template <size_t _Ip, class _T1, class _T2>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
const typename tuple_element<_Ip, pair<_T1, _T2> >::type&&
get(const pair<_T1, _T2>&& __p) noexcept
;
template <class _Arg, class _Result>
struct __attribute__ ((__type_visibility__("default"))) unary_function
{
    typedef _Arg argument_type;
    typedef _Result result_type;
};
template <class _Size>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_Size
__loadword(const void* __p)
;
template <class _Size, size_t = sizeof(_Size)*8>
struct __murmur2_or_cityhash;
template <class _Size>
struct __murmur2_or_cityhash<_Size, 32>
{
    inline _Size operator()(const void* __key, _Size __len)
         __attribute__((__no_sanitize__("unsigned-integer-overflow")));
};
template <class _Size>
struct __murmur2_or_cityhash<_Size, 64>
{
    inline _Size operator()(const void* __key, _Size __len) __attribute__((__no_sanitize__("unsigned-integer-overflow")));
 private:
  static const _Size __k0 = 0xc3a5c85c97cb3127ULL;
  static const _Size __k1 = 0xb492b66fbe98f273ULL;
  static const _Size __k2 = 0x9ae16a3b2f90404fULL;
  static const _Size __k3 = 0xc949d7c7509e6557ULL;
  static _Size __rotate(_Size __val, int __shift) ;
  static _Size __rotate_by_at_least_1(_Size __val, int __shift) ;
  static _Size __shift_mix(_Size __val) ;
  static _Size __hash_len_16(_Size __u, _Size __v)
     __attribute__((__no_sanitize__("unsigned-integer-overflow")))
  ;
  static _Size __hash_len_0_to_16(const char* __s, _Size __len)
     __attribute__((__no_sanitize__("unsigned-integer-overflow")))
  ;
  static _Size __hash_len_17_to_32(const char *__s, _Size __len)
     __attribute__((__no_sanitize__("unsigned-integer-overflow")))
  ;
  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(
      _Size __w, _Size __x, _Size __y, _Size __z, _Size __a, _Size __b)
        __attribute__((__no_sanitize__("unsigned-integer-overflow")))
  ;
  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(
      const char* __s, _Size __a, _Size __b)
    __attribute__((__no_sanitize__("unsigned-integer-overflow")))
  ;
  static _Size __hash_len_33_to_64(const char *__s, size_t __len)
    __attribute__((__no_sanitize__("unsigned-integer-overflow")))
  ;
};
template <class _Tp, size_t = sizeof(_Tp) / sizeof(size_t)>
struct __scalar_hash;
template <class _Tp>
struct __scalar_hash<_Tp, 0>
    : public unary_function<_Tp, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t operator()(_Tp __v) const noexcept
    ;
};
template <class _Tp>
struct __scalar_hash<_Tp, 1>
    : public unary_function<_Tp, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t operator()(_Tp __v) const noexcept
    ;
};
template <class _Tp>
struct __scalar_hash<_Tp, 2>
    : public unary_function<_Tp, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t operator()(_Tp __v) const noexcept
    ;
};
template <class _Tp>
struct __scalar_hash<_Tp, 3>
    : public unary_function<_Tp, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t operator()(_Tp __v) const noexcept
    ;
};
template <class _Tp>
struct __scalar_hash<_Tp, 4>
    : public unary_function<_Tp, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t operator()(_Tp __v) const noexcept
    ;
};
struct _PairT {
  size_t first;
  size_t second;
};
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) size_t __hash_combine(size_t __lhs, size_t __rhs) noexcept ;
template<class _Tp>
struct __attribute__ ((__type_visibility__("default"))) hash<_Tp*>
    : public unary_function<_Tp*, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t operator()(_Tp* __v) const noexcept
    ;
};
template <>
struct __attribute__ ((__type_visibility__("default"))) hash<bool>
    : public unary_function<bool, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t operator()(bool __v) const noexcept ;
};
template <>
struct __attribute__ ((__type_visibility__("default"))) hash<char>
    : public unary_function<char, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t operator()(char __v) const noexcept ;
};
template <>
struct __attribute__ ((__type_visibility__("default"))) hash<signed char>
    : public unary_function<signed char, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t operator()(signed char __v) const noexcept ;
};
template <>
struct __attribute__ ((__type_visibility__("default"))) hash<unsigned char>
    : public unary_function<unsigned char, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t operator()(unsigned char __v) const noexcept ;
};
template <>
struct __attribute__ ((__type_visibility__("default"))) hash<char16_t>
    : public unary_function<char16_t, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t operator()(char16_t __v) const noexcept ;
};
template <>
struct __attribute__ ((__type_visibility__("default"))) hash<char32_t>
    : public unary_function<char32_t, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t operator()(char32_t __v) const noexcept ;
};
template <>
struct __attribute__ ((__type_visibility__("default"))) hash<wchar_t>
    : public unary_function<wchar_t, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t operator()(wchar_t __v) const noexcept ;
};
template <>
struct __attribute__ ((__type_visibility__("default"))) hash<short>
    : public unary_function<short, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t operator()(short __v) const noexcept ;
};
template <>
struct __attribute__ ((__type_visibility__("default"))) hash<unsigned short>
    : public unary_function<unsigned short, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t operator()(unsigned short __v) const noexcept ;
};
template <>
struct __attribute__ ((__type_visibility__("default"))) hash<int>
    : public unary_function<int, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t operator()(int __v) const noexcept ;
};
template <>
struct __attribute__ ((__type_visibility__("default"))) hash<unsigned int>
    : public unary_function<unsigned int, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t operator()(unsigned int __v) const noexcept ;
};
template <>
struct __attribute__ ((__type_visibility__("default"))) hash<long>
    : public unary_function<long, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t operator()(long __v) const noexcept ;
};
template <>
struct __attribute__ ((__type_visibility__("default"))) hash<unsigned long>
    : public unary_function<unsigned long, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t operator()(unsigned long __v) const noexcept ;
};
template <>
struct __attribute__ ((__type_visibility__("default"))) hash<long long>
    : public __scalar_hash<long long>
{
};
template <>
struct __attribute__ ((__type_visibility__("default"))) hash<unsigned long long>
    : public __scalar_hash<unsigned long long>
{
};
template <>
struct __attribute__ ((__type_visibility__("default"))) hash<__int128_t>
    : public __scalar_hash<__int128_t>
{
};
template <>
struct __attribute__ ((__type_visibility__("default"))) hash<__uint128_t>
    : public __scalar_hash<__uint128_t>
{
};
template <>
struct __attribute__ ((__type_visibility__("default"))) hash<float>
    : public __scalar_hash<float>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t operator()(float __v) const noexcept
    ;
};
template <>
struct __attribute__ ((__type_visibility__("default"))) hash<double>
    : public __scalar_hash<double>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t operator()(double __v) const noexcept
    ;
};
template <>
struct __attribute__ ((__type_visibility__("default"))) hash<long double>
    : public __scalar_hash<long double>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t operator()(long double __v) const noexcept
    ;
};
template <class _Key, class _Hash>
using __check_hash_requirements = integral_constant<bool,
    is_copy_constructible<_Hash>::value &&
    is_move_constructible<_Hash>::value &&
    __invokable_r<size_t, _Hash, _Key const&>::value
>;
template <class _Key, class _Hash = std::hash<_Key> >
using __has_enabled_hash = integral_constant<bool,
    __check_hash_requirements<_Key, _Hash>::value &&
    is_default_constructible<_Hash>::value
>;
template <class _Type, class ...>
using __enable_hash_helper = _Type;
} }
namespace std { inline namespace __1 {
using ::size_t;
using ::div_t;
using ::ldiv_t;
using ::lldiv_t;
} }
namespace std
{
class __attribute__ ((__visibility__("default"))) exception
{
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) exception() noexcept ;
    virtual ~exception() noexcept;
    virtual const char* what() const noexcept;
};
class __attribute__ ((__visibility__("default"))) bad_exception
    : public exception
{
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bad_exception() noexcept ;
    virtual ~bad_exception() noexcept;
    virtual const char* what() const noexcept;
};
typedef void (*unexpected_handler)();
__attribute__ ((__visibility__("default"))) unexpected_handler set_unexpected(unexpected_handler) noexcept;
__attribute__ ((__visibility__("default"))) unexpected_handler get_unexpected() noexcept;
[[noreturn]] __attribute__ ((__visibility__("default"))) void unexpected();
typedef void (*terminate_handler)();
__attribute__ ((__visibility__("default"))) terminate_handler set_terminate(terminate_handler) noexcept;
__attribute__ ((__visibility__("default"))) terminate_handler get_terminate() noexcept;
[[noreturn]] __attribute__ ((__visibility__("default"))) void terminate() noexcept;
__attribute__ ((__visibility__("default"))) bool uncaught_exception() noexcept;
__attribute__ ((__visibility__("default"))) __attribute__((availability(macosx,strict,introduced=10.12))) __attribute__((availability(ios,strict,introduced=10.0))) __attribute__((availability(tvos,strict,introduced=10.0))) __attribute__((availability(watchos,strict,introduced=3.0))) int uncaught_exceptions() noexcept;
class __attribute__ ((__visibility__("default"))) exception_ptr;
__attribute__ ((__visibility__("default"))) exception_ptr current_exception() noexcept;
[[noreturn]] __attribute__ ((__visibility__("default"))) void rethrow_exception(exception_ptr);
class __attribute__ ((__visibility__("default"))) exception_ptr
{
    void* __ptr_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) exception_ptr() ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) exception_ptr(nullptr_t) ;
    exception_ptr(const exception_ptr&) noexcept;
    exception_ptr& operator=(const exception_ptr&) noexcept;
    ~exception_ptr() noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit operator bool() const noexcept
    ;
    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator==(const exception_ptr& __x, const exception_ptr& __y) noexcept
        ;
    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator!=(const exception_ptr& __x, const exception_ptr& __y) noexcept
        ;
    friend __attribute__ ((__visibility__("default"))) exception_ptr current_exception() noexcept;
    friend __attribute__ ((__visibility__("default"))) void rethrow_exception(exception_ptr);
};
template<class _Ep>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) exception_ptr
make_exception_ptr(_Ep __e) noexcept
;
class __attribute__ ((__visibility__("default"))) nested_exception
{
    exception_ptr __ptr_;
public:
    nested_exception() noexcept;
    virtual ~nested_exception() noexcept;
    [[noreturn]] void rethrow_nested() const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) exception_ptr nested_ptr() const noexcept ;
};
template <class _Tp>
struct __nested
    : public _Tp,
      public nested_exception
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit __nested(const _Tp& __t) ;
};
template <class _Tp, class _Up, bool>
struct __throw_with_nested;
template <class _Tp, class _Up>
struct __throw_with_nested<_Tp, _Up, true> {
    [[noreturn]] static __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void
    __do_throw(_Tp&& __t)
    ;
};
template <class _Tp, class _Up>
struct __throw_with_nested<_Tp, _Up, false> {
    [[noreturn]] static __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void
    __do_throw(_Tp&& __t)
    ;
};
template <class _Tp>
[[noreturn]]
void
throw_with_nested(_Tp&& __t)
;
template <class _From, class _To>
struct __can_dynamic_cast : public integral_constant<bool,(is_polymorphic<_From>::value && (!is_base_of<_To, _From>::value || is_convertible<const _From*, const _To*>::value))> {};
template <class _Ep>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
rethrow_if_nested(const _Ep& __e,
                  typename enable_if< __can_dynamic_cast<_Ep, nested_exception>::value>::type* = 0)
;
template <class _Ep>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
rethrow_if_nested(const _Ep&,
                  typename enable_if<!__can_dynamic_cast<_Ep, nested_exception>::value>::type* = 0)
;
}
namespace std
{
class __attribute__ ((__visibility__("default"))) type_info
{
    type_info& operator=(const type_info&);
    type_info(const type_info&);
protected:
    const char *__type_name;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit type_info(const char* __n) ;
public:
    __attribute__((availability(macosx,strict,introduced=10.9))) __attribute__((availability(ios,strict,introduced=7.0)))
    virtual ~type_info();
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const char* name() const noexcept
    ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool before(const type_info& __arg) const noexcept
    ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t hash_code() const noexcept
    ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator==(const type_info& __arg) const noexcept
    ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator!=(const type_info& __arg) const noexcept
    ;
};
class __attribute__ ((__visibility__("default"))) bad_cast
    : public exception
{
public:
    bad_cast() noexcept;
    virtual ~bad_cast() noexcept;
    virtual const char* what() const noexcept;
};
class __attribute__ ((__visibility__("default"))) bad_typeid
    : public exception
{
public:
    bad_typeid() noexcept;
    virtual ~bad_typeid() noexcept;
    virtual const char* what() const noexcept;
};
}
namespace std { inline namespace __1 {
[[noreturn]] __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void __throw_bad_cast()
;
} }
namespace std
{
struct __attribute__ ((__visibility__("default"))) nothrow_t {};
extern __attribute__ ((__visibility__("default"))) const nothrow_t nothrow;
class __attribute__ ((__visibility__("default"))) bad_alloc
    : public exception
{
public:
    bad_alloc() noexcept;
    virtual ~bad_alloc() noexcept;
    virtual const char* what() const noexcept;
};
class __attribute__ ((__visibility__("default"))) bad_array_new_length
    : public bad_alloc
{
public:
    bad_array_new_length() noexcept;
    virtual ~bad_array_new_length() noexcept;
    virtual const char* what() const noexcept;
};
typedef void (*new_handler)();
__attribute__ ((__visibility__("default"))) new_handler set_new_handler(new_handler) noexcept;
__attribute__ ((__visibility__("default"))) new_handler get_new_handler() noexcept;
[[noreturn]] __attribute__ ((__visibility__("default"))) void __throw_bad_alloc();
enum class __attribute__ ((__type_visibility__("default"))) align_val_t : size_t { };
}
                              __attribute__ ((__visibility__("default"))) void* operator new(std::size_t __sz) ;
                              __attribute__ ((__visibility__("default"))) void* operator new(std::size_t __sz, const std::nothrow_t&) noexcept __attribute__((__malloc__));
__attribute__ ((__visibility__("default"))) void operator delete(void* __p) noexcept;
__attribute__ ((__visibility__("default"))) void operator delete(void* __p, const std::nothrow_t&) noexcept;
                              __attribute__ ((__visibility__("default"))) void* operator new[](std::size_t __sz) ;
                              __attribute__ ((__visibility__("default"))) void* operator new[](std::size_t __sz, const std::nothrow_t&) noexcept __attribute__((__malloc__));
__attribute__ ((__visibility__("default"))) void operator delete[](void* __p) noexcept;
__attribute__ ((__visibility__("default"))) void operator delete[](void* __p, const std::nothrow_t&) noexcept;
                              __attribute__ ((__visibility__("default"))) void* operator new(std::size_t __sz, std::align_val_t) ;
                              __attribute__ ((__visibility__("default"))) void* operator new(std::size_t __sz, std::align_val_t, const std::nothrow_t&) noexcept __attribute__((__malloc__));
__attribute__ ((__visibility__("default"))) void operator delete(void* __p, std::align_val_t) noexcept;
__attribute__ ((__visibility__("default"))) void operator delete(void* __p, std::align_val_t, const std::nothrow_t&) noexcept;
                              __attribute__ ((__visibility__("default"))) void* operator new[](std::size_t __sz, std::align_val_t) ;
                              __attribute__ ((__visibility__("default"))) void* operator new[](std::size_t __sz, std::align_val_t, const std::nothrow_t&) noexcept __attribute__((__malloc__));
__attribute__ ((__visibility__("default"))) void operator delete[](void* __p, std::align_val_t) noexcept;
__attribute__ ((__visibility__("default"))) void operator delete[](void* __p, std::align_val_t, const std::nothrow_t&) noexcept;
                               __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void* operator new (std::size_t, void* __p) noexcept ;
                               __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void* operator new[](std::size_t, void* __p) noexcept ;
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void operator delete (void*, void*) noexcept ;
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void operator delete[](void*, void*) noexcept ;
namespace std { inline namespace __1 {
constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool __is_overaligned_for_new(size_t __align) noexcept ;
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void *__libcpp_allocate(size_t __size, size_t __align) ;
struct _DeallocateCaller {
  static __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  void __do_deallocate_handle_size_align(void *__ptr, size_t __size, size_t __align) ;
  static __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  void __do_deallocate_handle_align(void *__ptr, size_t __align) ;
 private:
  static void __do_deallocate_handle_size(void *__ptr, size_t __size) ;
private:
  template <class _A1, class _A2>
  static void __do_call(void *__ptr, _A1 __a1, _A2 __a2) ;
  template <class _A1>
  static void __do_call(void *__ptr, _A1 __a1) ;
  static void __do_call(void *__ptr) ;
};
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void __libcpp_deallocate(void* __ptr, size_t __size, size_t __align) ;
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void __libcpp_deallocate_unsized(void* __ptr, size_t __align) ;
template <class _Tp>
constexpr _Tp* __launder(_Tp* __p) noexcept
;
} }
namespace std { inline namespace __1 {
enum float_round_style
{
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
};
enum float_denorm_style
{
    denorm_indeterminate = -1,
    denorm_absent = 0,
    denorm_present = 1
};
template <class _Tp, bool = is_arithmetic<_Tp>::value>
class __libcpp_numeric_limits
{
protected:
    typedef _Tp type;
    static constexpr const bool is_specialized = false;
    static constexpr const int digits = 0;
    static constexpr const int digits10 = 0;
    static constexpr const int max_digits10 = 0;
    static constexpr const bool is_signed = false;
    static constexpr const bool is_integer = false;
    static constexpr const bool is_exact = false;
    static constexpr const int radix = 0;
    static constexpr const int min_exponent = 0;
    static constexpr const int min_exponent10 = 0;
    static constexpr const int max_exponent = 0;
    static constexpr const int max_exponent10 = 0;
    static constexpr const bool has_infinity = false;
    static constexpr const bool has_quiet_NaN = false;
    static constexpr const bool has_signaling_NaN = false;
    static constexpr const float_denorm_style has_denorm = denorm_absent;
    static constexpr const bool has_denorm_loss = false;
    static constexpr const bool is_iec559 = false;
    static constexpr const bool is_bounded = false;
    static constexpr const bool is_modulo = false;
    static constexpr const bool traps = false;
    static constexpr const bool tinyness_before = false;
    static constexpr const float_round_style round_style = round_toward_zero;
};
template <class _Tp, int __digits, bool _IsSigned>
struct __libcpp_compute_min
{
    static constexpr const _Tp value = _Tp(_Tp(1) << __digits);
};
template <class _Tp, int __digits>
struct __libcpp_compute_min<_Tp, __digits, false>
{
    static constexpr const _Tp value = _Tp(0);
};
template <class _Tp>
class __libcpp_numeric_limits<_Tp, true>
{
protected:
    typedef _Tp type;
    static constexpr const bool is_specialized = true;
    static constexpr const bool is_signed = type(-1) < type(0);
    static constexpr const int digits = static_cast<int>(sizeof(type) * 8 - is_signed);
    static constexpr const int digits10 = digits * 3 / 10;
    static constexpr const int max_digits10 = 0;
    static constexpr const type __min = __libcpp_compute_min<type, digits, is_signed>::value;
    static constexpr const type __max = is_signed ? type(type(~0) ^ __min) : type(~0);
    static constexpr const bool is_integer = true;
    static constexpr const bool is_exact = true;
    static constexpr const int radix = 2;
    static constexpr const int min_exponent = 0;
    static constexpr const int min_exponent10 = 0;
    static constexpr const int max_exponent = 0;
    static constexpr const int max_exponent10 = 0;
    static constexpr const bool has_infinity = false;
    static constexpr const bool has_quiet_NaN = false;
    static constexpr const bool has_signaling_NaN = false;
    static constexpr const float_denorm_style has_denorm = denorm_absent;
    static constexpr const bool has_denorm_loss = false;
    static constexpr const bool is_iec559 = false;
    static constexpr const bool is_bounded = true;
    static constexpr const bool is_modulo = !std::__1::is_signed<_Tp>::value;
    static constexpr const bool traps = true;
    static constexpr const bool tinyness_before = false;
    static constexpr const float_round_style round_style = round_toward_zero;
};
template <>
class __libcpp_numeric_limits<bool, true>
{
protected:
    typedef bool type;
    static constexpr const bool is_specialized = true;
    static constexpr const bool is_signed = false;
    static constexpr const int digits = 1;
    static constexpr const int digits10 = 0;
    static constexpr const int max_digits10 = 0;
    static constexpr const type __min = false;
    static constexpr const type __max = true;
    static constexpr const bool is_integer = true;
    static constexpr const bool is_exact = true;
    static constexpr const int radix = 2;
    static constexpr const int min_exponent = 0;
    static constexpr const int min_exponent10 = 0;
    static constexpr const int max_exponent = 0;
    static constexpr const int max_exponent10 = 0;
    static constexpr const bool has_infinity = false;
    static constexpr const bool has_quiet_NaN = false;
    static constexpr const bool has_signaling_NaN = false;
    static constexpr const float_denorm_style has_denorm = denorm_absent;
    static constexpr const bool has_denorm_loss = false;
    static constexpr const bool is_iec559 = false;
    static constexpr const bool is_bounded = true;
    static constexpr const bool is_modulo = false;
    static constexpr const bool traps = false;
    static constexpr const bool tinyness_before = false;
    static constexpr const float_round_style round_style = round_toward_zero;
};
template <>
class __libcpp_numeric_limits<float, true>
{
protected:
    typedef float type;
    static constexpr const bool is_specialized = true;
    static constexpr const bool is_signed = true;
    static constexpr const int digits = 24;
    static constexpr const int digits10 = 6;
    static constexpr const int max_digits10 = 2+(digits * 30103l)/100000l;
    static constexpr const bool is_integer = false;
    static constexpr const bool is_exact = false;
    static constexpr const int radix = 2;
    static constexpr const int min_exponent = (-125);
    static constexpr const int min_exponent10 = (-37);
    static constexpr const int max_exponent = 128;
    static constexpr const int max_exponent10 = 38;
    static constexpr const bool has_infinity = true;
    static constexpr const bool has_quiet_NaN = true;
    static constexpr const bool has_signaling_NaN = true;
    static constexpr const float_denorm_style has_denorm = denorm_present;
    static constexpr const bool has_denorm_loss = false;
    static constexpr const bool is_iec559 = true;
    static constexpr const bool is_bounded = true;
    static constexpr const bool is_modulo = false;
    static constexpr const bool traps = false;
    static constexpr const bool tinyness_before = false;
    static constexpr const float_round_style round_style = round_to_nearest;
};
template <>
class __libcpp_numeric_limits<double, true>
{
protected:
    typedef double type;
    static constexpr const bool is_specialized = true;
    static constexpr const bool is_signed = true;
    static constexpr const int digits = 53;
    static constexpr const int digits10 = 15;
    static constexpr const int max_digits10 = 2+(digits * 30103l)/100000l;
    static constexpr const bool is_integer = false;
    static constexpr const bool is_exact = false;
    static constexpr const int radix = 2;
    static constexpr const int min_exponent = (-1021);
    static constexpr const int min_exponent10 = (-307);
    static constexpr const int max_exponent = 1024;
    static constexpr const int max_exponent10 = 308;
    static constexpr const bool has_infinity = true;
    static constexpr const bool has_quiet_NaN = true;
    static constexpr const bool has_signaling_NaN = true;
    static constexpr const float_denorm_style has_denorm = denorm_present;
    static constexpr const bool has_denorm_loss = false;
    static constexpr const bool is_iec559 = true;
    static constexpr const bool is_bounded = true;
    static constexpr const bool is_modulo = false;
    static constexpr const bool traps = false;
    static constexpr const bool tinyness_before = false;
    static constexpr const float_round_style round_style = round_to_nearest;
};
template <>
class __libcpp_numeric_limits<long double, true>
{
protected:
    typedef long double type;
    static constexpr const bool is_specialized = true;
    static constexpr const bool is_signed = true;
    static constexpr const int digits = 64;
    static constexpr const int digits10 = 18;
    static constexpr const int max_digits10 = 2+(digits * 30103l)/100000l;
    static constexpr const bool is_integer = false;
    static constexpr const bool is_exact = false;
    static constexpr const int radix = 2;
    static constexpr const int min_exponent = (-16381);
    static constexpr const int min_exponent10 = (-4931);
    static constexpr const int max_exponent = 16384;
    static constexpr const int max_exponent10 = 4932;
    static constexpr const bool has_infinity = true;
    static constexpr const bool has_quiet_NaN = true;
    static constexpr const bool has_signaling_NaN = true;
    static constexpr const float_denorm_style has_denorm = denorm_present;
    static constexpr const bool has_denorm_loss = false;
    static constexpr const bool is_iec559 = true;
    static constexpr const bool is_bounded = true;
    static constexpr const bool is_modulo = false;
    static constexpr const bool traps = false;
    static constexpr const bool tinyness_before = false;
    static constexpr const float_round_style round_style = round_to_nearest;
};
template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) numeric_limits
    : private __libcpp_numeric_limits<typename remove_cv<_Tp>::type>
{
    typedef __libcpp_numeric_limits<typename remove_cv<_Tp>::type> __base;
    typedef typename __base::type type;
public:
    static constexpr const bool is_specialized = __base::is_specialized;
    static constexpr const int digits = __base::digits;
    static constexpr const int digits10 = __base::digits10;
    static constexpr const int max_digits10 = __base::max_digits10;
    static constexpr const bool is_signed = __base::is_signed;
    static constexpr const bool is_integer = __base::is_integer;
    static constexpr const bool is_exact = __base::is_exact;
    static constexpr const int radix = __base::radix;
    static constexpr const int min_exponent = __base::min_exponent;
    static constexpr const int min_exponent10 = __base::min_exponent10;
    static constexpr const int max_exponent = __base::max_exponent;
    static constexpr const int max_exponent10 = __base::max_exponent10;
    static constexpr const bool has_infinity = __base::has_infinity;
    static constexpr const bool has_quiet_NaN = __base::has_quiet_NaN;
    static constexpr const bool has_signaling_NaN = __base::has_signaling_NaN;
    static constexpr const float_denorm_style has_denorm = __base::has_denorm;
    static constexpr const bool has_denorm_loss = __base::has_denorm_loss;
    static constexpr const bool is_iec559 = __base::is_iec559;
    static constexpr const bool is_bounded = __base::is_bounded;
    static constexpr const bool is_modulo = __base::is_modulo;
    static constexpr const bool traps = __base::traps;
    static constexpr const bool tinyness_before = __base::tinyness_before;
    static constexpr const float_round_style round_style = __base::round_style;
};
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_specialized;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::digits;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::digits10;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::max_digits10;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_signed;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_integer;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_exact;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::radix;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::min_exponent;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::min_exponent10;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::max_exponent;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::max_exponent10;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::has_infinity;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::has_quiet_NaN;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::has_signaling_NaN;
template <class _Tp>
    constexpr const float_denorm_style numeric_limits<_Tp>::has_denorm;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::has_denorm_loss;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_iec559;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_bounded;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_modulo;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::traps;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::tinyness_before;
template <class _Tp>
    constexpr const float_round_style numeric_limits<_Tp>::round_style;
template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) numeric_limits<const _Tp>
    : private numeric_limits<_Tp>
{
    typedef numeric_limits<_Tp> __base;
    typedef _Tp type;
public:
    static constexpr const bool is_specialized = __base::is_specialized;
    static constexpr const int digits = __base::digits;
    static constexpr const int digits10 = __base::digits10;
    static constexpr const int max_digits10 = __base::max_digits10;
    static constexpr const bool is_signed = __base::is_signed;
    static constexpr const bool is_integer = __base::is_integer;
    static constexpr const bool is_exact = __base::is_exact;
    static constexpr const int radix = __base::radix;
    static constexpr const int min_exponent = __base::min_exponent;
    static constexpr const int min_exponent10 = __base::min_exponent10;
    static constexpr const int max_exponent = __base::max_exponent;
    static constexpr const int max_exponent10 = __base::max_exponent10;
    static constexpr const bool has_infinity = __base::has_infinity;
    static constexpr const bool has_quiet_NaN = __base::has_quiet_NaN;
    static constexpr const bool has_signaling_NaN = __base::has_signaling_NaN;
    static constexpr const float_denorm_style has_denorm = __base::has_denorm;
    static constexpr const bool has_denorm_loss = __base::has_denorm_loss;
    static constexpr const bool is_iec559 = __base::is_iec559;
    static constexpr const bool is_bounded = __base::is_bounded;
    static constexpr const bool is_modulo = __base::is_modulo;
    static constexpr const bool traps = __base::traps;
    static constexpr const bool tinyness_before = __base::tinyness_before;
    static constexpr const float_round_style round_style = __base::round_style;
};
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_specialized;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::digits;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::digits10;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::max_digits10;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_signed;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_integer;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_exact;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::radix;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::min_exponent;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::min_exponent10;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::max_exponent;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::max_exponent10;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::has_infinity;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::has_quiet_NaN;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::has_signaling_NaN;
template <class _Tp>
    constexpr const float_denorm_style numeric_limits<const _Tp>::has_denorm;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::has_denorm_loss;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_iec559;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_bounded;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_modulo;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::traps;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::tinyness_before;
template <class _Tp>
    constexpr const float_round_style numeric_limits<const _Tp>::round_style;
template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) numeric_limits<volatile _Tp>
    : private numeric_limits<_Tp>
{
    typedef numeric_limits<_Tp> __base;
    typedef _Tp type;
public:
    static constexpr const bool is_specialized = __base::is_specialized;
    static constexpr const int digits = __base::digits;
    static constexpr const int digits10 = __base::digits10;
    static constexpr const int max_digits10 = __base::max_digits10;
    static constexpr const bool is_signed = __base::is_signed;
    static constexpr const bool is_integer = __base::is_integer;
    static constexpr const bool is_exact = __base::is_exact;
    static constexpr const int radix = __base::radix;
    static constexpr const int min_exponent = __base::min_exponent;
    static constexpr const int min_exponent10 = __base::min_exponent10;
    static constexpr const int max_exponent = __base::max_exponent;
    static constexpr const int max_exponent10 = __base::max_exponent10;
    static constexpr const bool has_infinity = __base::has_infinity;
    static constexpr const bool has_quiet_NaN = __base::has_quiet_NaN;
    static constexpr const bool has_signaling_NaN = __base::has_signaling_NaN;
    static constexpr const float_denorm_style has_denorm = __base::has_denorm;
    static constexpr const bool has_denorm_loss = __base::has_denorm_loss;
    static constexpr const bool is_iec559 = __base::is_iec559;
    static constexpr const bool is_bounded = __base::is_bounded;
    static constexpr const bool is_modulo = __base::is_modulo;
    static constexpr const bool traps = __base::traps;
    static constexpr const bool tinyness_before = __base::tinyness_before;
    static constexpr const float_round_style round_style = __base::round_style;
};
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_specialized;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::digits;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::digits10;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::max_digits10;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_signed;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_integer;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_exact;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::radix;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::min_exponent;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::min_exponent10;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::max_exponent;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::max_exponent10;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::has_infinity;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::has_quiet_NaN;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::has_signaling_NaN;
template <class _Tp>
    constexpr const float_denorm_style numeric_limits<volatile _Tp>::has_denorm;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::has_denorm_loss;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_iec559;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_bounded;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_modulo;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::traps;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::tinyness_before;
template <class _Tp>
    constexpr const float_round_style numeric_limits<volatile _Tp>::round_style;
template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) numeric_limits<const volatile _Tp>
    : private numeric_limits<_Tp>
{
    typedef numeric_limits<_Tp> __base;
    typedef _Tp type;
public:
    static constexpr const bool is_specialized = __base::is_specialized;
    static constexpr const int digits = __base::digits;
    static constexpr const int digits10 = __base::digits10;
    static constexpr const int max_digits10 = __base::max_digits10;
    static constexpr const bool is_signed = __base::is_signed;
    static constexpr const bool is_integer = __base::is_integer;
    static constexpr const bool is_exact = __base::is_exact;
    static constexpr const int radix = __base::radix;
    static constexpr const int min_exponent = __base::min_exponent;
    static constexpr const int min_exponent10 = __base::min_exponent10;
    static constexpr const int max_exponent = __base::max_exponent;
    static constexpr const int max_exponent10 = __base::max_exponent10;
    static constexpr const bool has_infinity = __base::has_infinity;
    static constexpr const bool has_quiet_NaN = __base::has_quiet_NaN;
    static constexpr const bool has_signaling_NaN = __base::has_signaling_NaN;
    static constexpr const float_denorm_style has_denorm = __base::has_denorm;
    static constexpr const bool has_denorm_loss = __base::has_denorm_loss;
    static constexpr const bool is_iec559 = __base::is_iec559;
    static constexpr const bool is_bounded = __base::is_bounded;
    static constexpr const bool is_modulo = __base::is_modulo;
    static constexpr const bool traps = __base::traps;
    static constexpr const bool tinyness_before = __base::tinyness_before;
    static constexpr const float_round_style round_style = __base::round_style;
};
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_specialized;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::digits;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::digits10;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::max_digits10;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_signed;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_integer;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_exact;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::radix;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::min_exponent;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::min_exponent10;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::max_exponent;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::max_exponent10;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::has_infinity;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::has_quiet_NaN;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::has_signaling_NaN;
template <class _Tp>
    constexpr const float_denorm_style numeric_limits<const volatile _Tp>::has_denorm;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::has_denorm_loss;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_iec559;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_bounded;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_modulo;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::traps;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::tinyness_before;
template <class _Tp>
    constexpr const float_round_style numeric_limits<const volatile _Tp>::round_style;
} }
typedef __darwin_mbstate_t mbstate_t;
typedef __builtin_va_list va_list;
typedef __builtin_va_list __gnuc_va_list;
typedef __darwin_va_list va_list;
extern "C" {
;
;
;
}
typedef __darwin_off_t fpos_t;
struct __sbuf {
 unsigned char *_base;
 int _size;
};
struct __sFILEX;
typedef struct __sFILE {
 unsigned char *_p;
 int _r;
 int _w;
 short _flags;
 short _file;
 struct __sbuf _bf;
 int _lbfsize;
 void *_cookie;
 int (* _Nullable _close)(void *);
 int (* _Nullable _read) (void *, char *, int);
 fpos_t (* _Nullable _seek) (void *, fpos_t, int);
 int (* _Nullable _write)(void *, const char *, int);
 struct __sbuf _ub;
 struct __sFILEX *_extra;
 int _ur;
 unsigned char _ubuf[3];
 unsigned char _nbuf[1];
 struct __sbuf _lb;
 int _blksize;
 fpos_t _offset;
} FILE;
extern "C" {
extern FILE *__stdinp;
extern FILE *__stdoutp;
extern FILE *__stderrp;
}
extern "C" {
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
}
extern "C" {
;
;
;
}
extern "C" {
;
;
}
extern "C" {
;
;
;
}
extern "C" {
;
;
;
;
;
;
;
;
;
;
}
typedef __darwin_off_t off_t;
extern "C" {
;
;
}
extern "C" {
;
;
;
;
;
}
extern "C" {
;
;
;
;
;
;
}
extern "C" {
extern const int sys_nerr;
extern const char *const sys_errlist[];
;
;
;
;
;
;
;
;
;
;
}
typedef __darwin_clock_t clock_t;
typedef __darwin_time_t time_t;
struct timespec
{
 __darwin_time_t tv_sec;
 long tv_nsec;
};
struct tm {
 int tm_sec;
 int tm_min;
 int tm_hour;
 int tm_mday;
 int tm_mon;
 int tm_year;
 int tm_wday;
 int tm_yday;
 int tm_isdst;
 long tm_gmtoff;
 char *tm_zone;
};
extern char *tzname[];
extern int getdate_err;
extern long timezone __asm("_" "timezone" );
extern int daylight;
extern "C" {
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
typedef enum {
_CLOCK_REALTIME __attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0))) = 0,
_CLOCK_MONOTONIC __attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0))) = 6,
_CLOCK_MONOTONIC_RAW __attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0))) = 4,
_CLOCK_MONOTONIC_RAW_APPROX __attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0))) = 5,
_CLOCK_UPTIME_RAW __attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0))) = 8,
_CLOCK_UPTIME_RAW_APPROX __attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0))) = 9,
_CLOCK_PROCESS_CPUTIME_ID __attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0))) = 12,
_CLOCK_THREAD_CPUTIME_ID __attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0))) = 16
} clockid_t;
;
;
;
;
}
typedef __darwin_wint_t wint_t;
typedef __darwin_wctype_t wctype_t;
typedef struct {
 __darwin_rune_t __min;
 __darwin_rune_t __max;
 __darwin_rune_t __map;
 __uint32_t *__types;
} _RuneEntry;
typedef struct {
 int __nranges;
 _RuneEntry *__ranges;
} _RuneRange;
typedef struct {
 char __name[14];
 __uint32_t __mask;
} _RuneCharClass;
typedef struct {
 char __magic[8];
 char __encoding[32];
 __darwin_rune_t (*__sgetrune)(const char *, __darwin_size_t, char const **);
 int (*__sputrune)(__darwin_rune_t, char *, __darwin_size_t, char **);
 __darwin_rune_t __invalid_rune;
 __uint32_t __runetype[(1 <<8 )];
 __darwin_rune_t __maplower[(1 <<8 )];
 __darwin_rune_t __mapupper[(1 <<8 )];
 _RuneRange __runetype_ext;
 _RuneRange __maplower_ext;
 _RuneRange __mapupper_ext;
 void *__variable;
 int __variable_len;
 int __ncharclasses;
 _RuneCharClass *__charclasses;
} _RuneLocale;
extern "C" {
extern _RuneLocale _DefaultRuneLocale;
extern _RuneLocale *_CurrentRuneLocale;
}
extern "C" {
;
;
;
}
extern "C" {
;
}
extern "C" {
;
;
}
extern "C" {
;
}
extern "C" {
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
}
extern "C" {
;
;
;
;
;
;
;
}
extern "C" {
;
;
;
;
;
;
;
;
;
}
extern "C" {
;
;
;
}
extern "C++" {
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __attribute__ ((__enable_if__(true, "")))
      wchar_t* wmemchr( wchar_t* __s, wchar_t __c, size_t __n) ;
}
namespace std { inline namespace __1 {
class __attribute__ ((__visibility__("default"))) ios_base;
template<class _CharT> struct __attribute__ ((__type_visibility__("default"))) char_traits;
template<> struct char_traits<char>;
template<> struct char_traits<char16_t>;
template<> struct char_traits<char32_t>;
template<> struct char_traits<wchar_t>;
template<class _Tp> class __attribute__ ((__type_visibility__("default"))) allocator;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_ios;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_streambuf;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_istream;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_ostream;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_iostream;
template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_stringbuf;
template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_istringstream;
template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_ostringstream;
template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_stringstream;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_filebuf;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_ifstream;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_ofstream;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_fstream;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) istreambuf_iterator;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) ostreambuf_iterator;
typedef basic_ios<char> ios;
typedef basic_ios<wchar_t> wios;
typedef basic_streambuf<char> streambuf;
typedef basic_istream<char> istream;
typedef basic_ostream<char> ostream;
typedef basic_iostream<char> iostream;
typedef basic_stringbuf<char> stringbuf;
typedef basic_istringstream<char> istringstream;
typedef basic_ostringstream<char> ostringstream;
typedef basic_stringstream<char> stringstream;
typedef basic_filebuf<char> filebuf;
typedef basic_ifstream<char> ifstream;
typedef basic_ofstream<char> ofstream;
typedef basic_fstream<char> fstream;
typedef basic_streambuf<wchar_t> wstreambuf;
typedef basic_istream<wchar_t> wistream;
typedef basic_ostream<wchar_t> wostream;
typedef basic_iostream<wchar_t> wiostream;
typedef basic_stringbuf<wchar_t> wstringbuf;
typedef basic_istringstream<wchar_t> wistringstream;
typedef basic_ostringstream<wchar_t> wostringstream;
typedef basic_stringstream<wchar_t> wstringstream;
typedef basic_filebuf<wchar_t> wfilebuf;
typedef basic_ifstream<wchar_t> wifstream;
typedef basic_ofstream<wchar_t> wofstream;
typedef basic_fstream<wchar_t> wfstream;
template <class _State> class __attribute__ ((__type_visibility__("default"))) fpos;
typedef fpos<mbstate_t> streampos;
typedef fpos<mbstate_t> wstreampos;
typedef fpos<mbstate_t> u16streampos;
typedef fpos<mbstate_t> u32streampos;
typedef long long streamoff;
template <class _CharT,
          class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_string;
typedef basic_string<char, char_traits<char>, allocator<char> > string;
typedef basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > wstring;
template <class _Tp, class _Alloc = allocator<_Tp> >
class __attribute__ ((__type_visibility__("default"))) vector;
} }
namespace std { inline namespace __1 {
template <class _Arg1, class _Arg2, class _Result>
struct __attribute__ ((__type_visibility__("default"))) binary_function
{
    typedef _Arg1 first_argument_type;
    typedef _Arg2 second_argument_type;
    typedef _Result result_type;
};
template <class _Tp>
struct __has_result_type
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::result_type* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};
template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) less : binary_function<_Tp, _Tp, bool>
{
                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        ;
};
template <class _Tp>
struct __derives_from_unary_function
{
private:
    struct __two {char __lx; char __lxx;};
    static __two __test(...);
    template <class _Ap, class _Rp>
        static unary_function<_Ap, _Rp>
        __test(const volatile unary_function<_Ap, _Rp>*);
public:
    static const bool value = !is_same<decltype(__test((_Tp*)0)), __two>::value;
    typedef decltype(__test((_Tp*)0)) type;
};
template <class _Tp>
struct __derives_from_binary_function
{
private:
    struct __two {char __lx; char __lxx;};
    static __two __test(...);
    template <class _A1, class _A2, class _Rp>
        static binary_function<_A1, _A2, _Rp>
        __test(const volatile binary_function<_A1, _A2, _Rp>*);
public:
    static const bool value = !is_same<decltype(__test((_Tp*)0)), __two>::value;
    typedef decltype(__test((_Tp*)0)) type;
};
template <class _Tp, bool = __derives_from_unary_function<_Tp>::value>
struct __maybe_derive_from_unary_function
    : public __derives_from_unary_function<_Tp>::type
{
};
template <class _Tp>
struct __maybe_derive_from_unary_function<_Tp, false>
{
};
template <class _Tp, bool = __derives_from_binary_function<_Tp>::value>
struct __maybe_derive_from_binary_function
    : public __derives_from_binary_function<_Tp>::type
{
};
template <class _Tp>
struct __maybe_derive_from_binary_function<_Tp, false>
{
};
template <class _Tp, bool = __has_result_type<_Tp>::value>
struct __weak_result_type_imp
    : public __maybe_derive_from_unary_function<_Tp>,
      public __maybe_derive_from_binary_function<_Tp>
{
    typedef typename _Tp::result_type result_type;
};
template <class _Tp>
struct __weak_result_type_imp<_Tp, false>
    : public __maybe_derive_from_unary_function<_Tp>,
      public __maybe_derive_from_binary_function<_Tp>
{
};
template <class _Tp>
struct __weak_result_type
    : public __weak_result_type_imp<_Tp>
{
};
template <class _Rp>
struct __weak_result_type<_Rp ()>
{
    typedef _Rp result_type;
};
template <class _Rp>
struct __weak_result_type<_Rp (&)()>
{
    typedef _Rp result_type;
};
template <class _Rp>
struct __weak_result_type<_Rp (*)()>
{
    typedef _Rp result_type;
};
template <class _Rp, class _A1>
struct __weak_result_type<_Rp (_A1)>
    : public unary_function<_A1, _Rp>
{
};
template <class _Rp, class _A1>
struct __weak_result_type<_Rp (&)(_A1)>
    : public unary_function<_A1, _Rp>
{
};
template <class _Rp, class _A1>
struct __weak_result_type<_Rp (*)(_A1)>
    : public unary_function<_A1, _Rp>
{
};
template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)()>
    : public unary_function<_Cp*, _Rp>
{
};
template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)() const>
    : public unary_function<const _Cp*, _Rp>
{
};
template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)() volatile>
    : public unary_function<volatile _Cp*, _Rp>
{
};
template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)() const volatile>
    : public unary_function<const volatile _Cp*, _Rp>
{
};
template <class _Rp, class _A1, class _A2>
struct __weak_result_type<_Rp (_A1, _A2)>
    : public binary_function<_A1, _A2, _Rp>
{
};
template <class _Rp, class _A1, class _A2>
struct __weak_result_type<_Rp (*)(_A1, _A2)>
    : public binary_function<_A1, _A2, _Rp>
{
};
template <class _Rp, class _A1, class _A2>
struct __weak_result_type<_Rp (&)(_A1, _A2)>
    : public binary_function<_A1, _A2, _Rp>
{
};
template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1)>
    : public binary_function<_Cp*, _A1, _Rp>
{
};
template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1) const>
    : public binary_function<const _Cp*, _A1, _Rp>
{
};
template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1) volatile>
    : public binary_function<volatile _Cp*, _A1, _Rp>
{
};
template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1) const volatile>
    : public binary_function<const volatile _Cp*, _A1, _Rp>
{
};
template <class _Rp, class _A1, class _A2, class _A3, class ..._A4>
struct __weak_result_type<_Rp (_A1, _A2, _A3, _A4...)>
{
    typedef _Rp result_type;
};
template <class _Rp, class _A1, class _A2, class _A3, class ..._A4>
struct __weak_result_type<_Rp (&)(_A1, _A2, _A3, _A4...)>
{
    typedef _Rp result_type;
};
template <class _Rp, class _A1, class _A2, class _A3, class ..._A4>
struct __weak_result_type<_Rp (*)(_A1, _A2, _A3, _A4...)>
{
    typedef _Rp result_type;
};
template <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>
struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...)>
{
    typedef _Rp result_type;
};
template <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>
struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) const>
{
    typedef _Rp result_type;
};
template <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>
struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) volatile>
{
    typedef _Rp result_type;
};
template <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>
struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) const volatile>
{
    typedef _Rp result_type;
};
template <class _Tp, class ..._Args>
struct __invoke_return
{
    typedef decltype(__invoke(std::__1::declval<_Tp>(), std::__1::declval<_Args>()...)) type;
};
template <class _Ret>
struct __invoke_void_return_wrapper
{
    template <class ..._Args>
    static _Ret __call(_Args&&... __args) ;
};
template <>
struct __invoke_void_return_wrapper<void>
{
    template <class ..._Args>
    static void __call(_Args&&... __args) ;
};
template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) reference_wrapper
    : public __weak_result_type<_Tp>
{
public:
    typedef _Tp type;
private:
    type* __f_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) reference_wrapper(type& __f) ;
    private: reference_wrapper(type&&); public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) operator type& () const noexcept ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) type& get() const noexcept ;
    template <class... _ArgTypes>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename __invoke_of<type&, _ArgTypes...>::type
    operator() (_ArgTypes&&... __args) const ;
};
template <class _Tp>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
reference_wrapper<_Tp>
ref(_Tp& __t) noexcept
;
template <class _Tp>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
reference_wrapper<_Tp>
ref(reference_wrapper<_Tp> __t) noexcept
;
template <class _Tp>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
reference_wrapper<const _Tp>
cref(const _Tp& __t) noexcept
;
template <class _Tp>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
reference_wrapper<const _Tp>
cref(reference_wrapper<_Tp> __t) noexcept
;
template <class _Tp> void ref(const _Tp&&) = delete;
template <class _Tp> void cref(const _Tp&&) = delete;
struct __attribute__ ((__type_visibility__("default"))) allocator_arg_t { };
 constexpr allocator_arg_t allocator_arg = allocator_arg_t();
template <class _Tp>
struct __has_allocator_type
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::allocator_type* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};
template <class _Tp, class _Alloc, bool = __has_allocator_type<_Tp>::value>
struct __uses_allocator
    : public integral_constant<bool,
        is_convertible<_Alloc, typename _Tp::allocator_type>::value>
{
};
template <class _Tp, class _Alloc>
struct __uses_allocator<_Tp, _Alloc, false>
    : public false_type
{
};
template <class _Tp, class _Alloc>
struct __attribute__ ((__type_visibility__("default"))) uses_allocator
    : public __uses_allocator<_Tp, _Alloc>
{
};
template <class _Tp, class _Alloc, class ..._Args>
struct __uses_alloc_ctor_imp
{
    typedef typename __uncvref<_Alloc>::type _RawAlloc;
    static const bool __ua = uses_allocator<_Tp, _RawAlloc>::value;
    static const bool __ic =
        is_constructible<_Tp, allocator_arg_t, _Alloc, _Args...>::value;
    static const int value = __ua ? 2 - __ic : 0;
};
template <class _Tp, class _Alloc, class ..._Args>
struct __uses_alloc_ctor
    : integral_constant<int, __uses_alloc_ctor_imp<_Tp, _Alloc, _Args...>::value>
    {};
template <class _Tp, class _Allocator, class... _Args>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void __user_alloc_construct_impl (integral_constant<int, 0>, _Tp *__storage, const _Allocator &, _Args &&... __args )
;
template <class _Tp, class _Allocator, class... _Args>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void __user_alloc_construct_impl (integral_constant<int, 1>, _Tp *__storage, const _Allocator &__a, _Args &&... __args )
;
template <class _Tp, class _Allocator, class... _Args>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void __user_alloc_construct_impl (integral_constant<int, 2>, _Tp *__storage, const _Allocator &__a, _Args &&... __args )
;
} }
namespace std { inline namespace __1 {
struct __attribute__ ((__type_visibility__("default"))) input_iterator_tag {};
struct __attribute__ ((__type_visibility__("default"))) output_iterator_tag {};
struct __attribute__ ((__type_visibility__("default"))) forward_iterator_tag : public input_iterator_tag {};
struct __attribute__ ((__type_visibility__("default"))) bidirectional_iterator_tag : public forward_iterator_tag {};
struct __attribute__ ((__type_visibility__("default"))) random_access_iterator_tag : public bidirectional_iterator_tag {};
template <class _Tp>
struct __has_iterator_typedefs
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename std::__void_t<typename _Up::iterator_category>::type* = 0,
              typename std::__void_t<typename _Up::difference_type>::type* = 0,
              typename std::__void_t<typename _Up::value_type>::type* = 0,
              typename std::__void_t<typename _Up::reference>::type* = 0,
              typename std::__void_t<typename _Up::pointer>::type* = 0
              );
public:
    static const bool value = sizeof(__test<_Tp>(0,0,0,0,0)) == 1;
};
template <class _Tp>
struct __has_iterator_category
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::iterator_category* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};
template <class _Iter, bool> struct __iterator_traits_impl {};
template <class _Iter>
struct __iterator_traits_impl<_Iter, true>
{
    typedef typename _Iter::difference_type difference_type;
    typedef typename _Iter::value_type value_type;
    typedef typename _Iter::pointer pointer;
    typedef typename _Iter::reference reference;
    typedef typename _Iter::iterator_category iterator_category;
};
template <class _Iter, bool> struct __iterator_traits {};
template <class _Iter>
struct __iterator_traits<_Iter, true>
    : __iterator_traits_impl
      <
        _Iter,
        is_convertible<typename _Iter::iterator_category, input_iterator_tag>::value ||
        is_convertible<typename _Iter::iterator_category, output_iterator_tag>::value
      >
{};
template <class _Iter>
struct __attribute__ ((__type_visibility__("default"))) iterator_traits
    : __iterator_traits<_Iter, __has_iterator_typedefs<_Iter>::value> {};
template<class _Tp>
struct __attribute__ ((__type_visibility__("default"))) iterator_traits<_Tp*>
{
    typedef ptrdiff_t difference_type;
    typedef typename remove_cv<_Tp>::type value_type;
    typedef _Tp* pointer;
    typedef _Tp& reference;
    typedef random_access_iterator_tag iterator_category;
};
template <class _Tp, class _Up, bool = __has_iterator_category<iterator_traits<_Tp> >::value>
struct __has_iterator_category_convertible_to
    : public integral_constant<bool, is_convertible<typename iterator_traits<_Tp>::iterator_category, _Up>::value>
{};
template <class _Tp, class _Up>
struct __has_iterator_category_convertible_to<_Tp, _Up, false> : public false_type {};
template <class _Tp>
struct __is_input_iterator : public __has_iterator_category_convertible_to<_Tp, input_iterator_tag> {};
template <class _Tp>
struct __is_forward_iterator : public __has_iterator_category_convertible_to<_Tp, forward_iterator_tag> {};
template <class _Tp>
struct __is_bidirectional_iterator : public __has_iterator_category_convertible_to<_Tp, bidirectional_iterator_tag> {};
template <class _Tp>
struct __is_random_access_iterator : public __has_iterator_category_convertible_to<_Tp, random_access_iterator_tag> {};
template <class _Tp>
struct __is_exactly_input_iterator
    : public integral_constant<bool,
         __has_iterator_category_convertible_to<_Tp, input_iterator_tag>::value &&
        !__has_iterator_category_convertible_to<_Tp, forward_iterator_tag>::value> {};
template<class _Category, class _Tp, class _Distance = ptrdiff_t,
         class _Pointer = _Tp*, class _Reference = _Tp&>
struct __attribute__ ((__type_visibility__("default"))) iterator
{
    typedef _Tp value_type;
    typedef _Distance difference_type;
    typedef _Pointer pointer;
    typedef _Reference reference;
    typedef _Category iterator_category;
};
template <class _InputIter>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void __advance(_InputIter& __i,
             typename iterator_traits<_InputIter>::difference_type __n, input_iterator_tag)
;
template <class _BiDirIter>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void __advance(_BiDirIter& __i,
             typename iterator_traits<_BiDirIter>::difference_type __n, bidirectional_iterator_tag)
;
template <class _RandIter>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void __advance(_RandIter& __i,
             typename iterator_traits<_RandIter>::difference_type __n, random_access_iterator_tag)
;
template <class _InputIter>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void advance(_InputIter& __i,
             typename iterator_traits<_InputIter>::difference_type __n)
;
template <class _InputIter>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename iterator_traits<_InputIter>::difference_type
__distance(_InputIter __first, _InputIter __last, input_iterator_tag)
;
template <class _RandIter>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename iterator_traits<_RandIter>::difference_type
__distance(_RandIter __first, _RandIter __last, random_access_iterator_tag)
;
template <class _InputIter>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename iterator_traits<_InputIter>::difference_type
distance(_InputIter __first, _InputIter __last)
;
template <class _InputIter>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_input_iterator<_InputIter>::value,
    _InputIter
>::type
next(_InputIter __x,
     typename iterator_traits<_InputIter>::difference_type __n = 1)
;
template <class _BidirectionalIter>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_bidirectional_iterator<_BidirectionalIter>::value,
    _BidirectionalIter
>::type
prev(_BidirectionalIter __x,
     typename iterator_traits<_BidirectionalIter>::difference_type __n = 1)
;
template <class _Tp, class = void>
struct __is_stashing_iterator : false_type {};
template <class _Tp>
struct __is_stashing_iterator<_Tp, typename __void_t<typename _Tp::__stashing_iterator_tag>::type>
  : true_type {};
template <class _Iter>
class __attribute__ ((__type_visibility__("default"))) reverse_iterator
    : public iterator<typename iterator_traits<_Iter>::iterator_category,
                      typename iterator_traits<_Iter>::value_type,
                      typename iterator_traits<_Iter>::difference_type,
                      typename iterator_traits<_Iter>::pointer,
                      typename iterator_traits<_Iter>::reference>
{
private:
     _Iter __t;
    static_assert(!__is_stashing_iterator<_Iter>::value,
      "The specified iterator type cannot be used with reverse_iterator; "
      "Using stashing iterators with reverse_iterator causes undefined behavior");
protected:
    _Iter current;
public:
    typedef _Iter iterator_type;
    typedef typename iterator_traits<_Iter>::difference_type difference_type;
    typedef typename iterator_traits<_Iter>::reference reference;
    typedef typename iterator_traits<_Iter>::pointer pointer;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    reverse_iterator() ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit reverse_iterator(_Iter __x) ;
    template <class _Up>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        reverse_iterator(const reverse_iterator<_Up>& __u) ;
    template <class _Up>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        reverse_iterator& operator=(const reverse_iterator<_Up>& __u)
            ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Iter base() const ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    reference operator*() const ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pointer operator->() const ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    reverse_iterator& operator++() ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    reverse_iterator operator++(int) ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    reverse_iterator& operator--() ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    reverse_iterator operator--(int) ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    reverse_iterator operator+ (difference_type __n) const ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    reverse_iterator& operator+=(difference_type __n) ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    reverse_iterator operator- (difference_type __n) const ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    reverse_iterator& operator-=(difference_type __n) ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    reference operator[](difference_type __n) const ;
};
template <class _Iter1, class _Iter2>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator==(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
;
template <class _Iter1, class _Iter2>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator<(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
;
template <class _Iter1, class _Iter2>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator!=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
;
template <class _Iter1, class _Iter2>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator>(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
;
template <class _Iter1, class _Iter2>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator>=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
;
template <class _Iter1, class _Iter2>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator<=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
;
template <class _Iter1, class _Iter2>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
auto
operator-(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
-> decltype(__y.base() - __x.base())
;
template <class _Iter>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
reverse_iterator<_Iter>
operator+(typename reverse_iterator<_Iter>::difference_type __n, const reverse_iterator<_Iter>& __x)
;
template <class _Container>
class __attribute__ ((__type_visibility__("default"))) back_insert_iterator
    : public iterator<output_iterator_tag,
                      void,
                      void,
                      void,
                      void>
{
protected:
    _Container* container;
public:
    typedef _Container container_type;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit back_insert_iterator(_Container& __x) ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) back_insert_iterator& operator=(const typename _Container::value_type& __value_)
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) back_insert_iterator& operator=(typename _Container::value_type&& __value_)
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) back_insert_iterator& operator*() ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) back_insert_iterator& operator++() ;
};
;
template <class _Container>
class __attribute__ ((__type_visibility__("default"))) front_insert_iterator
    : public iterator<output_iterator_tag,
                      void,
                      void,
                      void,
                      void>
{
protected:
    _Container* container;
public:
    typedef _Container container_type;
};
;
template <class _Container>
class __attribute__ ((__type_visibility__("default"))) insert_iterator
    : public iterator<output_iterator_tag,
                      void,
                      void,
                      void,
                      void>
{
protected:
    _Container* container;
    typename _Container::iterator iter;
public:
    typedef _Container container_type;
};
;
template <class _Tp, class _CharT = char,
          class _Traits = char_traits<_CharT>, class _Distance = ptrdiff_t>
class __attribute__ ((__type_visibility__("default"))) istream_iterator
    : public iterator<input_iterator_tag, _Tp, _Distance, const _Tp*, const _Tp&>
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef basic_istream<_CharT,_Traits> istream_type;
private:
    istream_type* __in_stream_;
    _Tp __value_;
public:
    ;
    ;
};
;
;
template <class _Tp, class _CharT = char, class _Traits = char_traits<_CharT> >
class __attribute__ ((__type_visibility__("default"))) ostream_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef basic_ostream<_CharT,_Traits> ostream_type;
private:
    ostream_type* __out_stream_;
    const char_type* __delim_;
public:
};
template<class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) istreambuf_iterator
    : public iterator<input_iterator_tag, _CharT,
                      typename _Traits::off_type, _CharT*,
                      _CharT>
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename _Traits::int_type int_type;
    typedef basic_streambuf<_CharT,_Traits> streambuf_type;
    typedef basic_istream<_CharT,_Traits> istream_type;
private:
    mutable streambuf_type* __sbuf_;
    class __proxy
    {
        char_type __keep_;
        streambuf_type* __sbuf_;
        friend class istreambuf_iterator;
    public:
    };
public:
};
                ;
                ;
template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) ostreambuf_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef basic_streambuf<_CharT,_Traits> streambuf_type;
    typedef basic_ostream<_CharT,_Traits> ostream_type;
private:
    streambuf_type* __sbuf_;
public:
    ;
};
template <class _Iter>
class __attribute__ ((__type_visibility__("default"))) move_iterator
{
private:
    _Iter __i;
public:
    typedef _Iter iterator_type;
    typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;
    typedef typename iterator_traits<iterator_type>::value_type value_type;
    typedef typename iterator_traits<iterator_type>::difference_type difference_type;
    typedef iterator_type pointer;
    typedef typename iterator_traits<iterator_type>::reference __reference;
    typedef typename conditional<
            is_reference<__reference>::value,
            typename remove_reference<__reference>::type&&,
            __reference
        >::type reference;
      ;
};
template <class _Iter1, class _Iter2>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator==(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
;
template <class _Iter1, class _Iter2>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator<(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
;
template <class _Iter1, class _Iter2>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator!=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
;
template <class _Iter1, class _Iter2>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator>(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
;
template <class _Iter1, class _Iter2>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator>=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
;
template <class _Iter1, class _Iter2>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator<=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
;
template <class _Iter1, class _Iter2>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
auto
operator-(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
-> decltype(__x.base() - __y.base())
;
template <class _Iter>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
move_iterator<_Iter>
operator+(typename move_iterator<_Iter>::difference_type __n, const move_iterator<_Iter>& __x)
;
template <class _Iter>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
move_iterator<_Iter>
make_move_iterator(_Iter __i)
;
template <class _Iter> class __wrap_iter;
template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator==(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;
template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator<(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;
template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator!=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;
template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator>(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;
template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator>=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;
template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator<=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;
template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
auto
operator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
-> decltype(__x.base() - __y.base());
template <class _Iter>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__wrap_iter<_Iter>
operator+(typename __wrap_iter<_Iter>::difference_type, __wrap_iter<_Iter>) noexcept;
template <class _Ip, class _Op> _Op __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) copy(_Ip, _Ip, _Op);
template <class _B1, class _B2> _B2 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) copy_backward(_B1, _B1, _B2);
template <class _Ip, class _Op> _Op __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) move(_Ip, _Ip, _Op);
template <class _B1, class _B2> _B2 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) move_backward(_B1, _B1, _B2);
template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    is_trivially_copy_assignable<_Tp>::value,
    _Tp*
>::type
__unwrap_iter(__wrap_iter<_Tp*>);
template <class _Iter>
class __wrap_iter
{
public:
    typedef _Iter iterator_type;
    typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;
    typedef typename iterator_traits<iterator_type>::value_type value_type;
    typedef typename iterator_traits<iterator_type>::difference_type difference_type;
    typedef typename iterator_traits<iterator_type>::pointer pointer;
    typedef typename iterator_traits<iterator_type>::reference reference;
private:
    iterator_type __i;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __wrap_iter() noexcept
    ;
    template <class _Up> __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        __wrap_iter(const __wrap_iter<_Up>& __u,
            typename enable_if<is_convertible<_Up, iterator_type>::value>::type* = 0)
    ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) reference operator*() const noexcept
    ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) pointer operator->() const noexcept
    ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __wrap_iter& operator++() noexcept
    ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __wrap_iter operator++(int) noexcept
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __wrap_iter& operator--() noexcept
    ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __wrap_iter operator--(int) noexcept
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __wrap_iter operator+ (difference_type __n) const noexcept
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __wrap_iter& operator+=(difference_type __n) noexcept
    ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __wrap_iter operator- (difference_type __n) const noexcept
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __wrap_iter& operator-=(difference_type __n) noexcept
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) reference operator[](difference_type __n) const noexcept
    ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) iterator_type base() const noexcept ;
private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __wrap_iter(iterator_type __x) ;
    template <class _Up> friend class __wrap_iter;
    template <class _CharT, class _Traits, class _Alloc> friend class basic_string;
    template <class _Tp, class _Alloc> friend class __attribute__ ((__type_visibility__("default"))) vector;
    template <class _Tp, ptrdiff_t> friend class __attribute__ ((__type_visibility__("default"))) span;
    template <class _Iter1, class _Iter2>
                                 friend
    bool
    operator==(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;
    template <class _Iter1, class _Iter2>
                                 friend
    bool
    operator<(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;
    template <class _Iter1, class _Iter2>
                                 friend
    bool
    operator!=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;
    template <class _Iter1, class _Iter2>
                                 friend
    bool
    operator>(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;
    template <class _Iter1, class _Iter2>
                                 friend
    bool
    operator>=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;
    template <class _Iter1, class _Iter2>
                                 friend
    bool
    operator<=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;
    template <class _Iter1, class _Iter2>
                                 friend
    auto
    operator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
    -> decltype(__x.base() - __y.base());
    template <class _Iter1>
                                 friend
    __wrap_iter<_Iter1>
    operator+(typename __wrap_iter<_Iter1>::difference_type, __wrap_iter<_Iter1>) noexcept;
    template <class _Ip, class _Op> friend _Op copy(_Ip, _Ip, _Op);
    template <class _B1, class _B2> friend _B2 copy_backward(_B1, _B1, _B2);
    template <class _Ip, class _Op> friend _Op move(_Ip, _Ip, _Op);
    template <class _B1, class _B2> friend _B2 move_backward(_B1, _B1, _B2);
    template <class _Tp>
                                 friend
    typename enable_if
    <
        is_trivially_copy_assignable<_Tp>::value,
        _Tp*
    >::type
    __unwrap_iter(__wrap_iter<_Tp*>);
};
template <class _Iter1, class _Iter2>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator==(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
;
template <class _Iter1, class _Iter2>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator<(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
;
template <class _Iter1, class _Iter2>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
;
template <class _Iter1, class _Iter2>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator>(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
;
template <class _Iter1, class _Iter2>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
;
template <class _Iter1, class _Iter2>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator<=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
;
template <class _Iter1>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) noexcept
;
template <class _Iter1>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator>(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) noexcept
;
template <class _Iter1>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) noexcept
;
template <class _Iter1>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator<=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) noexcept
;
template <class _Iter1, class _Iter2>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
auto
operator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
-> decltype(__x.base() - __y.base())
;
template <class _Iter>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__wrap_iter<_Iter>
operator+(typename __wrap_iter<_Iter>::difference_type __n,
          __wrap_iter<_Iter> __x) noexcept
;
template <class _Iter>
struct __libcpp_is_trivial_iterator
    : public integral_constant<bool,(is_pointer<_Iter>::value)> {};
template <class _Iter>
struct __libcpp_is_trivial_iterator<move_iterator<_Iter> >
    : public integral_constant<bool,(__libcpp_is_trivial_iterator<_Iter>::value)> {};
template <class _Iter>
struct __libcpp_is_trivial_iterator<reverse_iterator<_Iter> >
    : public integral_constant<bool,(__libcpp_is_trivial_iterator<_Iter>::value)> {};
template <class _Iter>
struct __libcpp_is_trivial_iterator<__wrap_iter<_Iter> >
    : public integral_constant<bool,(__libcpp_is_trivial_iterator<_Iter>::value)> {};
template <class _Tp, size_t _Np>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_Tp*
begin(_Tp (&__array)[_Np])
;
template <class _Tp, size_t _Np>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_Tp*
end(_Tp (&__array)[_Np])
;
template <class _Cp>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
auto
begin(_Cp& __c) -> decltype(__c.begin())
;
template <class _Cp>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
auto
begin(const _Cp& __c) -> decltype(__c.begin())
;
template <class _Cp>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
auto
end(_Cp& __c) -> decltype(__c.end())
;
template <class _Cp>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
auto
end(const _Cp& __c) -> decltype(__c.end())
;
} }
namespace std { inline namespace __1 {
template <size_t _Ip, class _Hp,
          bool=is_empty<_Hp>::value && !__libcpp_is_final<_Hp>::value
         >
class __tuple_leaf;
template <size_t _Ip, class _Hp, bool _Ep>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void swap(__tuple_leaf<_Ip, _Hp, _Ep>& __x, __tuple_leaf<_Ip, _Hp, _Ep>& __y)
    noexcept(__is_nothrow_swappable<_Hp>::value)
;
template <size_t _Ip, class _Hp, bool>
class __tuple_leaf
{
    _Hp __value_;
    template <class _Tp>
    static constexpr bool __can_bind_reference() ;
    __tuple_leaf& operator=(const __tuple_leaf&);
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr __tuple_leaf()
             noexcept(is_nothrow_default_constructible<_Hp>::value)
       ;
    template <class _Alloc>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        __tuple_leaf(integral_constant<int, 0>, const _Alloc&)
        ;
    template <class _Alloc>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a)
        ;
    template <class _Alloc>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a)
        ;
        ;
        ;
        ;
        ;
        ;
};
template <size_t _Ip, class _Hp>
class __tuple_leaf<_Ip, _Hp, true>
    : private _Hp
{
public:
     ;
      ;
      ;
      ;
      ;
      ;
      ;
        ;
};
template <class ..._Tp>
struct __lazy_all : __all<_Tp::value...> {};
template <class _Tp>
struct __all_default_constructible;
template <class ..._Tp>
struct __all_default_constructible<__tuple_types<_Tp...>>
    : __all<is_default_constructible<_Tp>::value...>
{ };
template<class _Indx, class ..._Tp> struct __tuple_impl;
template<size_t ..._Indx, class ..._Tp>
struct __tuple_impl<__tuple_indices<_Indx...>, _Tp...>
    : public __tuple_leaf<_Indx, _Tp>...
{
};
template <class ..._Tp>
class __attribute__ ((__type_visibility__("default"))) tuple
{
    typedef __tuple_impl<typename __make_tuple_indices<sizeof...(_Tp)>::type, _Tp...> _BaseT;
    _BaseT __base_;
    static constexpr bool _EnableImplicitReducedArityExtension = false;
    template <class ..._Args>
    struct _PackExpandsToThisTuple : false_type {};
    template <class _Arg>
    struct _PackExpandsToThisTuple<_Arg>
        : is_same<typename __uncvref<_Arg>::type, tuple> {};
    template <bool _MaybeEnable, class _Dummy = void>
    struct _CheckArgsConstructor : __check_tuple_constructor_fail {};
    template <class _Dummy>
    struct _CheckArgsConstructor<true, _Dummy>
    {
         ;
         ;
         ;
    };
    template <bool _MaybeEnable,
              bool = sizeof...(_Tp) == 1,
              class _Dummy = void>
    struct _CheckTupleLikeConstructor : __check_tuple_constructor_fail {};
    template <class _Dummy>
    struct _CheckTupleLikeConstructor<true, false, _Dummy>
    {
         ;
         ;
    };
    template <class _Dummy>
    struct _CheckTupleLikeConstructor<true, true, _Dummy>
    {
        template <class _Tuple>
        using _PreferTupleLikeConstructor = __lazy_or<
            is_same<typename __uncvref<_Tuple>::type, tuple>,
            __lazy_and<
                __lazy_not<is_constructible<_Tp..., _Tuple>>,
                __lazy_not<is_convertible<_Tuple, _Tp...>>
            >
        >;
         ;
         ;
    };
    ;
    ;
    ;
    ;
public:
     ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
    using _CanCopyAssign = __all<is_copy_assignable<_Tp>::value...>;
    using _CanMoveAssign = __all<is_move_assignable<_Tp>::value...>;
        ;
};
template <>
class __attribute__ ((__type_visibility__("default"))) tuple<>
{
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr tuple() noexcept ;
    template <class _Alloc>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        tuple(allocator_arg_t, const _Alloc&) noexcept ;
    template <class _Alloc>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        tuple(allocator_arg_t, const _Alloc&, const tuple&) noexcept ;
    template <class _Up>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        tuple(array<_Up, 0>) noexcept ;
    template <class _Alloc, class _Up>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        tuple(allocator_arg_t, const _Alloc&, array<_Up, 0>) noexcept ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void swap(tuple&) noexcept ;
};
template <class ..._Tp>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __all<__is_swappable<_Tp>::value...>::value,
    void
>::type
swap(tuple<_Tp...>& __t, tuple<_Tp...>& __u)
                 noexcept(__all<__is_nothrow_swappable<_Tp>::value...>::value)
    ;
template <size_t _Ip, class ..._Tp>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename tuple_element<_Ip, tuple<_Tp...> >::type&
get(tuple<_Tp...>& __t) noexcept
;
template <size_t _Ip, class ..._Tp>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
const typename tuple_element<_Ip, tuple<_Tp...> >::type&
get(const tuple<_Tp...>& __t) noexcept
;
template <size_t _Ip, class ..._Tp>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename tuple_element<_Ip, tuple<_Tp...> >::type&&
get(tuple<_Tp...>&& __t) noexcept
;
template <size_t _Ip, class ..._Tp>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
const typename tuple_element<_Ip, tuple<_Tp...> >::type&&
get(const tuple<_Tp...>&& __t) noexcept
;
template <class ..._Tp>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
tuple<_Tp&...>
tie(_Tp&... __t) noexcept
;
template <class _Up>
struct __ignore_t
{
    template <class _Tp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const __ignore_t& operator=(_Tp&&) const ;
};
namespace {
                     constexpr __ignore_t<unsigned char> ignore = __ignore_t<unsigned char>();
}
template <class... _Tp>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
tuple<typename __unwrap_ref_decay<_Tp>::type...>
make_tuple(_Tp&&... __t)
;
template <class... _Tp>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
tuple<_Tp&&...>
forward_as_tuple(_Tp&&... __t) noexcept
;
template <size_t _Ip>
struct __tuple_equal
{
    template <class _Tp, class _Up>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator()(const _Tp& __x, const _Up& __y)
    ;
};
template <>
struct __tuple_equal<0>
{
    template <class _Tp, class _Up>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator()(const _Tp&, const _Up&)
    ;
};
template <class ..._Tp, class ..._Up>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator==(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
;
template <class ..._Tp, class ..._Up>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator!=(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
;
template <size_t _Ip>
struct __tuple_less
{
    template <class _Tp, class _Up>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator()(const _Tp& __x, const _Up& __y)
    ;
};
template <>
struct __tuple_less<0>
{
    template <class _Tp, class _Up>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator()(const _Tp&, const _Up&)
    ;
};
template <class ..._Tp, class ..._Up>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator<(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
;
template <class ..._Tp, class ..._Up>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator>(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
;
template <class ..._Tp, class ..._Up>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator>=(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
;
template <class ..._Tp, class ..._Up>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator<=(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
;
template <class _Tp, class _Up> struct __tuple_cat_type;
template <class ..._Ttypes, class ..._Utypes>
struct __tuple_cat_type<tuple<_Ttypes...>, __tuple_types<_Utypes...> >
{
    typedef tuple<_Ttypes..., _Utypes...> type;
};
template <class _ResultTuple, bool _Is_Tuple0TupleLike, class ..._Tuples>
struct __tuple_cat_return_1
{
};
template <class ..._Types, class _Tuple0>
struct __tuple_cat_return_1<tuple<_Types...>, true, _Tuple0>
{
    typedef typename __tuple_cat_type<tuple<_Types...>,
            typename __make_tuple_types<typename remove_reference<_Tuple0>::type>::type>::type
                                                                           type;
};
template <class ..._Types, class _Tuple0, class _Tuple1, class ..._Tuples>
struct __tuple_cat_return_1<tuple<_Types...>, true, _Tuple0, _Tuple1, _Tuples...>
    : public __tuple_cat_return_1<
                 typename __tuple_cat_type<
                     tuple<_Types...>,
                     typename __make_tuple_types<typename remove_reference<_Tuple0>::type>::type
                 >::type,
                 __tuple_like<typename remove_reference<_Tuple1>::type>::value,
                 _Tuple1, _Tuples...>
{
};
template <class ..._Tuples> struct __tuple_cat_return;
template <class _Tuple0, class ..._Tuples>
struct __tuple_cat_return<_Tuple0, _Tuples...>
    : public __tuple_cat_return_1<tuple<>,
         __tuple_like<typename remove_reference<_Tuple0>::type>::value, _Tuple0,
                                                                     _Tuples...>
{
};
template <>
struct __tuple_cat_return<>
{
    typedef tuple<> type;
};
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
tuple<>
tuple_cat()
;
template <class _Rp, class _Indices, class _Tuple0, class ..._Tuples>
struct __tuple_cat_return_ref_imp;
template <class ..._Types, size_t ..._I0, class _Tuple0>
struct __tuple_cat_return_ref_imp<tuple<_Types...>, __tuple_indices<_I0...>, _Tuple0>
{
    typedef typename remove_reference<_Tuple0>::type _T0;
    typedef tuple<_Types..., typename __apply_cv<_Tuple0,
                          typename tuple_element<_I0, _T0>::type>::type&&...> type;
};
template <class ..._Types, size_t ..._I0, class _Tuple0, class _Tuple1, class ..._Tuples>
struct __tuple_cat_return_ref_imp<tuple<_Types...>, __tuple_indices<_I0...>,
                                  _Tuple0, _Tuple1, _Tuples...>
    : public __tuple_cat_return_ref_imp<
         tuple<_Types..., typename __apply_cv<_Tuple0,
               typename tuple_element<_I0,
                  typename remove_reference<_Tuple0>::type>::type>::type&&...>,
         typename __make_tuple_indices<tuple_size<typename
                                 remove_reference<_Tuple1>::type>::value>::type,
         _Tuple1, _Tuples...>
{
};
template <class _Tuple0, class ..._Tuples>
struct __tuple_cat_return_ref
    : public __tuple_cat_return_ref_imp<tuple<>,
               typename __make_tuple_indices<
                        tuple_size<typename remove_reference<_Tuple0>::type>::value
               >::type, _Tuple0, _Tuples...>
{
};
template <class _Types, class _I0, class _J0>
struct __tuple_cat;
template <class ..._Types, size_t ..._I0, size_t ..._J0>
struct __tuple_cat<tuple<_Types...>, __tuple_indices<_I0...>, __tuple_indices<_J0...> >
{
    template <class _Tuple0>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename __tuple_cat_return_ref<tuple<_Types...>&&, _Tuple0&&>::type
    operator()(tuple<_Types...> __t, _Tuple0&& __t0)
    ;
    template <class _Tuple0, class _Tuple1, class ..._Tuples>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename __tuple_cat_return_ref<tuple<_Types...>&&, _Tuple0&&, _Tuple1&&, _Tuples&&...>::type
    operator()(tuple<_Types...> __t, _Tuple0&& __t0, _Tuple1&& __t1, _Tuples&& ...__tpls)
    ;
};
template <class _Tuple0, class... _Tuples>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename __tuple_cat_return<_Tuple0, _Tuples...>::type
tuple_cat(_Tuple0&& __t0, _Tuples&&... __tpls)
;
template <class ..._Tp, class _Alloc>
struct __attribute__ ((__type_visibility__("default"))) uses_allocator<tuple<_Tp...>, _Alloc>
    : true_type {};
} }
namespace std { inline namespace __1 {
class __attribute__ ((__visibility__("hidden"))) __libcpp_refstring
{
    const char* __imp_;
    bool __uses_refcount() const;
public:
    explicit __libcpp_refstring(const char* __msg);
    __libcpp_refstring(const __libcpp_refstring& __s) noexcept;
    __libcpp_refstring& operator=(const __libcpp_refstring& __s) noexcept;
    ~__libcpp_refstring();
    const char* c_str() const noexcept ;
};
} }
namespace std
{
class __attribute__ ((__visibility__("default"))) logic_error
    : public exception
{
private:
    std::__1::__libcpp_refstring __imp_;
public:
    explicit logic_error(const string&);
    explicit logic_error(const char*);
    logic_error(const logic_error&) noexcept;
    logic_error& operator=(const logic_error&) noexcept;
    virtual ~logic_error() noexcept;
    virtual const char* what() const noexcept;
};
class __attribute__ ((__visibility__("default"))) runtime_error
    : public exception
{
private:
    std::__1::__libcpp_refstring __imp_;
public:
    explicit runtime_error(const string&);
    explicit runtime_error(const char*);
    runtime_error(const runtime_error&) noexcept;
    runtime_error& operator=(const runtime_error&) noexcept;
    virtual ~runtime_error() noexcept;
    virtual const char* what() const noexcept;
};
class __attribute__ ((__visibility__("default"))) domain_error
    : public logic_error
{
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit domain_error(const string& __s) ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit domain_error(const char* __s) ;
    virtual ~domain_error() noexcept;
};
class __attribute__ ((__visibility__("default"))) invalid_argument
    : public logic_error
{
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit invalid_argument(const string& __s) ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit invalid_argument(const char* __s) ;
    virtual ~invalid_argument() noexcept;
};
class __attribute__ ((__visibility__("default"))) length_error
    : public logic_error
{
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit length_error(const string& __s) ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit length_error(const char* __s) ;
    virtual ~length_error() noexcept;
};
class __attribute__ ((__visibility__("default"))) out_of_range
    : public logic_error
{
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit out_of_range(const string& __s) ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit out_of_range(const char* __s) ;
    virtual ~out_of_range() noexcept;
};
class __attribute__ ((__visibility__("default"))) range_error
    : public runtime_error
{
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit range_error(const string& __s) ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit range_error(const char* __s) ;
    virtual ~range_error() noexcept;
};
class __attribute__ ((__visibility__("default"))) overflow_error
    : public runtime_error
{
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit overflow_error(const string& __s) ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit overflow_error(const char* __s) ;
    virtual ~overflow_error() noexcept;
};
class __attribute__ ((__visibility__("default"))) underflow_error
    : public runtime_error
{
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit underflow_error(const string& __s) ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit underflow_error(const char* __s) ;
    virtual ~underflow_error() noexcept;
};
}
namespace std { inline namespace __1 {
[[noreturn]] __attribute__ ((__visibility__("default"))) void __throw_runtime_error(const char*);
[[noreturn]] __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void __throw_logic_error(const char*__msg)
;
[[noreturn]] __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void __throw_domain_error(const char*__msg)
;
[[noreturn]] __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void __throw_invalid_argument(const char*__msg)
;
[[noreturn]] __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void __throw_length_error(const char*__msg)
;
[[noreturn]] __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void __throw_out_of_range(const char*__msg)
;
[[noreturn]] __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void __throw_range_error(const char*__msg)
;
[[noreturn]] __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void __throw_overflow_error(const char*__msg)
;
[[noreturn]] __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void __throw_underflow_error(const char*__msg)
;
} }
extern "C" {
;
}
namespace std { inline namespace __1 {
typedef enum memory_order
{
    memory_order_relaxed, memory_order_consume, memory_order_acquire,
    memory_order_release, memory_order_acq_rel, memory_order_seq_cst
} memory_order;
template <class _Tp>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_Tp
kill_dependency(_Tp __y) noexcept
;
template <class _Tp, bool = is_integral<_Tp>::value && !is_same<_Tp, bool>::value>
struct __atomic_base
{
    mutable _Atomic(_Tp) __a_;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool is_lock_free() const volatile noexcept
    ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool is_lock_free() const noexcept
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void store(_Tp __d, memory_order __m = memory_order_seq_cst) volatile noexcept
      __attribute__((diagnose_if(__m == memory_order_consume || __m == memory_order_acquire || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void store(_Tp __d, memory_order __m = memory_order_seq_cst) noexcept
      __attribute__((diagnose_if(__m == memory_order_consume || __m == memory_order_acquire || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp load(memory_order __m = memory_order_seq_cst) const volatile noexcept
      __attribute__((diagnose_if(__m == memory_order_release || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp load(memory_order __m = memory_order_seq_cst) const noexcept
      __attribute__((diagnose_if(__m == memory_order_release || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    operator _Tp() const volatile noexcept ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    operator _Tp() const noexcept ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp exchange(_Tp __d, memory_order __m = memory_order_seq_cst) volatile noexcept
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp exchange(_Tp __d, memory_order __m = memory_order_seq_cst) noexcept
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool compare_exchange_weak(_Tp& __e, _Tp __d,
                               memory_order __s, memory_order __f) volatile noexcept
      __attribute__((diagnose_if(__f == memory_order_release || __f == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool compare_exchange_weak(_Tp& __e, _Tp __d,
                               memory_order __s, memory_order __f) noexcept
      __attribute__((diagnose_if(__f == memory_order_release || __f == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool compare_exchange_strong(_Tp& __e, _Tp __d,
                                 memory_order __s, memory_order __f) volatile noexcept
      __attribute__((diagnose_if(__f == memory_order_release || __f == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool compare_exchange_strong(_Tp& __e, _Tp __d,
                                 memory_order __s, memory_order __f) noexcept
      __attribute__((diagnose_if(__f == memory_order_release || __f == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool compare_exchange_weak(_Tp& __e, _Tp __d,
                              memory_order __m = memory_order_seq_cst) volatile noexcept
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool compare_exchange_weak(_Tp& __e, _Tp __d,
                               memory_order __m = memory_order_seq_cst) noexcept
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool compare_exchange_strong(_Tp& __e, _Tp __d,
                              memory_order __m = memory_order_seq_cst) volatile noexcept
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool compare_exchange_strong(_Tp& __e, _Tp __d,
                                 memory_order __m = memory_order_seq_cst) noexcept
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __atomic_base() noexcept = default;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr __atomic_base(_Tp __d) ;
    __atomic_base(const __atomic_base&) = delete;
    __atomic_base& operator=(const __atomic_base&) = delete;
    __atomic_base& operator=(const __atomic_base&) volatile = delete;
};
template <class _Tp>
struct __atomic_base<_Tp, true>
    : public __atomic_base<_Tp, false>
{
    typedef __atomic_base<_Tp, false> __base;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __atomic_base() noexcept = default;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr __atomic_base(_Tp __d) ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp fetch_add(_Tp __op, memory_order __m = memory_order_seq_cst) volatile noexcept
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp fetch_add(_Tp __op, memory_order __m = memory_order_seq_cst) noexcept
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp fetch_sub(_Tp __op, memory_order __m = memory_order_seq_cst) volatile noexcept
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp fetch_sub(_Tp __op, memory_order __m = memory_order_seq_cst) noexcept
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp fetch_and(_Tp __op, memory_order __m = memory_order_seq_cst) volatile noexcept
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp fetch_and(_Tp __op, memory_order __m = memory_order_seq_cst) noexcept
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp fetch_or(_Tp __op, memory_order __m = memory_order_seq_cst) volatile noexcept
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp fetch_or(_Tp __op, memory_order __m = memory_order_seq_cst) noexcept
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp fetch_xor(_Tp __op, memory_order __m = memory_order_seq_cst) volatile noexcept
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp fetch_xor(_Tp __op, memory_order __m = memory_order_seq_cst) noexcept
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp operator++(int) volatile noexcept ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp operator++(int) noexcept ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp operator--(int) volatile noexcept ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp operator--(int) noexcept ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp operator++() volatile noexcept ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp operator++() noexcept ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp operator--() volatile noexcept ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp operator--() noexcept ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp operator+=(_Tp __op) volatile noexcept ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp operator+=(_Tp __op) noexcept ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp operator-=(_Tp __op) volatile noexcept ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp operator-=(_Tp __op) noexcept ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp operator&=(_Tp __op) volatile noexcept ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp operator&=(_Tp __op) noexcept ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp operator|=(_Tp __op) volatile noexcept ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp operator|=(_Tp __op) noexcept ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp operator^=(_Tp __op) volatile noexcept ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp operator^=(_Tp __op) noexcept ;
};
template <class _Tp>
struct atomic
    : public __atomic_base<_Tp>
{
    typedef __atomic_base<_Tp> __base;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    atomic() noexcept = default;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr atomic(_Tp __d) ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp operator=(_Tp __d) volatile noexcept
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp operator=(_Tp __d) noexcept
        ;
};
template <class _Tp>
struct atomic<_Tp*>
    : public __atomic_base<_Tp*>
{
    typedef __atomic_base<_Tp*> __base;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    atomic() noexcept = default;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr atomic(_Tp* __d) ;
};
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
template <class _Tp>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_xor_explicit(volatile atomic<_Tp>* __o, _Tp __op, memory_order __m) noexcept
;
template <class _Tp>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_xor_explicit(atomic<_Tp>* __o, _Tp __op, memory_order __m) noexcept
;
typedef struct atomic_flag
{
    _Atomic(bool) __a_;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool test_and_set(memory_order __m = memory_order_seq_cst) volatile noexcept
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool test_and_set(memory_order __m = memory_order_seq_cst) noexcept
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void clear(memory_order __m = memory_order_seq_cst) volatile noexcept
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void clear(memory_order __m = memory_order_seq_cst) noexcept
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    atomic_flag() noexcept = default;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    atomic_flag(bool __b) ;
    atomic_flag(const atomic_flag&) = delete;
    atomic_flag& operator=(const atomic_flag&) = delete;
    atomic_flag& operator=(const atomic_flag&) volatile = delete;
} atomic_flag;
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
atomic_flag_test_and_set(volatile atomic_flag* __o) noexcept
;
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
atomic_flag_test_and_set(atomic_flag* __o) noexcept
;
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
atomic_flag_test_and_set_explicit(volatile atomic_flag* __o, memory_order __m) noexcept
;
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
atomic_flag_test_and_set_explicit(atomic_flag* __o, memory_order __m) noexcept
;
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
atomic_flag_clear(volatile atomic_flag* __o) noexcept
;
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
atomic_flag_clear(atomic_flag* __o) noexcept
;
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
atomic_flag_clear_explicit(volatile atomic_flag* __o, memory_order __m) noexcept
;
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
atomic_flag_clear_explicit(atomic_flag* __o, memory_order __m) noexcept
;
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
atomic_thread_fence(memory_order __m) noexcept
;
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
atomic_signal_fence(memory_order __m) noexcept
;
typedef atomic<bool> atomic_bool;
typedef atomic<char> atomic_char;
typedef atomic<signed char> atomic_schar;
typedef atomic<unsigned char> atomic_uchar;
typedef atomic<short> atomic_short;
typedef atomic<unsigned short> atomic_ushort;
typedef atomic<int> atomic_int;
typedef atomic<unsigned int> atomic_uint;
typedef atomic<long> atomic_long;
typedef atomic<unsigned long> atomic_ulong;
typedef atomic<long long> atomic_llong;
typedef atomic<unsigned long long> atomic_ullong;
typedef atomic<char16_t> atomic_char16_t;
typedef atomic<char32_t> atomic_char32_t;
typedef atomic<wchar_t> atomic_wchar_t;
typedef atomic<int_least8_t> atomic_int_least8_t;
typedef atomic<uint_least8_t> atomic_uint_least8_t;
typedef atomic<int_least16_t> atomic_int_least16_t;
typedef atomic<uint_least16_t> atomic_uint_least16_t;
typedef atomic<int_least32_t> atomic_int_least32_t;
typedef atomic<uint_least32_t> atomic_uint_least32_t;
typedef atomic<int_least64_t> atomic_int_least64_t;
typedef atomic<uint_least64_t> atomic_uint_least64_t;
typedef atomic<int_fast8_t> atomic_int_fast8_t;
typedef atomic<uint_fast8_t> atomic_uint_fast8_t;
typedef atomic<int_fast16_t> atomic_int_fast16_t;
typedef atomic<uint_fast16_t> atomic_uint_fast16_t;
typedef atomic<int_fast32_t> atomic_int_fast32_t;
typedef atomic<uint_fast32_t> atomic_uint_fast32_t;
typedef atomic<int_fast64_t> atomic_int_fast64_t;
typedef atomic<uint_fast64_t> atomic_uint_fast64_t;
typedef atomic< int8_t> atomic_int8_t;
typedef atomic<uint8_t> atomic_uint8_t;
typedef atomic< int16_t> atomic_int16_t;
typedef atomic<uint16_t> atomic_uint16_t;
typedef atomic< int32_t> atomic_int32_t;
typedef atomic<uint32_t> atomic_uint32_t;
typedef atomic< int64_t> atomic_int64_t;
typedef atomic<uint64_t> atomic_uint64_t;
typedef atomic<intptr_t> atomic_intptr_t;
typedef atomic<uintptr_t> atomic_uintptr_t;
typedef atomic<size_t> atomic_size_t;
typedef atomic<ptrdiff_t> atomic_ptrdiff_t;
typedef atomic<intmax_t> atomic_intmax_t;
typedef atomic<uintmax_t> atomic_uintmax_t;
} }
namespace std { inline namespace __1 {
template <class _ValueType>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_ValueType __libcpp_relaxed_load(_ValueType const* __value) ;
template <class _ValueType>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_ValueType __libcpp_acquire_load(_ValueType const* __value) ;
template <class _Tp> class allocator;
template <>
class __attribute__ ((__type_visibility__("default"))) allocator<void>
{
public:
    typedef void* pointer;
    typedef const void* const_pointer;
    typedef void value_type;
    template <class _Up> struct rebind {typedef allocator<_Up> other;};
};
template <>
class __attribute__ ((__type_visibility__("default"))) allocator<const void>
{
public:
    typedef const void* pointer;
    typedef const void* const_pointer;
    typedef const void value_type;
    template <class _Up> struct rebind {typedef allocator<_Up> other;};
};
template <class _Tp, class = void>
struct __has_element_type : false_type {};
template <class _Tp>
struct __has_element_type<_Tp,
              typename __void_t<typename _Tp::element_type>::type> : true_type {};
template <class _Ptr, bool = __has_element_type<_Ptr>::value>
struct __pointer_traits_element_type;
template <class _Ptr>
struct __pointer_traits_element_type<_Ptr, true>
{
    typedef typename _Ptr::element_type type;
};
template <template <class, class...> class _Sp, class _Tp, class ..._Args>
struct __pointer_traits_element_type<_Sp<_Tp, _Args...>, true>
{
    typedef typename _Sp<_Tp, _Args...>::element_type type;
};
template <template <class, class...> class _Sp, class _Tp, class ..._Args>
struct __pointer_traits_element_type<_Sp<_Tp, _Args...>, false>
{
    typedef _Tp type;
};
template <class _Tp, class = void>
struct __has_difference_type : false_type {};
template <class _Tp>
struct __has_difference_type<_Tp,
            typename __void_t<typename _Tp::difference_type>::type> : true_type {};
template <class _Ptr, bool = __has_difference_type<_Ptr>::value>
struct __pointer_traits_difference_type
{
    typedef ptrdiff_t type;
};
template <class _Ptr>
struct __pointer_traits_difference_type<_Ptr, true>
{
    typedef typename _Ptr::difference_type type;
};
template <class _Tp, class _Up>
struct __has_rebind
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Xp> static __two __test(...);
    template <class _Xp> static char __test(typename _Xp::template rebind<_Up>* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};
template <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>
struct __pointer_traits_rebind
{
    typedef typename _Tp::template rebind<_Up> type;
};
template <template <class, class...> class _Sp, class _Tp, class ..._Args, class _Up>
struct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, true>
{
    typedef typename _Sp<_Tp, _Args...>::template rebind<_Up> type;
};
template <template <class, class...> class _Sp, class _Tp, class ..._Args, class _Up>
struct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, false>
{
    typedef _Sp<_Up, _Args...> type;
};
template <class _Ptr>
struct __attribute__ ((__type_visibility__("default"))) pointer_traits
{
    typedef _Ptr pointer;
    typedef typename __pointer_traits_element_type<pointer>::type element_type;
    typedef typename __pointer_traits_difference_type<pointer>::type difference_type;
    template <class _Up> using rebind = typename __pointer_traits_rebind<pointer, _Up>::type;
private:
    struct __nat {};
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static pointer pointer_to(typename conditional<is_void<element_type>::value,
                                           __nat, element_type>::type& __r)
        ;
};
template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) pointer_traits<_Tp*>
{
    typedef _Tp* pointer;
    typedef _Tp element_type;
    typedef ptrdiff_t difference_type;
    template <class _Up> using rebind = _Up*;
private:
    struct __nat {};
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static pointer pointer_to(typename conditional<is_void<element_type>::value,
                                      __nat, element_type>::type& __r) noexcept
        ;
};
template <class _From, class _To>
struct __rebind_pointer {
    typedef typename pointer_traits<_From>::template rebind<_To> type;
};
template <class _Tp, class = void>
struct __has_pointer_type : false_type {};
template <class _Tp>
struct __has_pointer_type<_Tp,
          typename __void_t<typename _Tp::pointer>::type> : true_type {};
namespace __pointer_type_imp
{
template <class _Tp, class _Dp, bool = __has_pointer_type<_Dp>::value>
struct __pointer_type
{
    typedef typename _Dp::pointer type;
};
template <class _Tp, class _Dp>
struct __pointer_type<_Tp, _Dp, false>
{
    typedef _Tp* type;
};
}
template <class _Tp, class _Dp>
struct __pointer_type
{
    typedef typename __pointer_type_imp::__pointer_type<_Tp, typename remove_reference<_Dp>::type>::type type;
};
template <class _Tp, class = void>
struct __has_const_pointer : false_type {};
template <class _Tp>
struct __has_const_pointer<_Tp,
            typename __void_t<typename _Tp::const_pointer>::type> : true_type {};
template <class _Tp, class _Ptr, class _Alloc, bool = __has_const_pointer<_Alloc>::value>
struct __const_pointer
{
    typedef typename _Alloc::const_pointer type;
};
template <class _Tp, class _Ptr, class _Alloc>
struct __const_pointer<_Tp, _Ptr, _Alloc, false>
{
    typedef typename pointer_traits<_Ptr>::template rebind<const _Tp> type;
};
template <class _Tp, class = void>
struct __has_void_pointer : false_type {};
template <class _Tp>
struct __has_void_pointer<_Tp,
               typename __void_t<typename _Tp::void_pointer>::type> : true_type {};
template <class _Ptr, class _Alloc, bool = __has_void_pointer<_Alloc>::value>
struct __void_pointer
{
    typedef typename _Alloc::void_pointer type;
};
template <class _Ptr, class _Alloc>
struct __void_pointer<_Ptr, _Alloc, false>
{
    typedef typename pointer_traits<_Ptr>::template rebind<void> type;
};
template <class _Tp, class = void>
struct __has_const_void_pointer : false_type {};
template <class _Tp>
struct __has_const_void_pointer<_Tp,
            typename __void_t<typename _Tp::const_void_pointer>::type> : true_type {};
template <class _Ptr, class _Alloc, bool = __has_const_void_pointer<_Alloc>::value>
struct __const_void_pointer
{
    typedef typename _Alloc::const_void_pointer type;
};
template <class _Ptr, class _Alloc>
struct __const_void_pointer<_Ptr, _Alloc, false>
{
    typedef typename pointer_traits<_Ptr>::template rebind<const void> type;
};
template <class _Tp>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
_Tp*
__to_raw_pointer(_Tp* __p) noexcept
;
template <class _Pointer>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename pointer_traits<_Pointer>::element_type*
__to_raw_pointer(_Pointer __p) noexcept
;
template <class _Tp, class = void>
struct __has_size_type : false_type {};
template <class _Tp>
struct __has_size_type<_Tp,
               typename __void_t<typename _Tp::size_type>::type> : true_type {};
template <class _Alloc, class _DiffType, bool = __has_size_type<_Alloc>::value>
struct __size_type
{
    typedef typename make_unsigned<_DiffType>::type type;
};
template <class _Alloc, class _DiffType>
struct __size_type<_Alloc, _DiffType, true>
{
    typedef typename _Alloc::size_type type;
};
template <class _Tp, class = void>
struct __has_propagate_on_container_copy_assignment : false_type {};
template <class _Tp>
struct __has_propagate_on_container_copy_assignment<_Tp,
    typename __void_t<typename _Tp::propagate_on_container_copy_assignment>::type>
        : true_type {};
template <class _Alloc, bool = __has_propagate_on_container_copy_assignment<_Alloc>::value>
struct __propagate_on_container_copy_assignment
{
    typedef false_type type;
};
template <class _Alloc>
struct __propagate_on_container_copy_assignment<_Alloc, true>
{
    typedef typename _Alloc::propagate_on_container_copy_assignment type;
};
template <class _Tp, class = void>
struct __has_propagate_on_container_move_assignment : false_type {};
template <class _Tp>
struct __has_propagate_on_container_move_assignment<_Tp,
           typename __void_t<typename _Tp::propagate_on_container_move_assignment>::type>
               : true_type {};
template <class _Alloc, bool = __has_propagate_on_container_move_assignment<_Alloc>::value>
struct __propagate_on_container_move_assignment
{
    typedef false_type type;
};
template <class _Alloc>
struct __propagate_on_container_move_assignment<_Alloc, true>
{
    typedef typename _Alloc::propagate_on_container_move_assignment type;
};
template <class _Tp, class = void>
struct __has_propagate_on_container_swap : false_type {};
template <class _Tp>
struct __has_propagate_on_container_swap<_Tp,
           typename __void_t<typename _Tp::propagate_on_container_swap>::type>
               : true_type {};
template <class _Alloc, bool = __has_propagate_on_container_swap<_Alloc>::value>
struct __propagate_on_container_swap
{
    typedef false_type type;
};
template <class _Alloc>
struct __propagate_on_container_swap<_Alloc, true>
{
    typedef typename _Alloc::propagate_on_container_swap type;
};
template <class _Tp, class = void>
struct __has_is_always_equal : false_type {};
template <class _Tp>
struct __has_is_always_equal<_Tp,
           typename __void_t<typename _Tp::is_always_equal>::type>
               : true_type {};
template <class _Alloc, bool = __has_is_always_equal<_Alloc>::value>
struct __is_always_equal
{
    typedef typename std::__1::is_empty<_Alloc>::type type;
};
template <class _Alloc>
struct __is_always_equal<_Alloc, true>
{
    typedef typename _Alloc::is_always_equal type;
};
template <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>
struct __has_rebind_other
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Xp> static __two __test(...);
    template <class _Xp> static char __test(typename _Xp::template rebind<_Up>::other* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};
template <class _Tp, class _Up>
struct __has_rebind_other<_Tp, _Up, false>
{
    static const bool value = false;
};
template <class _Tp, class _Up, bool = __has_rebind_other<_Tp, _Up>::value>
struct __allocator_traits_rebind
{
    typedef typename _Tp::template rebind<_Up>::other type;
};
template <template <class, class...> class _Alloc, class _Tp, class ..._Args, class _Up>
struct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, true>
{
    typedef typename _Alloc<_Tp, _Args...>::template rebind<_Up>::other type;
};
template <template <class, class...> class _Alloc, class _Tp, class ..._Args, class _Up>
struct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, false>
{
    typedef _Alloc<_Up, _Args...> type;
};
template <class _Alloc, class _SizeType, class _ConstVoidPtr>
auto
__has_allocate_hint_test(_Alloc&& __a, _SizeType&& __sz, _ConstVoidPtr&& __p)
    -> decltype((void)__a.allocate(__sz, __p), true_type());
template <class _Alloc, class _SizeType, class _ConstVoidPtr>
auto
__has_allocate_hint_test(const _Alloc& __a, _SizeType&& __sz, _ConstVoidPtr&& __p)
    -> false_type;
template <class _Alloc, class _SizeType, class _ConstVoidPtr>
struct __has_allocate_hint
    : integral_constant<bool,
        is_same<
            decltype(std::__1::__has_allocate_hint_test(declval<_Alloc>(),
                                          declval<_SizeType>(),
                                          declval<_ConstVoidPtr>())),
            true_type>::value>
{
};
template <class _Alloc, class _Tp, class ..._Args>
decltype(std::__1::declval<_Alloc>().construct(std::__1::declval<_Tp*>(),
                                           std::__1::declval<_Args>()...),
                                           true_type())
__has_construct_test(_Alloc&& __a, _Tp* __p, _Args&& ...__args);
template <class _Alloc, class _Pointer, class ..._Args>
false_type
__has_construct_test(const _Alloc& __a, _Pointer&& __p, _Args&& ...__args);
template <class _Alloc, class _Pointer, class ..._Args>
struct __has_construct
    : integral_constant<bool,
        is_same<
            decltype(std::__1::__has_construct_test(declval<_Alloc>(),
                                          declval<_Pointer>(),
                                          declval<_Args>()...)),
            true_type>::value>
{
};
template <class _Alloc, class _Pointer>
auto
__has_destroy_test(_Alloc&& __a, _Pointer&& __p)
    -> decltype(__a.destroy(__p), true_type());
template <class _Alloc, class _Pointer>
auto
__has_destroy_test(const _Alloc& __a, _Pointer&& __p)
    -> false_type;
template <class _Alloc, class _Pointer>
struct __has_destroy
    : integral_constant<bool,
        is_same<
            decltype(std::__1::__has_destroy_test(declval<_Alloc>(),
                                        declval<_Pointer>())),
            true_type>::value>
{
};
template <class _Alloc>
auto
__has_max_size_test(_Alloc&& __a)
    -> decltype(__a.max_size(), true_type());
template <class _Alloc>
auto
__has_max_size_test(const volatile _Alloc& __a)
    -> false_type;
template <class _Alloc>
struct __has_max_size
    : integral_constant<bool,
        is_same<
            decltype(std::__1::__has_max_size_test(declval<_Alloc&>())),
            true_type>::value>
{
};
template <class _Alloc>
auto
__has_select_on_container_copy_construction_test(_Alloc&& __a)
    -> decltype(__a.select_on_container_copy_construction(), true_type());
template <class _Alloc>
auto
__has_select_on_container_copy_construction_test(const volatile _Alloc& __a)
    -> false_type;
template <class _Alloc>
struct __has_select_on_container_copy_construction
    : integral_constant<bool,
        is_same<
            decltype(std::__1::__has_select_on_container_copy_construction_test(declval<_Alloc&>())),
            true_type>::value>
{
};
template <class _Alloc, class _Ptr, bool = __has_difference_type<_Alloc>::value>
struct __alloc_traits_difference_type
{
    typedef typename pointer_traits<_Ptr>::difference_type type;
};
template <class _Alloc, class _Ptr>
struct __alloc_traits_difference_type<_Alloc, _Ptr, true>
{
    typedef typename _Alloc::difference_type type;
};
template <class _Tp>
struct __is_default_allocator : false_type {};
template <class _Tp>
struct __is_default_allocator<std::__1::allocator<_Tp> > : true_type {};
template <class _Alloc>
struct __attribute__ ((__type_visibility__("default"))) allocator_traits
{
    typedef _Alloc allocator_type;
    typedef typename allocator_type::value_type value_type;
    typedef typename __pointer_type<value_type, allocator_type>::type pointer;
    typedef typename __const_pointer<value_type, pointer, allocator_type>::type const_pointer;
    typedef typename __void_pointer<pointer, allocator_type>::type void_pointer;
    typedef typename __const_void_pointer<pointer, allocator_type>::type const_void_pointer;
    typedef typename __alloc_traits_difference_type<allocator_type, pointer>::type difference_type;
    typedef typename __size_type<allocator_type, difference_type>::type size_type;
    typedef typename __propagate_on_container_copy_assignment<allocator_type>::type
                     propagate_on_container_copy_assignment;
    typedef typename __propagate_on_container_move_assignment<allocator_type>::type
                     propagate_on_container_move_assignment;
    typedef typename __propagate_on_container_swap<allocator_type>::type
                     propagate_on_container_swap;
    typedef typename __is_always_equal<allocator_type>::type
                     is_always_equal;
    template <class _Tp> using rebind_alloc =
                  typename __allocator_traits_rebind<allocator_type, _Tp>::type;
    template <class _Tp> using rebind_traits = allocator_traits<rebind_alloc<_Tp>>;
                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static pointer allocate(allocator_type& __a, size_type __n)
        ;
                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static pointer allocate(allocator_type& __a, size_type __n, const_void_pointer __hint)
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static void deallocate(allocator_type& __a, pointer __p, size_type __n) noexcept
        ;
    template <class _Tp, class... _Args>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        static void construct(allocator_type& __a, _Tp* __p, _Args&&... __args)
            ;
    template <class _Tp>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        static void destroy(allocator_type& __a, _Tp* __p)
            ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static size_type max_size(const allocator_type& __a) noexcept
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static allocator_type
        select_on_container_copy_construction(const allocator_type& __a)
            ;
    template <class _Ptr>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        static
        void
        __construct_forward(allocator_type& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __begin2)
        ;
    template <class _Tp>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        static
        typename enable_if
        <
            (__is_default_allocator<allocator_type>::value
                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&
             is_trivially_move_constructible<_Tp>::value,
            void
        >::type
        __construct_forward(allocator_type&, _Tp* __begin1, _Tp* __end1, _Tp*& __begin2)
        ;
    template <class _Iter, class _Ptr>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        static
        void
        __construct_range_forward(allocator_type& __a, _Iter __begin1, _Iter __end1, _Ptr& __begin2)
        ;
    template <class _SourceTp, class _DestTp,
              class _RawSourceTp = typename remove_const<_SourceTp>::type,
              class _RawDestTp = typename remove_const<_DestTp>::type>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        static
        typename enable_if
        <
            is_trivially_move_constructible<_DestTp>::value &&
            is_same<_RawSourceTp, _RawDestTp>::value &&
            (__is_default_allocator<allocator_type>::value ||
             !__has_construct<allocator_type, _DestTp*, _SourceTp&>::value),
            void
        >::type
        __construct_range_forward(allocator_type&, _SourceTp* __begin1, _SourceTp* __end1, _DestTp*& __begin2)
        ;
    template <class _Ptr>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        static
        void
        __construct_backward(allocator_type& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __end2)
        ;
    template <class _Tp>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        static
        typename enable_if
        <
            (__is_default_allocator<allocator_type>::value
                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&
             is_trivially_move_constructible<_Tp>::value,
            void
        >::type
        __construct_backward(allocator_type&, _Tp* __begin1, _Tp* __end1, _Tp*& __end2)
        ;
private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static pointer __allocate(allocator_type& __a, size_type __n,
        const_void_pointer __hint, true_type)
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static pointer __allocate(allocator_type& __a, size_type __n,
        const_void_pointer, false_type)
        ;
    template <class _Tp, class... _Args>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        static void __construct(true_type, allocator_type& __a, _Tp* __p, _Args&&... __args)
            ;
    template <class _Tp, class... _Args>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        static void __construct(false_type, allocator_type&, _Tp* __p, _Args&&... __args)
            ;
    template <class _Tp>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        static void __destroy(true_type, allocator_type& __a, _Tp* __p)
            ;
    template <class _Tp>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        static void __destroy(false_type, allocator_type&, _Tp* __p)
            ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static size_type __max_size(true_type, const allocator_type& __a) noexcept
            ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static size_type __max_size(false_type, const allocator_type&) noexcept
            ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static allocator_type
        __select_on_container_copy_construction(true_type, const allocator_type& __a)
            ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static allocator_type
        __select_on_container_copy_construction(false_type, const allocator_type& __a)
            ;
};
template <class _Traits, class _Tp>
struct __rebind_alloc_helper
{
    typedef typename _Traits::template rebind_alloc<_Tp> type;
};
template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) allocator
{
public:
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _Tp* pointer;
    typedef const _Tp* const_pointer;
    typedef _Tp& reference;
    typedef const _Tp& const_reference;
    typedef _Tp value_type;
    typedef true_type propagate_on_container_move_assignment;
    typedef true_type is_always_equal;
    template <class _Up> struct rebind {typedef allocator<_Up> other;};
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    allocator() noexcept ;
    template <class _Up>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    allocator(const allocator<_Up>&) noexcept ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) pointer address(reference __x) const noexcept
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) const_pointer address(const_reference __x) const noexcept
        ;
                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pointer allocate(size_type __n, allocator<void>::const_pointer = 0)
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void deallocate(pointer __p, size_type __n) noexcept
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) size_type max_size() const noexcept
        ;
    template <class _Up, class... _Args>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        void
        construct(_Up* __p, _Args&&... __args)
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void destroy(pointer __p) ;
};
template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) allocator<const _Tp>
{
public:
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef const _Tp* pointer;
    typedef const _Tp* const_pointer;
    typedef const _Tp& reference;
    typedef const _Tp& const_reference;
    typedef const _Tp value_type;
    typedef true_type propagate_on_container_move_assignment;
    typedef true_type is_always_equal;
    template <class _Up> struct rebind {typedef allocator<_Up> other;};
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    allocator() noexcept ;
    template <class _Up>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    allocator(const allocator<_Up>&) noexcept ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) const_pointer address(const_reference __x) const noexcept
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) pointer allocate(size_type __n, allocator<void>::const_pointer = 0)
    ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void deallocate(pointer __p, size_type __n) noexcept
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) size_type max_size() const noexcept
        ;
    template <class _Up, class... _Args>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        void
        construct(_Up* __p, _Args&&... __args)
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void destroy(pointer __p) ;
};
template <class _Tp, class _Up>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool operator==(const allocator<_Tp>&, const allocator<_Up>&) noexcept ;
template <class _Tp, class _Up>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool operator!=(const allocator<_Tp>&, const allocator<_Up>&) noexcept ;
template <class _OutputIterator, class _Tp>
class __attribute__ ((__type_visibility__("default"))) raw_storage_iterator
    : public iterator<output_iterator_tag,
                      _Tp,
                      ptrdiff_t,
                      _Tp*,
                      raw_storage_iterator<_OutputIterator, _Tp>&>
{
private:
    _OutputIterator __x_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit raw_storage_iterator(_OutputIterator __x) ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) raw_storage_iterator& operator*() ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) raw_storage_iterator& operator=(const _Tp& __element)
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) raw_storage_iterator& operator++() ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) raw_storage_iterator operator++(int)
        ;
};
template <class _Tp>
                      __attribute__((__no_sanitize__("cfi")))
pair<_Tp*, ptrdiff_t>
get_temporary_buffer(ptrdiff_t __n) noexcept
;
template <class _Tp>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void return_temporary_buffer(_Tp* __p) noexcept
;
template <class _Tp>
struct __attribute__ ((deprecated)) auto_ptr_ref
{
    _Tp* __ptr_;
};
template<class _Tp>
class __attribute__ ((__type_visibility__("default"))) __attribute__ ((deprecated)) auto_ptr
{
private:
    _Tp* __ptr_;
public:
    typedef _Tp element_type;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit auto_ptr(_Tp* __p = 0) throw() ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) auto_ptr(auto_ptr& __p) throw() ;
    template<class _Up> __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) auto_ptr(auto_ptr<_Up>& __p) throw() ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) auto_ptr& operator=(auto_ptr& __p) throw()
        ;
    template<class _Up> __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) auto_ptr& operator=(auto_ptr<_Up>& __p) throw()
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) auto_ptr& operator=(auto_ptr_ref<_Tp> __p) throw()
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) ~auto_ptr() throw() ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) _Tp& operator*() const throw()
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) _Tp* operator->() const throw() ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) _Tp* get() const throw() ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) _Tp* release() throw()
    ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void reset(_Tp* __p = 0) throw()
    ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) auto_ptr(auto_ptr_ref<_Tp> __p) throw() ;
    template<class _Up> __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) operator auto_ptr_ref<_Up>() throw()
        ;
    template<class _Up> __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) operator auto_ptr<_Up>() throw()
        ;
};
template <>
class __attribute__ ((__type_visibility__("default"))) __attribute__ ((deprecated)) auto_ptr<void>
{
public:
    typedef void element_type;
};
template <class _Tp, int _Idx,
          bool _CanBeEmptyBase =
              is_empty<_Tp>::value && !__libcpp_is_final<_Tp>::value>
struct __compressed_pair_elem {
  typedef _Tp _ParamT;
  typedef _Tp& reference;
  typedef const _Tp& const_reference;
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr __compressed_pair_elem() ;
  template <class _Up, class = typename enable_if<
      !is_same<__compressed_pair_elem, typename decay<_Up>::type>::value
  >::type>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  constexpr explicit
  __compressed_pair_elem(_Up&& __u)
    ;
  template <class... _Args, size_t... _Indexes>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  __compressed_pair_elem(piecewise_construct_t, tuple<_Args...> __args,
                         __tuple_indices<_Indexes...>) ;
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) reference __get() noexcept ;
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  const_reference __get() const noexcept ;
private:
  _Tp __value_;
};
template <class _Tp, int _Idx>
struct __compressed_pair_elem<_Tp, _Idx, true> : private _Tp {
  typedef _Tp _ParamT;
  typedef _Tp& reference;
  typedef const _Tp& const_reference;
  typedef _Tp __value_type;
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr __compressed_pair_elem() = default;
  template <class _Up, class = typename enable_if<
        !is_same<__compressed_pair_elem, typename decay<_Up>::type>::value
  >::type>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  constexpr explicit
  __compressed_pair_elem(_Up&& __u)
  ;
  template <class... _Args, size_t... _Indexes>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  __compressed_pair_elem(piecewise_construct_t, tuple<_Args...> __args,
                         __tuple_indices<_Indexes...>) ;
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) reference __get() noexcept ;
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  const_reference __get() const noexcept ;
};
struct __second_tag {};
template <class _T1, class _T2>
class __compressed_pair : private __compressed_pair_elem<_T1, 0>,
                          private __compressed_pair_elem<_T2, 1> {
  typedef __compressed_pair_elem<_T1, 0> _Base1;
  typedef __compressed_pair_elem<_T2, 1> _Base2;
  static_assert((!is_same<_T1, _T2>::value),
    "__compressed_pair cannot be instantated when T1 and T2 are the same type; "
    "The current implementation is NOT ABI-compatible with the previous "
    "implementation for this configuration");
public:
  template <bool _Dummy = true,
      class = typename enable_if<
          __dependent_type<is_default_constructible<_T1>, _Dummy>::value &&
          __dependent_type<is_default_constructible<_T2>, _Dummy>::value
      >::type
  >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  constexpr __compressed_pair() ;
  template <class _Tp, typename enable_if<!is_same<typename decay<_Tp>::type,
                                                   __compressed_pair>::value,
                                          bool>::type = true>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr explicit
  __compressed_pair(_Tp&& __t) ;
  template <class _Tp>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
  __compressed_pair(__second_tag, _Tp&& __t) ;
  template <class _U1, class _U2>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
  __compressed_pair(_U1&& __t1, _U2&& __t2) ;
  template <class... _Args1, class... _Args2>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  __compressed_pair(piecewise_construct_t __pc, tuple<_Args1...> __first_args,
                    tuple<_Args2...> __second_args) ;
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  typename _Base1::reference first() noexcept ;
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  typename _Base1::const_reference first() const noexcept ;
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  typename _Base2::reference second() noexcept ;
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  typename _Base2::const_reference second() const noexcept ;
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  void swap(__compressed_pair& __x)
    noexcept(__is_nothrow_swappable<_T1>::value && __is_nothrow_swappable<_T2>::value)
  ;
};
template <class _T1, class _T2>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void swap(__compressed_pair<_T1, _T2>& __x, __compressed_pair<_T1, _T2>& __y)
    noexcept(__is_nothrow_swappable<_T1>::value && __is_nothrow_swappable<_T2>::value) ;
template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) default_delete {
    static_assert(!is_function<_Tp>::value,
                  "default_delete cannot be instantiated for function types");
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr default_delete() noexcept = default;
  template <class _Up>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  default_delete(const default_delete<_Up>&,
                 typename enable_if<is_convertible<_Up*, _Tp*>::value>::type* =
                     0) noexcept ;
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void operator()(_Tp* __ptr) const noexcept ;
};
template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) default_delete<_Tp[]> {
private:
  template <class _Up>
  struct _EnableIfConvertible
      : enable_if<is_convertible<_Up(*)[], _Tp(*)[]>::value> {};
public:
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr default_delete() noexcept = default;
  template <class _Up>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  default_delete(const default_delete<_Up[]>&,
                 typename _EnableIfConvertible<_Up>::type* = 0) noexcept ;
  template <class _Up>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  typename _EnableIfConvertible<_Up>::type
  operator()(_Up* __ptr) const noexcept ;
};
template <class _Deleter>
struct __unique_ptr_deleter_sfinae {
  static_assert(!is_reference<_Deleter>::value, "incorrect specialization");
  typedef const _Deleter& __lval_ref_type;
  typedef _Deleter&& __good_rval_ref_type;
  typedef true_type __enable_rval_overload;
};
template <class _Deleter>
struct __unique_ptr_deleter_sfinae<_Deleter const&> {
  typedef const _Deleter& __lval_ref_type;
  typedef const _Deleter&& __bad_rval_ref_type;
  typedef false_type __enable_rval_overload;
};
template <class _Deleter>
struct __unique_ptr_deleter_sfinae<_Deleter&> {
  typedef _Deleter& __lval_ref_type;
  typedef _Deleter&& __bad_rval_ref_type;
  typedef false_type __enable_rval_overload;
};
template <class _Tp, class _Dp = default_delete<_Tp> >
class __attribute__ ((__type_visibility__("default"))) unique_ptr {
public:
  typedef _Tp element_type;
  typedef _Dp deleter_type;
  typedef typename __pointer_type<_Tp, deleter_type>::type pointer;
  static_assert(!is_rvalue_reference<deleter_type>::value,
                "the specified deleter type cannot be an rvalue reference");
private:
  __compressed_pair<pointer, deleter_type> __ptr_;
  struct __nat { int __for_bool_; };
  typedef __unique_ptr_deleter_sfinae<_Dp> _DeleterSFINAE;
  template <bool _Dummy>
  using _LValRefType =
      typename __dependent_type<_DeleterSFINAE, _Dummy>::__lval_ref_type;
  template <bool _Dummy>
  using _GoodRValRefType =
      typename __dependent_type<_DeleterSFINAE, _Dummy>::__good_rval_ref_type;
  template <bool _Dummy>
  using _BadRValRefType =
      typename __dependent_type<_DeleterSFINAE, _Dummy>::__bad_rval_ref_type;
  template <bool _Dummy, class _Deleter = typename __dependent_type<
                             __identity<deleter_type>, _Dummy>::type>
  using _EnableIfDeleterDefaultConstructible =
      typename enable_if<is_default_constructible<_Deleter>::value &&
                         !is_pointer<_Deleter>::value>::type;
  template <class _ArgType>
  using _EnableIfDeleterConstructible =
      typename enable_if<is_constructible<deleter_type, _ArgType>::value>::type;
  template <class _UPtr, class _Up>
  using _EnableIfMoveConvertible = typename enable_if<
      is_convertible<typename _UPtr::pointer, pointer>::value &&
      !is_array<_Up>::value
  >::type;
  template <class _UDel>
  using _EnableIfDeleterConvertible = typename enable_if<
      (is_reference<_Dp>::value && is_same<_Dp, _UDel>::value) ||
      (!is_reference<_Dp>::value && is_convertible<_UDel, _Dp>::value)
    >::type;
  template <class _UDel>
  using _EnableIfDeleterAssignable = typename enable_if<
      is_assignable<_Dp&, _UDel&&>::value
    >::type;
public:
  template <bool _Dummy = true,
            class = _EnableIfDeleterDefaultConstructible<_Dummy>>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  constexpr unique_ptr() ;
  template <bool _Dummy = true,
            class = _EnableIfDeleterDefaultConstructible<_Dummy>>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  constexpr unique_ptr(nullptr_t) ;
  template <bool _Dummy = true,
            class = _EnableIfDeleterDefaultConstructible<_Dummy>>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  explicit unique_ptr(pointer __p) ;
  template <bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_LValRefType<_Dummy>>>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  unique_ptr(pointer __p, _LValRefType<_Dummy> __d) ;
  template <bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_GoodRValRefType<_Dummy>>>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  unique_ptr(pointer __p, _GoodRValRefType<_Dummy> __d) ;
  template <bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_BadRValRefType<_Dummy>>>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  unique_ptr(pointer __p, _BadRValRefType<_Dummy> __d) = delete;
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  unique_ptr(unique_ptr&& __u) ;
  template <class _Up, class _Ep,
      class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>,
      class = _EnableIfDeleterConvertible<_Ep>
  >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  unique_ptr(unique_ptr<_Up, _Ep>&& __u) ;
  template <class _Up>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  unique_ptr(auto_ptr<_Up>&& __p,
             typename enable_if<is_convertible<_Up*, _Tp*>::value &&
                                    is_same<_Dp, default_delete<_Tp>>::value,
                                __nat>::type = __nat()) ;
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  unique_ptr& operator=(unique_ptr&& __u) noexcept ;
  template <class _Up, class _Ep,
      class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>,
      class = _EnableIfDeleterAssignable<_Ep>
  >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  unique_ptr& operator=(unique_ptr<_Up, _Ep>&& __u) noexcept ;
  template <class _Up>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
      typename enable_if<is_convertible<_Up*, _Tp*>::value &&
                             is_same<_Dp, default_delete<_Tp> >::value,
                         unique_ptr&>::type
      operator=(auto_ptr<_Up> __p) ;
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  ~unique_ptr() ;
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  unique_ptr& operator=(nullptr_t) noexcept ;
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  typename add_lvalue_reference<_Tp>::type
  operator*() const ;
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  pointer operator->() const noexcept ;
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  pointer get() const noexcept ;
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  deleter_type& get_deleter() noexcept ;
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  const deleter_type& get_deleter() const noexcept ;
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  explicit operator bool() const noexcept ;
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  pointer release() noexcept ;
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  void reset(pointer __p = pointer()) noexcept ;
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  void swap(unique_ptr& __u) noexcept ;
};
template <class _Tp, class _Dp>
class __attribute__ ((__type_visibility__("default"))) unique_ptr<_Tp[], _Dp> {
public:
  typedef _Tp element_type;
  typedef _Dp deleter_type;
  typedef typename __pointer_type<_Tp, deleter_type>::type pointer;
private:
  __compressed_pair<pointer, deleter_type> __ptr_;
  template <class _From>
  struct _CheckArrayPointerConversion : is_same<_From, pointer> {};
  template <class _FromElem>
  struct _CheckArrayPointerConversion<_FromElem*>
      : integral_constant<bool,
          is_same<_FromElem*, pointer>::value ||
            (is_same<pointer, element_type*>::value &&
             is_convertible<_FromElem(*)[], element_type(*)[]>::value)
      >
  {};
  typedef __unique_ptr_deleter_sfinae<_Dp> _DeleterSFINAE;
  template <bool _Dummy>
  using _LValRefType =
      typename __dependent_type<_DeleterSFINAE, _Dummy>::__lval_ref_type;
  template <bool _Dummy>
  using _GoodRValRefType =
      typename __dependent_type<_DeleterSFINAE, _Dummy>::__good_rval_ref_type;
  template <bool _Dummy>
  using _BadRValRefType =
      typename __dependent_type<_DeleterSFINAE, _Dummy>::__bad_rval_ref_type;
  template <bool _Dummy, class _Deleter = typename __dependent_type<
                             __identity<deleter_type>, _Dummy>::type>
  using _EnableIfDeleterDefaultConstructible =
      typename enable_if<is_default_constructible<_Deleter>::value &&
                         !is_pointer<_Deleter>::value>::type;
  template <class _ArgType>
  using _EnableIfDeleterConstructible =
      typename enable_if<is_constructible<deleter_type, _ArgType>::value>::type;
  template <class _Pp>
  using _EnableIfPointerConvertible = typename enable_if<
      _CheckArrayPointerConversion<_Pp>::value
  >::type;
  template <class _UPtr, class _Up,
        class _ElemT = typename _UPtr::element_type>
  using _EnableIfMoveConvertible = typename enable_if<
      is_array<_Up>::value &&
      is_same<pointer, element_type*>::value &&
      is_same<typename _UPtr::pointer, _ElemT*>::value &&
      is_convertible<_ElemT(*)[], element_type(*)[]>::value
    >::type;
  template <class _UDel>
  using _EnableIfDeleterConvertible = typename enable_if<
      (is_reference<_Dp>::value && is_same<_Dp, _UDel>::value) ||
      (!is_reference<_Dp>::value && is_convertible<_UDel, _Dp>::value)
    >::type;
  template <class _UDel>
  using _EnableIfDeleterAssignable = typename enable_if<
      is_assignable<_Dp&, _UDel&&>::value
    >::type;
public:
  template <bool _Dummy = true,
            class = _EnableIfDeleterDefaultConstructible<_Dummy>>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  constexpr unique_ptr() ;
  template <bool _Dummy = true,
            class = _EnableIfDeleterDefaultConstructible<_Dummy>>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  constexpr unique_ptr(nullptr_t) ;
  template <class _Pp, bool _Dummy = true,
            class = _EnableIfDeleterDefaultConstructible<_Dummy>,
            class = _EnableIfPointerConvertible<_Pp>>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  explicit unique_ptr(_Pp __p) ;
  template <class _Pp, bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_LValRefType<_Dummy>>,
            class = _EnableIfPointerConvertible<_Pp>>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  unique_ptr(_Pp __p, _LValRefType<_Dummy> __d) ;
  template <bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_LValRefType<_Dummy>>>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  unique_ptr(nullptr_t, _LValRefType<_Dummy> __d) ;
  template <class _Pp, bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_GoodRValRefType<_Dummy>>,
            class = _EnableIfPointerConvertible<_Pp>>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  unique_ptr(_Pp __p, _GoodRValRefType<_Dummy> __d) ;
  template <bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_GoodRValRefType<_Dummy>>>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  unique_ptr(nullptr_t, _GoodRValRefType<_Dummy> __d) ;
  template <class _Pp, bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_BadRValRefType<_Dummy>>,
            class = _EnableIfPointerConvertible<_Pp>>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  unique_ptr(_Pp __p, _BadRValRefType<_Dummy> __d) = delete;
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  unique_ptr(unique_ptr&& __u) ;
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  unique_ptr& operator=(unique_ptr&& __u) noexcept ;
  template <class _Up, class _Ep,
      class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>,
      class = _EnableIfDeleterConvertible<_Ep>
  >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  unique_ptr(unique_ptr<_Up, _Ep>&& __u) ;
  template <class _Up, class _Ep,
      class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>,
      class = _EnableIfDeleterAssignable<_Ep>
  >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  unique_ptr&
  operator=(unique_ptr<_Up, _Ep>&& __u) noexcept ;
public:
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  ~unique_ptr() ;
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  unique_ptr& operator=(nullptr_t) noexcept ;
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  typename add_lvalue_reference<_Tp>::type
  operator[](size_t __i) const ;
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  pointer get() const noexcept ;
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  deleter_type& get_deleter() noexcept ;
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  const deleter_type& get_deleter() const noexcept ;
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  explicit operator bool() const noexcept ;
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  pointer release() noexcept ;
  template <class _Pp>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  typename enable_if<
      _CheckArrayPointerConversion<_Pp>::value
  >::type
  reset(_Pp __p) noexcept ;
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  void reset(nullptr_t = nullptr) noexcept ;
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  void swap(unique_ptr& __u) noexcept ;
};
template <class _Tp, class _Dp>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if<
    __is_swappable<_Dp>::value,
    void
>::type
swap(unique_ptr<_Tp, _Dp>& __x, unique_ptr<_Tp, _Dp>& __y) noexcept ;
template <class _T1, class _D1, class _T2, class _D2>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator==(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) ;
template <class _T1, class _D1, class _T2, class _D2>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator!=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) ;
template <class _T1, class _D1, class _T2, class _D2>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator< (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y)
;
template <class _T1, class _D1, class _T2, class _D2>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator> (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) ;
template <class _T1, class _D1, class _T2, class _D2>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator<=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) ;
template <class _T1, class _D1, class _T2, class _D2>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator>=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) ;
template <class _T1, class _D1>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator==(const unique_ptr<_T1, _D1>& __x, nullptr_t) noexcept
;
template <class _T1, class _D1>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator==(nullptr_t, const unique_ptr<_T1, _D1>& __x) noexcept
;
template <class _T1, class _D1>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator!=(const unique_ptr<_T1, _D1>& __x, nullptr_t) noexcept
;
template <class _T1, class _D1>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator!=(nullptr_t, const unique_ptr<_T1, _D1>& __x) noexcept
;
template <class _T1, class _D1>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator<(const unique_ptr<_T1, _D1>& __x, nullptr_t)
;
template <class _T1, class _D1>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator<(nullptr_t, const unique_ptr<_T1, _D1>& __x)
;
template <class _T1, class _D1>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator>(const unique_ptr<_T1, _D1>& __x, nullptr_t)
;
template <class _T1, class _D1>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator>(nullptr_t, const unique_ptr<_T1, _D1>& __x)
;
template <class _T1, class _D1>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator<=(const unique_ptr<_T1, _D1>& __x, nullptr_t)
;
template <class _T1, class _D1>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator<=(nullptr_t, const unique_ptr<_T1, _D1>& __x)
;
template <class _T1, class _D1>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator>=(const unique_ptr<_T1, _D1>& __x, nullptr_t)
;
template <class _T1, class _D1>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator>=(nullptr_t, const unique_ptr<_T1, _D1>& __x)
;
template <class _Tp, class _Dp>
struct __attribute__ ((__type_visibility__("default"))) hash<__enable_hash_helper<
    unique_ptr<_Tp, _Dp>, typename unique_ptr<_Tp, _Dp>::pointer>>
{
    typedef unique_ptr<_Tp, _Dp> argument_type;
    typedef size_t result_type;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result_type operator()(const argument_type& __ptr) const
    ;
};
struct __destruct_n
{
private:
    size_t __size_;
    template <class _Tp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void __process(_Tp* __p, false_type) noexcept
        ;
    template <class _Tp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void __process(_Tp*, true_type) noexcept
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void __incr(false_type) noexcept
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void __incr(true_type) noexcept
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void __set(size_t __s, false_type) noexcept
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void __set(size_t, true_type) noexcept
        ;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit __destruct_n(size_t __s) ;
    template <class _Tp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void __incr(_Tp*) noexcept
        ;
    template <class _Tp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void __set(size_t __s, _Tp*) noexcept
        ;
    template <class _Tp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void operator()(_Tp* __p) noexcept
        ;
};
template <class _Alloc>
class __allocator_destructor
{
    typedef allocator_traits<_Alloc> __alloc_traits;
public:
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::size_type size_type;
private:
    _Alloc& __alloc_;
    size_type __s_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __allocator_destructor(_Alloc& __a, size_type __s) ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void operator()(pointer __p) noexcept
        ;
};
template <class _InputIterator, class _ForwardIterator>
_ForwardIterator
uninitialized_copy(_InputIterator __f, _InputIterator __l, _ForwardIterator __r)
;
template <class _InputIterator, class _Size, class _ForwardIterator>
_ForwardIterator
uninitialized_copy_n(_InputIterator __f, _Size __n, _ForwardIterator __r)
;
template <class _ForwardIterator, class _Tp>
void
uninitialized_fill(_ForwardIterator __f, _ForwardIterator __l, const _Tp& __x)
;
template <class _ForwardIterator, class _Size, class _Tp>
_ForwardIterator
uninitialized_fill_n(_ForwardIterator __f, _Size __n, const _Tp& __x)
;
template <class _Tp>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) _Tp
__libcpp_atomic_refcount_increment(_Tp& __t) noexcept
;
template <class _Tp>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) _Tp
__libcpp_atomic_refcount_decrement(_Tp& __t) noexcept
;
class __attribute__ ((__visibility__("default"))) bad_weak_ptr
    : public std::exception
{
public:
    virtual ~bad_weak_ptr() noexcept;
    virtual const char* what() const noexcept;
};
[[noreturn]] __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void __throw_bad_weak_ptr()
;
template<class _Tp> class __attribute__ ((__type_visibility__("default"))) weak_ptr;
class __attribute__ ((__visibility__("default"))) __shared_count
{
    __shared_count(const __shared_count&);
    __shared_count& operator=(const __shared_count&);
protected:
    long __shared_owners_;
    virtual ~__shared_count();
private:
    virtual void __on_zero_shared() noexcept = 0;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __shared_count(long __refs = 0) ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __add_shared() noexcept ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool __release_shared() noexcept ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    long use_count() const noexcept ;
};
class __attribute__ ((__visibility__("default"))) __shared_weak_count
    : private __shared_count
{
    long __shared_weak_owners_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __shared_weak_count(long __refs = 0) ;
protected:
    virtual ~__shared_weak_count();
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __add_shared() noexcept ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __add_weak() noexcept ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __release_shared() noexcept ;
    void __release_weak() noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    long use_count() const noexcept ;
    __shared_weak_count* lock() noexcept;
    virtual const void* __get_deleter(const type_info&) const noexcept;
private:
    virtual void __on_zero_shared_weak() noexcept = 0;
};
template <class _Tp, class _Dp, class _Alloc>
class __shared_ptr_pointer
    : public __shared_weak_count
{
    __compressed_pair<__compressed_pair<_Tp, _Dp>, _Alloc> __data_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __shared_ptr_pointer(_Tp __p, _Dp __d, _Alloc __a) ;
    virtual const void* __get_deleter(const type_info&) const noexcept;
private:
    virtual void __on_zero_shared() noexcept;
    virtual void __on_zero_shared_weak() noexcept;
};
template <class _Tp, class _Alloc>
class __shared_ptr_emplace
    : public __shared_weak_count
{
    __compressed_pair<_Alloc, _Tp> __data_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __shared_ptr_emplace(_Alloc __a) ;
    template <class ..._Args>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        __shared_ptr_emplace(_Alloc __a, _Args&& ...__args) ;
private:
    virtual void __on_zero_shared() noexcept;
    virtual void __on_zero_shared_weak() noexcept;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp* get() noexcept ;
};
struct __shared_ptr_dummy_rebind_allocator_type;
template <>
class __attribute__ ((__type_visibility__("default"))) allocator<__shared_ptr_dummy_rebind_allocator_type>
{
public:
    template <class _Other>
    struct rebind
    {
        typedef allocator<_Other> other;
    };
};
template<class _Tp> class __attribute__ ((__type_visibility__("default"))) enable_shared_from_this;
template<class _Tp>
class __attribute__ ((__type_visibility__("default"))) shared_ptr
{
public:
    typedef _Tp element_type;
private:
    element_type* __ptr_;
    __shared_weak_count* __cntrl_;
    struct __nat {int __for_bool_;};
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr shared_ptr() noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr shared_ptr(nullptr_t) noexcept;
    template<class _Yp>
        explicit shared_ptr(_Yp* __p,
                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());
    template<class _Yp, class _Dp>
        shared_ptr(_Yp* __p, _Dp __d,
                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());
    template<class _Yp, class _Dp, class _Alloc>
        shared_ptr(_Yp* __p, _Dp __d, _Alloc __a,
                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());
    template <class _Dp> shared_ptr(nullptr_t __p, _Dp __d);
    template <class _Dp, class _Alloc> shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a);
    template<class _Yp> __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) shared_ptr(const shared_ptr<_Yp>& __r, element_type* __p) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    shared_ptr(const shared_ptr& __r) noexcept;
    template<class _Yp>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        shared_ptr(const shared_ptr<_Yp>& __r,
                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat())
                       noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    shared_ptr(shared_ptr&& __r) noexcept;
    template<class _Yp> __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) shared_ptr(shared_ptr<_Yp>&& __r,
                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat())
                       noexcept;
    template<class _Yp> explicit shared_ptr(const weak_ptr<_Yp>& __r,
                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type= __nat());
    template<class _Yp>
        shared_ptr(auto_ptr<_Yp>&& __r,
                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());
    template <class _Yp, class _Dp>
        shared_ptr(unique_ptr<_Yp, _Dp>&&,
                   typename enable_if
                   <
                       !is_lvalue_reference<_Dp>::value &&
                       !is_array<_Yp>::value &&
                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,
                       __nat
                   >::type = __nat());
    template <class _Yp, class _Dp>
        shared_ptr(unique_ptr<_Yp, _Dp>&&,
                   typename enable_if
                   <
                       is_lvalue_reference<_Dp>::value &&
                       !is_array<_Yp>::value &&
                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,
                       __nat
                   >::type = __nat());
    ~shared_ptr();
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    shared_ptr& operator=(const shared_ptr& __r) noexcept;
    template<class _Yp>
        typename enable_if
        <
            is_convertible<_Yp*, element_type*>::value,
            shared_ptr&
        >::type
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        operator=(const shared_ptr<_Yp>& __r) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    shared_ptr& operator=(shared_ptr&& __r) noexcept;
    template<class _Yp>
        typename enable_if
        <
            is_convertible<_Yp*, element_type*>::value,
            shared_ptr<_Tp>&
        >::type
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        operator=(shared_ptr<_Yp>&& __r);
    template<class _Yp>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        typename enable_if
        <
            !is_array<_Yp>::value &&
            is_convertible<_Yp*, element_type*>::value,
            shared_ptr
        >::type&
        operator=(auto_ptr<_Yp>&& __r);
    template <class _Yp, class _Dp>
        typename enable_if
        <
            !is_array<_Yp>::value &&
            is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,
            shared_ptr&
        >::type
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        operator=(unique_ptr<_Yp, _Dp>&& __r);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void swap(shared_ptr& __r) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void reset() noexcept;
    ;
    ;
    ;
        ;
        ;
            ;
    ;
    ;
private:
    template <class _Yp, bool = is_function<_Yp>::value>
        struct __shared_ptr_default_allocator
        {
            typedef allocator<_Yp> type;
        };
    template <class _Yp>
        struct __shared_ptr_default_allocator<_Yp, true>
        {
            typedef allocator<__shared_ptr_dummy_rebind_allocator_type> type;
        };
        ;
    template <class _Up> friend class __attribute__ ((__type_visibility__("default"))) shared_ptr;
    template <class _Up> friend class __attribute__ ((__type_visibility__("default"))) weak_ptr;
};
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
template<class _Tp>
class __attribute__ ((__type_visibility__("default"))) weak_ptr
{
public:
    typedef _Tp element_type;
private:
    element_type* __ptr_;
    __shared_weak_count* __cntrl_;
public:
    ;
    ;
    ;
    ;
    ;
    ;
        ;
        ;
    template <class _Up> friend class __attribute__ ((__type_visibility__("default"))) weak_ptr;
    template <class _Up> friend class __attribute__ ((__type_visibility__("default"))) shared_ptr;
};
;
template <class _Tp> struct owner_less;
template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) owner_less<shared_ptr<_Tp> >
    : binary_function<shared_ptr<_Tp>, shared_ptr<_Tp>, bool>
{
    typedef bool result_type;
};
template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) owner_less<weak_ptr<_Tp> >
    : binary_function<weak_ptr<_Tp>, weak_ptr<_Tp>, bool>
{
    typedef bool result_type;
};
template<class _Tp>
class __attribute__ ((__type_visibility__("default"))) enable_shared_from_this
{
    mutable weak_ptr<_Tp> __weak_this_;
protected:
public:
    template <class _Up> friend class shared_ptr;
};
template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) hash<shared_ptr<_Tp> >
{
    typedef shared_ptr<_Tp> argument_type;
    typedef size_t result_type;
};
;
class __attribute__ ((__visibility__("default"))) __sp_mut
{
    void* __lx;
public:
private:
};
;
;
;
;
;
;
;
;
;
;
;
struct __attribute__ ((__visibility__("default"))) pointer_safety
{
    enum __lx
    {
        relaxed,
        preferred,
        strict
    };
    __lx __v_;
};
;
;
;
 ;
template <typename _Alloc, typename _Traits=allocator_traits<_Alloc> >
struct __noexcept_move_assign_container : public integral_constant<bool,
    _Traits::propagate_on_container_move_assignment::value
        && is_nothrow_move_assignable<_Alloc>::value
    > {};
template <class _Tp, class _Alloc>
struct __temp_value {
    typedef allocator_traits<_Alloc> _Traits;
    typename aligned_storage<sizeof(_Tp), alignof(_Tp)>::type __v;
    _Alloc &__a;
      ;
    };
template<typename _Alloc, typename = void, typename = void>
struct __is_allocator : false_type {};
template<typename _Alloc>
struct __is_allocator<_Alloc,
       typename __void_t<typename _Alloc::value_type>::type,
       typename __void_t<decltype(std::__1::declval<_Alloc&>().allocate(size_t(0)))>::type
     >
   : true_type {};
} }
namespace std { inline namespace __1 {
template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) plus : binary_function<_Tp, _Tp, _Tp>
{
};
template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) minus : binary_function<_Tp, _Tp, _Tp>
{
};
template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) multiplies : binary_function<_Tp, _Tp, _Tp>
{
};
template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) divides : binary_function<_Tp, _Tp, _Tp>
{
};
template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) modulus : binary_function<_Tp, _Tp, _Tp>
{
};
template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) negate : unary_function<_Tp, _Tp>
{
};
template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) equal_to : binary_function<_Tp, _Tp, bool>
{
};
template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) not_equal_to : binary_function<_Tp, _Tp, bool>
{
};
template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) greater : binary_function<_Tp, _Tp, bool>
{
};
template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) greater_equal : binary_function<_Tp, _Tp, bool>
{
};
template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) less_equal : binary_function<_Tp, _Tp, bool>
{
};
template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) logical_and : binary_function<_Tp, _Tp, bool>
{
};
template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) logical_or : binary_function<_Tp, _Tp, bool>
{
};
template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) logical_not : unary_function<_Tp, bool>
{
};
template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) bit_and : binary_function<_Tp, _Tp, _Tp>
{
};
template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) bit_or : binary_function<_Tp, _Tp, _Tp>
{
};
template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) bit_xor : binary_function<_Tp, _Tp, _Tp>
{
};
template <class _Predicate>
class __attribute__ ((__type_visibility__("default"))) unary_negate
    : public unary_function<typename _Predicate::argument_type, bool>
{
    _Predicate __pred_;
public:
};
 ;
template <class _Predicate>
class __attribute__ ((__type_visibility__("default"))) binary_negate
    : public binary_function<typename _Predicate::first_argument_type,
                             typename _Predicate::second_argument_type,
                             bool>
{
    _Predicate __pred_;
public:
};
 ;
template <class __Operation>
class __attribute__ ((__type_visibility__("default"))) __attribute__ ((deprecated)) binder1st
    : public unary_function<typename __Operation::second_argument_type,
                            typename __Operation::result_type>
{
protected:
    __Operation op;
    typename __Operation::first_argument_type value;
public:
};
template <class __Operation, class _Tp>
__attribute__ ((deprecated)) __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
binder1st<__Operation>
bind1st(const __Operation& __op, const _Tp& __x)
    ;
template <class __Operation>
class __attribute__ ((__type_visibility__("default"))) __attribute__ ((deprecated)) binder2nd
    : public unary_function<typename __Operation::first_argument_type,
                            typename __Operation::result_type>
{
protected:
    __Operation op;
    typename __Operation::second_argument_type value;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    binder2nd(const __Operation& __x, const typename __Operation::second_argument_type __y) ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) typename __Operation::result_type operator()
        ( typename __Operation::first_argument_type& __x) const
            ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) typename __Operation::result_type operator()
        (const typename __Operation::first_argument_type& __x) const
            ;
};
template <class __Operation, class _Tp>
__attribute__ ((deprecated)) __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
binder2nd<__Operation>
bind2nd(const __Operation& __op, const _Tp& __x)
    ;
template <class _Arg, class _Result>
class __attribute__ ((__type_visibility__("default"))) __attribute__ ((deprecated)) pointer_to_unary_function
    : public unary_function<_Arg, _Result>
{
    _Result (*__f_)(_Arg);
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit pointer_to_unary_function(_Result (*__f)(_Arg)) ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) _Result operator()(_Arg __x) const
        ;
};
template <class _Arg, class _Result>
__attribute__ ((deprecated)) __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
pointer_to_unary_function<_Arg,_Result>
ptr_fun(_Result (*__f)(_Arg))
    ;
template <class _Arg1, class _Arg2, class _Result>
class __attribute__ ((__type_visibility__("default"))) __attribute__ ((deprecated)) pointer_to_binary_function
    : public binary_function<_Arg1, _Arg2, _Result>
{
    _Result (*__f_)(_Arg1, _Arg2);
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit pointer_to_binary_function(_Result (*__f)(_Arg1, _Arg2)) ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) _Result operator()(_Arg1 __x, _Arg2 __y) const
        ;
};
template <class _Arg1, class _Arg2, class _Result>
__attribute__ ((deprecated)) __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
pointer_to_binary_function<_Arg1,_Arg2,_Result>
ptr_fun(_Result (*__f)(_Arg1,_Arg2))
    ;
template<class _Sp, class _Tp>
class __attribute__ ((__type_visibility__("default"))) __attribute__ ((deprecated)) mem_fun_t
    : public unary_function<_Tp*, _Sp>
{
    _Sp (_Tp::*__p_)();
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit mem_fun_t(_Sp (_Tp::*__p)()) ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) _Sp operator()(_Tp* __p) const
        ;
};
template<class _Sp, class _Tp, class _Ap>
class __attribute__ ((__type_visibility__("default"))) __attribute__ ((deprecated)) mem_fun1_t
    : public binary_function<_Tp*, _Ap, _Sp>
{
    _Sp (_Tp::*__p_)(_Ap);
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit mem_fun1_t(_Sp (_Tp::*__p)(_Ap)) ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) _Sp operator()(_Tp* __p, _Ap __x) const
        ;
};
template<class _Sp, class _Tp>
__attribute__ ((deprecated)) __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
mem_fun_t<_Sp,_Tp>
mem_fun(_Sp (_Tp::*__f)())
    ;
template<class _Sp, class _Tp, class _Ap>
__attribute__ ((deprecated)) __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
mem_fun1_t<_Sp,_Tp,_Ap>
mem_fun(_Sp (_Tp::*__f)(_Ap))
    ;
template<class _Sp, class _Tp>
class __attribute__ ((__type_visibility__("default"))) __attribute__ ((deprecated)) mem_fun_ref_t
    : public unary_function<_Tp, _Sp>
{
    _Sp (_Tp::*__p_)();
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit mem_fun_ref_t(_Sp (_Tp::*__p)()) ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) _Sp operator()(_Tp& __p) const
        ;
};
template<class _Sp, class _Tp, class _Ap>
class __attribute__ ((__type_visibility__("default"))) __attribute__ ((deprecated)) mem_fun1_ref_t
    : public binary_function<_Tp, _Ap, _Sp>
{
    _Sp (_Tp::*__p_)(_Ap);
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit mem_fun1_ref_t(_Sp (_Tp::*__p)(_Ap)) ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) _Sp operator()(_Tp& __p, _Ap __x) const
        ;
};
template<class _Sp, class _Tp>
__attribute__ ((deprecated)) __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
mem_fun_ref_t<_Sp,_Tp>
mem_fun_ref(_Sp (_Tp::*__f)())
    ;
template<class _Sp, class _Tp, class _Ap>
__attribute__ ((deprecated)) __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
mem_fun1_ref_t<_Sp,_Tp,_Ap>
mem_fun_ref(_Sp (_Tp::*__f)(_Ap))
    ;
template <class _Sp, class _Tp>
class __attribute__ ((__type_visibility__("default"))) __attribute__ ((deprecated)) const_mem_fun_t
    : public unary_function<const _Tp*, _Sp>
{
    _Sp (_Tp::*__p_)() const;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit const_mem_fun_t(_Sp (_Tp::*__p)() const) ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) _Sp operator()(const _Tp* __p) const
        ;
};
template <class _Sp, class _Tp, class _Ap>
class __attribute__ ((__type_visibility__("default"))) __attribute__ ((deprecated)) const_mem_fun1_t
    : public binary_function<const _Tp*, _Ap, _Sp>
{
    _Sp (_Tp::*__p_)(_Ap) const;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit const_mem_fun1_t(_Sp (_Tp::*__p)(_Ap) const) ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) _Sp operator()(const _Tp* __p, _Ap __x) const
        ;
};
template <class _Sp, class _Tp>
__attribute__ ((deprecated)) __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
const_mem_fun_t<_Sp,_Tp>
mem_fun(_Sp (_Tp::*__f)() const)
    ;
template <class _Sp, class _Tp, class _Ap>
__attribute__ ((deprecated)) __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
const_mem_fun1_t<_Sp,_Tp,_Ap>
mem_fun(_Sp (_Tp::*__f)(_Ap) const)
    ;
template <class _Sp, class _Tp>
class __attribute__ ((__type_visibility__("default"))) __attribute__ ((deprecated)) const_mem_fun_ref_t
    : public unary_function<_Tp, _Sp>
{
    _Sp (_Tp::*__p_)() const;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit const_mem_fun_ref_t(_Sp (_Tp::*__p)() const) ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) _Sp operator()(const _Tp& __p) const
        ;
};
template <class _Sp, class _Tp, class _Ap>
class __attribute__ ((__type_visibility__("default"))) __attribute__ ((deprecated)) const_mem_fun1_ref_t
    : public binary_function<_Tp, _Ap, _Sp>
{
    _Sp (_Tp::*__p_)(_Ap) const;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit const_mem_fun1_ref_t(_Sp (_Tp::*__p)(_Ap) const) ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) _Sp operator()(const _Tp& __p, _Ap __x) const
        ;
};
template <class _Sp, class _Tp>
__attribute__ ((deprecated)) __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
const_mem_fun_ref_t<_Sp,_Tp>
mem_fun_ref(_Sp (_Tp::*__f)() const)
    ;
template <class _Sp, class _Tp, class _Ap>
__attribute__ ((deprecated)) __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
const_mem_fun1_ref_t<_Sp,_Tp,_Ap>
mem_fun_ref(_Sp (_Tp::*__f)(_Ap) const)
    ;
template <class _Tp>
class __mem_fn
    : public __weak_result_type<_Tp>
{
public:
    typedef _Tp type;
private:
    type __f_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __mem_fn(type __f) ;
    template <class... _ArgTypes>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename __invoke_return<type, _ArgTypes...>::type
    operator() (_ArgTypes&&... __args) const ;
};
template<class _Rp, class _Tp>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__mem_fn<_Rp _Tp::*>
mem_fn(_Rp _Tp::* __pm) noexcept
;
class __attribute__ ((__visibility__("default"))) bad_function_call
    : public exception
{
};
[[noreturn]] __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void __throw_bad_function_call()
;
template<class _Fp> class __attribute__ ((__type_visibility__("default"))) function;
namespace __function
{
template<class _Rp>
struct __maybe_derive_from_unary_function
{
};
template<class _Rp, class _A1>
struct __maybe_derive_from_unary_function<_Rp(_A1)>
    : public unary_function<_A1, _Rp>
{
};
template<class _Rp>
struct __maybe_derive_from_binary_function
{
};
template<class _Rp, class _A1, class _A2>
struct __maybe_derive_from_binary_function<_Rp(_A1, _A2)>
    : public binary_function<_A1, _A2, _Rp>
{
};
template <class _Fp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool __not_null(_Fp const&) ;
template <class _Fp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool __not_null(_Fp* __ptr) ;
template <class _Ret, class _Class>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool __not_null(_Ret _Class::*__ptr) ;
template <class _Fp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool __not_null(function<_Fp> const& __f) ;
}
namespace __function {
template <class _Fp, class _Ap, class _FB> class __alloc_func;
template <class _Fp, class _Ap, class _Rp, class... _ArgTypes>
class __alloc_func<_Fp, _Ap, _Rp(_ArgTypes...)>
{
    __compressed_pair<_Fp, _Ap> __f_;
  public:
    typedef _Fp _Target;
    typedef _Ap _Alloc;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const _Target& __target() const ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const _Alloc& __allocator() const ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __alloc_func(_Target&& __f)
    ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __alloc_func(const _Target& __f, const _Alloc& __a)
    ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __alloc_func(const _Target& __f, _Alloc&& __a)
    ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __alloc_func(_Target&& __f, _Alloc&& __a)
    ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Rp operator()(_ArgTypes&&... __arg)
    ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __alloc_func* __clone() const
    ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void destroy() noexcept ;
};
template<class _Fp> class __base;
template<class _Rp, class ..._ArgTypes>
class __base<_Rp(_ArgTypes...)>
{
    __base(const __base&);
    __base& operator=(const __base&);
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __base() ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) virtual ~__base() ;
    virtual __base* __clone() const = 0;
    virtual void __clone(__base*) const = 0;
    virtual void destroy() noexcept = 0;
    virtual void destroy_deallocate() noexcept = 0;
    virtual _Rp operator()(_ArgTypes&& ...) = 0;
    virtual const void* target(const type_info&) const noexcept = 0;
    virtual const std::type_info& target_type() const noexcept = 0;
};
template<class _FD, class _Alloc, class _FB> class __func;
template<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
class __func<_Fp, _Alloc, _Rp(_ArgTypes...)>
    : public __base<_Rp(_ArgTypes...)>
{
    __alloc_func<_Fp, _Alloc, _Rp(_ArgTypes...)> __f_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __func(_Fp&& __f) ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __func(const _Fp& __f, const _Alloc& __a) ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __func(const _Fp& __f, _Alloc&& __a) ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __func(_Fp&& __f, _Alloc&& __a) ;
    virtual __base<_Rp(_ArgTypes...)>* __clone() const;
    virtual void __clone(__base<_Rp(_ArgTypes...)>*) const;
    virtual void destroy() noexcept;
    virtual void destroy_deallocate() noexcept;
    virtual _Rp operator()(_ArgTypes&&... __arg);
    virtual const void* target(const type_info&) const noexcept;
    virtual const std::type_info& target_type() const noexcept;
};
template <class _Fp> class __value_func;
template <class _Rp, class... _ArgTypes> class __value_func<_Rp(_ArgTypes...)>
{
    typename aligned_storage<3 * sizeof(void*)>::type __buf_;
    typedef __base<_Rp(_ArgTypes...)> __func;
    __func* __f_;
    __attribute__((__no_sanitize__("cfi"))) static __func* __as_base(void* p)
    ;
  public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __value_func() ;
    template <class _Fp, class _Alloc>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __value_func(_Fp&& __f, const _Alloc __a)
    ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __value_func(const __value_func& __f)
    ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __value_func(__value_func&& __f) noexcept
    ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    ~__value_func()
    ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __value_func& operator=(__value_func&& __f)
    ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __value_func& operator=(nullptr_t)
    ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Rp operator()(_ArgTypes&&... __args) const
    ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void swap(__value_func& __f) noexcept
    ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit operator bool() const noexcept ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const std::type_info& target_type() const noexcept
    ;
    template <typename _Tp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) const _Tp* target() const noexcept
    ;
};
union __policy_storage
{
    mutable char __small[sizeof(void*) * 2];
    void* __large;
};
template <typename _Fun>
struct __use_small_storage
    : public std::__1::integral_constant<
          bool, sizeof(_Fun) <= sizeof(__policy_storage) &&
                    alignof(_Fun) <= alignof(__policy_storage) &&
                    std::__1::is_trivially_copy_constructible<_Fun>::value &&
                    std::__1::is_trivially_destructible<_Fun>::value> {};
struct __policy
{
    void* (*const __clone)(const void*);
    void (*const __destroy)(void*);
    const bool __is_null;
    const std::type_info* const __type_info;
    template <typename _Fun>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static const __policy* __create()
    ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static const __policy* __create_empty()
    ;
  private:
    template <typename _Fun> static void* __large_clone(const void* __s)
    ;
    template <typename _Fun> static void __large_destroy(void* __s)
    ;
    template <typename _Fun>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static const __policy*
        __choose_policy( false_type)
    ;
    template <typename _Fun>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static const __policy*
        __choose_policy( true_type)
    ;
};
template <typename _Tp>
using __fast_forward =
    typename std::__1::conditional<std::__1::is_scalar<_Tp>::value, _Tp, _Tp&&>::type;
template <class _Fp> struct __policy_invoker;
template <class _Rp, class... _ArgTypes>
struct __policy_invoker<_Rp(_ArgTypes...)>
{
    typedef _Rp (*__Call)(const __policy_storage*,
                          __fast_forward<_ArgTypes>...);
    __Call __call_;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __policy_invoker() ;
    template <typename _Fun>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static __policy_invoker __create()
    ;
  private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __policy_invoker(__Call __c) ;
    static _Rp __call_empty(const __policy_storage*,
                            __fast_forward<_ArgTypes>...)
    ;
    template <typename _Fun>
    static _Rp __call_impl(const __policy_storage* __buf,
                           __fast_forward<_ArgTypes>... __args)
    ;
};
template <class _Fp> class __policy_func;
template <class _Rp, class... _ArgTypes> class __policy_func<_Rp(_ArgTypes...)>
{
    __policy_storage __buf_;
    typedef __function::__policy_invoker<_Rp(_ArgTypes...)> __invoker;
    __invoker __invoker_;
    const __policy* __policy_;
  public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __policy_func() ;
    template <class _Fp, class _Alloc>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __policy_func(_Fp&& __f, const _Alloc& __a)
    ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __policy_func(const __policy_func& __f)
    ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __policy_func(__policy_func&& __f)
    ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    ~__policy_func()
    ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __policy_func& operator=(__policy_func&& __f)
    ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __policy_func& operator=(nullptr_t)
    ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Rp operator()(_ArgTypes&&... __args) const
    ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void swap(__policy_func& __f)
    ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit operator bool() const noexcept
    ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const std::type_info& target_type() const noexcept
    ;
    template <typename _Tp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) const _Tp* target() const noexcept
    ;
};
}
template<class _Rp, class ..._ArgTypes>
class __attribute__ ((__type_visibility__("default"))) function<_Rp(_ArgTypes...)>
    : public __function::__maybe_derive_from_unary_function<_Rp(_ArgTypes...)>,
      public __function::__maybe_derive_from_binary_function<_Rp(_ArgTypes...)>
{
    typedef __function::__value_func<_Rp(_ArgTypes...)> __func;
    __func __f_;
    template <class _Fp, bool = __lazy_and<
        integral_constant<bool, !is_same<__uncvref_t<_Fp>, function>::value>,
        __invokable<_Fp&, _ArgTypes...>
    >::value>
    struct __callable;
    template <class _Fp>
        struct __callable<_Fp, true>
        {
            static const bool value = is_same<void, _Rp>::value ||
                is_convertible<typename __invoke_of<_Fp&, _ArgTypes...>::type,
                               _Rp>::value;
        };
    template <class _Fp>
        struct __callable<_Fp, false>
        {
            static const bool value = false;
        };
  template <class _Fp>
  using _EnableIfCallable = typename enable_if<__callable<_Fp>::value>::type;
public:
    typedef _Rp result_type;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    function() noexcept ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    function(nullptr_t) noexcept ;
    function(const function&);
    function(function&&) noexcept;
    template<class _Fp, class = _EnableIfCallable<_Fp>>
    function(_Fp);
    template<class _Alloc>
      __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
      function(allocator_arg_t, const _Alloc&) noexcept ;
    template<class _Alloc>
      __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
      function(allocator_arg_t, const _Alloc&, nullptr_t) noexcept ;
    template<class _Alloc>
      function(allocator_arg_t, const _Alloc&, const function&);
    template<class _Alloc>
      function(allocator_arg_t, const _Alloc&, function&&);
    template<class _Fp, class _Alloc, class = _EnableIfCallable<_Fp>>
      function(allocator_arg_t, const _Alloc& __a, _Fp __f);
    function& operator=(const function&);
    function& operator=(function&&) noexcept;
    function& operator=(nullptr_t) noexcept;
    template<class _Fp, class = _EnableIfCallable<_Fp>>
    function& operator=(_Fp&&);
    ~function();
    void swap(function&) noexcept;
    template<class _Fp, class _Alloc>
      __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
      void assign(_Fp&& __f, const _Alloc& __a)
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit operator bool() const noexcept ;
    template<class _R2, class... _ArgTypes2>
      bool operator==(const function<_R2(_ArgTypes2...)>&) const = delete;
    template<class _R2, class... _ArgTypes2>
      bool operator!=(const function<_R2(_ArgTypes2...)>&) const = delete;
public:
    _Rp operator()(_ArgTypes...) const;
    const std::type_info& target_type() const noexcept;
    template <typename _Tp> _Tp* target() noexcept;
    template <typename _Tp> const _Tp* target() const noexcept;
};
 ;
 ;
 ;
 ;
;
template<class _Tp> struct __is_bind_expression : public false_type {};
template<class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_bind_expression
    : public __is_bind_expression<typename remove_cv<_Tp>::type> {};
template<class _Tp> struct __is_placeholder : public integral_constant<int, 0> {};
template<class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_placeholder
    : public __is_placeholder<typename remove_cv<_Tp>::type> {};
namespace placeholders
{
template <int _Np> struct __ph {};
 constexpr __ph<1> _1{};
 constexpr __ph<2> _2{};
 constexpr __ph<3> _3{};
 constexpr __ph<4> _4{};
 constexpr __ph<5> _5{};
 constexpr __ph<6> _6{};
 constexpr __ph<7> _7{};
 constexpr __ph<8> _8{};
 constexpr __ph<9> _9{};
 constexpr __ph<10> _10{};
}
template<int _Np>
struct __is_placeholder<placeholders::__ph<_Np> >
    : public integral_constant<int, _Np> {};
;
;
;
template <bool IsPh, class _Ti, class _Uj>
struct __mu_return2 {};
template <class _Ti, class _Uj>
struct __mu_return2<true, _Ti, _Uj>
{
    typedef typename tuple_element<is_placeholder<_Ti>::value - 1, _Uj>::type type;
};
;
;
template <class _Ti, bool IsReferenceWrapper, bool IsBindEx, bool IsPh,
          class _TupleUj>
struct __mu_return_impl;
template <bool _Invokable, class _Ti, class ..._Uj>
struct __mu_return_invokable
{
    typedef __nat type;
};
template <class _Ti, class ..._Uj>
struct __mu_return_invokable<true, _Ti, _Uj...>
{
    typedef typename __invoke_of<_Ti&, _Uj...>::type type;
};
template <class _Ti, class ..._Uj>
struct __mu_return_impl<_Ti, false, true, false, tuple<_Uj...> >
    : public __mu_return_invokable<__invokable<_Ti&, _Uj...>::value, _Ti, _Uj...>
{
};
template <class _Ti, class _TupleUj>
struct __mu_return_impl<_Ti, false, false, true, _TupleUj>
{
    typedef typename tuple_element<is_placeholder<_Ti>::value - 1,
                                   _TupleUj>::type&& type;
};
template <class _Ti, class _TupleUj>
struct __mu_return_impl<_Ti, true, false, false, _TupleUj>
{
    typedef typename _Ti::type& type;
};
template <class _Ti, class _TupleUj>
struct __mu_return_impl<_Ti, false, false, false, _TupleUj>
{
    typedef _Ti& type;
};
template <class _Ti, class _TupleUj>
struct __mu_return
    : public __mu_return_impl<_Ti,
                              __is_reference_wrapper<_Ti>::value,
                              is_bind_expression<_Ti>::value,
                              0 < is_placeholder<_Ti>::value &&
                              is_placeholder<_Ti>::value <= tuple_size<_TupleUj>::value,
                              _TupleUj>
{
};
template <class _Fp, class _BoundArgs, class _TupleUj>
struct __is_valid_bind_return
{
    static const bool value = false;
};
template <class _Fp, class ..._BoundArgs, class _TupleUj>
struct __is_valid_bind_return<_Fp, tuple<_BoundArgs...>, _TupleUj>
{
    static const bool value = __invokable<_Fp,
                    typename __mu_return<_BoundArgs, _TupleUj>::type...>::value;
};
template <class _Fp, class ..._BoundArgs, class _TupleUj>
struct __is_valid_bind_return<_Fp, const tuple<_BoundArgs...>, _TupleUj>
{
    static const bool value = __invokable<_Fp,
                    typename __mu_return<const _BoundArgs, _TupleUj>::type...>::value;
};
template <class _Fp, class _BoundArgs, class _TupleUj,
          bool = __is_valid_bind_return<_Fp, _BoundArgs, _TupleUj>::value>
struct __bind_return;
template <class _Fp, class ..._BoundArgs, class _TupleUj>
struct __bind_return<_Fp, tuple<_BoundArgs...>, _TupleUj, true>
{
    typedef typename __invoke_of
    <
        _Fp&,
        typename __mu_return
        <
            _BoundArgs,
            _TupleUj
        >::type...
    >::type type;
};
template <class _Fp, class ..._BoundArgs, class _TupleUj>
struct __bind_return<_Fp, const tuple<_BoundArgs...>, _TupleUj, true>
{
    typedef typename __invoke_of
    <
        _Fp&,
        typename __mu_return
        <
            const _BoundArgs,
            _TupleUj
        >::type...
    >::type type;
};
;
template<class _Fp, class ..._BoundArgs>
class __bind
    : public __weak_result_type<typename decay<_Fp>::type>
{
protected:
    typedef typename decay<_Fp>::type _Fd;
    typedef tuple<typename decay<_BoundArgs>::type...> _Td;
private:
    _Fd __f_;
    _Td __bound_args_;
    typedef typename __make_tuple_indices<sizeof...(_BoundArgs)>::type __indices;
public:
      ;
        ;
        ;
};
template<class _Fp, class ..._BoundArgs>
struct __is_bind_expression<__bind<_Fp, _BoundArgs...> > : public true_type {};
template<class _Rp, class _Fp, class ..._BoundArgs>
class __bind_r
    : public __bind<_Fp, _BoundArgs...>
{
    typedef __bind<_Fp, _BoundArgs...> base;
    typedef typename base::_Fd _Fd;
    typedef typename base::_Td _Td;
public:
    typedef _Rp result_type;
      ;
        ;
        ;
};
template<class _Rp, class _Fp, class ..._BoundArgs>
struct __is_bind_expression<__bind_r<_Rp, _Fp, _BoundArgs...> > : public true_type {};
;
;
;
;
;
} }
namespace std { inline namespace __1 {
} }
namespace std { inline namespace __1 {
template <class _T1, class _T2 = _T1>
struct __equal_to
{
};
template <class _T1>
struct __equal_to<_T1, _T1>
{
};
template <class _T1>
struct __equal_to<const _T1, _T1>
{
};
template <class _T1>
struct __equal_to<_T1, const _T1>
{
};
template <class _T1, class _T2 = _T1>
struct __less
{
};
template <class _T1>
struct __less<_T1, _T1>
{
};
template <class _T1>
struct __less<const _T1, _T1>
{
};
template <class _T1>
struct __less<_T1, const _T1>
{
};
template <class _Predicate>
class __invert
{
private:
    _Predicate __p_;
public:
     ;
     ;
};
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
template <class _Tp>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    is_trivially_copy_assignable<_Tp>::value,
    _Tp*
>::type
__unwrap_iter(__wrap_iter<_Tp*> __i)
;
;
;
template <class _InputIterator, class _OutputIterator>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_OutputIterator
copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
;
;
;
template <class _BidirectionalIterator1, class _BidirectionalIterator2>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_BidirectionalIterator2
copy_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last,
              _BidirectionalIterator2 __result)
;
;
;
;
;
;
template <class _InputIterator, class _OutputIterator>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_OutputIterator
move(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
;
;
;
template <class _BidirectionalIterator1, class _BidirectionalIterator2>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_BidirectionalIterator2
move_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last,
              _BidirectionalIterator2 __result)
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
template <unsigned long long _Xp, size_t _Rp>
struct __log2_imp
{
    static const size_t value = _Xp & ((unsigned long long)(1) << _Rp) ? _Rp
                                           : __log2_imp<_Xp, _Rp - 1>::value;
};
template <unsigned long long _Xp>
struct __log2_imp<_Xp, 0>
{
    static const size_t value = 0;
};
template <size_t _Rp>
struct __log2_imp<0, _Rp>
{
    static const size_t value = _Rp + 1;
};
template <class _UIntType, _UIntType _Xp>
struct __log2
{
    static const size_t value = __log2_imp<_Xp,
                                         sizeof(_UIntType) * 8 - 1>::value;
};
template<class _Engine, class _UIntType>
class __independent_bits_engine
{
public:
    typedef _UIntType result_type;
private:
    typedef typename _Engine::result_type _Engine_result_type;
    typedef typename conditional
        <
            sizeof(_Engine_result_type) <= sizeof(result_type),
                result_type,
                _Engine_result_type
        >::type _Working_result_type;
    _Engine& __e_;
    size_t __w_;
    size_t __w0_;
    size_t __n_;
    size_t __n0_;
    _Working_result_type __y0_;
    _Working_result_type __y1_;
    _Engine_result_type __mask0_;
    _Engine_result_type __mask1_;
    static constexpr const _Working_result_type _Rp = _Engine::max() - _Engine::min()
                                                      + _Working_result_type(1);
    static constexpr const size_t __m = __log2<_Working_result_type, _Rp>::value;
    static constexpr const size_t _WDt = numeric_limits<_Working_result_type>::digits;
    static constexpr const size_t _EDt = numeric_limits<_Engine_result_type>::digits;
public:
private:
};
template<class _IntType = int>
class uniform_int_distribution
{
public:
    typedef _IntType result_type;
    class param_type
    {
        result_type __a_;
        result_type __b_;
    public:
        typedef uniform_int_distribution distribution_type;
    };
private:
    param_type __p_;
public:
        ;
    ;
};
class __attribute__ ((__visibility__("default"))) __rs_default;
class __attribute__ ((__visibility__("default"))) __rs_default
{
    static unsigned __c_;
public:
    typedef uint_fast32_t result_type;
    static const result_type _Min = 0;
    static const result_type _Max = 0xFFFFFFFF;
};
;
;
 ;
 ;
 ;
;
;
;
;
;
;
;
;
struct __return_temporary_buffer
{
     ;
};
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
template <class _Tp>
struct __stable_sort_switch
{
    static const unsigned value = 128*is_trivially_copy_assignable<_Tp>::value;
};
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
} }
namespace std { inline namespace __1 {
using ::FILE;
using ::fpos_t;
using ::size_t;
} }
namespace std { inline namespace __1 {
template <class _CharT>
struct __attribute__ ((__type_visibility__("default"))) char_traits
{
    typedef _CharT char_type;
    typedef int int_type;
    typedef streamoff off_type;
    typedef streampos pos_type;
    typedef mbstate_t state_type;
};
template <>
struct __attribute__ ((__type_visibility__("default"))) char_traits<char>
{
    typedef char char_type;
    typedef int int_type;
    typedef streamoff off_type;
    typedef streampos pos_type;
    typedef mbstate_t state_type;
};
template <>
struct __attribute__ ((__type_visibility__("default"))) char_traits<wchar_t>
{
    typedef wchar_t char_type;
    typedef wint_t int_type;
    typedef streamoff off_type;
    typedef streampos pos_type;
    typedef mbstate_t state_type;
};
template <>
struct __attribute__ ((__type_visibility__("default"))) char_traits<char16_t>
{
    typedef char16_t char_type;
    typedef uint_least16_t int_type;
    typedef streamoff off_type;
    typedef u16streampos pos_type;
    typedef mbstate_t state_type;
};
template <>
struct __attribute__ ((__type_visibility__("default"))) char_traits<char32_t>
{
    typedef char32_t char_type;
    typedef uint_least32_t int_type;
    typedef streamoff off_type;
    typedef u32streampos pos_type;
    typedef mbstate_t state_type;
};
;
 ;
;
;
;
;
    ;
;
;
;
;
;
template <class _CharT, class _Iter, class _Traits=char_traits<_CharT> >
struct __quoted_output_proxy
{
    _Iter __first;
    _Iter __last;
    _CharT __delim;
    _CharT __escape;
};
} }
namespace std { inline namespace __1 {
template<class _CharT, class _Traits = char_traits<_CharT> >
class __attribute__ ((__type_visibility__("default"))) basic_string_view {
public:
    typedef _Traits traits_type;
    typedef _CharT value_type;
    typedef _CharT* pointer;
    typedef const _CharT* const_pointer;
    typedef _CharT& reference;
    typedef const _CharT& const_reference;
    typedef const_pointer const_iterator;
    typedef const_iterator iterator;
    typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;
    typedef const_reverse_iterator reverse_iterator;
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    static constexpr const size_type npos = -1;
    static_assert((!is_array<value_type>::value), "Character type of basic_string_view must not be an array");
    static_assert(( is_standard_layout<value_type>::value), "Character type of basic_string_view must be standard-layout");
    static_assert(( is_trivial<value_type>::value), "Character type of basic_string_view must be trivial");
    static_assert((is_same<_CharT, typename traits_type::char_type>::value),
                  "traits_type::char_type must be the same type as CharT");
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_string_view(const basic_string_view&) noexcept = default;
private:
    const value_type* __data;
    size_type __size;
};
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
typedef basic_string_view<char> string_view;
typedef basic_string_view<char16_t> u16string_view;
typedef basic_string_view<char32_t> u32string_view;
typedef basic_string_view<wchar_t> wstring_view;
template<class _CharT, class _Traits>
struct __attribute__ ((__type_visibility__("default"))) hash<basic_string_view<_CharT, _Traits> >
    : public unary_function<basic_string_view<_CharT, _Traits>, size_t>
{
};
} }
namespace std { inline namespace __1 {
} }
typedef __darwin_wctrans_t wctrans_t;
extern "C" {
;
;
;
}
namespace std { inline namespace __1 {
using ::wint_t;
using ::wctrans_t;
using ::wctype_t;
} }
namespace std { inline namespace __1 {
using ::mbstate_t;
using ::size_t;
using ::tm;
using ::wint_t;
using ::FILE;
} }
namespace std { inline namespace __1 {
template <class _StateT>
class __attribute__ ((__type_visibility__("default"))) fpos
{
private:
    _StateT __st_;
    streamoff __off_;
public:
};
    ;
    ;
template <class _StateT>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool operator!=(const fpos<_StateT>& __x, const fpos<_StateT>& __y)
    ;
template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __x,
          const basic_string<_CharT, _Traits, _Allocator>& __y);
template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const _CharT* __x, const basic_string<_CharT,_Traits,_Allocator>& __y);
template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(_CharT __x, const basic_string<_CharT,_Traits,_Allocator>& __y);
template<class _CharT, class _Traits, class _Allocator>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __x, const _CharT* __y);
template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __x, _CharT __y);
extern template __attribute__ ((__visibility__("default"))) string operator+<char, char_traits<char>, allocator<char> >(char const*, string const&);
template <bool>
class __attribute__ ((__type_visibility__("default"))) __basic_string_common
{
protected:
    [[noreturn]] void __throw_length_error() const;
    [[noreturn]] void __throw_out_of_range() const;
};
extern template class __attribute__ ((__visibility__("default"))) __basic_string_common<true>;
template <class _Iter, bool = __is_forward_iterator<_Iter>::value>
struct __libcpp_string_gets_noexcept_iterator_impl : public integral_constant<bool,(( noexcept(++(declval<_Iter&>())) && is_nothrow_assignable<_Iter&, _Iter>::value && noexcept(declval<_Iter>() == declval<_Iter>()) && noexcept(*declval<_Iter>())))> {};
template <class _Iter>
struct __libcpp_string_gets_noexcept_iterator_impl<_Iter, false> : public false_type {};
template <class _Iter>
struct __libcpp_string_gets_noexcept_iterator
    : public integral_constant<bool,(__libcpp_is_trivial_iterator<_Iter>::value || __libcpp_string_gets_noexcept_iterator_impl<_Iter>::value)> {};
template <class _CharT, class _Traits, class _Tp>
struct __can_be_converted_to_string_view : public integral_constant<bool,(( is_convertible<const _Tp&, basic_string_view<_CharT, _Traits> >::value && !is_convertible<const _Tp&, const _CharT*>::value))> {};
template<class _CharT, class _Traits, class _Allocator>
class __attribute__ ((__type_visibility__("default"))) basic_string
    : private __basic_string_common<true>
{
public:
    typedef basic_string __self;
    typedef basic_string_view<_CharT, _Traits> __self_view;
    typedef _Traits traits_type;
    typedef _CharT value_type;
    typedef _Allocator allocator_type;
    typedef allocator_traits<allocator_type> __alloc_traits;
    typedef typename __alloc_traits::size_type size_type;
    typedef typename __alloc_traits::difference_type difference_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::const_pointer const_pointer;
    static_assert((!is_array<value_type>::value), "Character type of basic_string must not be an array");
    static_assert(( is_standard_layout<value_type>::value), "Character type of basic_string must be standard-layout");
    static_assert(( is_trivial<value_type>::value), "Character type of basic_string must be trivial");
    static_assert(( is_same<_CharT, typename traits_type::char_type>::value),
                  "traits_type::char_type must be the same type as CharT");
    static_assert(( is_same<typename allocator_type::value_type, value_type>::value),
                  "Allocator::value_type must be same type as value_type");
    typedef __wrap_iter<pointer> iterator;
    typedef __wrap_iter<const_pointer> const_iterator;
    typedef std::__1::reverse_iterator<iterator> reverse_iterator;
    typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;
private:
    struct __long
    {
        size_type __cap_;
        size_type __size_;
        pointer __data_;
    };
    static const size_type __short_mask = 0x01;
    static const size_type __long_mask = 0x1ul;
    enum {__min_cap = (sizeof(__long) - 1)/sizeof(value_type) > 2 ?
                      (sizeof(__long) - 1)/sizeof(value_type) : 2};
    struct __short
    {
        union
        {
            unsigned char __size_;
            value_type __lx;
        };
        value_type __data_[__min_cap];
    };
    union __ulx{__long __lx; __short __lxx;};
    enum {__n_words = sizeof(__ulx) / sizeof(size_type)};
    struct __raw
    {
        size_type __words[__n_words];
    };
    struct __rep
    {
        union
        {
            __long __l;
            __short __s;
            __raw __r;
        };
    };
    __compressed_pair<__rep, allocator_type> __r_;
public:
    static const size_type npos = -1;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) basic_string()
        noexcept(is_nothrow_default_constructible<allocator_type>::value);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit basic_string(const allocator_type& __a)
        noexcept(is_nothrow_copy_constructible<allocator_type>::value);
    basic_string(const basic_string& __str);
    basic_string(const basic_string& __str, const allocator_type& __a);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_string(basic_string&& __str)
        noexcept(is_nothrow_move_constructible<allocator_type>::value);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_string(basic_string&& __str, const allocator_type& __a);
    template <class = typename enable_if<__is_allocator<_Allocator>::value, nullptr_t>::type>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_string(const _CharT* __s) ;
    template <class = typename enable_if<__is_allocator<_Allocator>::value, nullptr_t>::type>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        basic_string(const _CharT* __s, const _Allocator& __a);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_string(const _CharT* __s, size_type __n);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_string(const _CharT* __s, size_type __n, const _Allocator& __a);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_string(size_type __n, _CharT __c);
    template <class = typename enable_if<__is_allocator<_Allocator>::value, nullptr_t>::type>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        basic_string(size_type __n, _CharT __c, const _Allocator& __a);
    basic_string(const basic_string& __str, size_type __pos, size_type __n,
                 const _Allocator& __a = _Allocator());
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_string(const basic_string& __str, size_type __pos,
                 const _Allocator& __a = _Allocator());
    template<class _Tp, class = typename enable_if<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, void>::type>
        inline __attribute__ ((__visibility__("hidden")))
        basic_string(const _Tp& __t, size_type __pos, size_type __n,
                              const allocator_type& __a = allocator_type());
    template<class _Tp, class = typename enable_if<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, void>::type>
        inline __attribute__ ((__visibility__("hidden")))
        explicit basic_string(const _Tp& __t);
    template<class _Tp, class = typename enable_if<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, void>::type>
        inline __attribute__ ((__visibility__("hidden")))
        explicit basic_string(const _Tp& __t, const allocator_type& __a);
    template<class _InputIterator>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        basic_string(_InputIterator __first, _InputIterator __last);
    template<class _InputIterator>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        basic_string(_InputIterator __first, _InputIterator __last, const allocator_type& __a);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_string(initializer_list<_CharT> __il);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_string(initializer_list<_CharT> __il, const _Allocator& __a);
    inline ~basic_string();
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    operator __self_view() const noexcept ;
    basic_string& operator=(const basic_string& __str);
    template <class _Tp, class = typename enable_if<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, void>::type>
    basic_string& operator=(const _Tp& __t)
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_string& operator=(basic_string&& __str)
        noexcept((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value));
     __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_string& operator=(initializer_list<value_type> __il) ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) basic_string& operator=(const value_type* __s) ;
    basic_string& operator=(value_type __c);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator begin() noexcept
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator begin() const noexcept
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator end() noexcept
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator end() const noexcept
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    reverse_iterator rbegin() noexcept
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reverse_iterator rbegin() const noexcept
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    reverse_iterator rend() noexcept
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reverse_iterator rend() const noexcept
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator cbegin() const noexcept
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator cend() const noexcept
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reverse_iterator crbegin() const noexcept
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reverse_iterator crend() const noexcept
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) size_type size() const noexcept
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) size_type length() const noexcept ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) size_type max_size() const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) size_type capacity() const noexcept
        ;
    void resize(size_type __n, value_type __c);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void resize(size_type __n) ;
    void reserve(size_type __res_arg);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void __resize_default_init(size_type __n);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void reserve() noexcept ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void shrink_to_fit() noexcept ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void clear() noexcept;
                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool empty() const noexcept ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) const_reference operator[](size_type __pos) const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) reference operator[](size_type __pos) noexcept;
    const_reference at(size_type __n) const;
    reference at(size_type __n);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) basic_string& operator+=(const basic_string& __str) ;
    template <class _Tp>
     __attribute__ ((__visibility__("hidden")))
    typename enable_if
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
            basic_string&
        >::type
                                            operator+=(const _Tp& __t) ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) basic_string& operator+=(const value_type* __s) ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) basic_string& operator+=(value_type __c) ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) basic_string& operator+=(initializer_list<value_type> __il) ;
     ;
    ;
    ;
     ;
     ;
     ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
     ;
    ;
     ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
private:
            ;
    enum {__alignment = 16};
    ;
    ;
    friend basic_string operator+<>(const basic_string&, const basic_string&);
    friend basic_string operator+<>(const value_type*, const basic_string&);
    friend basic_string operator+<>(value_type, const basic_string&);
    friend basic_string operator+<>(const basic_string&, const value_type*);
    friend basic_string operator+<>(const basic_string&, value_type);
};
;
;
template <class _Traits>
struct __attribute__ ((__visibility__("hidden"))) __traits_eq
{
    typedef typename _Traits::char_type char_type;
};
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
          const basic_string<_CharT, _Traits, _Allocator>& __rhs)
;
template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const _CharT* __lhs , const basic_string<_CharT,_Traits,_Allocator>& __rhs)
;
template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Allocator>& __rhs)
;
template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, const _CharT* __rhs)
;
template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, _CharT __rhs)
;
;
;
;
;
;
;
;
;
typedef basic_string<char16_t> u16string;
typedef basic_string<char32_t> u32string;
template<class _CharT, class _Traits, class _Allocator>
    const typename basic_string<_CharT, _Traits, _Allocator>::size_type
                   basic_string<_CharT, _Traits, _Allocator>::npos;
template<class _CharT, class _Traits, class _Allocator>
struct __attribute__ ((__type_visibility__("default"))) hash<basic_string<_CharT, _Traits, _Allocator> >
    : public unary_function<basic_string<_CharT, _Traits, _Allocator>, size_t>
{
};
;
;
;
;
;
;
extern template class __attribute__ ((__visibility__("default"))) basic_string<char>;
extern template class __attribute__ ((__visibility__("default"))) basic_string<wchar_t>;
} }
extern "C" {
;
}
namespace octave
{
  template <typename T>
  class refcount
  {
  public:
    typedef T count_type;
  private:
    count_type count;
  };
}
template <typename T>
using octave_refcount __attribute__ ((__deprecated__)) = octave::refcount<T>;
template <typename T> class Array;
class
dim_vector
{
private:
  octave_idx_type *rep;
public:
  ;
private:
public:
};
extern "C" {
;
}
template <typename T> class octave_int;
typedef octave_int<int8_t> octave_int8;
typedef octave_int<int16_t> octave_int16;
typedef octave_int<int32_t> octave_int32;
typedef octave_int<int64_t> octave_int64;
typedef octave_int<uint8_t> octave_uint8;
typedef octave_int<uint16_t> octave_uint16;
typedef octave_int<uint32_t> octave_uint32;
typedef octave_int<uint64_t> octave_uint64;
template <typename T> class Array;
template <typename T> class Sparse;
class Range;
class
idx_vector
{
public:
  enum idx_class_type
  {
    class_invalid = -1,
    class_colon = 0,
    class_range,
    class_scalar,
    class_vector,
    class_mask
  };
  template <typename T, typename D> friend class std::unique_ptr;
private:
  class idx_base_rep
  {
  public:
    octave::refcount<int> count;
    bool err;
  };
  class idx_colon_rep : public idx_base_rep
  {
  public:
  };
  enum direct { DIRECT };
  class idx_range_rep : public idx_base_rep
  {
  public:
  private:
    octave_idx_type start, len, step;
  };
  class idx_scalar_rep : public idx_base_rep
  {
  public:
    ;
  private:
    octave_idx_type data;
  };
  class idx_vector_rep : public idx_base_rep
  {
  public:
    ;
  private:
    const octave_idx_type *data;
    octave_idx_type len;
    octave_idx_type ext;
    Array<octave_idx_type> *aowner;
    dim_vector orig_dims;
  };
  class idx_mask_rep : public idx_base_rep
  {
  public:
  private:
    const bool *data;
    octave_idx_type len;
    octave_idx_type ext;
    mutable octave_idx_type lsti;
    mutable octave_idx_type lste;
    Array<bool> *aowner;
    dim_vector orig_dims;
  };
public:
  static const idx_vector colon;
    ;
  ;
  ;
  ;
  ;
  ;
  ;
private:
  idx_base_rep *rep;
};
extern "C" {
;
;
;
;
typedef void (*liboctave_error_handler) (const char *, ...);
typedef void (*liboctave_error_with_id_handler) (const char *, const char *,
                                                 ...);
typedef void (*liboctave_warning_handler) (const char *, ...);
typedef void (*liboctave_warning_with_id_handler) (const char *, const char *,
                                                   ...);
__attribute__ ((__format__(printf, 1, 2)))
__attribute__ ((__noreturn__)) extern liboctave_error_handler
  current_liboctave_error_handler;
__attribute__ ((__format__(printf, 2, 3)))
__attribute__ ((__noreturn__)) extern liboctave_error_with_id_handler
  current_liboctave_error_with_id_handler;
__attribute__ ((__format__(printf, 1, 2)))
           extern liboctave_warning_handler current_liboctave_warning_handler;
__attribute__ ((__format__(printf, 2, 3)))
           extern liboctave_warning_with_id_handler
  current_liboctave_warning_with_id_handler;
           ;
           ;
           ;
           ;
}
template <bool cond, typename T1, typename T2>
class if_then_else;
template <typename T1, typename T2>
class if_then_else<true, T1, T2>
{
public:
  typedef T1 result;
};
template <typename T1, typename T2>
class if_then_else<false, T1, T2>
{
public:
  typedef T2 result;
};
template <typename T1, typename T2>
class equal_types
{
public:
  static const bool value = false;
};
template <typename T>
class equal_types <T, T>
{
public:
  static const bool value = true;
};
template <template <typename> class Template, typename T>
class is_instance
{
public:
  static const bool value = false;
};
template <template <typename> class Template, typename T>
class is_instance <Template, Template<T>>
{
public:
  static const bool value = true;
};
template <typename T1>
class is_class_type
{
private:
  typedef char one;
  typedef struct { char c[2]; } two;
  template <typename T2> static one is_class_type_test (int T2::*);
  template <typename T2> static two is_class_type_test (...);
public:
  enum { yes = sizeof (is_class_type_test<T1> (0)) == 1 };
  enum { no = ! yes };
};
template <typename T>
class ref_param
{
public:
  typedef typename if_then_else<is_class_type<T>::no, T, T const&>::result type;
};
template <template <typename> class TemplatedClass, typename T>
class strip_template_param
{
public:
  typedef T type;
};
template <template <typename> class TemplatedClass, typename T>
class strip_template_param<TemplatedClass, TemplatedClass<T>>
{
public:
  typedef T type;
};
template <template <typename> class TemplatedClass, typename T, typename S>
class subst_template_param
{
public:
  typedef S type;
};
template <template <typename> class TemplatedClass, typename T, typename S>
class subst_template_param<TemplatedClass, TemplatedClass<T>, S>
{
public:
  typedef TemplatedClass<S> type;
};
typedef unsigned char u_char;
typedef unsigned short u_short;
typedef unsigned int u_int;
typedef unsigned long u_long;
typedef unsigned short ushort;
typedef unsigned int uint;
typedef u_int64_t u_quad_t;
typedef int64_t quad_t;
typedef quad_t * qaddr_t;
typedef char * caddr_t;
typedef int32_t daddr_t;
typedef u_int32_t fixpt_t;
typedef __darwin_blkcnt_t blkcnt_t;
typedef __darwin_blksize_t blksize_t;
typedef __darwin_gid_t gid_t;
typedef __uint32_t in_addr_t;
typedef __uint16_t in_port_t;
typedef __darwin_ino_t ino_t;
typedef __darwin_ino64_t ino64_t;
typedef __int32_t key_t;
typedef __uint16_t nlink_t;
typedef int32_t segsz_t;
typedef int32_t swblk_t;
typedef __darwin_useconds_t useconds_t;
typedef __darwin_suseconds_t suseconds_t;
extern "C" {
typedef struct fd_set {
 __int32_t fds_bits[((((1024) % ((sizeof(__int32_t) * 8))) == 0) ? ((1024) / ((sizeof(__int32_t) * 8))) : (((1024) / ((sizeof(__int32_t) * 8))) + 1))];
} fd_set;
}
typedef __int32_t fd_mask;
typedef __darwin_pthread_cond_t pthread_cond_t;
typedef __darwin_pthread_condattr_t pthread_condattr_t;
typedef __darwin_pthread_mutex_t pthread_mutex_t;
typedef __darwin_pthread_mutexattr_t pthread_mutexattr_t;
typedef __darwin_pthread_once_t pthread_once_t;
typedef __darwin_pthread_rwlock_t pthread_rwlock_t;
typedef __darwin_pthread_rwlockattr_t pthread_rwlockattr_t;
typedef __darwin_pthread_t pthread_t;
typedef __darwin_pthread_key_t pthread_key_t;
typedef __darwin_fsblkcnt_t fsblkcnt_t;
typedef __darwin_fsfilcnt_t fsfilcnt_t;
extern "C" {
           ;
           ;
           ;
}
extern "C" {
    typedef float float_t;
    typedef double double_t;
;
;
;
;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
 ;
 ;
;
;
;
;
;
;
 ;
 ;
struct __float2 { float __sinval; float __cosval; };
struct __double2 { double __sinval; double __cosval; };
;
;
;
;
  ;
  ;
  ;
  ;
;
;
;
;
;
;
;
extern int signgam;
;
;
;
;
;
;
}
extern "C++" {
;
;
;
;
;
;
;
;
;
;
;
;
;
  ;
  ;
  ;
;
;
;
  ;
  ;
  ;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
  ;
  ;
  ;
  ;
  ;
 ;
  ;
  ;
 ;
  ;
  ;
 ;
  ;
  ;
;
  ;
  ;
 ;
  ;
  ;
 ;
  ;
  ;
 ;
  ;
  ;
 ;
  ;
  ;
 ;
  ;
  ;
 ;
  ;
  ;
;
  ;
  ;
 ;
  ;
  ;
 ;
  ;
  ;
 ;
  ;
  ;
 ;
  ;
  ;
  ;
  ;
;
  ;
  ;
 ;
  ;
  ;
 ;
  ;
  ;
 ;
  ;
  ;
 ;
  ;
  ;
 ;
  ;
  ;
 ;
  ;
  ;
 ;
  ;
  ;
 ;
  ;
  ;
 ;
  ;
  ;
;
  ;
  ;
 ;
  ;
  ;
 ;
  ;
  ;
 ;
  ;
  ;
 ;
  ;
  ;
;
  ;
  ;
;
  ;
  ;
;
  ;
  ;
;
  ;
  ;
;
  ;
  ;
 ;
  ;
  ;
 ;
  ;
  ;
 ;
  ;
  ;
 ;
  ;
  ;
 ;
  ;
  ;
 ;
  ;
  ;
 ;
  ;
  ;
 ;
  ;
  ;
 ;
  ;
  ;
 ;
  ;
  ;
;
  ;
  ;
 ;
  ;
  ;
;
  ;
  ;
;
  ;
  ;
 ;
  ;
  ;
 ;
  ;
  ;
 ;
  ;
  ;
 ;
  ;
  ;
 ;
  ;
  ;
 ;
}
namespace std { inline namespace __1 {
using ::float_t;
using ::double_t;
;
;
;
;
;
;
} }
namespace std { inline namespace __1 {
using ::clock_t;
using ::size_t;
using ::time_t;
using ::tm;
} }
namespace std { inline namespace __1 {
template <intmax_t _Xp, intmax_t _Yp>
struct __static_gcd
{
    static const intmax_t value = __static_gcd<_Yp, _Xp % _Yp>::value;
};
template <intmax_t _Xp>
struct __static_gcd<_Xp, 0>
{
    static const intmax_t value = _Xp;
};
template <>
struct __static_gcd<0, 0>
{
    static const intmax_t value = 1;
};
template <intmax_t _Xp, intmax_t _Yp>
struct __static_lcm
{
    static const intmax_t value = _Xp / __static_gcd<_Xp, _Yp>::value * _Yp;
};
template <intmax_t _Xp>
struct __static_abs
{
    static const intmax_t value = _Xp < 0 ? -_Xp : _Xp;
};
template <intmax_t _Xp>
struct __static_sign
{
    static const intmax_t value = _Xp == 0 ? 0 : (_Xp < 0 ? -1 : 1);
};
template <intmax_t _Xp, intmax_t _Yp, intmax_t = __static_sign<_Yp>::value>
class __ll_add;
template <intmax_t _Xp, intmax_t _Yp>
class __ll_add<_Xp, _Yp, 1>
{
    static const intmax_t min = (1LL << (sizeof(intmax_t) * 8 - 1)) + 1;
    static const intmax_t max = -min;
    static_assert(_Xp <= max - _Yp, "overflow in __ll_add");
public:
    static const intmax_t value = _Xp + _Yp;
};
template <intmax_t _Xp, intmax_t _Yp>
class __ll_add<_Xp, _Yp, 0>
{
public:
    static const intmax_t value = _Xp;
};
template <intmax_t _Xp, intmax_t _Yp>
class __ll_add<_Xp, _Yp, -1>
{
    static const intmax_t min = (1LL << (sizeof(intmax_t) * 8 - 1)) + 1;
    static const intmax_t max = -min;
    static_assert(min - _Yp <= _Xp, "overflow in __ll_add");
public:
    static const intmax_t value = _Xp + _Yp;
};
template <intmax_t _Xp, intmax_t _Yp, intmax_t = __static_sign<_Yp>::value>
class __ll_sub;
template <intmax_t _Xp, intmax_t _Yp>
class __ll_sub<_Xp, _Yp, 1>
{
    static const intmax_t min = (1LL << (sizeof(intmax_t) * 8 - 1)) + 1;
    static const intmax_t max = -min;
    static_assert(min + _Yp <= _Xp, "overflow in __ll_sub");
public:
    static const intmax_t value = _Xp - _Yp;
};
template <intmax_t _Xp, intmax_t _Yp>
class __ll_sub<_Xp, _Yp, 0>
{
public:
    static const intmax_t value = _Xp;
};
template <intmax_t _Xp, intmax_t _Yp>
class __ll_sub<_Xp, _Yp, -1>
{
    static const intmax_t min = (1LL << (sizeof(intmax_t) * 8 - 1)) + 1;
    static const intmax_t max = -min;
    static_assert(_Xp <= max + _Yp, "overflow in __ll_sub");
public:
    static const intmax_t value = _Xp - _Yp;
};
template <intmax_t _Xp, intmax_t _Yp>
class __ll_mul
{
    static const intmax_t nan = (1LL << (sizeof(intmax_t) * 8 - 1));
    static const intmax_t min = nan + 1;
    static const intmax_t max = -min;
    static const intmax_t __a_x = __static_abs<_Xp>::value;
    static const intmax_t __a_y = __static_abs<_Yp>::value;
    static_assert(_Xp != nan && _Yp != nan && __a_x <= max / __a_y, "overflow in __ll_mul");
public:
    static const intmax_t value = _Xp * _Yp;
};
template <intmax_t _Yp>
class __ll_mul<0, _Yp>
{
public:
    static const intmax_t value = 0;
};
template <intmax_t _Xp>
class __ll_mul<_Xp, 0>
{
public:
    static const intmax_t value = 0;
};
template <>
class __ll_mul<0, 0>
{
public:
    static const intmax_t value = 0;
};
template <intmax_t _Xp, intmax_t _Yp>
class __ll_div
{
    static const intmax_t nan = (1LL << (sizeof(intmax_t) * 8 - 1));
    static const intmax_t min = nan + 1;
    static const intmax_t max = -min;
    static_assert(_Xp != nan && _Yp != nan && _Yp != 0, "overflow in __ll_div");
public:
    static const intmax_t value = _Xp / _Yp;
};
template <intmax_t _Num, intmax_t _Den = 1>
class __attribute__ ((__type_visibility__("default"))) ratio
{
    static_assert(__static_abs<_Num>::value >= 0, "ratio numerator is out of range");
    static_assert(_Den != 0, "ratio divide by 0");
    static_assert(__static_abs<_Den>::value > 0, "ratio denominator is out of range");
    static constexpr const intmax_t __na = __static_abs<_Num>::value;
    static constexpr const intmax_t __da = __static_abs<_Den>::value;
    static constexpr const intmax_t __s = __static_sign<_Num>::value * __static_sign<_Den>::value;
    static constexpr const intmax_t __gcd = __static_gcd<__na, __da>::value;
public:
    static constexpr const intmax_t num = __s * __na / __gcd;
    static constexpr const intmax_t den = __da / __gcd;
    typedef ratio<num, den> type;
};
template <intmax_t _Num, intmax_t _Den>
constexpr const intmax_t ratio<_Num, _Den>::num;
template <intmax_t _Num, intmax_t _Den>
constexpr const intmax_t ratio<_Num, _Den>::den;
template <class _Tp> struct __is_ratio : false_type {};
template <intmax_t _Num, intmax_t _Den> struct __is_ratio<ratio<_Num, _Den> > : true_type {};
typedef ratio<1LL, 1000000000000000000LL> atto;
typedef ratio<1LL, 1000000000000000LL> femto;
typedef ratio<1LL, 1000000000000LL> pico;
typedef ratio<1LL, 1000000000LL> nano;
typedef ratio<1LL, 1000000LL> micro;
typedef ratio<1LL, 1000LL> milli;
typedef ratio<1LL, 100LL> centi;
typedef ratio<1LL, 10LL> deci;
typedef ratio< 10LL, 1LL> deca;
typedef ratio< 100LL, 1LL> hecto;
typedef ratio< 1000LL, 1LL> kilo;
typedef ratio< 1000000LL, 1LL> mega;
typedef ratio< 1000000000LL, 1LL> giga;
typedef ratio< 1000000000000LL, 1LL> tera;
typedef ratio< 1000000000000000LL, 1LL> peta;
typedef ratio<1000000000000000000LL, 1LL> exa;
template <class _R1, class _R2>
struct __ratio_multiply
{
private:
    static const intmax_t __gcd_n1_d2 = __static_gcd<_R1::num, _R2::den>::value;
    static const intmax_t __gcd_d1_n2 = __static_gcd<_R1::den, _R2::num>::value;
public:
    typedef typename ratio
        <
            __ll_mul<_R1::num / __gcd_n1_d2, _R2::num / __gcd_d1_n2>::value,
            __ll_mul<_R2::den / __gcd_n1_d2, _R1::den / __gcd_d1_n2>::value
        >::type type;
};
template <class _R1, class _R2> using ratio_multiply
                                    = typename __ratio_multiply<_R1, _R2>::type;
template <class _R1, class _R2>
struct __ratio_divide
{
private:
    static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
    static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;
public:
    typedef typename ratio
        <
            __ll_mul<_R1::num / __gcd_n1_n2, _R2::den / __gcd_d1_d2>::value,
            __ll_mul<_R2::num / __gcd_n1_n2, _R1::den / __gcd_d1_d2>::value
        >::type type;
};
template <class _R1, class _R2> using ratio_divide
                                      = typename __ratio_divide<_R1, _R2>::type;
template <class _R1, class _R2>
struct __ratio_add
{
private:
    static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
    static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;
public:
    typedef typename ratio_multiply
        <
            ratio<__gcd_n1_n2, _R1::den / __gcd_d1_d2>,
            ratio
            <
                __ll_add
                <
                    __ll_mul<_R1::num / __gcd_n1_n2, _R2::den / __gcd_d1_d2>::value,
                    __ll_mul<_R2::num / __gcd_n1_n2, _R1::den / __gcd_d1_d2>::value
                >::value,
                _R2::den
            >
        >::type type;
};
template <class _R1, class _R2> using ratio_add
                                         = typename __ratio_add<_R1, _R2>::type;
template <class _R1, class _R2>
struct __ratio_subtract
{
private:
    static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
    static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;
public:
    typedef typename ratio_multiply
        <
            ratio<__gcd_n1_n2, _R1::den / __gcd_d1_d2>,
            ratio
            <
                __ll_sub
                <
                    __ll_mul<_R1::num / __gcd_n1_n2, _R2::den / __gcd_d1_d2>::value,
                    __ll_mul<_R2::num / __gcd_n1_n2, _R1::den / __gcd_d1_d2>::value
                >::value,
                _R2::den
            >
        >::type type;
};
template <class _R1, class _R2> using ratio_subtract
                                    = typename __ratio_subtract<_R1, _R2>::type;
template <class _R1, class _R2>
struct __attribute__ ((__type_visibility__("default"))) ratio_equal
    : public integral_constant<bool,((_R1::num == _R2::num && _R1::den == _R2::den))> {};
template <class _R1, class _R2>
struct __attribute__ ((__type_visibility__("default"))) ratio_not_equal
    : public integral_constant<bool,((!ratio_equal<_R1, _R2>::value))> {};
template <class _R1, class _R2, bool _Odd = false,
          intmax_t _Q1 = _R1::num / _R1::den, intmax_t _M1 = _R1::num % _R1::den,
          intmax_t _Q2 = _R2::num / _R2::den, intmax_t _M2 = _R2::num % _R2::den>
struct __ratio_less1
{
    static const bool value = _Odd ? _Q2 < _Q1 : _Q1 < _Q2;
};
template <class _R1, class _R2, bool _Odd, intmax_t _Qp>
struct __ratio_less1<_R1, _R2, _Odd, _Qp, 0, _Qp, 0>
{
    static const bool value = false;
};
template <class _R1, class _R2, bool _Odd, intmax_t _Qp, intmax_t _M2>
struct __ratio_less1<_R1, _R2, _Odd, _Qp, 0, _Qp, _M2>
{
    static const bool value = !_Odd;
};
template <class _R1, class _R2, bool _Odd, intmax_t _Qp, intmax_t _M1>
struct __ratio_less1<_R1, _R2, _Odd, _Qp, _M1, _Qp, 0>
{
    static const bool value = _Odd;
};
template <class _R1, class _R2, bool _Odd, intmax_t _Qp, intmax_t _M1,
                                                        intmax_t _M2>
struct __ratio_less1<_R1, _R2, _Odd, _Qp, _M1, _Qp, _M2>
{
    static const bool value = __ratio_less1<ratio<_R1::den, _M1>,
                                            ratio<_R2::den, _M2>, !_Odd>::value;
};
template <class _R1, class _R2, intmax_t _S1 = __static_sign<_R1::num>::value,
                                intmax_t _S2 = __static_sign<_R2::num>::value>
struct __ratio_less
{
    static const bool value = _S1 < _S2;
};
template <class _R1, class _R2>
struct __ratio_less<_R1, _R2, 1LL, 1LL>
{
    static const bool value = __ratio_less1<_R1, _R2>::value;
};
template <class _R1, class _R2>
struct __ratio_less<_R1, _R2, -1LL, -1LL>
{
    static const bool value = __ratio_less1<ratio<-_R2::num, _R2::den>, ratio<-_R1::num, _R1::den> >::value;
};
template <class _R1, class _R2>
struct __attribute__ ((__type_visibility__("default"))) ratio_less
    : public integral_constant<bool,((__ratio_less<_R1, _R2>::value))> {};
template <class _R1, class _R2>
struct __attribute__ ((__type_visibility__("default"))) ratio_less_equal
    : public integral_constant<bool,((!ratio_less<_R2, _R1>::value))> {};
template <class _R1, class _R2>
struct __attribute__ ((__type_visibility__("default"))) ratio_greater
    : public integral_constant<bool,((ratio_less<_R2, _R1>::value))> {};
template <class _R1, class _R2>
struct __attribute__ ((__type_visibility__("default"))) ratio_greater_equal
    : public integral_constant<bool,((!ratio_less<_R1, _R2>::value))> {};
template <class _R1, class _R2>
struct __ratio_gcd
{
    typedef ratio<__static_gcd<_R1::num, _R2::num>::value,
                  __static_lcm<_R1::den, _R2::den>::value> type;
};
} }
namespace std { inline namespace __1 { namespace __fs { namespace filesystem {
struct _FilesystemClock;
} } } }
namespace std { inline namespace __1 {
namespace chrono
{
template <class _Rep, class _Period = ratio<1> > class __attribute__ ((__type_visibility__("default"))) duration;
template <class _Tp>
struct __is_duration : false_type {};
template <class _Rep, class _Period>
struct __is_duration<duration<_Rep, _Period> > : true_type {};
template <class _Rep, class _Period>
struct __is_duration<const duration<_Rep, _Period> > : true_type {};
template <class _Rep, class _Period>
struct __is_duration<volatile duration<_Rep, _Period> > : true_type {};
template <class _Rep, class _Period>
struct __is_duration<const volatile duration<_Rep, _Period> > : true_type {};
}
template <class _Rep1, class _Period1, class _Rep2, class _Period2>
struct __attribute__ ((__type_visibility__("default"))) common_type<chrono::duration<_Rep1, _Period1>,
                                         chrono::duration<_Rep2, _Period2> >
{
    typedef chrono::duration<typename common_type<_Rep1, _Rep2>::type,
                             typename __ratio_gcd<_Period1, _Period2>::type> type;
};
namespace chrono {
template <class _FromDuration, class _ToDuration,
          class _Period = typename ratio_divide<typename _FromDuration::period, typename _ToDuration::period>::type,
          bool = _Period::num == 1,
          bool = _Period::den == 1>
struct __duration_cast;
template <class _FromDuration, class _ToDuration, class _Period>
struct __duration_cast<_FromDuration, _ToDuration, _Period, true, true>
{
};
template <class _FromDuration, class _ToDuration, class _Period>
struct __duration_cast<_FromDuration, _ToDuration, _Period, true, false>
{
};
template <class _FromDuration, class _ToDuration, class _Period>
struct __duration_cast<_FromDuration, _ToDuration, _Period, false, true>
{
};
template <class _FromDuration, class _ToDuration, class _Period>
struct __duration_cast<_FromDuration, _ToDuration, _Period, false, false>
{
};
;
template <class _Rep>
struct __attribute__ ((__type_visibility__("default"))) treat_as_floating_point : is_floating_point<_Rep> {};
template <class _Rep>
struct __attribute__ ((__type_visibility__("default"))) duration_values
{
public:
};
template <class _Rep, class _Period>
class __attribute__ ((__type_visibility__("default"))) duration
{
    static_assert(!__is_duration<_Rep>::value, "A duration representation can not be a duration");
    static_assert(__is_ratio<_Period>::value, "Second template parameter of duration must be a std::ratio");
    static_assert(_Period::num > 0, "duration period must be positive");
    template <class _R1, class _R2>
    struct __no_overflow
    {
    private:
        static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
        static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;
        static const intmax_t __n1 = _R1::num / __gcd_n1_n2;
        static const intmax_t __d1 = _R1::den / __gcd_d1_d2;
        static const intmax_t __n2 = _R2::num / __gcd_n1_n2;
        static const intmax_t __d2 = _R2::den / __gcd_d1_d2;
        static const intmax_t max = -((intmax_t(1) << (sizeof(intmax_t) * 8 - 1)) + 1);
        template <intmax_t _Xp, intmax_t _Yp, bool __overflow>
        struct __mul
        {
            static const intmax_t value = _Xp * _Yp;
        };
        template <intmax_t _Xp, intmax_t _Yp>
        struct __mul<_Xp, _Yp, true>
        {
            static const intmax_t value = 1;
        };
    public:
        static const bool value = (__n1 <= max / __d2) && (__n2 <= max / __d1);
        typedef ratio<__mul<__n1, __d2, !value>::value,
                      __mul<__n2, __d1, !value>::value> type;
    };
public:
    typedef _Rep rep;
    typedef typename _Period::type period;
private:
    rep __rep_;
public:
      ;
      ;
};
typedef duration<long long, nano> nanoseconds;
typedef duration<long long, micro> microseconds;
typedef duration<long long, milli> milliseconds;
typedef duration<long long > seconds;
typedef duration< long, ratio< 60> > minutes;
typedef duration< long, ratio<3600> > hours;
template <class _LhsDuration, class _RhsDuration>
struct __duration_eq
{
};
template <class _LhsDuration>
struct __duration_eq<_LhsDuration, _LhsDuration>
{
};
;
;
template <class _LhsDuration, class _RhsDuration>
struct __duration_lt
{
};
template <class _LhsDuration>
struct __duration_lt<_LhsDuration, _LhsDuration>
{
};
;
;
;
;
;
;
;
;
template <class _Duration, class _Rep, bool = __is_duration<_Rep>::value>
struct __duration_divide_result
{
};
template <class _Duration, class _Rep2,
    bool = is_convertible<_Rep2,
                          typename common_type<typename _Duration::rep, _Rep2>::type>::value>
struct __duration_divide_imp
{
};
template <class _Rep1, class _Period, class _Rep2>
struct __duration_divide_imp<duration<_Rep1, _Period>, _Rep2, true>
{
    typedef duration<typename common_type<_Rep1, _Rep2>::type, _Period> type;
};
template <class _Rep1, class _Period, class _Rep2>
struct __duration_divide_result<duration<_Rep1, _Period>, _Rep2, false>
    : __duration_divide_imp<duration<_Rep1, _Period>, _Rep2>
{
};
;
;
;
;
template <class _Clock, class _Duration = typename _Clock::duration>
class __attribute__ ((__type_visibility__("default"))) time_point
{
    static_assert(__is_duration<_Duration>::value,
                  "Second template parameter of time_point must be a std::chrono::duration");
public:
    typedef _Clock clock;
    typedef _Duration duration;
    typedef typename duration::rep rep;
    typedef typename duration::period period;
private:
    duration __d_;
public:
      ;
};
}
template <class _Clock, class _Duration1, class _Duration2>
struct __attribute__ ((__type_visibility__("default"))) common_type<chrono::time_point<_Clock, _Duration1>,
                                         chrono::time_point<_Clock, _Duration2> >
{
    typedef chrono::time_point<_Clock, typename common_type<_Duration1, _Duration2>::type> type;
};
namespace chrono {
;
;
;
;
;
;
;
;
;
;
;
class __attribute__ ((__visibility__("default"))) system_clock
{
public:
    typedef microseconds duration;
    typedef duration::rep rep;
    typedef duration::period period;
    typedef chrono::time_point<system_clock> time_point;
    static const bool is_steady = false;
};
class __attribute__ ((__visibility__("default"))) steady_clock
{
public:
    typedef nanoseconds duration;
    typedef duration::rep rep;
    typedef duration::period period;
    typedef chrono::time_point<steady_clock, duration> time_point;
    static const bool is_steady = true;
};
typedef steady_clock high_resolution_clock;
}
} }
namespace std { inline namespace __1 { namespace __fs { namespace filesystem {
struct _FilesystemClock {
  typedef __int128_t rep;
  typedef nano period;
  typedef chrono::duration<rep, period> duration;
  typedef chrono::time_point<_FilesystemClock> time_point;
  static const bool is_steady = false;
};
} } } }
extern "C" {
;
}
namespace std { inline namespace __1 {
enum class __attribute__ ((__type_visibility__("default"))) errc
{
    address_family_not_supported = 47,
    address_in_use = 48,
    address_not_available = 49,
    already_connected = 56,
    argument_list_too_long = 7,
    argument_out_of_domain = 33,
    bad_address = 14,
    bad_file_descriptor = 9,
    bad_message = 94,
    broken_pipe = 32,
    connection_aborted = 53,
    connection_already_in_progress = 37,
    connection_refused = 61,
    connection_reset = 54,
    cross_device_link = 18,
    destination_address_required = 39,
    device_or_resource_busy = 16,
    directory_not_empty = 66,
    executable_format_error = 8,
    file_exists = 17,
    file_too_large = 27,
    filename_too_long = 63,
    function_not_supported = 78,
    host_unreachable = 65,
    identifier_removed = 90,
    illegal_byte_sequence = 92,
    inappropriate_io_control_operation = 25,
    interrupted = 4,
    invalid_argument = 22,
    invalid_seek = 29,
    io_error = 5,
    is_a_directory = 21,
    message_size = 40,
    network_down = 50,
    network_reset = 52,
    network_unreachable = 51,
    no_buffer_space = 55,
    no_child_process = 10,
    no_link = 97,
    no_lock_available = 77,
    no_message_available = 96,
    no_message = 91,
    no_protocol_option = 42,
    no_space_on_device = 28,
    no_stream_resources = 98,
    no_such_device_or_address = 6,
    no_such_device = 19,
    no_such_file_or_directory = 2,
    no_such_process = 3,
    not_a_directory = 20,
    not_a_socket = 38,
    not_a_stream = 99,
    not_connected = 57,
    not_enough_memory = 12,
    not_supported = 45,
    operation_canceled = 89,
    operation_in_progress = 36,
    operation_not_permitted = 1,
    operation_not_supported = 102,
    operation_would_block = 35,
    owner_dead = 105,
    permission_denied = 13,
    protocol_error = 100,
    protocol_not_supported = 43,
    read_only_file_system = 30,
    resource_deadlock_would_occur = 11,
    resource_unavailable_try_again = 35,
    result_out_of_range = 34,
    state_not_recoverable = 104,
    stream_timeout = 101,
    text_file_busy = 26,
    timed_out = 60,
    too_many_files_open_in_system = 23,
    too_many_files_open = 24,
    too_many_links = 31,
    too_many_symbolic_link_levels = 62,
    value_too_large = 84,
    wrong_protocol_type = 41
};
} }
namespace std { inline namespace __1 {
template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_error_code_enum
    : public false_type {};
template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_error_condition_enum
    : public false_type {};
template <>
struct __attribute__ ((__type_visibility__("default"))) is_error_condition_enum<errc>
    : true_type { };
class __attribute__ ((__visibility__("default"))) error_condition;
class __attribute__ ((__visibility__("default"))) error_code;
class __attribute__ ((__visibility__("hidden"))) __do_message;
class __attribute__ ((__visibility__("default"))) error_category
{
public:
private:
public:
    friend class __attribute__ ((__visibility__("hidden"))) __do_message;
};
class __attribute__ ((__visibility__("hidden"))) __do_message
    : public error_category
{
public:
};
class __attribute__ ((__visibility__("default"))) error_condition
{
    int __val_;
    const error_category* __cat_;
public:
            ;
            ;
};
class __attribute__ ((__visibility__("default"))) error_code
{
    int __val_;
    const error_category* __cat_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    error_code() ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    error_code(int __val, const error_category& __cat) ;
    template <class _Ep>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        error_code(_Ep __e,
                   typename enable_if<is_error_code_enum<_Ep>::value>::type* = 0
                                                                     ) noexcept
            ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void assign(int __val, const error_category& __cat) noexcept
    ;
    template <class _Ep>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        typename enable_if
        <
            is_error_code_enum<_Ep>::value,
            error_code&
        >::type
        operator=(_Ep __e) noexcept
            ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void clear() noexcept
    ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    int value() const noexcept ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const error_category& category() const noexcept ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    error_condition default_error_condition() const noexcept
        ;
    string message() const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        explicit
        operator bool() const noexcept ;
};
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
error_code
make_error_code(errc __e) noexcept
;
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator<(const error_code& __x, const error_code& __y) noexcept
;
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator==(const error_code& __x, const error_code& __y) noexcept
;
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator==(const error_code& __x, const error_condition& __y) noexcept
;
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator==(const error_condition& __x, const error_code& __y) noexcept
;
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator==(const error_condition& __x, const error_condition& __y) noexcept
;
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator!=(const error_code& __x, const error_code& __y) noexcept
;
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator!=(const error_code& __x, const error_condition& __y) noexcept
;
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator!=(const error_condition& __x, const error_code& __y) noexcept
;
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator!=(const error_condition& __x, const error_condition& __y) noexcept
;
template <>
struct __attribute__ ((__type_visibility__("default"))) hash<error_code>
    : public unary_function<error_code, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t operator()(const error_code& __ec) const noexcept
    ;
};
template <>
struct __attribute__ ((__type_visibility__("default"))) hash<error_condition>
    : public unary_function<error_condition, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t operator()(const error_condition& __ec) const noexcept
    ;
};
class __attribute__ ((__visibility__("default"))) system_error
    : public runtime_error
{
    error_code __ec_;
public:
    system_error(error_code __ec, const string& __what_arg);
    system_error(error_code __ec, const char* __what_arg);
    system_error(error_code __ec);
    system_error(int __ev, const error_category& __ecat, const string& __what_arg);
    system_error(int __ev, const error_category& __ecat, const char* __what_arg);
    system_error(int __ev, const error_category& __ecat);
    ~system_error() noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const error_code& code() const noexcept ;
private:
    static string __init(const error_code&, string);
};
[[noreturn]] __attribute__ ((__visibility__("default")))
void __throw_system_error(int ev, const char* what_arg);
} }
extern "C" {
struct sched_param { int sched_priority; char __opaque[4]; };
extern int sched_yield(void);
extern int sched_get_priority_min(int);
extern int sched_get_priority_max(int);
}
typedef enum : unsigned int { QOS_CLASS_USER_INTERACTIVE __attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0))) = 0x21, QOS_CLASS_USER_INITIATED __attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0))) = 0x19, QOS_CLASS_DEFAULT __attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0))) = 0x15, QOS_CLASS_UTILITY __attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0))) = 0x11, QOS_CLASS_BACKGROUND __attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0))) = 0x09, QOS_CLASS_UNSPECIFIED __attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0))) = 0x00, } qos_class_t;
extern "C" {
__attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0)))
qos_class_t
qos_class_self(void);
__attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0)))
qos_class_t
qos_class_main(void);
}
extern "C" {
__attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0)))
int
pthread_attr_set_qos_class_np(pthread_attr_t *__attr,
  qos_class_t __qos_class, int __relative_priority);
__attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0)))
int
pthread_attr_get_qos_class_np(pthread_attr_t * __attr,
  qos_class_t * _Nullable __qos_class,
  int * _Nullable __relative_priority);
__attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0)))
int
pthread_set_qos_class_self_np(qos_class_t __qos_class,
  int __relative_priority);
__attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0)))
int
pthread_get_qos_class_np(pthread_t __pthread,
  qos_class_t * _Nullable __qos_class,
  int * _Nullable __relative_priority);
typedef struct pthread_override_s* pthread_override_t;
__attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0)))
pthread_override_t
pthread_override_qos_class_start_np(pthread_t __pthread,
  qos_class_t __qos_class, int __relative_priority);
__attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0)))
int
pthread_override_qos_class_end_np(pthread_override_t __override);
}
typedef __darwin_mach_port_t mach_port_t;
extern "C" {
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_atfork(void (* _Nullable)(void), void (* _Nullable)(void),
  void (* _Nullable)(void));
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_destroy(pthread_attr_t *);
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_getdetachstate(const pthread_attr_t *, int *);
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_getguardsize(const pthread_attr_t * , size_t * );
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_getinheritsched(const pthread_attr_t * , int * );
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_getschedparam(const pthread_attr_t * ,
  struct sched_param * );
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_getschedpolicy(const pthread_attr_t * , int * );
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_getscope(const pthread_attr_t * , int * );
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_getstack(const pthread_attr_t * ,
  void * _Nullable * _Nonnull , size_t * );
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_getstackaddr(const pthread_attr_t * ,
  void * _Nullable * _Nonnull );
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_getstacksize(const pthread_attr_t * , size_t * );
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_init(pthread_attr_t *);
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_setdetachstate(pthread_attr_t *, int);
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_setguardsize(pthread_attr_t *, size_t);
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_setinheritsched(pthread_attr_t *, int);
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_setschedparam(pthread_attr_t * ,
  const struct sched_param * );
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_setschedpolicy(pthread_attr_t *, int);
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_setscope(pthread_attr_t *, int);
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_setstack(pthread_attr_t *, void *, size_t);
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_setstackaddr(pthread_attr_t *, void *);
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_setstacksize(pthread_attr_t *, size_t);
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_cancel(pthread_t) __asm("_" "pthread_cancel" );
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_cond_broadcast(pthread_cond_t *);
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_cond_destroy(pthread_cond_t *);
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
}
namespace std { inline namespace __1 {
typedef pthread_mutex_t __libcpp_mutex_t;
typedef pthread_mutex_t __libcpp_recursive_mutex_t;
typedef pthread_cond_t __libcpp_condvar_t;
typedef pthread_once_t __libcpp_exec_once_flag;
typedef pthread_t __libcpp_thread_id;
typedef pthread_t __libcpp_thread_t;
typedef pthread_key_t __libcpp_tls_key;
} }
namespace std { inline namespace __1 {
class __attribute__ ((__visibility__("default"))) mutex
{
    __libcpp_mutex_t __m_ = {0x32AAABA7, {0}};
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr mutex() = default;
    ~mutex();
private:
public:
    typedef __libcpp_mutex_t* native_handle_type;
};
static_assert(is_nothrow_default_constructible<mutex>::value,
              "the default constructor for std::mutex must be nothrow");
struct __attribute__ ((__visibility__("default"))) defer_lock_t {};
struct __attribute__ ((__visibility__("default"))) try_to_lock_t {};
struct __attribute__ ((__visibility__("default"))) adopt_lock_t {};
 constexpr defer_lock_t defer_lock = defer_lock_t();
 constexpr try_to_lock_t try_to_lock = try_to_lock_t();
 constexpr adopt_lock_t adopt_lock = adopt_lock_t();
template <class _Mutex>
class __attribute__ ((__type_visibility__("default")))
lock_guard
{
public:
    typedef _Mutex mutex_type;
private:
    mutex_type& __m_;
public:
private:
};
template <class _Mutex>
class __attribute__ ((__type_visibility__("default"))) unique_lock
{
public:
    typedef _Mutex mutex_type;
private:
    mutex_type* __m_;
    bool __owns_;
public:
      ;
      ;
private:
public:
    ;
    ;
};
    ;
enum class __attribute__ ((__type_visibility__("default"))) cv_status
{
    no_timeout,
    timeout
};
class __attribute__ ((__visibility__("default"))) condition_variable
{
    __libcpp_condvar_t __cv_ = {0x3CB0B1BB, {0}};
public:
private:
public:
    ;
    ;
    ;
    ;
    ;
    typedef __libcpp_condvar_t* native_handle_type;
private:
};
;
} }
namespace std { inline namespace __1 {
class __attribute__ ((__visibility__("default"))) recursive_mutex
{
    __libcpp_recursive_mutex_t __m_;
public:
private:
public:
    typedef __libcpp_recursive_mutex_t* native_handle_type;
};
class __attribute__ ((__visibility__("default"))) timed_mutex
{
    mutex __m_;
    condition_variable __cv_;
    bool __locked_;
public:
private:
public:
            ;
    ;
};
class __attribute__ ((__visibility__("default"))) recursive_timed_mutex
{
    mutex __m_;
    condition_variable __cv_;
    size_t __count_;
    __libcpp_thread_id __id_;
public:
private:
public:
            ;
    ;
};
;
;
;
;
;
 ;
 ;
 ;
struct __attribute__ ((__type_visibility__("default"))) once_flag;
;
struct __attribute__ ((__type_visibility__("default"))) once_flag
{
private:
    unsigned long __state_;
    ;
};
template <class _Fp>
class __call_once_param
{
    _Fp& __f_;
public:
private:
    ;
};
;
;
} }
struct lconv {
 char *decimal_point;
 char *thousands_sep;
 char *grouping;
 char *int_curr_symbol;
 char *currency_symbol;
 char *mon_decimal_point;
 char *mon_thousands_sep;
 char *mon_grouping;
 char *positive_sign;
 char *negative_sign;
 char int_frac_digits;
 char frac_digits;
 char p_cs_precedes;
 char p_sep_by_space;
 char n_cs_precedes;
 char n_sep_by_space;
 char p_sign_posn;
 char n_sign_posn;
 char int_p_cs_precedes;
 char int_n_cs_precedes;
 char int_p_sep_by_space;
 char int_n_sep_by_space;
 char int_p_sign_posn;
 char int_n_sign_posn;
};
extern "C" {
;
}
extern "C" {
;
}
struct _xlocale;
typedef struct _xlocale * locale_t;
extern "C" {
;
;
}
extern "C" {
extern const locale_t _c_locale;
;
;
;
;
;
;
}
extern "C" {
;
;
;
}
extern "C" {
;
}
extern "C" {
;
}
extern "C" {
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
}
extern "C" {
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
}
extern "C" {
;
;
;
;
;
}
extern "C" {
;
;
}
extern "C" {
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
}
extern "C" {
;
;
;
;
;
;
;
}
extern "C" {
;
;
;
;
}
extern "C" {
;
}
extern "C" {
;
;
;
}
namespace std { inline namespace __1 {
class __attribute__ ((__visibility__("default"))) locale;
;
;
class __attribute__ ((__visibility__("default"))) locale
{
public:
    class __attribute__ ((__visibility__("default"))) facet;
    class __attribute__ ((__visibility__("default"))) id;
    typedef int category;
    __attribute__((availability(macosx,strict,introduced=10.9))) __attribute__((availability(ios,strict,introduced=7.0)))
    static const category
        none = 0,
        collate = (1 << 0),
        ctype = (1 << 1),
        monetary = (1 << 3),
        numeric = (1 << 4),
        time = (1 << 5),
        messages = (1 << 2),
        all = collate | ctype | monetary | numeric | time | messages;
    ;
    ;
    ;
private:
    class __imp;
    __imp* __locale_;
    ;
    ;
};
class __attribute__ ((__visibility__("default"))) locale::facet
    : public __shared_count
{
protected:
private:
};
class __attribute__ ((__visibility__("default"))) locale::id
{
    once_flag __flag_;
    int32_t __id_;
    static int32_t __next_id;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr id() ;
private:
public:
    friend class locale;
    friend class locale::__imp;
};
;
;
template <class _CharT>
class __attribute__ ((__type_visibility__("default"))) collate
    : public locale::facet
{
public:
    typedef _CharT char_type;
    typedef basic_string<char_type> string_type;
    static locale::id id;
protected:
};
template <class _CharT> locale::id collate<_CharT>::id;
extern template class __attribute__ ((__visibility__("default"))) collate<char>;
extern template class __attribute__ ((__visibility__("default"))) collate<wchar_t>;
template <class _CharT> class __attribute__ ((__type_visibility__("default"))) collate_byname;
template <>
class __attribute__ ((__visibility__("default"))) collate_byname<char>
    : public collate<char>
{
    locale_t __l;
public:
    typedef char char_type;
    typedef basic_string<char_type> string_type;
protected:
};
template <>
class __attribute__ ((__visibility__("default"))) collate_byname<wchar_t>
    : public collate<wchar_t>
{
    locale_t __l;
public:
    typedef wchar_t char_type;
    typedef basic_string<char_type> string_type;
protected:
};
class __attribute__ ((__visibility__("default"))) ctype_base
{
public:
    typedef __uint32_t mask;
    static const mask space = 0x00004000L;
    static const mask print = 0x00040000L;
    static const mask cntrl = 0x00000200L;
    static const mask upper = 0x00008000L;
    static const mask lower = 0x00001000L;
    static const mask alpha = 0x00000100L;
    static const mask digit = 0x00000400L;
    static const mask punct = 0x00002000L;
    static const mask xdigit = 0x00010000L;
    static const mask blank = 0x00020000L;
    static const mask alnum = alpha | digit;
    static const mask graph = alnum | punct;
};
template <class _CharT> class __attribute__ ((__type_visibility__("default"))) ctype;
template <>
class __attribute__ ((__visibility__("default"))) ctype<wchar_t>
    : public locale::facet,
      public ctype_base
{
public:
    typedef wchar_t char_type;
    static locale::id id;
protected:
};
template <>
class __attribute__ ((__visibility__("default"))) ctype<char>
    : public locale::facet, public ctype_base
{
    const mask* __tab_;
    bool __del_;
public:
    typedef char char_type;
    static locale::id id;
    static const size_t table_size = (1 <<8 );
protected:
};
template <class _CharT> class __attribute__ ((__type_visibility__("default"))) ctype_byname;
template <>
class __attribute__ ((__visibility__("default"))) ctype_byname<char>
    : public ctype<char>
{
    locale_t __l;
public:
protected:
};
template <>
class __attribute__ ((__visibility__("default"))) ctype_byname<wchar_t>
    : public ctype<wchar_t>
{
    locale_t __l;
public:
protected:
};
;
;
;
;
;
;
;
;
;
;
;
;
;
class __attribute__ ((__visibility__("default"))) codecvt_base
{
public:
    enum result {ok, partial, error, noconv};
};
template <class _InternT, class _ExternT, class _StateT> class __attribute__ ((__type_visibility__("default"))) codecvt;
template <>
class __attribute__ ((__visibility__("default"))) codecvt<char, char, mbstate_t>
    : public locale::facet,
      public codecvt_base
{
public:
    typedef char intern_type;
    typedef char extern_type;
    typedef mbstate_t state_type;
    static locale::id id;
protected:
};
template <>
class __attribute__ ((__visibility__("default"))) codecvt<wchar_t, char, mbstate_t>
    : public locale::facet,
      public codecvt_base
{
    locale_t __l;
public:
    typedef wchar_t intern_type;
    typedef char extern_type;
    typedef mbstate_t state_type;
    static locale::id id;
protected:
};
template <>
class __attribute__ ((__visibility__("default"))) codecvt<char16_t, char, mbstate_t>
    : public locale::facet,
      public codecvt_base
{
public:
    typedef char16_t intern_type;
    typedef char extern_type;
    typedef mbstate_t state_type;
    static locale::id id;
protected:
};
template <>
class __attribute__ ((__visibility__("default"))) codecvt<char32_t, char, mbstate_t>
    : public locale::facet,
      public codecvt_base
{
public:
    typedef char32_t intern_type;
    typedef char extern_type;
    typedef mbstate_t state_type;
    static locale::id id;
protected:
};
template <class _InternT, class _ExternT, class _StateT>
class __attribute__ ((__type_visibility__("default"))) codecvt_byname
    : public codecvt<_InternT, _ExternT, _StateT>
{
public:
protected:
};
extern template class __attribute__ ((__visibility__("default"))) codecvt_byname<char, char, mbstate_t>;
extern template class __attribute__ ((__visibility__("default"))) codecvt_byname<wchar_t, char, mbstate_t>;
extern template class __attribute__ ((__visibility__("default"))) codecvt_byname<char16_t, char, mbstate_t>;
extern template class __attribute__ ((__visibility__("default"))) codecvt_byname<char32_t, char, mbstate_t>;
[[noreturn]] __attribute__ ((__visibility__("default"))) void __throw_runtime_error(const char*);
template <size_t _Np>
struct __narrow_to_utf8
{
    ;
};
template <>
struct __narrow_to_utf8<8>
{
    ;
};
template <>
struct __attribute__ ((__type_visibility__("default"))) __narrow_to_utf8<16>
    : public codecvt<char16_t, char, mbstate_t>
{
    ;
};
template <>
struct __attribute__ ((__type_visibility__("default"))) __narrow_to_utf8<32>
    : public codecvt<char32_t, char, mbstate_t>
{
    ;
};
template <size_t _Np>
struct __widen_from_utf8
{
    ;
};
template <>
struct __widen_from_utf8<8>
{
    ;
};
template <>
struct __attribute__ ((__type_visibility__("default"))) __widen_from_utf8<16>
    : public codecvt<char16_t, char, mbstate_t>
{
    ;
};
template <>
struct __attribute__ ((__type_visibility__("default"))) __widen_from_utf8<32>
    : public codecvt<char32_t, char, mbstate_t>
{
    ;
};
template <class _CharT> class __attribute__ ((__type_visibility__("default"))) numpunct;
template <>
class __attribute__ ((__visibility__("default"))) numpunct<char>
    : public locale::facet
{
public:
    typedef char char_type;
    typedef basic_string<char_type> string_type;
    static locale::id id;
protected:
    char_type __decimal_point_;
    char_type __thousands_sep_;
    string __grouping_;
};
template <>
class __attribute__ ((__visibility__("default"))) numpunct<wchar_t>
    : public locale::facet
{
public:
    typedef wchar_t char_type;
    typedef basic_string<char_type> string_type;
    static locale::id id;
protected:
    char_type __decimal_point_;
    char_type __thousands_sep_;
    string __grouping_;
};
template <class _CharT> class __attribute__ ((__type_visibility__("default"))) numpunct_byname;
template <>
class __attribute__ ((__visibility__("default"))) numpunct_byname<char>
: public numpunct<char>
{
public:
    typedef char char_type;
    typedef basic_string<char_type> string_type;
protected:
private:
};
template <>
class __attribute__ ((__visibility__("default"))) numpunct_byname<wchar_t>
: public numpunct<wchar_t>
{
public:
    typedef wchar_t char_type;
    typedef basic_string<char_type> string_type;
protected:
private:
};
} }
namespace std { inline namespace __1 {
typedef ptrdiff_t streamsize;
class __attribute__ ((__visibility__("default"))) ios_base
{
public:
    class __attribute__ ((__visibility__("default"))) failure;
    typedef unsigned int fmtflags;
    static const fmtflags boolalpha = 0x0001;
    static const fmtflags dec = 0x0002;
    static const fmtflags fixed = 0x0004;
    static const fmtflags hex = 0x0008;
    static const fmtflags internal = 0x0010;
    static const fmtflags left = 0x0020;
    static const fmtflags oct = 0x0040;
    static const fmtflags right = 0x0080;
    static const fmtflags scientific = 0x0100;
    static const fmtflags showbase = 0x0200;
    static const fmtflags showpoint = 0x0400;
    static const fmtflags showpos = 0x0800;
    static const fmtflags skipws = 0x1000;
    static const fmtflags unitbuf = 0x2000;
    static const fmtflags uppercase = 0x4000;
    static const fmtflags adjustfield = left | right | internal;
    static const fmtflags basefield = dec | oct | hex;
    static const fmtflags floatfield = scientific | fixed;
    typedef unsigned int iostate;
    static const iostate badbit = 0x1;
    static const iostate eofbit = 0x2;
    static const iostate failbit = 0x4;
    static const iostate goodbit = 0x0;
    typedef unsigned int openmode;
    static const openmode app = 0x01;
    static const openmode ate = 0x02;
    static const openmode binary = 0x04;
    static const openmode in = 0x08;
    static const openmode out = 0x10;
    static const openmode trunc = 0x20;
    enum seekdir {beg, cur, end};
    typedef iostate io_state;
    typedef openmode open_mode;
    typedef seekdir seek_dir;
    typedef std::__1::streamoff streamoff;
    typedef std::__1::streampos streampos;
    class __attribute__ ((__visibility__("default"))) Init;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) streamsize precision(streamsize __prec);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) streamsize width() const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) streamsize width(streamsize __wide);
    locale imbue(const locale& __loc);
    locale getloc() const;
    static int xalloc();
    long& iword(int __index);
    void*& pword(int __index);
    virtual ~ios_base();
    enum event { erase_event, imbue_event, copyfmt_event };
    typedef void (*event_callback)(event, ios_base&, int __index);
    void register_callback(event_callback __fn, int __index);
private:
    ios_base(const ios_base&);
    ios_base& operator=(const ios_base&);
public:
    static bool sync_with_stdio(bool __sync = true);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) iostate rdstate() const;
    void clear(iostate __state = goodbit);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void setstate(iostate __state);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool good() const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool eof() const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool fail() const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool bad() const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) iostate exceptions() const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void exceptions(iostate __iostate);
    void __set_badbit_and_consider_rethrow();
    void __set_failbit_and_consider_rethrow();
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __setstate_nothrow(iostate __state)
    ;
protected:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    ios_base() ;
    void init(void* __sb);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void* rdbuf() const ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void rdbuf(void* __sb)
    ;
    void __call_callbacks(event);
    void copyfmt(const ios_base&);
    void move(ios_base&);
    void swap(ios_base&) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void set_rdbuf(void* __sb)
    ;
private:
    fmtflags __fmtflags_;
    streamsize __precision_;
    streamsize __width_;
    iostate __rdstate_;
    iostate __exceptions_;
    void* __rdbuf_;
    void* __loc_;
    event_callback* __fn_;
    int* __index_;
    size_t __event_size_;
    size_t __event_cap_;
    static atomic<int> __xindex_;
    long* __iarray_;
    size_t __iarray_size_;
    size_t __iarray_cap_;
    void** __parray_;
    size_t __parray_size_;
    size_t __parray_cap_;
};
enum class __attribute__ ((__type_visibility__("default"))) io_errc
{
    stream = 1
};
template <>
struct __attribute__ ((__type_visibility__("default"))) is_error_code_enum<io_errc> : public true_type { };
__attribute__ ((__visibility__("default")))
const error_category& iostream_category() noexcept;
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
error_code
make_error_code(io_errc __e) noexcept
;
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
error_condition
make_error_condition(io_errc __e) noexcept
;
class __attribute__ ((__visibility__("default"))) ios_base::failure
    : public system_error
{
public:
    explicit failure(const string& __msg, const error_code& __ec = io_errc::stream);
    explicit failure(const char* __msg, const error_code& __ec = io_errc::stream);
    virtual ~failure() throw();
};
[[noreturn]] __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void __throw_failure(char const* __msg) ;
class __attribute__ ((__visibility__("default"))) ios_base::Init
{
public:
    Init();
    ~Init();
};
template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) basic_ios
    : public ios_base
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;
    static_assert((is_same<_CharT, typename traits_type::char_type>::value),
                  "traits_type::char_type must be the same type as CharT");
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit operator bool() const ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool operator!() const ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) iostate rdstate() const ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void clear(iostate __state = goodbit) ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void setstate(iostate __state) ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool good() const ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool eof() const ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool fail() const ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool bad() const ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) iostate exceptions() const ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void exceptions(iostate __iostate) ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit basic_ios(basic_streambuf<char_type,traits_type>* __sb);
    virtual ~basic_ios();
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_ostream<char_type, traits_type>* tie() const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_ostream<char_type, traits_type>* tie(basic_ostream<char_type, traits_type>* __tiestr);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_streambuf<char_type, traits_type>* rdbuf() const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_streambuf<char_type, traits_type>* rdbuf(basic_streambuf<char_type, traits_type>* __sb);
    basic_ios& copyfmt(const basic_ios& __rhs);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    char_type fill() const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    char_type fill(char_type __ch);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    locale imbue(const locale& __loc);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    char narrow(char_type __c, char __dfault) const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    char_type widen(char __c) const;
protected:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_ios() ;
private:
    basic_ostream<char_type, traits_type>* __tie_;
    mutable int_type __fill_;
};
template <class _CharT, class _Traits>
class __save_flags
{
    typedef basic_ios<_CharT, _Traits> __stream_type;
    typedef typename __stream_type::fmtflags fmtflags;
    __stream_type& __stream_;
    fmtflags __fmtflags_;
    _CharT __fill_;
public:
};
} }
namespace std { inline namespace __1 {
template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) basic_streambuf
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;
    static_assert((is_same<_CharT, typename traits_type::char_type>::value),
                  "traits_type::char_type must be the same type as CharT");
protected:
private:
    locale __loc_;
    char_type* __binp_;
    char_type* __ninp_;
    char_type* __einp_;
    char_type* __bout_;
    char_type* __nout_;
    char_type* __eout_;
};
extern template class __attribute__ ((__visibility__("default"))) basic_streambuf<char>;
extern template class __attribute__ ((__visibility__("default"))) basic_streambuf<wchar_t>;
extern template class __attribute__ ((__visibility__("default"))) basic_ios<char>;
extern template class __attribute__ ((__visibility__("default"))) basic_ios<wchar_t>;
} }
typedef struct __nl_cat_d {
 void *__data;
 int __size;
} *nl_catd;
typedef __darwin_nl_item nl_item;
extern "C" {
;
;
;
}
namespace std { inline namespace __1 {
;
struct __attribute__ ((__visibility__("default"))) __num_get_base
{
    static const int __num_get_buf_sz = 40;
    static const char __src[33];
};
template <class _CharT>
struct __num_get
    : protected __num_get_base
{
};
extern template struct __attribute__ ((__visibility__("default"))) __num_get<char>;
extern template struct __attribute__ ((__visibility__("default"))) __num_get<wchar_t>;
template <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >
class __attribute__ ((__type_visibility__("default"))) num_get
    : public locale::facet,
      private __num_get<_CharT>
{
public:
    typedef _CharT char_type;
    typedef _InputIterator iter_type;
    static locale::id id;
protected:
    ;
    ;
    ;
};
template <class _CharT, class _InputIterator>
locale::id
num_get<_CharT, _InputIterator>::id;
;
;
;
;
extern template class __attribute__ ((__visibility__("default"))) num_get<char>;
extern template class __attribute__ ((__visibility__("default"))) num_get<wchar_t>;
struct __attribute__ ((__visibility__("default"))) __num_put_base
{
protected:
};
template <class _CharT>
struct __num_put
    : protected __num_put_base
{
};
extern template struct __attribute__ ((__visibility__("default"))) __num_put<char>;
extern template struct __attribute__ ((__visibility__("default"))) __num_put<wchar_t>;
template <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >
class __attribute__ ((__type_visibility__("default"))) num_put
    : public locale::facet,
      private __num_put<_CharT>
{
public:
    typedef _CharT char_type;
    typedef _OutputIterator iter_type;
    static locale::id id;
protected:
    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             unsigned long long) const;
    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             double __v) const;
    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             long double __v) const;
    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             const void* __v) const;
};
template <class _CharT, class _OutputIterator>
locale::id
num_put<_CharT, _OutputIterator>::id;
template <class _CharT, class _OutputIterator>
__attribute__ ((__visibility__("hidden")))
_OutputIterator
__pad_and_output(_OutputIterator __s,
                 const _CharT* __ob, const _CharT* __op, const _CharT* __oe,
                 ios_base& __iob, _CharT __fl)
;
template <class _CharT, class _Traits>
__attribute__ ((__visibility__("hidden")))
ostreambuf_iterator<_CharT, _Traits>
__pad_and_output(ostreambuf_iterator<_CharT, _Traits> __s,
                 const _CharT* __ob, const _CharT* __op, const _CharT* __oe,
                 ios_base& __iob, _CharT __fl)
;
extern template class __attribute__ ((__visibility__("default"))) num_put<char>;
extern template class __attribute__ ((__visibility__("default"))) num_put<wchar_t>;
template <class _CharT, class _InputIterator>
__attribute__ ((__visibility__("hidden")))
int
__get_up_to_n_digits(_InputIterator& __b, _InputIterator __e,
                     ios_base::iostate& __err, const ctype<_CharT>& __ct, int __n)
;
class __attribute__ ((__visibility__("default"))) time_base
{
public:
    enum dateorder {no_order, dmy, mdy, ymd, ydm};
};
template <class _CharT>
class __attribute__ ((__type_visibility__("default"))) __time_get_c_storage
{
protected:
    typedef basic_string<_CharT> string_type;
    virtual const string_type* __weeks() const;
    virtual const string_type* __months() const;
    virtual const string_type* __am_pm() const;
    virtual const string_type& __c() const;
    virtual const string_type& __r() const;
    virtual const string_type& __x() const;
    virtual const string_type& __X() const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    ~__time_get_c_storage() ;
};
template <> __attribute__ ((__visibility__("default"))) const string* __time_get_c_storage<char>::__weeks() const;
template <> __attribute__ ((__visibility__("default"))) const string* __time_get_c_storage<char>::__months() const;
template <> __attribute__ ((__visibility__("default"))) const string* __time_get_c_storage<char>::__am_pm() const;
template <> __attribute__ ((__visibility__("default"))) const string& __time_get_c_storage<char>::__c() const;
template <> __attribute__ ((__visibility__("default"))) const string& __time_get_c_storage<char>::__r() const;
template <> __attribute__ ((__visibility__("default"))) const string& __time_get_c_storage<char>::__x() const;
template <> __attribute__ ((__visibility__("default"))) const string& __time_get_c_storage<char>::__X() const;
template <> __attribute__ ((__visibility__("default"))) const wstring* __time_get_c_storage<wchar_t>::__weeks() const;
template <> __attribute__ ((__visibility__("default"))) const wstring* __time_get_c_storage<wchar_t>::__months() const;
template <> __attribute__ ((__visibility__("default"))) const wstring* __time_get_c_storage<wchar_t>::__am_pm() const;
template <> __attribute__ ((__visibility__("default"))) const wstring& __time_get_c_storage<wchar_t>::__c() const;
template <> __attribute__ ((__visibility__("default"))) const wstring& __time_get_c_storage<wchar_t>::__r() const;
template <> __attribute__ ((__visibility__("default"))) const wstring& __time_get_c_storage<wchar_t>::__x() const;
template <> __attribute__ ((__visibility__("default"))) const wstring& __time_get_c_storage<wchar_t>::__X() const;
template <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >
class __attribute__ ((__type_visibility__("default"))) time_get
    : public locale::facet,
      public time_base,
      private __time_get_c_storage<_CharT>
{
public:
    typedef _CharT char_type;
    typedef _InputIterator iter_type;
    typedef time_base::dateorder dateorder;
    typedef basic_string<char_type> string_type;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit time_get(size_t __refs = 0) ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    dateorder date_order() const
    ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iter_type get_time(iter_type __b, iter_type __e, ios_base& __iob,
                       ios_base::iostate& __err, tm* __tm) const
    ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iter_type get_date(iter_type __b, iter_type __e, ios_base& __iob,
                       ios_base::iostate& __err, tm* __tm) const
    ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iter_type get_weekday(iter_type __b, iter_type __e, ios_base& __iob,
                          ios_base::iostate& __err, tm* __tm) const
    ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iter_type get_monthname(iter_type __b, iter_type __e, ios_base& __iob,
                            ios_base::iostate& __err, tm* __tm) const
    ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iter_type get_year(iter_type __b, iter_type __e, ios_base& __iob,
                       ios_base::iostate& __err, tm* __tm) const
    ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, tm *__tm,
                  char __fmt, char __mod = 0) const
    ;
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, tm* __tm,
                  const char_type* __fmtb, const char_type* __fmte) const;
    static locale::id id;
protected:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    ~time_get() ;
    virtual dateorder do_date_order() const;
    virtual iter_type do_get_time(iter_type __b, iter_type __e, ios_base& __iob,
                                  ios_base::iostate& __err, tm* __tm) const;
    virtual iter_type do_get_date(iter_type __b, iter_type __e, ios_base& __iob,
                                  ios_base::iostate& __err, tm* __tm) const;
    virtual iter_type do_get_weekday(iter_type __b, iter_type __e, ios_base& __iob,
                                     ios_base::iostate& __err, tm* __tm) const;
    virtual iter_type do_get_monthname(iter_type __b, iter_type __e, ios_base& __iob,
                                       ios_base::iostate& __err, tm* __tm) const;
    virtual iter_type do_get_year(iter_type __b, iter_type __e, ios_base& __iob,
                                  ios_base::iostate& __err, tm* __tm) const;
    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, tm* __tm,
                             char __fmt, char __mod) const;
private:
    void __get_white_space(iter_type& __b, iter_type __e,
                           ios_base::iostate& __err, const ctype<char_type>& __ct) const;
    void __get_percent(iter_type& __b, iter_type __e, ios_base::iostate& __err,
                       const ctype<char_type>& __ct) const;
    void __get_weekdayname(int& __m,
                           iter_type& __b, iter_type __e,
                           ios_base::iostate& __err,
                           const ctype<char_type>& __ct) const;
    void __get_monthname(int& __m,
                         iter_type& __b, iter_type __e,
                         ios_base::iostate& __err,
                         const ctype<char_type>& __ct) const;
    void __get_day(int& __d,
                   iter_type& __b, iter_type __e,
                   ios_base::iostate& __err,
                   const ctype<char_type>& __ct) const;
    void __get_month(int& __m,
                     iter_type& __b, iter_type __e,
                     ios_base::iostate& __err,
                     const ctype<char_type>& __ct) const;
    void __get_year(int& __y,
                   iter_type& __b, iter_type __e,
                   ios_base::iostate& __err,
                   const ctype<char_type>& __ct) const;
    void __get_year4(int& __y,
                    iter_type& __b, iter_type __e,
                    ios_base::iostate& __err,
                    const ctype<char_type>& __ct) const;
    void __get_hour(int& __d,
                    iter_type& __b, iter_type __e,
                    ios_base::iostate& __err,
                    const ctype<char_type>& __ct) const;
    void __get_12_hour(int& __h,
                       iter_type& __b, iter_type __e,
                       ios_base::iostate& __err,
                       const ctype<char_type>& __ct) const;
    void __get_am_pm(int& __h,
                     iter_type& __b, iter_type __e,
                     ios_base::iostate& __err,
                     const ctype<char_type>& __ct) const;
    void __get_minute(int& __m,
                      iter_type& __b, iter_type __e,
                      ios_base::iostate& __err,
                      const ctype<char_type>& __ct) const;
    void __get_second(int& __s,
                      iter_type& __b, iter_type __e,
                      ios_base::iostate& __err,
                      const ctype<char_type>& __ct) const;
    void __get_weekday(int& __w,
                       iter_type& __b, iter_type __e,
                       ios_base::iostate& __err,
                       const ctype<char_type>& __ct) const;
    void __get_day_year_num(int& __w,
                            iter_type& __b, iter_type __e,
                            ios_base::iostate& __err,
                            const ctype<char_type>& __ct) const;
};
template <class _CharT, class _InputIterator>
locale::id
time_get<_CharT, _InputIterator>::id;
extern template class __attribute__ ((__visibility__("default"))) time_get<char>;
extern template class __attribute__ ((__visibility__("default"))) time_get<wchar_t>;
class __attribute__ ((__visibility__("default"))) __time_get
{
protected:
    locale_t __loc_;
    __time_get(const char* __nm);
    __time_get(const string& __nm);
    ~__time_get();
};
template <class _CharT>
class __attribute__ ((__type_visibility__("default"))) __time_get_storage
    : public __time_get
{
protected:
    typedef basic_string<_CharT> string_type;
    string_type __weeks_[14];
    string_type __months_[24];
    string_type __am_pm_[2];
    string_type __c_;
    string_type __r_;
    string_type __x_;
    string_type __X_;
    explicit __time_get_storage(const char* __nm);
    explicit __time_get_storage(const string& __nm);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) ~__time_get_storage() ;
    time_base::dateorder __do_date_order() const;
private:
    void init(const ctype<_CharT>&);
    string_type __analyze(char __fmt, const ctype<_CharT>&);
};
template <> __attribute__ ((__visibility__("default"))) time_base::dateorder __time_get_storage<char>::__do_date_order() const; template <> __attribute__ ((__visibility__("default"))) __time_get_storage<char>::__time_get_storage(const char*); template <> __attribute__ ((__visibility__("default"))) __time_get_storage<char>::__time_get_storage(const string&); template <> __attribute__ ((__visibility__("default"))) void __time_get_storage<char>::init(const ctype<char>&); template <> __attribute__ ((__visibility__("default"))) __time_get_storage<char>::string_type __time_get_storage<char>::__analyze(char, const ctype<char>&); extern template __attribute__ ((__visibility__("default"))) time_base::dateorder __time_get_storage<char>::__do_date_order() const; extern template __attribute__ ((__visibility__("default"))) __time_get_storage<char>::__time_get_storage(const char*); extern template __attribute__ ((__visibility__("default"))) __time_get_storage<char>::__time_get_storage(const string&); extern template __attribute__ ((__visibility__("default"))) void __time_get_storage<char>::init(const ctype<char>&); extern template __attribute__ ((__visibility__("default"))) __time_get_storage<char>::string_type __time_get_storage<char>::__analyze(char, const ctype<char>&);
template <> __attribute__ ((__visibility__("default"))) time_base::dateorder __time_get_storage<wchar_t>::__do_date_order() const; template <> __attribute__ ((__visibility__("default"))) __time_get_storage<wchar_t>::__time_get_storage(const char*); template <> __attribute__ ((__visibility__("default"))) __time_get_storage<wchar_t>::__time_get_storage(const string&); template <> __attribute__ ((__visibility__("default"))) void __time_get_storage<wchar_t>::init(const ctype<wchar_t>&); template <> __attribute__ ((__visibility__("default"))) __time_get_storage<wchar_t>::string_type __time_get_storage<wchar_t>::__analyze(char, const ctype<wchar_t>&); extern template __attribute__ ((__visibility__("default"))) time_base::dateorder __time_get_storage<wchar_t>::__do_date_order() const; extern template __attribute__ ((__visibility__("default"))) __time_get_storage<wchar_t>::__time_get_storage(const char*); extern template __attribute__ ((__visibility__("default"))) __time_get_storage<wchar_t>::__time_get_storage(const string&); extern template __attribute__ ((__visibility__("default"))) void __time_get_storage<wchar_t>::init(const ctype<wchar_t>&); extern template __attribute__ ((__visibility__("default"))) __time_get_storage<wchar_t>::string_type __time_get_storage<wchar_t>::__analyze(char, const ctype<wchar_t>&);
template <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >
class __attribute__ ((__type_visibility__("default"))) time_get_byname
    : public time_get<_CharT, _InputIterator>,
      private __time_get_storage<_CharT>
{
public:
    typedef time_base::dateorder dateorder;
    typedef _InputIterator iter_type;
    typedef _CharT char_type;
    typedef basic_string<char_type> string_type;
protected:
private:
};
extern template class __attribute__ ((__visibility__("default"))) time_get_byname<char>;
extern template class __attribute__ ((__visibility__("default"))) time_get_byname<wchar_t>;
class __attribute__ ((__visibility__("default"))) __time_put
{
    locale_t __loc_;
protected:
};
template <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >
class __attribute__ ((__type_visibility__("default"))) time_put
    : public locale::facet,
      private __time_put
{
public:
    typedef _CharT char_type;
    typedef _OutputIterator iter_type;
    static locale::id id;
protected:
};
template <class _CharT, class _OutputIterator>
locale::id
time_put<_CharT, _OutputIterator>::id;
extern template class __attribute__ ((__visibility__("default"))) time_put<char>;
extern template class __attribute__ ((__visibility__("default"))) time_put<wchar_t>;
template <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >
class __attribute__ ((__type_visibility__("default"))) time_put_byname
    : public time_put<_CharT, _OutputIterator>
{
public:
protected:
};
extern template class __attribute__ ((__visibility__("default"))) time_put_byname<char>;
extern template class __attribute__ ((__visibility__("default"))) time_put_byname<wchar_t>;
class __attribute__ ((__visibility__("default"))) money_base
{
public:
    enum part {none, space, symbol, sign, value};
    struct pattern {char field[4];};
};
template <class _CharT, bool _International = false>
class __attribute__ ((__type_visibility__("default"))) moneypunct
    : public locale::facet,
      public money_base
{
public:
    typedef _CharT char_type;
    typedef basic_string<char_type> string_type;
    static locale::id id;
    static const bool intl = _International;
protected:
};
template <class _CharT, bool _International>
locale::id
moneypunct<_CharT, _International>::id;
template <class _CharT, bool _International>
const bool
moneypunct<_CharT, _International>::intl;
extern template class __attribute__ ((__visibility__("default"))) moneypunct<char, false>;
extern template class __attribute__ ((__visibility__("default"))) moneypunct<char, true>;
extern template class __attribute__ ((__visibility__("default"))) moneypunct<wchar_t, false>;
extern template class __attribute__ ((__visibility__("default"))) moneypunct<wchar_t, true>;
template <class _CharT, bool _International = false>
class __attribute__ ((__type_visibility__("default"))) moneypunct_byname
    : public moneypunct<_CharT, _International>
{
public:
    typedef money_base::pattern pattern;
    typedef _CharT char_type;
    typedef basic_string<char_type> string_type;
protected:
private:
    char_type __decimal_point_;
    char_type __thousands_sep_;
    string __grouping_;
    string_type __curr_symbol_;
    string_type __positive_sign_;
    string_type __negative_sign_;
    int __frac_digits_;
    pattern __pos_format_;
    pattern __neg_format_;
};
extern template class __attribute__ ((__visibility__("default"))) moneypunct_byname<char, false>;
extern template class __attribute__ ((__visibility__("default"))) moneypunct_byname<char, true>;
extern template class __attribute__ ((__visibility__("default"))) moneypunct_byname<wchar_t, false>;
extern template class __attribute__ ((__visibility__("default"))) moneypunct_byname<wchar_t, true>;
template <class _CharT>
class __money_get
{
protected:
    typedef _CharT char_type;
    typedef basic_string<char_type> string_type;
};
extern template class __attribute__ ((__visibility__("default"))) __money_get<char>;
extern template class __attribute__ ((__visibility__("default"))) __money_get<wchar_t>;
template <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >
class __attribute__ ((__type_visibility__("default"))) money_get
    : public locale::facet,
      private __money_get<_CharT>
{
public:
    typedef _CharT char_type;
    typedef _InputIterator iter_type;
    typedef basic_string<char_type> string_type;
    static locale::id id;
protected:
private:
};
template <class _CharT, class _InputIterator>
locale::id
money_get<_CharT, _InputIterator>::id;
;
extern template class __attribute__ ((__visibility__("default"))) money_get<char>;
extern template class __attribute__ ((__visibility__("default"))) money_get<wchar_t>;
template <class _CharT>
class __money_put
{
protected:
    typedef _CharT char_type;
    typedef basic_string<char_type> string_type;
};
extern template class __attribute__ ((__visibility__("default"))) __money_put<char>;
extern template class __attribute__ ((__visibility__("default"))) __money_put<wchar_t>;
template <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >
class __attribute__ ((__type_visibility__("default"))) money_put
    : public locale::facet,
      private __money_put<_CharT>
{
public:
    typedef _CharT char_type;
    typedef _OutputIterator iter_type;
    typedef basic_string<char_type> string_type;
    static locale::id id;
protected:
};
template <class _CharT, class _OutputIterator>
locale::id
money_put<_CharT, _OutputIterator>::id;
extern template class __attribute__ ((__visibility__("default"))) money_put<char>;
extern template class __attribute__ ((__visibility__("default"))) money_put<wchar_t>;
class __attribute__ ((__visibility__("default"))) messages_base
{
public:
    typedef ptrdiff_t catalog;
};
template <class _CharT>
class __attribute__ ((__type_visibility__("default"))) messages
    : public locale::facet,
      public messages_base
{
public:
    typedef _CharT char_type;
    typedef basic_string<_CharT> string_type;
    static locale::id id;
protected:
};
template <class _CharT>
locale::id
messages<_CharT>::id;
extern template class __attribute__ ((__visibility__("default"))) messages<char>;
extern template class __attribute__ ((__visibility__("default"))) messages<wchar_t>;
template <class _CharT>
class __attribute__ ((__type_visibility__("default"))) messages_byname
    : public messages<_CharT>
{
public:
    typedef messages_base::catalog catalog;
    typedef basic_string<_CharT> string_type;
protected:
};
extern template class __attribute__ ((__visibility__("default"))) messages_byname<char>;
extern template class __attribute__ ((__visibility__("default"))) messages_byname<wchar_t>;
template<class _Codecvt, class _Elem = wchar_t,
         class _Wide_alloc = allocator<_Elem>,
         class _Byte_alloc = allocator<char> >
class __attribute__ ((__type_visibility__("default"))) wstring_convert
{
public:
    typedef basic_string<char, char_traits<char>, _Byte_alloc> byte_string;
    typedef basic_string<_Elem, char_traits<_Elem>, _Wide_alloc> wide_string;
    typedef typename _Codecvt::state_type state_type;
    typedef typename wide_string::traits_type::int_type int_type;
private:
    byte_string __byte_err_string_;
    wide_string __wide_err_string_;
    _Codecvt* __cvtptr_;
    state_type __cvtstate_;
    size_t __cvtcount_;
public:
};
template <class _Codecvt, class _Elem = wchar_t, class _Tr = char_traits<_Elem> >
class __attribute__ ((__type_visibility__("default"))) wbuffer_convert
    : public basic_streambuf<_Elem, _Tr>
{
public:
    typedef _Elem char_type;
    typedef _Tr traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;
    typedef typename _Codecvt::state_type state_type;
private:
    char* __extbuf_;
    const char* __extbufnext_;
    const char* __extbufend_;
    char __extbuf_min_[8];
    size_t __ebs_;
    char_type* __intbuf_;
    size_t __ibs_;
    streambuf* __bufptr_;
    _Codecvt* __cv_;
    state_type __st_;
    ios_base::openmode __cm_;
    bool __owns_eb_;
    bool __owns_ib_;
    bool __always_noconv_;
public:
protected:
private:
};
} }
namespace std { inline namespace __1 {
template <class _Cp, bool _IsConst, typename _Cp::__storage_type = 0> class __bit_iterator;
template <class _Cp> class __bit_const_reference;
template <class _Tp>
struct __has_storage_type
{
    static const bool value = false;
};
template <class _Cp, bool = __has_storage_type<_Cp>::value>
class __bit_reference
{
    typedef typename _Cp::__storage_type __storage_type;
    typedef typename _Cp::__storage_pointer __storage_pointer;
    __storage_pointer __seg_;
    __storage_type __mask_;
    friend typename _Cp::__self;
    friend class __bit_const_reference<_Cp>;
    friend class __bit_iterator<_Cp, false>;
public:
private:
};
template <class _Cp>
class __bit_reference<_Cp, false>
{
};
;
;
;
;
template <class _Cp>
class __bit_const_reference
{
    typedef typename _Cp::__storage_type __storage_type;
    typedef typename _Cp::__const_storage_pointer __storage_pointer;
    __storage_pointer __seg_;
    __storage_type __mask_;
    friend typename _Cp::__self;
    friend class __bit_iterator<_Cp, true>;
public:
private:
};
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
template <class _Cp>
struct __bit_array
{
    typedef typename _Cp::difference_type difference_type;
    typedef typename _Cp::__storage_type __storage_type;
    typedef typename _Cp::__storage_pointer __storage_pointer;
    typedef typename _Cp::iterator iterator;
    static const unsigned __bits_per_word = _Cp::__bits_per_word;
    static const unsigned _Np = 4;
    difference_type __size_;
    __storage_type __word_[_Np];
};
;
;
;
;
template <class _Cp, bool _IsConst,
          typename _Cp::__storage_type>
class __bit_iterator
{
public:
    typedef typename _Cp::difference_type difference_type;
    typedef bool value_type;
    typedef __bit_iterator pointer;
    typedef typename conditional<_IsConst, __bit_const_reference<_Cp>, __bit_reference<_Cp> >::type reference;
    typedef random_access_iterator_tag iterator_category;
private:
    typedef typename _Cp::__storage_type __storage_type;
    typedef typename conditional<_IsConst, typename _Cp::__const_storage_pointer,
                                           typename _Cp::__storage_pointer>::type __storage_pointer;
    static const unsigned __bits_per_word = _Cp::__bits_per_word;
    __storage_pointer __seg_;
    unsigned __ctz_;
public:
private:
    friend typename _Cp::__self;
    friend class __bit_reference<_Cp>;
    friend class __bit_const_reference<_Cp>;
    friend class __bit_iterator<_Cp, true>;
    template <class _Dp> friend struct __bit_array;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
};
} }
namespace std { inline namespace __1 {
template <size_t _N_words, size_t _Size>
class __bitset;
template <size_t _N_words, size_t _Size>
struct __has_storage_type<__bitset<_N_words, _Size> >
{
    static const bool value = true;
};
template <size_t _N_words, size_t _Size>
class __bitset
{
public:
    typedef ptrdiff_t difference_type;
    typedef size_t size_type;
    typedef size_type __storage_type;
protected:
    typedef __bitset __self;
    typedef __storage_type* __storage_pointer;
    typedef const __storage_type* __const_storage_pointer;
    static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * 8);
    friend class __bit_reference<__bitset>;
    friend class __bit_const_reference<__bitset>;
    friend class __bit_iterator<__bitset, false>;
    friend class __bit_iterator<__bitset, true>;
    friend struct __bit_array<__bitset>;
    __storage_type __first_[_N_words];
    typedef __bit_reference<__bitset> reference;
    typedef __bit_const_reference<__bitset> const_reference;
    typedef __bit_iterator<__bitset, false> iterator;
    typedef __bit_iterator<__bitset, true> const_iterator;
private:
};
template <size_t _Size>
class __bitset<1, _Size>
{
public:
    typedef ptrdiff_t difference_type;
    typedef size_t size_type;
    typedef size_type __storage_type;
protected:
    typedef __bitset __self;
    typedef __storage_type* __storage_pointer;
    typedef const __storage_type* __const_storage_pointer;
    static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * 8);
    friend class __bit_reference<__bitset>;
    friend class __bit_const_reference<__bitset>;
    friend class __bit_iterator<__bitset, false>;
    friend class __bit_iterator<__bitset, true>;
    friend struct __bit_array<__bitset>;
    __storage_type __first_;
    typedef __bit_reference<__bitset> reference;
    typedef __bit_const_reference<__bitset> const_reference;
    typedef __bit_iterator<__bitset, false> iterator;
    typedef __bit_iterator<__bitset, true> const_iterator;
};
template <>
class __bitset<0, 0>
{
public:
    typedef ptrdiff_t difference_type;
    typedef size_t size_type;
    typedef size_type __storage_type;
protected:
    typedef __bitset __self;
    typedef __storage_type* __storage_pointer;
    typedef const __storage_type* __const_storage_pointer;
    static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * 8);
    friend class __bit_reference<__bitset>;
    friend class __bit_const_reference<__bitset>;
    friend class __bit_iterator<__bitset, false>;
    friend class __bit_iterator<__bitset, true>;
    friend struct __bit_array<__bitset>;
    typedef __bit_reference<__bitset> reference;
    typedef __bit_const_reference<__bitset> const_reference;
    typedef __bit_iterator<__bitset, false> iterator;
    typedef __bit_iterator<__bitset, true> const_iterator;
};
template <size_t _Size> class __attribute__ ((__type_visibility__("default"))) bitset;
template <size_t _Size> struct hash<bitset<_Size> >;
template <size_t _Size>
class __attribute__ ((__type_visibility__("default"))) bitset
    : private __bitset<_Size == 0 ? 0 : (_Size - 1) / (sizeof(size_t) * 8) + 1, _Size>
{
public:
    static const unsigned __n_words = _Size == 0 ? 0 : (_Size - 1) / (sizeof(size_t) * 8) + 1;
    typedef __bitset<__n_words, _Size> base;
public:
    typedef typename base::reference reference;
    typedef typename base::const_reference const_reference;
    ;
    ;
    ;
    ;
    ;
private:
    friend struct hash<bitset>;
};
;
;
;
template <size_t _Size>
struct __attribute__ ((__type_visibility__("default"))) hash<bitset<_Size> >
    : public unary_function<bitset<_Size>, size_t>
{
};
;
;
} }
namespace std { inline namespace __1 {
template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) basic_ostream
    : virtual public basic_ios<_CharT, _Traits>
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;
protected:
public:
    class __attribute__ ((__type_visibility__("default"))) sentry;
protected:
};
template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) basic_ostream<_CharT, _Traits>::sentry
{
    bool __ok_;
    basic_ostream<_CharT, _Traits>& __os_;
public:
};
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
extern template class __attribute__ ((__visibility__("default"))) basic_ostream<char>;
extern template class __attribute__ ((__visibility__("default"))) basic_ostream<wchar_t>;
} }
namespace std { inline namespace __1 {
template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) basic_istream
    : virtual public basic_ios<_CharT, _Traits>
{
    streamsize __gc_;
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;
protected:
public:
    class __attribute__ ((__type_visibility__("default"))) sentry;
};
template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) basic_istream<_CharT, _Traits>::sentry
{
    bool __ok_;
public:
};
 ;
 ;
;
;
;
;
;
;
;
;
;
template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) basic_iostream
    : public basic_istream<_CharT, _Traits>,
      public basic_ostream<_CharT, _Traits>
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;
protected:
public:
};
;
;
;
;
;
;
extern template class __attribute__ ((__visibility__("default"))) basic_istream<char>;
extern template class __attribute__ ((__visibility__("default"))) basic_istream<wchar_t>;
extern template class __attribute__ ((__visibility__("default"))) basic_iostream<char>;
} }
namespace std { inline namespace __1 {
template <class _CharT, class _Traits, class _Allocator>
class __attribute__ ((__type_visibility__("default"))) basic_stringbuf
    : public basic_streambuf<_CharT, _Traits>
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;
    typedef _Allocator allocator_type;
    typedef basic_string<char_type, traits_type, allocator_type> string_type;
private:
    string_type __str_;
    mutable char_type* __hm_;
    ios_base::openmode __mode_;
public:
protected:
};
;
template <class _CharT, class _Traits, class _Allocator>
class __attribute__ ((__type_visibility__("default"))) basic_istringstream
    : public basic_istream<_CharT, _Traits>
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;
    typedef _Allocator allocator_type;
    typedef basic_string<char_type, traits_type, allocator_type> string_type;
private:
    basic_stringbuf<char_type, traits_type, allocator_type> __sb_;
public:
};
;
template <class _CharT, class _Traits, class _Allocator>
class __attribute__ ((__type_visibility__("default"))) basic_ostringstream
    : public basic_ostream<_CharT, _Traits>
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;
    typedef _Allocator allocator_type;
    typedef basic_string<char_type, traits_type, allocator_type> string_type;
private:
    basic_stringbuf<char_type, traits_type, allocator_type> __sb_;
public:
};
;
template <class _CharT, class _Traits, class _Allocator>
class __attribute__ ((__type_visibility__("default"))) basic_stringstream
    : public basic_iostream<_CharT, _Traits>
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;
    typedef _Allocator allocator_type;
    typedef basic_string<char_type, traits_type, allocator_type> string_type;
private:
    basic_stringbuf<char_type, traits_type, allocator_type> __sb_;
public:
};
;
} }
namespace std { inline namespace __1 {
template<class _Tp> class __attribute__ ((__type_visibility__("default"))) complex;
;
;
template<class _Tp>
class __attribute__ ((__type_visibility__("default"))) complex
{
public:
    typedef _Tp value_type;
private:
    value_type __re_;
    value_type __im_;
public:
      ;
        ;
        ;
        ;
        ;
        ;
};
template<> class __attribute__ ((__type_visibility__("default"))) complex<double>;
template<> class __attribute__ ((__type_visibility__("default"))) complex<long double>;
template<>
class __attribute__ ((__type_visibility__("default"))) complex<float>
{
    float __re_;
    float __im_;
public:
    typedef float value_type;
        ;
        ;
        ;
        ;
        ;
};
template<>
class __attribute__ ((__type_visibility__("default"))) complex<double>
{
    double __re_;
    double __im_;
public:
    typedef double value_type;
        ;
        ;
        ;
        ;
        ;
};
template<>
class __attribute__ ((__type_visibility__("default"))) complex<long double>
{
    long double __re_;
    long double __im_;
public:
    typedef long double value_type;
        ;
        ;
        ;
        ;
        ;
};
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
template <class _Tp, bool = is_integral<_Tp>::value,
                     bool = is_floating_point<_Tp>::value
                     >
struct __libcpp_complex_overload_traits {};
template <class _Tp>
struct __libcpp_complex_overload_traits<_Tp, true, false>
{
    typedef double _ValueType;
    typedef complex<double> _ComplexType;
};
template <class _Tp>
struct __libcpp_complex_overload_traits<_Tp, false, true>
{
    typedef _Tp _ValueType;
    typedef complex<_Tp> _ComplexType;
};
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
} }
typedef std::complex<double> Complex;
typedef std::complex<float> FloatComplex;
 ; ; ;
 ; ; ;
 ; ; ;
 ; ; ;
extern const char *const sys_signame[32];
extern const char *const sys_siglist[32];
extern "C" {
;
}
extern "C" {
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
}
namespace std { inline namespace __1 {
using ::sig_atomic_t;
} }
extern "C" {
namespace octave
{
  class
  execution_exception
  {
  public:
  private:
    std::string m_stack_trace;
  };
  class
  exit_exception
  {
  public:
  private:
    int m_exit_status;
    bool m_safe_to_return;
  };
  class
  interrupt_exception
  {
  };
}
enum octave_exception
{
  octave_no_exception = 0,
  octave_exec_exception = 1,
  octave_alloc_exception = 3,
  octave_quit_exception = 4
};
           extern sig_atomic_t octave_interrupt_state;
           extern sig_atomic_t octave_exception_state;
__attribute__ ((__deprecated__))
           extern sig_atomic_t octave_exit_exception_status;
__attribute__ ((__deprecated__))
           extern sig_atomic_t octave_exit_exception_safe_to_return;
           extern volatile sig_atomic_t octave_signal_caught;
           ;
;
;
;
;
           ;
;
;;
}
extern void (*octave_signal_hook) (void);
extern void (*octave_interrupt_hook) (void);
extern void (*octave_bad_alloc_hook) (void);
;
;
enum sortmode { UNSORTED = 0, ASCENDING, DESCENDING };
template <typename T>
class
octave_sort
{
public:
  typedef bool (*compare_fcn_type) (typename ref_param<T>::type,
                                    typename ref_param<T>::type);
private:
  static const int MAX_MERGE_PENDING = 85;
  static const int MIN_GALLOP = 7;
  static const int MERGESTATE_TEMP_SIZE = 1024;
  struct s_slice
  {
    octave_idx_type base, len;
  };
  struct MergeState
  {
    octave_idx_type min_gallop;
    T *a;
    octave_idx_type *ia;
    octave_idx_type alloced;
    octave_idx_type n;
    struct s_slice pending[MAX_MERGE_PENDING];
  };
  compare_fcn_type compare;
  MergeState *ms;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
};
template <typename T>
class
vec_index
{
public:
  T vec;
  octave_idx_type indx;
};
template <typename T>
class
Array
{
protected:
  class ArrayRep
  {
  public:
    T *data;
    octave_idx_type len;
    octave::refcount<int> count;
    ;
  private:
  };
public:
  typedef T element_type;
  typedef T value_type;
  typedef octave_idx_type size_type;
  typedef typename ref_param<T>::type crefT;
  typedef bool (*compare_fcn_type) (typename ref_param<T>::type,
                                    typename ref_param<T>::type);
protected:
  dim_vector dimensions;
  typename Array<T>::ArrayRep *rep;
  T *slice_data;
  octave_idx_type slice_len;
private:
protected:
public:
  ;
  ;
public:
  Array<T> reshape (octave_idx_type nr, octave_idx_type nc) const
  ;
  Array<T> reshape (const dim_vector& new_dims) const
  ;
  Array<T> permute (const Array<octave_idx_type>& vec, bool inv = false) const;
  Array<T> ipermute (const Array<octave_idx_type>& vec) const
  ;
  bool issquare (void) const ;
  __attribute__ ((__deprecated__))
  bool is_square (void) const
  ;
  bool isempty (void) const ;
  __attribute__ ((__deprecated__))
  bool is_empty (void) const
  ;
  bool isvector (void) const ;
  __attribute__ ((__deprecated__))
  bool is_vector (void) const
  ;
  bool is_nd_vector (void) const ;
  Array<T> transpose (void) const;
  Array<T> hermitian (T (*fcn) (const T&) = nullptr) const;
  const T * data (void) const ;
  const T * fortran_vec (void) const ;
  T * fortran_vec (void);
  bool is_shared (void) ;
  int ndims (void) const ;
  Array<T> index (const idx_vector& i) const;
  Array<T> index (const idx_vector& i, const idx_vector& j) const;
  Array<T> index (const Array<idx_vector>& ia) const;
  virtual T resize_fill_value (void) const;
  void resize2 (octave_idx_type nr, octave_idx_type nc, const T& rfv);
  void resize2 (octave_idx_type nr, octave_idx_type nc)
  ;
  void resize1 (octave_idx_type n, const T& rfv);
  void resize1 (octave_idx_type n) ;
  void resize (const dim_vector& dv, const T& rfv);
  void resize (const dim_vector& dv) ;
  Array<T> index (const idx_vector& i, bool resize_ok, const T& rfv) const;
  Array<T> index (const idx_vector& i, bool resize_ok) const
  ;
  Array<T> index (const idx_vector& i, const idx_vector& j, bool resize_ok,
                  const T& rfv) const;
  Array<T> index (const idx_vector& i, const idx_vector& j,
                  bool resize_ok) const
  ;
  Array<T> index (const Array<idx_vector>& ia, bool resize_ok,
                  const T& rfv) const;
  Array<T> index (const Array<idx_vector>& ia, bool resize_ok) const
  ;
  void assign (const idx_vector& i, const Array<T>& rhs, const T& rfv);
  void assign (const idx_vector& i, const Array<T>& rhs)
  ;
  void assign (const idx_vector& i, const idx_vector& j, const Array<T>& rhs,
               const T& rfv);
  void assign (const idx_vector& i, const idx_vector& j, const Array<T>& rhs)
  ;
  void assign (const Array<idx_vector>& ia, const Array<T>& rhs, const T& rfv);
  void assign (const Array<idx_vector>& ia, const Array<T>& rhs)
  ;
  void delete_elements (const idx_vector& i);
  void delete_elements (int dim, const idx_vector& i);
  void delete_elements (const Array<idx_vector>& ia);
  Array<T>& insert (const Array<T>& a, const Array<octave_idx_type>& idx);
  Array<T>& insert (const Array<T>& a, octave_idx_type r, octave_idx_type c);
  void maybe_economize (void)
  ;
  void print_info (std::ostream& os, const std::string& prefix) const;
  void * mex_get_data (void) const ;
  Array<T> sort (int dim = 0, sortmode mode = ASCENDING) const;
  Array<T> sort (Array<octave_idx_type> &sidx, int dim = 0,
                 sortmode mode = ASCENDING) const;
  sortmode issorted (sortmode mode = UNSORTED) const;
  __attribute__ ((__deprecated__))
  sortmode is_sorted (sortmode mode = UNSORTED) const
  ;
  Array<octave_idx_type> sort_rows_idx (sortmode mode = ASCENDING) const;
  sortmode is_sorted_rows (sortmode mode = UNSORTED) const;
  octave_idx_type lookup (const T& value, sortmode mode = UNSORTED) const;
  Array<octave_idx_type> lookup (const Array<T>& values,
                                 sortmode mode = UNSORTED) const;
  octave_idx_type nnz (void) const;
  Array<octave_idx_type> find (octave_idx_type n = -1,
                               bool backward = false) const;
  Array<T> nth_element (const idx_vector& n, int dim = 0) const;
  Array<T> diag (octave_idx_type k = 0) const;
  Array<T> diag (octave_idx_type m, octave_idx_type n) const;
  static Array<T>
  cat (int dim, octave_idx_type n, const Array<T> *array_list);
  template <typename U, typename F>
  Array<U>
  map (F fcn) const
  ;
  template <typename U>
  Array<U>
  map (U (&fcn) (T)) const
  ;
  template <typename U>
  Array<U>
  map (U (&fcn) (const T&)) const
  ;
  template <typename F, bool zero>
  bool test (F fcn) const
  ;
  template <typename F>
  bool test_any (F fcn) const
  ;
  template <typename F>
  bool test_all (F fcn) const
  ;
  bool test_any (bool (&fcn) (T)) const
  ;
  bool test_any (bool (&fcn) (const T&)) const
  ;
  bool test_all (bool (&fcn) (T)) const
  ;
  bool test_all (bool (&fcn) (const T&)) const
  ;
  template <typename U> friend class Array;
  bool optimize_dimensions (const dim_vector& dv);
  int * jit_ref_count (void) ;
  T * jit_slice_data (void) const ;
  octave_idx_type * jit_dimensions (void) const ;
private:
};
template <typename ArrayClass>
class NoAlias : public ArrayClass
{
  typedef typename ArrayClass::element_type T;
public:
    ;
    ;
    ;
};
;
namespace octave
{
  class index_exception : public execution_exception
  {
  public:
  private:
    std::string index;
  protected:
    octave_idx_type nd;
    octave_idx_type dim;
    std::string var;
  };
}
struct
permute_vector
{
  octave_idx_type pidx;
  octave_idx_type iidx;
};
;
;
extern "C" {
typedef union
{
  double value;
  unsigned int word[2];
} lo_ieee_double;
typedef union
{
  float value;
  unsigned int word;
} lo_ieee_float;
;
  ;
  ;
  ;
;
;
;
;
;
;
  ;
  ;
  ;
  ;
;
;
;
;
  ;
}
namespace octave
{
  template <typename T>
  struct numeric_limits
  {
  };
  template <>
  struct numeric_limits<double>
  {
  };
  template <>
  struct numeric_limits<float>
  {
  };
}
namespace octave
{
  namespace math
  {
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
  }
}
;
template <typename T> class octave_int;
typedef octave_int<int8_t> octave_int8;
typedef octave_int<int16_t> octave_int16;
typedef octave_int<int32_t> octave_int32;
typedef octave_int<int64_t> octave_int64;
typedef octave_int<uint8_t> octave_uint8;
typedef octave_int<uint16_t> octave_uint16;
typedef octave_int<uint32_t> octave_uint32;
typedef octave_int<uint64_t> octave_uint64;
;
template <int qsize, bool qsigned>
struct query_integer_type
{
public:
  static const bool registered = false;
  typedef void type;
};
template <> class query_integer_type<sizeof (int8_t), std::numeric_limits<int8_t>::is_signed> { public: static const bool registered = true; typedef int8_t type; };
template <> class query_integer_type<sizeof (uint8_t), std::numeric_limits<uint8_t>::is_signed> { public: static const bool registered = true; typedef uint8_t type; };
template <> class query_integer_type<sizeof (int16_t), std::numeric_limits<int16_t>::is_signed> { public: static const bool registered = true; typedef int16_t type; };
template <> class query_integer_type<sizeof (uint16_t), std::numeric_limits<uint16_t>::is_signed> { public: static const bool registered = true; typedef uint16_t type; };
template <> class query_integer_type<sizeof (int32_t), std::numeric_limits<int32_t>::is_signed> { public: static const bool registered = true; typedef int32_t type; };
template <> class query_integer_type<sizeof (uint32_t), std::numeric_limits<uint32_t>::is_signed> { public: static const bool registered = true; typedef uint32_t type; };
template <> class query_integer_type<sizeof (int64_t), std::numeric_limits<int64_t>::is_signed> { public: static const bool registered = true; typedef int64_t type; };
template <> class query_integer_type<sizeof (uint64_t), std::numeric_limits<uint64_t>::is_signed> { public: static const bool registered = true; typedef uint64_t type; };
class octave_int_cmp_op
{
  template <typename T1, typename T2>
  class prom
  {
    static const bool pint = (sizeof (T1) < sizeof (int)
                              && sizeof (T2) < sizeof (int));
    static const bool t1sig = std::numeric_limits<T1>::is_signed;
    static const bool t2sig = std::numeric_limits<T2>::is_signed;
    static const bool psig =
      (pint || (sizeof (T2) > sizeof (T1) && t2sig) || t1sig);
    static const int psize =
      (pint ? sizeof (int) : (sizeof (T2) > sizeof (T1)
                              ? sizeof (T2) : sizeof (T1)));
  public:
    typedef typename query_integer_type<psize, psig>::type type;
  };
  template <typename xop, int size>
  class uiop
  {
    typedef typename query_integer_type<size, false>::type utype;
    typedef typename query_integer_type<size, true>::type stype;
  public:
  };
public:
  class lt { public: static const bool ltval = (0 < 1); static const bool gtval = (1 < 0); ; };
  class le { public: static const bool ltval = (0 <= 1); static const bool gtval = (1 <= 0); ; };
  class gt { public: static const bool ltval = (0 > 1); static const bool gtval = (1 > 0); ; };
  class ge { public: static const bool ltval = (0 >= 1); static const bool gtval = (1 >= 0); ; };
  class eq { public: static const bool ltval = (0 == 1); static const bool gtval = (1 == 0); ; };
  class ne { public: static const bool ltval = (0 != 1); static const bool gtval = (1 != 0); ; };
  class ct { public: static const bool ltval = true; static const bool gtval = true; ; };
  class cf { public: static const bool ltval = false; static const bool gtval = false; ; };
  ;
public:
  ;
  ;
  ; ; ; ;
  ; ; ; ;
};
template <typename T>
class octave_int_base
{
public:
  ;
private:
  ;
public:
  ;
};
template <typename T, bool is_signed>
class octave_int_arith_base
{ };
template <typename T>
class octave_int_arith_base<T, false> : octave_int_base<T>
{
public:
};
template <typename T>
class octave_int_arith_base<T, true> : octave_int_base<T>
{
  typedef typename query_integer_type<sizeof (T), false>::type UT;
public:
};
template <typename T>
class octave_int_arith
: public octave_int_arith_base<T, std::numeric_limits<T>::is_signed>
{ };
template <typename T>
class
octave_int : public octave_int_base<T>
{
public:
  typedef T val_type;
    ;
    ;
  static const octave_int zero, one;
private:
  T ival;
};
;
;
namespace octave
{
  namespace math
  {
    ;
  }
}
;
;
;
;
;
;
;
 ;
 ;
 ;
 ;
 ;
 ;
;
;
 ;
 ;
 ;
;
 ; ;
 ; ;
 ; ;
 ; ;
 ; ;
 ; ;
 ; ;
 ; ;
 ; ;
 ; ;
 ; ;
 ; ;
 ; ;
 ; ;
 ; ;
 ; ;
 ; ;
 ; ;
 ; ;
 ; ;
;
;
;
;
;
;
;
 ; ; ;
 ; ; ;
 ; ; ;
 ; ; ;
 ; ;
 ; ;
 ; ;
 ; ;
 ; ; ;
 ; ; ;
 ; ; ;
 ; ; ;
 ; ; ;
 ; ; ;
;
;
;
;
 ; ; ;
 ; ; ;
 ; ; ;
 ; ; ;
 ; ; ;
 ; ; ;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ; ;
 ; ;
 ; ;
 ; ;
 ; ;
 ; ;
 ; ;
 ; ;
 ; ;
 ; ;
 ; ;
 ; ;
;
;
;
;
;
;
;
;
;
;
 ;
template <typename T> class MArray;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
template <typename T>
class
MArray : public Array<T>
{
protected:
public:
    ;
};
extern "C" {
;
}
class idx_vector;
class PermMatrix;
template <typename T>
class
Sparse
{
public:
  typedef T element_type;
protected:
  class SparseRep
  {
  public:
    T *d;
    octave_idx_type *r;
    octave_idx_type *c;
    octave_idx_type nzmx;
    octave_idx_type nrows;
    octave_idx_type ncols;
    octave::refcount<int> count;
  private:
  };
public:
  typename Sparse<T>::SparseRep *rep;
  dim_vector dimensions;
private:
public:
  ;
public:
  ;
  ;
  ;
  ;
  ;
  ;
};
;
template <typename T>
class
MSparse : public Sparse<T>
{
public:
    ;
  ;
  ;
};
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
class Matrix;
class ComplexMatrix;
class FloatMatrix;
class FloatComplexMatrix;
class SparseMatrix;
class SparseComplexMatrix;
class
MatrixType
{
public:
  enum matrix_type
  {
    Unknown = 0,
    Full,
    Diagonal,
    Permuted_Diagonal,
    Upper,
    Lower,
    Permuted_Upper,
    Permuted_Lower,
    Banded,
    Hermitian,
    Banded_Hermitian,
    Tridiagonal,
    Tridiagonal_Hermitian,
    Rectangular
  };
  ;
private:
  matrix_type typ;
  double sp_bandden;
  double bandden;
  octave_idx_type upper_band;
  octave_idx_type lower_band;
  bool dense;
  bool full;
  octave_idx_type nperm;
  octave_idx_type *perm;
};
class Matrix;
class ComplexMatrix;
class FloatMatrix;
class FloatComplexMatrix;
class boolMatrix;
class charMatrix;
class NDArray;
class ComplexNDArray;
class FloatNDArray;
class FloatComplexNDArray;
class boolNDArray;
class charNDArray;
class ColumnVector;
class ComplexColumnVector;
class FloatColumnVector;
class FloatComplexColumnVector;
class RowVector;
class ComplexRowVector;
class FloatRowVector;
class FloatComplexRowVector;
class DiagMatrix;
class ComplexDiagMatrix;
class FloatDiagMatrix;
class FloatComplexDiagMatrix;
class PermMatrix;
template <typename T> class aepbalance;
template <typename T> class gepbalance;
template <typename T> class chol;
class EIG;
template <typename T> class gsvd;
template <typename T> class hess;
template <typename T> class schur;
template <typename T> class svd;
template <typename T> class lu;
template <typename T> class qr;
template <typename T> class qrp;
typedef bool (*b_d_Mapper)(double);
typedef bool (*b_c_Mapper)(const Complex&);
typedef double (*d_d_Mapper)(double);
typedef double (*d_c_Mapper)(const Complex&);
typedef Complex (*c_c_Mapper)(const Complex&);
typedef bool (*b_f_Mapper)(float);
typedef bool (*b_fc_Mapper)(const FloatComplex&);
typedef float (*f_f_Mapper)(float);
typedef float (*f_fc_Mapper)(const FloatComplex&);
typedef FloatComplex (*fc_fc_Mapper)(const FloatComplex&);
enum blas_trans_type
{
  blas_no_trans = 'N',
  blas_trans = 'T',
  blas_conj_trans = 'C'
};
class boolMatrix;
class boolNDArray;
class
boolNDArray : public Array<bool>
{
public:
  typedef boolMatrix matrix_type;
};
;
;
class
boolMatrix : public boolNDArray
{
public:
};
namespace std { inline namespace __1 {
template <class _Tp, class _VoidPtr> struct __list_node;
template <class _Tp, class _VoidPtr> struct __list_node_base;
template <class _Tp, class _VoidPtr>
struct __list_node_pointer_traits {
  typedef typename __rebind_pointer<_VoidPtr, __list_node<_Tp, _VoidPtr> >::type
        __node_pointer;
  typedef typename __rebind_pointer<_VoidPtr, __list_node_base<_Tp, _VoidPtr> >::type
        __base_pointer;
  typedef typename conditional<
          is_pointer<_VoidPtr>::value,
          __base_pointer,
          __node_pointer
  >::type __link_pointer;
  typedef typename conditional<
          is_same<__link_pointer, __node_pointer>::value,
          __base_pointer,
          __node_pointer
  >::type __non_link_pointer;
};
template <class _Tp, class _VoidPtr>
struct __list_node_base
{
    typedef __list_node_pointer_traits<_Tp, _VoidPtr> _NodeTraits;
    typedef typename _NodeTraits::__node_pointer __node_pointer;
    typedef typename _NodeTraits::__base_pointer __base_pointer;
    typedef typename _NodeTraits::__link_pointer __link_pointer;
    __link_pointer __prev_;
    __link_pointer __next_;
};
template <class _Tp, class _VoidPtr>
struct __list_node
    : public __list_node_base<_Tp, _VoidPtr>
{
    _Tp __value_;
    typedef __list_node_base<_Tp, _VoidPtr> __base;
    typedef typename __base::__link_pointer __link_pointer;
};
template <class _Tp, class _Alloc = allocator<_Tp> > class __attribute__ ((__type_visibility__("default"))) list;
template <class _Tp, class _Alloc> class __list_imp;
template <class _Tp, class _VoidPtr> class __attribute__ ((__type_visibility__("default"))) __list_const_iterator;
template <class _Tp, class _VoidPtr>
class __attribute__ ((__type_visibility__("default"))) __list_iterator
{
    typedef __list_node_pointer_traits<_Tp, _VoidPtr> _NodeTraits;
    typedef typename _NodeTraits::__link_pointer __link_pointer;
    __link_pointer __ptr_;
    template<class, class> friend class list;
    template<class, class> friend class __list_imp;
    template<class, class> friend class __list_const_iterator;
public:
    typedef bidirectional_iterator_tag iterator_category;
    typedef _Tp value_type;
    typedef value_type& reference;
    typedef typename __rebind_pointer<_VoidPtr, value_type>::type pointer;
    typedef typename pointer_traits<pointer>::difference_type difference_type;
};
template <class _Tp, class _VoidPtr>
class __attribute__ ((__type_visibility__("default"))) __list_const_iterator
{
    typedef __list_node_pointer_traits<_Tp, _VoidPtr> _NodeTraits;
    typedef typename _NodeTraits::__link_pointer __link_pointer;
    __link_pointer __ptr_;
    template<class, class> friend class list;
    template<class, class> friend class __list_imp;
public:
    typedef bidirectional_iterator_tag iterator_category;
    typedef _Tp value_type;
    typedef const value_type& reference;
    typedef typename __rebind_pointer<_VoidPtr, const value_type>::type pointer;
    typedef typename pointer_traits<pointer>::difference_type difference_type;
};
template <class _Tp, class _Alloc>
class __list_imp
{
public:
    typedef _Alloc allocator_type;
    typedef allocator_traits<allocator_type> __alloc_traits;
    typedef typename __alloc_traits::size_type size_type;
protected:
    typedef _Tp value_type;
    typedef typename __alloc_traits::void_pointer __void_pointer;
    typedef __list_iterator<value_type, __void_pointer> iterator;
    typedef __list_const_iterator<value_type, __void_pointer> const_iterator;
    typedef __list_node_base<value_type, __void_pointer> __node_base;
    typedef __list_node<value_type, __void_pointer> __node;
    typedef typename __rebind_alloc_helper<__alloc_traits, __node>::type __node_allocator;
    typedef allocator_traits<__node_allocator> __node_alloc_traits;
    typedef typename __node_alloc_traits::pointer __node_pointer;
    typedef typename __node_alloc_traits::pointer __node_const_pointer;
    typedef __list_node_pointer_traits<value_type, __void_pointer> __node_pointer_traits;
    typedef typename __node_pointer_traits::__link_pointer __link_pointer;
    typedef __link_pointer __link_const_pointer;
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::const_pointer const_pointer;
    typedef typename __alloc_traits::difference_type difference_type;
    typedef typename __rebind_alloc_helper<__alloc_traits, __node_base>::type __node_base_allocator;
    typedef typename allocator_traits<__node_base_allocator>::pointer __node_base_pointer;
    static_assert((!is_same<allocator_type, __node_allocator>::value),
                  "internal allocator type must differ from user-specified "
                  "type; otherwise overload resolution breaks");
    __node_base __end_;
    __compressed_pair<size_type, __node_allocator> __size_alloc_;
private:
};
template <class _Tp, class _Alloc >
class __attribute__ ((__type_visibility__("default"))) list
    : private __list_imp<_Tp, _Alloc>
{
    typedef __list_imp<_Tp, _Alloc> base;
    typedef typename base::__node __node;
    typedef typename base::__node_allocator __node_allocator;
    typedef typename base::__node_pointer __node_pointer;
    typedef typename base::__node_alloc_traits __node_alloc_traits;
    typedef typename base::__node_base __node_base;
    typedef typename base::__node_base_pointer __node_base_pointer;
    typedef typename base::__link_pointer __link_pointer;
public:
    typedef _Tp value_type;
    typedef _Alloc allocator_type;
    static_assert((is_same<value_type, typename allocator_type::value_type>::value),
                  "Invalid allocator::value_type");
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef typename base::pointer pointer;
    typedef typename base::const_pointer const_pointer;
    typedef typename base::size_type size_type;
    typedef typename base::difference_type difference_type;
    typedef typename base::iterator iterator;
    typedef typename base::const_iterator const_iterator;
    typedef std::__1::reverse_iterator<iterator> reverse_iterator;
    typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;
    ;
    ;
    ;
    ;
    ;
    ;
     ;
    ;
    ;
    ;
     ;
    ;
    ;
    typedef __allocator_destructor<__node_allocator> __node_destructor;
    typedef unique_ptr<__node, __node_destructor> __hold_pointer;
private:
    ;
};
;
;
;
;
;
;
;
} }
class
string_vector : public Array<std::string>
{
public:
  ;
};
class
charNDArray : public Array<char>
{
public:
  typedef charMatrix matrix_type;
};
class
charMatrix : public charNDArray
{
  friend class ComplexMatrix;
public:
};
template <typename T>
class
base_det
{
public:
private:
  T c2;
  int e2;
};
typedef base_det<double> DET;
typedef base_det<float> FloatDET;
typedef base_det<Complex> ComplexDET;
typedef base_det<FloatComplex> FloatComplexDET;
extern "C" {
;
}
template <typename T>
class
DiagArray2 : protected Array<T>
{
protected:
  octave_idx_type d1, d2;
public:
  using typename Array<T>::element_type;
    ;
private:
};
template <typename T> class MDiagArray2;
;
;
;
;
;
;
;
;
template <typename T>
class
MDiagArray2 : public DiagArray2<T>
{
public:
    ;
};
template <typename T> class intNDArray;
class
NDArray : public MArray<double>
{
public:
    ;
    ;
    ;
  friend class ComplexNDArray;
};
class
Matrix : public NDArray
{
public:
  typedef ColumnVector column_vector_type;
  typedef RowVector row_vector_type;
  typedef ColumnVector real_column_vector_type;
  typedef RowVector real_row_vector_type;
  typedef Matrix real_matrix_type;
  typedef ComplexMatrix complex_matrix_type;
  typedef DiagMatrix real_diag_matrix_type;
  typedef ComplexDiagMatrix complex_diag_matrix_type;
  typedef double real_elt_type;
  typedef Complex complex_elt_type;
  typedef void (*solve_singularity_handler) (double rcon);
    ;
    ;
  friend class ComplexMatrix;
private:
public:
private:
public:
};
;
class
ComplexNDArray : public MArray<Complex>
{
public:
    ;
    ;
};
class
ComplexMatrix : public ComplexNDArray
{
public:
  typedef ComplexColumnVector column_vector_type;
  typedef ComplexRowVector row_vector_type;
  typedef ColumnVector real_column_vector_type;
  typedef RowVector real_row_vector_type;
  typedef Matrix real_matrix_type;
  typedef ComplexMatrix complex_matrix_type;
  typedef DiagMatrix real_diag_matrix_type;
  typedef ComplexDiagMatrix complex_diag_matrix_type;
  typedef double real_elt_type;
  typedef Complex complex_elt_type;
  typedef void (*solve_singularity_handler) (double rcon);
    ;
    ;
private:
public:
private:
public:
};
template <typename T> class intNDArray;
class
FloatNDArray : public MArray<float>
{
public:
    ;
    ;
    ;
  friend class FloatComplexNDArray;
};
class
FloatMatrix : public FloatNDArray
{
public:
  typedef FloatColumnVector column_vector_type;
  typedef FloatRowVector row_vector_type;
  typedef FloatColumnVector real_column_vector_type;
  typedef FloatRowVector real_row_vector_type;
  typedef FloatMatrix real_matrix_type;
  typedef FloatComplexMatrix complex_matrix_type;
  typedef FloatDiagMatrix real_diag_matrix_type;
  typedef FloatComplexDiagMatrix complex_diag_matrix_type;
  typedef float real_elt_type;
  typedef FloatComplex complex_elt_type;
  typedef void (*solve_singularity_handler) (float rcon);
    ;
    ;
  friend class FloatComplexMatrix;
private:
public:
private:
public:
};
;
class
FloatComplexNDArray : public MArray<FloatComplex>
{
public:
    ;
    ;
};
class
FloatComplexMatrix : public FloatComplexNDArray
{
public:
  typedef FloatComplexColumnVector column_vector_type;
  typedef FloatComplexRowVector row_vector_type;
  typedef FloatColumnVector real_column_vector_type;
  typedef FloatRowVector real_row_vector_type;
  typedef FloatMatrix real_matrix_type;
  typedef FloatComplexMatrix complex_matrix_type;
  typedef FloatDiagMatrix real_diag_matrix_type;
  typedef FloatComplexDiagMatrix complex_diag_matrix_type;
  typedef float real_elt_type;
  typedef FloatComplex complex_elt_type;
  typedef void (*solve_singularity_handler) (float rcon);
    ;
    ;
private:
public:
private:
public:
};
class
ColumnVector : public MArray<double>
{
public:
};
class
ComplexColumnVector : public MArray<Complex>
{
  friend class ComplexMatrix;
  friend class ComplexRowVector;
public:
};
class
FloatColumnVector : public MArray<float>
{
public:
};
class
FloatComplexColumnVector : public MArray<FloatComplex>
{
  friend class FloatComplexMatrix;
  friend class FloatComplexRowVector;
public:
};
class
RowVector : public MArray<double>
{
public:
};
class
ComplexRowVector : public MArray<Complex>
{
  friend class ComplexColumnVector;
public:
};
class
FloatRowVector : public MArray<float>
{
public:
};
class
FloatComplexRowVector : public MArray<FloatComplex>
{
  friend class FloatComplexColumnVector;
public:
};
class
DiagMatrix : public MDiagArray2<double>
{
public:
  typedef Matrix full_matrix_type;
    ;
};
class
ComplexDiagMatrix : public MDiagArray2<Complex>
{
public:
  typedef ComplexMatrix full_matrix_type;
  typedef double real_elt_type;
  typedef Complex complex_elt_type;
  typedef Complex element_type;
    ;
};
class
FloatDiagMatrix : public MDiagArray2<float>
{
public:
  typedef FloatMatrix full_matrix_type;
    ;
};
class
FloatComplexDiagMatrix : public MDiagArray2<FloatComplex>
{
public:
  typedef FloatComplexMatrix full_matrix_type;
  typedef float real_elt_type;
  typedef FloatComplex complex_elt_type;
  typedef FloatComplex element_type;
    ;
};
class PermMatrix : protected Array<octave_idx_type>
{
public:
private:
};
class SparseBoolMatrix;
class SparseMatrix;
class
SparseBoolMatrix : public Sparse<bool>
{
public:
  typedef boolMatrix dense_matrix_type;
  ;
};
class PermMatrix;
class DiagMatrix;
class SparseComplexMatrix;
class SparseBoolMatrix;
class
SparseMatrix : public MSparse<double>
{
public:
  typedef Matrix dense_matrix_type;
  typedef void (*solve_singularity_handler) (double rcond);
private:
public:
private:
public:
};
class PermMatrix;
class DiagMatrix;
class ComplexDiagMatrix;
class SparseMatrix;
class SparseBoolMatrix;
class
SparseComplexMatrix : public MSparse<Complex>
{
public:
  typedef ComplexMatrix dense_matrix_type;
  typedef void (*solve_singularity_handler) (double rcond);
private:
public:
private:
public:
};
class NDArray;
template <typename T>
class
intNDArray : public MArray<T>
{
public:
  using typename MArray<T>::element_type;
    ;
    ;
    ;
};
;
;
typedef intNDArray<octave_int8> int8NDArray;
typedef intNDArray<octave_int16> int16NDArray;
typedef intNDArray<octave_int32> int32NDArray;
typedef intNDArray<octave_int64> int64NDArray;
typedef intNDArray<octave_uint8> uint8NDArray;
typedef intNDArray<octave_uint16> uint16NDArray;
typedef intNDArray<octave_uint32> uint32NDArray;
typedef intNDArray<octave_uint64> uint64NDArray;
namespace octave
{
  namespace math
  {
    template <typename MT>
    class aepbalance
    {
    public:
      typedef typename MT::real_column_vector_type VT;
    protected:
      MT balanced_mat;
      VT scale;
      octave_idx_type ilo;
      octave_idx_type ihi;
      char job;
    };
  }
}
namespace octave
{
  namespace math
  {
    template <typename T>
    class
    gepbalance
    {
    public:
      typedef typename T::real_matrix_type RT;
    private:
      T balanced_mat;
      T balanced_mat2;
      RT balancing_mat;
      RT balancing_mat2;
    };
  }
}
namespace octave
{
  namespace math
  {
    template <typename T>
    class
    chol
    {
    public:
      typedef typename T::column_vector_type VT;
      typedef typename T::real_elt_type COND_T;
    private:
      T chol_mat;
      COND_T xrcond;
      bool is_upper;
    };
    ;
  }
}
namespace octave
{
  namespace math
  {
    template <typename T>
    class
    hess
    {
    public:
    private:
      T hess_mat;
      T unitary_hess_mat;
    };
    ;
  }
}
namespace octave
{
  namespace math
  {
    template <typename T>
    class
    schur
    {
    public:
    protected:
    private:
      T schur_mat;
      T unitary_mat;
    };
    ;
  }
}
namespace std { inline namespace __1 {
template <bool>
class __split_buffer_common
{
protected:
};
template <class _Tp, class _Allocator = allocator<_Tp> >
struct __split_buffer
    : private __split_buffer_common<true>
{
private:
public:
    typedef _Tp value_type;
    typedef _Allocator allocator_type;
    typedef typename remove_reference<allocator_type>::type __alloc_rr;
    typedef allocator_traits<__alloc_rr> __alloc_traits;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef typename __alloc_traits::size_type size_type;
    typedef typename __alloc_traits::difference_type difference_type;
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::const_pointer const_pointer;
    typedef pointer iterator;
    typedef const_pointer const_iterator;
    pointer __first_;
    pointer __begin_;
    pointer __end_;
    __compressed_pair<pointer, allocator_type> __end_cap_;
    typedef typename add_lvalue_reference<allocator_type>::type __alloc_ref;
    typedef typename add_lvalue_reference<allocator_type>::type __alloc_const_ref;
    ;
    void __construct_at_end(size_type __n);
    void __construct_at_end(size_type __n, const_reference __x);
    template <class _InputIter>
        typename enable_if
        <
            __is_input_iterator<_InputIter>::value &&
           !__is_forward_iterator<_InputIter>::value,
            void
        >::type
        __construct_at_end(_InputIter __first, _InputIter __last);
    template <class _ForwardIterator>
        typename enable_if
        <
            __is_forward_iterator<_ForwardIterator>::value,
            void
        >::type
        __construct_at_end(_ForwardIterator __first, _ForwardIterator __last);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void __destruct_at_begin(pointer __new_begin)
        ;
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        void __destruct_at_begin(pointer __new_begin, false_type);
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        void __destruct_at_begin(pointer __new_begin, true_type);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __destruct_at_end(pointer __new_last) noexcept
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        void __destruct_at_end(pointer __new_last, false_type) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        void __destruct_at_end(pointer __new_last, true_type) noexcept;
    void swap(__split_buffer& __x)
        noexcept(!__alloc_traits::propagate_on_container_swap::value|| __is_nothrow_swappable<__alloc_rr>::value);
    bool __invariants() const;
private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __move_assign_alloc(__split_buffer& __c, true_type)
        noexcept(is_nothrow_move_assignable<allocator_type>::value)
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __move_assign_alloc(__split_buffer&, false_type) noexcept
        ;
};
template <class _Tp, class _Allocator>
 __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
swap(__split_buffer<_Tp, _Allocator>& __x, __split_buffer<_Tp, _Allocator>& __y)
        noexcept(noexcept(__x.swap(__y)))
;
} }
namespace std { inline namespace __1 {
template <bool>
class __vector_base_common
{
protected:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __vector_base_common() ;
    [[noreturn]] void __throw_length_error() const;
    [[noreturn]] void __throw_out_of_range() const;
};
extern template class __attribute__ ((__visibility__("default"))) __vector_base_common<true>;
template <class _Tp, class _Allocator>
class __vector_base
    : protected __vector_base_common<true>
{
public:
    typedef _Allocator allocator_type;
    typedef allocator_traits<allocator_type> __alloc_traits;
    typedef typename __alloc_traits::size_type size_type;
protected:
    typedef _Tp value_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef typename __alloc_traits::difference_type difference_type;
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::const_pointer const_pointer;
    typedef pointer iterator;
    typedef const_pointer const_iterator;
    pointer __begin_;
    pointer __end_;
    __compressed_pair<pointer, allocator_type> __end_cap_;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    allocator_type& __alloc() noexcept
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const allocator_type& __alloc() const noexcept
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pointer& __end_cap() noexcept
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const pointer& __end_cap() const noexcept
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __vector_base()
        noexcept(is_nothrow_default_constructible<allocator_type>::value);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __vector_base(const allocator_type& __a);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __vector_base(allocator_type&& __a) noexcept;
    ~__vector_base();
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void clear() noexcept ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type capacity() const noexcept
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __destruct_at_end(pointer __new_last) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __copy_assign_alloc(const __vector_base& __c)
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __move_assign_alloc(__vector_base& __c)
        noexcept(!__alloc_traits::propagate_on_container_move_assignment::value || is_nothrow_move_assignable<allocator_type>::value)
        ;
private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __copy_assign_alloc(const __vector_base& __c, true_type)
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __copy_assign_alloc(const __vector_base&, false_type)
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __move_assign_alloc(__vector_base& __c, true_type)
        noexcept(is_nothrow_move_assignable<allocator_type>::value)
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __move_assign_alloc(__vector_base&, false_type)
        noexcept
        ;
};
template <class _Tp, class _Allocator >
class __attribute__ ((__type_visibility__("default"))) vector
    : private __vector_base<_Tp, _Allocator>
{
private:
    typedef __vector_base<_Tp, _Allocator> __base;
    typedef allocator<_Tp> __default_allocator_type;
public:
    typedef vector __self;
    typedef _Tp value_type;
    typedef _Allocator allocator_type;
    typedef typename __base::__alloc_traits __alloc_traits;
    typedef typename __base::reference reference;
    typedef typename __base::const_reference const_reference;
    typedef typename __base::size_type size_type;
    typedef typename __base::difference_type difference_type;
    typedef typename __base::pointer pointer;
    typedef typename __base::const_pointer const_pointer;
    typedef __wrap_iter<pointer> iterator;
    typedef __wrap_iter<const_pointer> const_iterator;
    typedef std::__1::reverse_iterator<iterator> reverse_iterator;
    typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;
    static_assert((is_same<typename allocator_type::value_type, value_type>::value),
                  "Allocator::value_type must be same type as value_type");
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    vector() noexcept(is_nothrow_default_constructible<allocator_type>::value)
        ;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit vector(const allocator_type& __a)
        noexcept(is_nothrow_copy_constructible<allocator_type>::value)
    ;
    explicit vector(size_type __n);
    vector(size_type __n, const value_type& __x);
    vector(size_type __n, const value_type& __x, const allocator_type& __a);
    template <class _InputIterator>
        vector(_InputIterator __first,
               typename enable_if<__is_input_iterator <_InputIterator>::value &&
                                 !__is_forward_iterator<_InputIterator>::value &&
                                 is_constructible<
                                    value_type,
                                    typename iterator_traits<_InputIterator>::reference>::value,
                                 _InputIterator>::type __last);
    template <class _InputIterator>
        vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,
               typename enable_if<__is_input_iterator <_InputIterator>::value &&
                                 !__is_forward_iterator<_InputIterator>::value &&
                                 is_constructible<
                                    value_type,
                                    typename iterator_traits<_InputIterator>::reference>::value>::type* = 0);
    template <class _ForwardIterator>
        vector(_ForwardIterator __first,
               typename enable_if<__is_forward_iterator<_ForwardIterator>::value &&
                                 is_constructible<
                                    value_type,
                                    typename iterator_traits<_ForwardIterator>::reference>::value,
                                 _ForwardIterator>::type __last);
    template <class _ForwardIterator>
        vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,
               typename enable_if<__is_forward_iterator<_ForwardIterator>::value &&
                                 is_constructible<
                                    value_type,
                                    typename iterator_traits<_ForwardIterator>::reference>::value>::type* = 0);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    ~vector()
    ;
    vector(const vector& __x);
    vector(const vector& __x, const allocator_type& __a);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    vector& operator=(const vector& __x);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    vector(initializer_list<value_type> __il);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    vector(initializer_list<value_type> __il, const allocator_type& __a);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    vector(vector&& __x)
        noexcept(is_nothrow_move_constructible<allocator_type>::value);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    vector(vector&& __x, const allocator_type& __a);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    vector& operator=(vector&& __x)
        noexcept((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value));
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    vector& operator=(initializer_list<value_type> __il)
        ;
    template <class _InputIterator>
        typename enable_if
        <
             __is_input_iterator <_InputIterator>::value &&
            !__is_forward_iterator<_InputIterator>::value &&
            is_constructible<
                 value_type,
                 typename iterator_traits<_InputIterator>::reference>::value,
            void
        >::type
        assign(_InputIterator __first, _InputIterator __last);
    template <class _ForwardIterator>
        typename enable_if
        <
            __is_forward_iterator<_ForwardIterator>::value &&
            is_constructible<
                 value_type,
                 typename iterator_traits<_ForwardIterator>::reference>::value,
            void
        >::type
        assign(_ForwardIterator __first, _ForwardIterator __last);
     ;
    ;
    ;
    ;
    ;
private:
    ;
    ;
    ;
    struct __RAII_IncreaseAnnotator {
    };
};
template <class _Allocator> class vector<bool, _Allocator>;
template <class _Allocator> struct hash<vector<bool, _Allocator> >;
template <class _Allocator>
struct __has_storage_type<vector<bool, _Allocator> >
{
    static const bool value = true;
};
template <class _Allocator>
class __attribute__ ((__type_visibility__("default"))) vector<bool, _Allocator>
    : private __vector_base_common<true>
{
public:
    typedef vector __self;
    typedef bool value_type;
    typedef _Allocator allocator_type;
    typedef allocator_traits<allocator_type> __alloc_traits;
    typedef typename __alloc_traits::size_type size_type;
    typedef typename __alloc_traits::difference_type difference_type;
    typedef size_type __storage_type;
    typedef __bit_iterator<vector, false> pointer;
    typedef __bit_iterator<vector, true> const_pointer;
    typedef pointer iterator;
    typedef const_pointer const_iterator;
    typedef std::__1::reverse_iterator<iterator> reverse_iterator;
    typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;
private:
    typedef typename __rebind_alloc_helper<__alloc_traits, __storage_type>::type __storage_allocator;
    typedef allocator_traits<__storage_allocator> __storage_traits;
    typedef typename __storage_traits::pointer __storage_pointer;
    typedef typename __storage_traits::const_pointer __const_storage_pointer;
    __storage_pointer __begin_;
    size_type __size_;
    __compressed_pair<size_type, __storage_allocator> __cap_alloc_;
public:
    typedef __bit_reference<vector> reference;
    typedef __bit_const_reference<vector> const_reference;
private:
    static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * 8);
public:
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
private:
    ;
    friend class __bit_reference<vector>;
    friend class __bit_const_reference<vector>;
    friend class __bit_iterator<vector, false>;
    friend class __bit_iterator<vector, true>;
    friend struct __bit_array<vector>;
    friend struct __attribute__ ((__type_visibility__("default"))) hash<vector>;
};
template <class _Allocator>
struct __attribute__ ((__type_visibility__("default"))) hash<vector<bool, _Allocator> >
    : public unary_function<vector<bool, _Allocator>, size_t>
{
};
;
;
;
;
;
;
;
} }
namespace octave
{
  namespace math
  {
    template <typename T>
    class
    svd
    {
    public:
      typedef typename T::real_diag_matrix_type DM_T;
      enum class Type
      {
        std,
        economy,
        sigma_only
      };
      enum class Driver
      {
        GESVD,
        GESDD
      };
    private:
      typedef typename T::element_type P;
      typedef typename DM_T::element_type DM_P;
      svd::Type m_type;
      svd::Driver m_driver;
      T left_sm;
      DM_T sigma;
      T right_sm;
    };
  }
}
class Matrix;
class
EIG
{
  friend class Matrix;
  friend class ComplexMatrix;
public:
private:
  ComplexColumnVector lambda;
  ComplexMatrix v;
  ComplexMatrix w;
};
namespace octave
{
  namespace math
  {
    template <typename T>
    class
    gsvd
    {
    public:
      enum class Type
      {
        std,
        economy,
        sigma_only
      };
    private:
      typedef typename T::value_type P;
      typedef typename T::real_matrix_type real_matrix;
      gsvd::Type type;
      typename T::real_diag_matrix_type sigmaA, sigmaB;
      T left_smA, left_smB;
      T right_sm, R;
    };
  }
}
class ColumnVector;
class PermMatrix;
namespace octave
{
  namespace math
  {
    template <typename T>
    class
    lu
    {
    public:
      typedef typename T::column_vector_type VT;
      typedef typename T::element_type ELT_T;
    protected:
      T a_fact;
      T l_fact;
      Array<octave_f77_int_type> ipvt;
    };
  }
}
template <typename T> class Array;
namespace octave
{
  namespace math
  {
    template <typename T>
    class
    qr
    {
    public:
      typedef typename T::element_type ELT_T;
      typedef typename T::row_vector_type RV_T;
      typedef typename T::column_vector_type CV_T;
      enum type
      {
        std,
        raw,
        economy
      };
    protected:
      T q;
      T r;
    };
  }
}
namespace std { inline namespace __1 {
template <class _Tp, class _Compare, class _Allocator> class __tree;
template <class _Tp, class _NodePtr, class _DiffType>
    class __attribute__ ((__type_visibility__("default"))) __tree_iterator;
template <class _Tp, class _ConstNodePtr, class _DiffType>
    class __attribute__ ((__type_visibility__("default"))) __tree_const_iterator;
template <class _Pointer> class __tree_end_node;
template <class _VoidPtr> class __tree_node_base;
template <class _Tp, class _VoidPtr> class __tree_node;
template <class _Key, class _Value>
struct __value_type;
template <class _Allocator> class __map_node_destructor;
template <class _TreeIterator> class __attribute__ ((__type_visibility__("default"))) __map_iterator;
template <class _TreeIterator> class __attribute__ ((__type_visibility__("default"))) __map_const_iterator;
;
;
;
;
;
;
;
;
;
;
;
;
;
template <class _Tp>
struct __is_tree_value_type_imp : false_type {};
template <class _Key, class _Value>
struct __is_tree_value_type_imp<__value_type<_Key, _Value>> : true_type {};
template <class ..._Args>
struct __is_tree_value_type : false_type {};
template <class _One>
struct __is_tree_value_type<_One> : __is_tree_value_type_imp<typename __uncvref<_One>::type> {};
template <class _Tp>
struct __tree_key_value_types {
  typedef _Tp key_type;
  typedef _Tp __node_value_type;
  typedef _Tp __container_value_type;
  static const bool __is_map = false;
};
template <class _Key, class _Tp>
struct __tree_key_value_types<__value_type<_Key, _Tp> > {
  typedef _Key key_type;
  typedef _Tp mapped_type;
  typedef __value_type<_Key, _Tp> __node_value_type;
  typedef pair<const _Key, _Tp> __container_value_type;
  typedef __container_value_type __map_value_type;
  static const bool __is_map = true;
   ;
   ;
};
template <class _VoidPtr>
struct __tree_node_base_types {
  typedef _VoidPtr __void_pointer;
  typedef __tree_node_base<__void_pointer> __node_base_type;
  typedef typename __rebind_pointer<_VoidPtr, __node_base_type>::type
                                                             __node_base_pointer;
  typedef __tree_end_node<__node_base_pointer> __end_node_type;
  typedef typename __rebind_pointer<_VoidPtr, __end_node_type>::type
                                                             __end_node_pointer;
  typedef typename conditional<
      is_pointer<__end_node_pointer>::value,
        __end_node_pointer,
        __node_base_pointer>::type __parent_pointer;
private:
  static_assert((is_same<typename pointer_traits<_VoidPtr>::element_type, void>::value),
                  "_VoidPtr does not point to unqualified void type");
};
template <class _Tp, class _AllocPtr, class _KVTypes = __tree_key_value_types<_Tp>,
         bool = _KVTypes::__is_map>
struct __tree_map_pointer_types {};
template <class _Tp, class _AllocPtr, class _KVTypes>
struct __tree_map_pointer_types<_Tp, _AllocPtr, _KVTypes, true> {
  typedef typename _KVTypes::__map_value_type _Mv;
  typedef typename __rebind_pointer<_AllocPtr, _Mv>::type
                                                       __map_value_type_pointer;
  typedef typename __rebind_pointer<_AllocPtr, const _Mv>::type
                                                 __const_map_value_type_pointer;
};
template <class _NodePtr, class _NodeT = typename pointer_traits<_NodePtr>::element_type>
struct __tree_node_types;
template <class _NodePtr, class _Tp, class _VoidPtr>
struct __tree_node_types<_NodePtr, __tree_node<_Tp, _VoidPtr> >
    : public __tree_node_base_types<_VoidPtr>,
             __tree_key_value_types<_Tp>,
             __tree_map_pointer_types<_Tp, _VoidPtr>
{
  typedef __tree_node_base_types<_VoidPtr> __base;
  typedef __tree_key_value_types<_Tp> __key_base;
  typedef __tree_map_pointer_types<_Tp, _VoidPtr> __map_pointer_base;
public:
  typedef typename pointer_traits<_NodePtr>::element_type __node_type;
  typedef _NodePtr __node_pointer;
  typedef _Tp __node_value_type;
  typedef typename __rebind_pointer<_VoidPtr, __node_value_type>::type
                                                      __node_value_type_pointer;
  typedef typename __rebind_pointer<_VoidPtr, const __node_value_type>::type
                                                __const_node_value_type_pointer;
  typedef typename conditional<
      is_pointer<__node_pointer>::value,
        typename __base::__end_node_pointer,
        __node_pointer>::type __iter_pointer;
private:
    static_assert(!is_const<__node_type>::value,
                "_NodePtr should never be a pointer to const");
    static_assert((is_same<typename __rebind_pointer<_VoidPtr, __node_type>::type,
                          _NodePtr>::value), "_VoidPtr does not rebind to _NodePtr.");
};
template <class _ValueTp, class _VoidPtr>
struct __make_tree_node_types {
  typedef typename __rebind_pointer<_VoidPtr, __tree_node<_ValueTp, _VoidPtr> >::type
                                                                        _NodePtr;
  typedef __tree_node_types<_NodePtr> type;
};
template <class _Pointer>
class __tree_end_node
{
public:
    typedef _Pointer pointer;
    pointer __left_;
};
template <class _VoidPtr>
class __tree_node_base
    : public __tree_node_base_types<_VoidPtr>::__end_node_type
{
    typedef __tree_node_base_types<_VoidPtr> _NodeBaseTypes;
public:
    typedef typename _NodeBaseTypes::__node_base_pointer pointer;
    typedef typename _NodeBaseTypes::__parent_pointer __parent_pointer;
    pointer __right_;
    __parent_pointer __parent_;
    bool __is_black_;
private:
};
template <class _Tp, class _VoidPtr>
class __tree_node
    : public __tree_node_base<_VoidPtr>
{
public:
    typedef _Tp __node_value_type;
    __node_value_type __value_;
private:
};
template <class _Allocator>
class __tree_node_destructor
{
    typedef _Allocator allocator_type;
    typedef allocator_traits<allocator_type> __alloc_traits;
public:
    typedef typename __alloc_traits::pointer pointer;
private:
    typedef __tree_node_types<pointer> _NodeTypes;
    allocator_type& __na_;
public:
    bool __value_constructed;
    template <class> friend class __map_node_destructor;
};
template <class _Tp, class _NodePtr, class _DiffType>
class __attribute__ ((__type_visibility__("default"))) __tree_iterator
{
    typedef __tree_node_types<_NodePtr> _NodeTypes;
    typedef _NodePtr __node_pointer;
    typedef typename _NodeTypes::__node_base_pointer __node_base_pointer;
    typedef typename _NodeTypes::__end_node_pointer __end_node_pointer;
    typedef typename _NodeTypes::__iter_pointer __iter_pointer;
    typedef pointer_traits<__node_pointer> __pointer_traits;
    __iter_pointer __ptr_;
public:
    typedef bidirectional_iterator_tag iterator_category;
    typedef _Tp value_type;
    typedef _DiffType difference_type;
    typedef value_type& reference;
    typedef typename _NodeTypes::__node_value_type_pointer pointer;
private:
    template <class, class, class> friend class __tree;
    template <class, class, class> friend class __attribute__ ((__type_visibility__("default"))) __tree_const_iterator;
    template <class> friend class __attribute__ ((__type_visibility__("default"))) __map_iterator;
    template <class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) map;
    template <class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) multimap;
    template <class, class, class> friend class __attribute__ ((__type_visibility__("default"))) set;
    template <class, class, class> friend class __attribute__ ((__type_visibility__("default"))) multiset;
};
template <class _Tp, class _NodePtr, class _DiffType>
class __attribute__ ((__type_visibility__("default"))) __tree_const_iterator
{
    typedef __tree_node_types<_NodePtr> _NodeTypes;
    typedef typename _NodeTypes::__node_pointer __node_pointer;
    typedef typename _NodeTypes::__node_base_pointer __node_base_pointer;
    typedef typename _NodeTypes::__end_node_pointer __end_node_pointer;
    typedef typename _NodeTypes::__iter_pointer __iter_pointer;
    typedef pointer_traits<__node_pointer> __pointer_traits;
    __iter_pointer __ptr_;
public:
    typedef bidirectional_iterator_tag iterator_category;
    typedef _Tp value_type;
    typedef _DiffType difference_type;
    typedef const value_type& reference;
    typedef typename _NodeTypes::__const_node_value_type_pointer pointer;
private:
    typedef __tree_iterator<value_type, __node_pointer, difference_type>
                                                           __non_const_iterator;
public:
private:
    template <class, class, class> friend class __tree;
    template <class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) map;
    template <class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) multimap;
    template <class, class, class> friend class __attribute__ ((__type_visibility__("default"))) set;
    template <class, class, class> friend class __attribute__ ((__type_visibility__("default"))) multiset;
    template <class> friend class __attribute__ ((__type_visibility__("default"))) __map_const_iterator;
};
template<class _Tp, class _Compare>
    __attribute__((diagnose_if(!std::__invokable<_Compare const&, _Tp const&, _Tp const&>::value, "the specified comparator type does not provide a const call operator", "warning")))
int __diagnose_non_const_comparator();
template <class _Tp, class _Compare, class _Allocator>
class __tree
{
public:
    typedef _Tp value_type;
    typedef _Compare value_compare;
    typedef _Allocator allocator_type;
private:
    typedef allocator_traits<allocator_type> __alloc_traits;
    typedef typename __make_tree_node_types<value_type,
        typename __alloc_traits::void_pointer>::type
                                                    _NodeTypes;
    typedef typename _NodeTypes::key_type key_type;
public:
    typedef typename _NodeTypes::__node_value_type __node_value_type;
    typedef typename _NodeTypes::__container_value_type __container_value_type;
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::const_pointer const_pointer;
    typedef typename __alloc_traits::size_type size_type;
    typedef typename __alloc_traits::difference_type difference_type;
public:
    typedef typename _NodeTypes::__void_pointer __void_pointer;
    typedef typename _NodeTypes::__node_type __node;
    typedef typename _NodeTypes::__node_pointer __node_pointer;
    typedef typename _NodeTypes::__node_base_type __node_base;
    typedef typename _NodeTypes::__node_base_pointer __node_base_pointer;
    typedef typename _NodeTypes::__end_node_type __end_node_t;
    typedef typename _NodeTypes::__end_node_pointer __end_node_ptr;
    typedef typename _NodeTypes::__parent_pointer __parent_pointer;
    typedef typename _NodeTypes::__iter_pointer __iter_pointer;
    typedef typename __rebind_alloc_helper<__alloc_traits, __node>::type __node_allocator;
    typedef allocator_traits<__node_allocator> __node_traits;
private:
    static_assert((is_same<__node_pointer, typename __node_traits::pointer>::value),
                  "Allocator does not rebind pointers in a sane manner.");
    typedef typename __rebind_alloc_helper<__node_traits, __node_base>::type
        __node_base_allocator;
    typedef allocator_traits<__node_base_allocator> __node_base_traits;
    static_assert((is_same<__node_base_pointer, typename __node_base_traits::pointer>::value),
                 "Allocator does not rebind pointers in a sane manner.");
private:
    __iter_pointer __begin_node_;
    __compressed_pair<__end_node_t, __node_allocator> __pair1_;
    __compressed_pair<size_type, value_compare> __pair3_;
public:
private:
public:
private:
public:
public:
    typedef __tree_iterator<value_type, __node_pointer, difference_type> iterator;
    typedef __tree_const_iterator<value_type, __node_pointer, difference_type> const_iterator;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
     ;
     ;
     ;
     ;
     ;
     ;
     ;
     ;
     ;
     ;
     ;
     ;
     ;
     ;
     ;
     ;
    ;
    ;
    ;
    ;
    ;
    ;
            ;
    ;
            ;
    ;
            ;
    ;
            ;
    ;
    ;
    ;
    ;
    ;
    typedef __tree_node_destructor<__node_allocator> _Dp;
    typedef unique_ptr<__node, _Dp> __node_holder;
private:
    ;
     ;
    ;
    ;
    template <class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) map;
    template <class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) multimap;
};
;
} }
namespace std
{
class __attribute__ ((__visibility__("default"))) __attribute__((availability(macosx,strict,introduced=10.14))) __attribute__((availability(ios,strict,introduced=12.0))) __attribute__((availability(tvos,strict,introduced=12.0))) __attribute__((availability(watchos,strict,introduced=5.0))) bad_optional_access
    : public exception
{
public:
};
}
namespace std { inline namespace __1 {
} }
namespace std { inline namespace __1 {
template <class _Key, class _Compare, class _Allocator>
class multiset;
template <class _Key, class _Compare = less<_Key>,
          class _Allocator = allocator<_Key> >
class __attribute__ ((__type_visibility__("default"))) set
{
public:
    typedef _Key key_type;
    typedef key_type value_type;
    typedef _Compare key_compare;
    typedef key_compare value_compare;
    typedef _Allocator allocator_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    static_assert(sizeof(__diagnose_non_const_comparator<_Key, _Compare>()), "");
    static_assert((is_same<typename allocator_type::value_type, value_type>::value),
                  "Allocator::value_type must be same type as value_type");
private:
    typedef __tree<value_type, value_compare, allocator_type> __base;
    typedef allocator_traits<allocator_type> __alloc_traits;
    typedef typename __base::__node_holder __node_holder;
    __base __tree_;
public:
    typedef typename __base::pointer pointer;
    typedef typename __base::const_pointer const_pointer;
    typedef typename __base::size_type size_type;
    typedef typename __base::difference_type difference_type;
    typedef typename __base::const_iterator iterator;
    typedef typename __base::const_iterator const_iterator;
    typedef std::__1::reverse_iterator<iterator> reverse_iterator;
    typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;
    template <class _Key2, class _Compare2, class _Alloc2>
        friend class __attribute__ ((__type_visibility__("default"))) set;
    template <class _Key2, class _Compare2, class _Alloc2>
        friend class __attribute__ ((__type_visibility__("default"))) multiset;
        ;
        ;
            ;
            ;
        ;
};
;
;
;
;
;
;
;
template <class _Key, class _Compare = less<_Key>,
          class _Allocator = allocator<_Key> >
class __attribute__ ((__type_visibility__("default"))) multiset
{
public:
    typedef _Key key_type;
    typedef key_type value_type;
    typedef _Compare key_compare;
    typedef key_compare value_compare;
    typedef _Allocator allocator_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    static_assert(sizeof(__diagnose_non_const_comparator<_Key, _Compare>()), "");
    static_assert((is_same<typename allocator_type::value_type, value_type>::value),
                  "Allocator::value_type must be same type as value_type");
private:
    typedef __tree<value_type, value_compare, allocator_type> __base;
    typedef allocator_traits<allocator_type> __alloc_traits;
    typedef typename __base::__node_holder __node_holder;
    __base __tree_;
public:
    typedef typename __base::pointer pointer;
    typedef typename __base::const_pointer const_pointer;
    typedef typename __base::size_type size_type;
    typedef typename __base::difference_type difference_type;
    typedef typename __base::const_iterator iterator;
    typedef typename __base::const_iterator const_iterator;
    typedef std::__1::reverse_iterator<iterator> reverse_iterator;
    typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;
    template <class _Key2, class _Compare2, class _Alloc2>
        friend class __attribute__ ((__type_visibility__("default"))) set;
    template <class _Key2, class _Compare2, class _Alloc2>
        friend class __attribute__ ((__type_visibility__("default"))) multiset;
        ;
        ;
            ;
            ;
        ;
};
;
;
;
;
;
;
;
} }
namespace octave
{
  namespace sys
  {
    class base_tm;
    class
    time
    {
    public:
    private:
      time_t ot_unix_time;
      long ot_usec;
    };
    class
    base_tm
    {
    public:
    protected:
      int m_usec;
      int m_sec;
      int m_min;
      int m_hour;
      int m_mday;
      int m_mon;
      int m_year;
      int m_wday;
      int m_yday;
      int m_isdst;
      long m_gmtoff;
      std::string m_zone;
    };
    class
    localtime : public base_tm
    {
    public:
    private:
    };
    class
    gmtime : public base_tm
    {
    public:
    private:
    };
    class
    strptime : public base_tm
    {
    public:
    private:
      int nchars;
    };
    class
    cpu_time
    {
    public:
      friend class resource_usage;
    private:
      time_t m_usr_sec;
      time_t m_sys_sec;
      long m_usr_usec;
      long m_sys_usec;
    };
    class
    resource_usage
    {
    public:
    private:
      cpu_time m_cpu;
      long m_maxrss;
      long m_ixrss;
      long m_idrss;
      long m_isrss;
      long m_minflt;
      long m_majflt;
      long m_nswap;
      long m_inblock;
      long m_oublock;
      long m_msgsnd;
      long m_msgrcv;
      long m_nsignals;
      long m_nvcsw;
      long m_nivcsw;
    };
  }
}
namespace std { inline namespace __1 {
template <class _Key, class _CP, class _Compare,
          bool = is_empty<_Compare>::value && !__libcpp_is_final<_Compare>::value>
class __map_value_compare
    : private _Compare
{
public:
};
template <class _Key, class _CP, class _Compare>
class __map_value_compare<_Key, _CP, _Compare, false>
{
    _Compare comp;
public:
};
;
template <class _Allocator>
class __map_node_destructor
{
    typedef _Allocator allocator_type;
    typedef allocator_traits<allocator_type> __alloc_traits;
public:
    typedef typename __alloc_traits::pointer pointer;
private:
    allocator_type& __na_;
public:
    bool __first_constructed;
    bool __second_constructed;
};
template <class _Key, class _Tp, class _Compare, class _Allocator>
    class map;
template <class _Key, class _Tp, class _Compare, class _Allocator>
    class multimap;
template <class _TreeIterator> class __map_const_iterator;
template <class _Key, class _Tp>
struct __value_type
{
    typedef _Key key_type;
    typedef _Tp mapped_type;
    typedef pair<const key_type, mapped_type> value_type;
    typedef pair<key_type&, mapped_type&> __nc_ref_pair_type;
    typedef pair<key_type&&, mapped_type&&> __nc_rref_pair_type;
private:
    value_type __cc;
public:
    ;
private:
};
template <class _Tp>
struct __extract_key_value_types;
template <class _Key, class _Tp>
struct __extract_key_value_types<__value_type<_Key, _Tp> >
{
  typedef _Key const __key_type;
  typedef _Tp __mapped_type;
};
template <class _TreeIterator>
class __attribute__ ((__type_visibility__("default"))) __map_iterator
{
    typedef typename _TreeIterator::_NodeTypes _NodeTypes;
    typedef typename _TreeIterator::__pointer_traits __pointer_traits;
    _TreeIterator __i_;
public:
    typedef bidirectional_iterator_tag iterator_category;
    typedef typename _NodeTypes::__map_value_type value_type;
    typedef typename _TreeIterator::difference_type difference_type;
    typedef value_type& reference;
    typedef typename _NodeTypes::__map_value_type_pointer pointer;
    template <class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) map;
    template <class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) multimap;
    template <class> friend class __attribute__ ((__type_visibility__("default"))) __map_const_iterator;
};
template <class _TreeIterator>
class __attribute__ ((__type_visibility__("default"))) __map_const_iterator
{
    typedef typename _TreeIterator::_NodeTypes _NodeTypes;
    typedef typename _TreeIterator::__pointer_traits __pointer_traits;
    _TreeIterator __i_;
public:
    typedef bidirectional_iterator_tag iterator_category;
    typedef typename _NodeTypes::__map_value_type value_type;
    typedef typename _TreeIterator::difference_type difference_type;
    typedef const value_type& reference;
    typedef typename _NodeTypes::__const_map_value_type_pointer pointer;
    template <class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) map;
    template <class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) multimap;
    template <class, class, class> friend class __attribute__ ((__type_visibility__("default"))) __tree_const_iterator;
};
template <class _Key, class _Tp, class _Compare = less<_Key>,
          class _Allocator = allocator<pair<const _Key, _Tp> > >
class __attribute__ ((__type_visibility__("default"))) map
{
public:
    typedef _Key key_type;
    typedef _Tp mapped_type;
    typedef pair<const key_type, mapped_type> value_type;
    typedef _Compare key_compare;
    typedef _Allocator allocator_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    static_assert(sizeof(__diagnose_non_const_comparator<_Key, _Compare>()), "");
    static_assert((is_same<typename allocator_type::value_type, value_type>::value),
                  "Allocator::value_type must be same type as value_type");
    class __attribute__ ((__type_visibility__("default"))) value_compare
        : public binary_function<value_type, value_type, bool>
    {
        friend class map;
    protected:
        key_compare comp;
    public:
    };
private:
    typedef std::__1::__value_type<key_type, mapped_type> __value_type;
    typedef __map_value_compare<key_type, __value_type, key_compare> __vc;
    typedef typename __rebind_alloc_helper<allocator_traits<allocator_type>,
                                                 __value_type>::type __allocator_type;
    typedef __tree<__value_type, __vc, __allocator_type> __base;
    typedef typename __base::__node_traits __node_traits;
    typedef allocator_traits<allocator_type> __alloc_traits;
    __base __tree_;
public:
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::const_pointer const_pointer;
    typedef typename __alloc_traits::size_type size_type;
    typedef typename __alloc_traits::difference_type difference_type;
    typedef __map_iterator<typename __base::iterator> iterator;
    typedef __map_const_iterator<typename __base::const_iterator> const_iterator;
    typedef std::__1::reverse_iterator<iterator> reverse_iterator;
    typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;
    template <class _Key2, class _Value2, class _Comp2, class _Alloc2>
        friend class __attribute__ ((__type_visibility__("default"))) map;
    template <class _Key2, class _Value2, class _Comp2, class _Alloc2>
        friend class __attribute__ ((__type_visibility__("default"))) multimap;
        ;
        ;
     ;
     ;
            ;
            ;
        ;
private:
    typedef typename __base::__node __node;
    typedef typename __base::__node_allocator __node_allocator;
    typedef typename __base::__node_pointer __node_pointer;
    typedef typename __base::__node_base_pointer __node_base_pointer;
    typedef typename __base::__parent_pointer __parent_pointer;
    typedef __map_node_destructor<__node_allocator> _Dp;
    typedef unique_ptr<__node, _Dp> __node_holder;
};
;
;
;
;
;
;
;
template <class _Key, class _Tp, class _Compare = less<_Key>,
          class _Allocator = allocator<pair<const _Key, _Tp> > >
class __attribute__ ((__type_visibility__("default"))) multimap
{
public:
    typedef _Key key_type;
    typedef _Tp mapped_type;
    typedef pair<const key_type, mapped_type> value_type;
    typedef _Compare key_compare;
    typedef _Allocator allocator_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    static_assert(sizeof(__diagnose_non_const_comparator<_Key, _Compare>()), "");
    static_assert((is_same<typename allocator_type::value_type, value_type>::value),
                  "Allocator::value_type must be same type as value_type");
    class __attribute__ ((__type_visibility__("default"))) value_compare
        : public binary_function<value_type, value_type, bool>
    {
        friend class multimap;
    protected:
        key_compare comp;
    public:
    };
private:
    typedef std::__1::__value_type<key_type, mapped_type> __value_type;
    typedef __map_value_compare<key_type, __value_type, key_compare> __vc;
    typedef typename __rebind_alloc_helper<allocator_traits<allocator_type>,
                                                 __value_type>::type __allocator_type;
    typedef __tree<__value_type, __vc, __allocator_type> __base;
    typedef typename __base::__node_traits __node_traits;
    typedef allocator_traits<allocator_type> __alloc_traits;
    __base __tree_;
public:
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::const_pointer const_pointer;
    typedef typename __alloc_traits::size_type size_type;
    typedef typename __alloc_traits::difference_type difference_type;
    typedef __map_iterator<typename __base::iterator> iterator;
    typedef __map_const_iterator<typename __base::const_iterator> const_iterator;
    typedef std::__1::reverse_iterator<iterator> reverse_iterator;
    typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;
    template <class _Key2, class _Value2, class _Comp2, class _Alloc2>
        friend class __attribute__ ((__type_visibility__("default"))) map;
    template <class _Key2, class _Value2, class _Comp2, class _Alloc2>
        friend class __attribute__ ((__type_visibility__("default"))) multimap;
        ;
        ;
     ;
     ;
            ;
            ;
        ;
private:
    typedef typename __base::__node __node;
    typedef typename __base::__node_allocator __node_allocator;
    typedef typename __base::__node_pointer __node_pointer;
    typedef __map_node_destructor<__node_allocator> _Dp;
    typedef unique_ptr<__node, _Dp> __node_holder;
};
;
;
;
;
;
;
;
} }
class
Range
{
public:
private:
  double rng_base;
  double rng_limit;
  double rng_inc;
  octave_idx_type rng_numel;
  mutable Matrix cache;
protected:
};
namespace octave
{
  namespace mach_info
  {
    enum float_format
    {
      flt_fmt_unknown = 0,
      flt_fmt_ieee_little_endian = 1,
      flt_fmt_ieee_big_endian = 2,
    };
  }
}
class oct_mach_info
{
public:
  typedef octave::mach_info::float_format float_format;
};
class
oct_data_conv
{
public:
  enum data_type
  {
    dt_int8 = 0,
    dt_uint8 = 1,
    dt_int16 = 2,
    dt_uint16 = 3,
    dt_int32 = 4,
    dt_uint32 = 5,
    dt_int64 = 6,
    dt_uint64 = 7,
    dt_single = 8,
    dt_double = 9,
    dt_char = 10,
    dt_schar = 11,
    dt_uchar = 12,
    dt_logical = 13,
    dt_short = 14,
    dt_ushort = 15,
    dt_int = 16,
    dt_uint = 17,
    dt_long = 18,
    dt_ulong = 19,
    dt_longlong = 20,
    dt_ulonglong = 21,
    dt_float = 22,
    dt_unknown = 23
  };
};
enum save_type
{
  LS_U_CHAR = 0,
  LS_U_SHORT = 1,
  LS_U_INT = 2,
  LS_CHAR = 3,
  LS_SHORT = 4,
  LS_INT = 5,
  LS_FLOAT = 6,
  LS_DOUBLE = 7,
  LS_U_LONG = 8,
  LS_LONG = 9
};
;
namespace octave
{
  class type_info;
}
class Cell;
class float_format;
class mxArray;
class octave_map;
class octave_scalar_map;
class octave_function;
class octave_user_function;
class octave_fcn_handle;
class octave_fcn_inline;
class octave_value_list;
template <typename T> class Array;
class Cell;
class octave_value;
class octave_value_list;
class string_vector;
namespace octave
{
  class interpreter;
  class scanf_format_elt;
  class scanf_format_list;
  class printf_format_elt;
  class printf_format_list;
  class
  base_stream
  {
    friend class stream;
  public:
  protected:
  private:
    refcount<octave_idx_type> count;
    int md;
    mach_info::float_format flt_fmt;
    bool fail;
    bool open_state;
    std::string errmsg;
  };
  class
  stream
  {
  public:
    ;
  private:
    base_stream *rep;
  };
  class
  stream_list
  {
  public:
  private:
    typedef std::map<int, stream> ostrl_map;
    ostrl_map list;
    mutable ostrl_map::const_iterator lookup_cache;
    int m_stdin_file;
    int m_stdout_file;
    int m_stderr_file;
  };
}
__attribute__ ((__deprecated__))
typedef octave::base_stream octave_base_stream;
__attribute__ ((__deprecated__))
typedef octave::stream octave_stream;
__attribute__ ((__deprecated__))
typedef octave::stream_list octave_stream_list;
namespace std { inline namespace __1 {
using ::va_list;
} }
extern "C" {
;
typedef struct {
 intmax_t quot;
 intmax_t rem;
} imaxdiv_t;
;
;
;
;
;
}
extern "C" {
;
;
;
;
}
namespace std { inline namespace __1 {
using::imaxdiv_t;
} }
namespace std { inline namespace __1 {
template <class _Tp, class _Allocator> class __deque_base;
template <class _Tp, class _Allocator = allocator<_Tp> > class __attribute__ ((__type_visibility__("default"))) deque;
template <class _ValueType, class _Pointer, class _Reference, class _MapPointer,
          class _DiffType, _DiffType _BlockSize>
class __attribute__ ((__type_visibility__("default"))) __deque_iterator;
;
;
;
;
;
;
;
;
;
;
;
;
template <class _ValueType, class _DiffType>
struct __deque_block_size {
  static const _DiffType value = sizeof(_ValueType) < 256 ? 4096 / sizeof(_ValueType) : 16;
};
template <class _ValueType, class _Pointer, class _Reference, class _MapPointer,
          class _DiffType, _DiffType _BS =
                               __deque_block_size<_ValueType, _DiffType>::value
          >
class __attribute__ ((__type_visibility__("default"))) __deque_iterator
{
    typedef _MapPointer __map_iterator;
public:
    typedef _Pointer pointer;
    typedef _DiffType difference_type;
private:
    __map_iterator __m_iter_;
    pointer __ptr_;
    static const difference_type __block_size;
public:
    typedef _ValueType value_type;
    typedef random_access_iterator_tag iterator_category;
    typedef _Reference reference;
      ;
private:
    template <class _Tp, class _Ap> friend class __deque_base;
    template <class _Tp, class _Ap> friend class __attribute__ ((__type_visibility__("default"))) deque;
    template <class _Vp, class _Pp, class _Rp, class _MP, class _Dp, _Dp>
        friend class __attribute__ ((__type_visibility__("default"))) __deque_iterator;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    template <class _RAIter,
              class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
    friend
    __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
    move_backward(_RAIter __f,
                  _RAIter __l,
                  __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,
                  typename enable_if<__is_random_access_iterator<_RAIter>::value>::type*);
    template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
              class _OutputIterator>
    friend
    _OutputIterator
    move_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
                  __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
                  _OutputIterator __r);
    template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
              class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
    friend
    __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
    move_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
                  __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
                  __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r);
};
template <class _ValueType, class _Pointer, class _Reference, class _MapPointer,
          class _DiffType, _DiffType _BlockSize>
const _DiffType __deque_iterator<_ValueType, _Pointer, _Reference, _MapPointer,
                                 _DiffType, _BlockSize>::__block_size =
    __deque_block_size<_ValueType, _DiffType>::value;
;
;
;
;
;
;
;
;
;
;
;
;
template <bool>
class __deque_base_common
{
protected:
    [[noreturn]] void __throw_length_error() const;
    [[noreturn]] void __throw_out_of_range() const;
};
template <class _Tp, class _Allocator>
class __deque_base
    : protected __deque_base_common<true>
{
    __deque_base(const __deque_base& __c);
    __deque_base& operator=(const __deque_base& __c);
public:
    typedef _Allocator allocator_type;
    typedef allocator_traits<allocator_type> __alloc_traits;
    typedef typename __alloc_traits::size_type size_type;
protected:
    typedef _Tp value_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef typename __alloc_traits::difference_type difference_type;
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::const_pointer const_pointer;
    static const difference_type __block_size;
    typedef typename __rebind_alloc_helper<__alloc_traits, pointer>::type __pointer_allocator;
    typedef allocator_traits<__pointer_allocator> __map_traits;
    typedef typename __map_traits::pointer __map_pointer;
    typedef typename __rebind_alloc_helper<__alloc_traits, const_pointer>::type __const_pointer_allocator;
    typedef typename allocator_traits<__const_pointer_allocator>::const_pointer __map_const_pointer;
    typedef __split_buffer<pointer, __pointer_allocator> __map;
    typedef __deque_iterator<value_type, pointer, reference, __map_pointer,
                             difference_type> iterator;
    typedef __deque_iterator<value_type, const_pointer, const_reference, __map_const_pointer,
                             difference_type> const_iterator;
protected:
    __map __map_;
    size_type __start_;
    __compressed_pair<size_type, allocator_type> __size_;
    iterator begin() noexcept;
    const_iterator begin() const noexcept;
    iterator end() noexcept;
    const_iterator end() const noexcept;
public:
protected:
private:
};
template <class _Tp, class _Allocator>
const typename __deque_base<_Tp, _Allocator>::difference_type
    __deque_base<_Tp, _Allocator>::__block_size =
        __deque_block_size<value_type, difference_type>::value;
template <class _Tp, class _Allocator >
class __attribute__ ((__type_visibility__("default"))) deque
    : private __deque_base<_Tp, _Allocator>
{
public:
    typedef _Tp value_type;
    typedef _Allocator allocator_type;
    static_assert((is_same<typename allocator_type::value_type, value_type>::value),
                  "Allocator::value_type must be same type as value_type");
    typedef __deque_base<value_type, allocator_type> __base;
    typedef typename __base::__alloc_traits __alloc_traits;
    typedef typename __base::reference reference;
    typedef typename __base::const_reference const_reference;
    typedef typename __base::iterator iterator;
    typedef typename __base::const_iterator const_iterator;
    typedef typename __base::size_type size_type;
    typedef typename __base::difference_type difference_type;
    typedef typename __base::pointer pointer;
    typedef typename __base::const_pointer const_pointer;
    typedef std::__1::reverse_iterator<iterator> reverse_iterator;
    typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
private:
    typedef typename __base::__map_const_pointer __map_const_pointer;
    ;
    ;
};
;
;
;
;
;
;
;
} }
namespace std { inline namespace __1 {
template <class _Tp, class _Container = deque<_Tp> > class __attribute__ ((__type_visibility__("default"))) stack;
;
;
template <class _Tp, class _Container >
class __attribute__ ((__type_visibility__("default"))) stack
{
public:
    typedef _Container container_type;
    typedef typename container_type::value_type value_type;
    typedef typename container_type::reference reference;
    typedef typename container_type::const_reference const_reference;
    typedef typename container_type::size_type size_type;
    static_assert((is_same<_Tp, value_type>::value), "" );
protected:
    container_type c;
public:
      ;
      ;
      ;
      ;
      ;
        ;
    ;
    ;
};
;
;
;
;
;
;
;
template <class _Tp, class _Container, class _Alloc>
struct __attribute__ ((__type_visibility__("default"))) uses_allocator<stack<_Tp, _Container>, _Alloc>
    : public uses_allocator<_Container, _Alloc>
{
};
} }
namespace octave
{
  class
  action_container
  {
  public:
    class elem
    {
    public:
      friend class action_container;
    };
    class fcn_elem : public elem
    {
    public:
      ;
    private:
      std::function<void (void)> m_fcn;
    };
    template <typename T>
    class restore_var_elem : public elem
    {
    public:
    private:
      T *e_ptr, e_val;
    };
    template <typename T>
    class delete_ptr_elem : public elem
    {
    public:
    private:
      T *e_ptr;
    };
    ;
    ;
    ;
    ;
    ;
    ;
    ;
  protected:
  };
}
__attribute__ ((__deprecated__))
typedef octave::action_container action_container;
namespace octave
{
  class
  unwind_protect : public action_container
  {
  public:
  protected:
    std::stack<elem *> lifo;
  };
  class
  unwind_protect_safe : public unwind_protect
  {
  private:
  public:
  };
}
class octave_map;
class octave_value_list;
namespace octave
{
  class execution_exception;
}
__attribute__ ((__noreturn__)) extern
void vparse_error (const char *fmt, va_list args);
__attribute__ ((__format__(printf, 1, 2)))
__attribute__ ((__noreturn__)) extern
void parse_error (const char *fmt, ...);
extern void
vmessage_with_id (const char *id, const char *name,
                  const char *fmt, va_list args);
__attribute__ ((__format__(printf, 3, 4)))
extern void
message_with_id (const char *id, const char *name, const char *fmt, ...);
__attribute__ ((__noreturn__)) extern
void vusage_with_id (const char *id, const char *fmt, va_list args);
__attribute__ ((__format__(printf, 2, 3)))
__attribute__ ((__noreturn__)) extern
void usage_with_id (const char *id, const char *fmt, ...);
extern void
vwarning_with_id (const char *id, const char *fmt, va_list args);
__attribute__ ((__format__(printf, 2, 3)))
extern void
warning_with_id (const char *id, const char *fmt, ...);
__attribute__ ((__noreturn__)) extern
void verror_with_id (const char *id, const char *fmt, va_list args);
__attribute__ ((__format__(printf, 2, 3)))
__attribute__ ((__noreturn__)) extern
void error_with_id (const char *id, const char *fmt, ...);
__attribute__ ((__noreturn__)) extern
void verror_with_id_cfn (const char *id, const char *fmt, va_list args);
__attribute__ ((__format__(printf, 2, 3)))
__attribute__ ((__noreturn__)) extern
void error_with_id_cfn (const char *id, const char *fmt, ...);
__attribute__ ((__noreturn__)) extern
void vparse_error_with_id (const char *id, const char *fmt, va_list args);
__attribute__ ((__format__(printf, 2, 3)))
__attribute__ ((__noreturn__)) extern
void parse_error_with_id (const char *id, const char *fmt, ...);
__attribute__ ((__format__(printf, 1, 2)))
__attribute__ ((__noreturn__)) extern
void panic (const char *fmt, ...);
extern void defun_usage_message (const std::string& msg);
extern octave_value_list
set_warning_state (const std::string& id, const std::string& state);
extern octave_value_list
set_warning_state (const octave_value_list& args);
extern void disable_warning (const std::string& id);
extern void initialize_default_warning_state (void);
extern bool Vdebug_on_error;
extern bool Vdebug_on_caught;
extern bool Vdebug_on_warning;
extern int error_state;
extern int warning_state;
extern int buffer_error_messages;
extern int in_try_catch;
extern bool discard_error_messages;
extern bool discard_warning_messages;
extern std::string last_error_message (void);
extern std::string last_error_id (void);
extern octave_map last_error_stack (void);
extern std::string last_warning_message (void);
extern std::string last_warning_id (void);
extern void interpreter_try (octave::unwind_protect&);
extern bool check_hdf5_types (bool warn = true);
typedef int64_t octave_hdf5_id;
typedef int octave_hdf5_err;
extern "C" {
extern const octave_hdf5_id octave_H5E_DEFAULT;
extern const octave_hdf5_id octave_H5P_DEFAULT;
extern const octave_hdf5_id octave_H5S_ALL;
}
namespace octave
{
  class type_info;
  extern type_info& __get_type_info__ (const std::string&);
}
class Cell;
class float_display_format;
class mxArray;
class octave_map;
class octave_scalar_map;
class octave_value;
class octave_value_list;
class octave_classdef;
class octave_function;
class octave_user_function;
class octave_user_script;
class octave_user_code;
class octave_fcn_handle;
class octave_fcn_inline;
class octave_value_list;
enum builtin_type_t
{
  btyp_double,
  btyp_float,
  btyp_complex,
  btyp_float_complex,
  btyp_int8,
  btyp_int16,
  btyp_int32,
  btyp_int64,
  btyp_uint8,
  btyp_uint16,
  btyp_uint32,
  btyp_uint64,
  btyp_bool,
  btyp_char,
  btyp_struct,
  btyp_cell,
  btyp_func_handle,
  btyp_unknown,
  btyp_num_types = btyp_unknown
};
extern std::string
btyp_class_name [btyp_num_types];
 bool btyp_isnumeric (builtin_type_t btyp)
;
 bool btyp_isinteger (builtin_type_t btyp)
;
 bool btyp_isfloat (builtin_type_t btyp)
;
template <typename T>
struct class_to_btyp
{
  static const builtin_type_t btyp = btyp_unknown;
};
template <> struct class_to_btyp<double> { static const builtin_type_t btyp = btyp_double; };
template <> struct class_to_btyp<float> { static const builtin_type_t btyp = btyp_float; };
template <> struct class_to_btyp<Complex> { static const builtin_type_t btyp = btyp_complex; };
template <> struct class_to_btyp<FloatComplex> { static const builtin_type_t btyp = btyp_float_complex; };
template <> struct class_to_btyp<octave_int8> { static const builtin_type_t btyp = btyp_int8; };
template <> struct class_to_btyp<octave_int16> { static const builtin_type_t btyp = btyp_int16; };
template <> struct class_to_btyp<octave_int32> { static const builtin_type_t btyp = btyp_int32; };
template <> struct class_to_btyp<octave_int64> { static const builtin_type_t btyp = btyp_int64; };
template <> struct class_to_btyp<octave_uint8> { static const builtin_type_t btyp = btyp_uint8; };
template <> struct class_to_btyp<octave_uint16> { static const builtin_type_t btyp = btyp_uint16; };
template <> struct class_to_btyp<octave_uint32> { static const builtin_type_t btyp = btyp_uint32; };
template <> struct class_to_btyp<octave_uint64> { static const builtin_type_t btyp = btyp_uint64; };
template <> struct class_to_btyp<bool> { static const builtin_type_t btyp = btyp_bool; };
template <> struct class_to_btyp<char> { static const builtin_type_t btyp = btyp_char; };
class
octave_base_value
{
public:
  typedef octave_base_value * (*type_conv_fcn) (const octave_base_value&);
  class type_conv_info
  {
  public:
  private:
    type_conv_fcn _fcn;
    int _type_id;
  };
  friend class octave_value;
  enum unary_mapper_t
  {
    umap_abs,
    umap_acos,
    umap_acosh,
    umap_angle,
    umap_arg,
    umap_asin,
    umap_asinh,
    umap_atan,
    umap_atanh,
    umap_cbrt,
    umap_ceil,
    umap_conj,
    umap_cos,
    umap_cosh,
    umap_erf,
    umap_erfinv,
    umap_erfcinv,
    umap_erfc,
    umap_erfcx,
    umap_erfi,
    umap_dawson,
    umap_exp,
    umap_expm1,
    umap_isfinite,
    umap_fix,
    umap_floor,
    umap_gamma,
    umap_imag,
    umap_isinf,
    umap_isna,
    umap_isnan,
    umap_lgamma,
    umap_log,
    umap_log2,
    umap_log10,
    umap_log1p,
    umap_real,
    umap_round,
    umap_roundb,
    umap_signum,
    umap_sin,
    umap_sinh,
    umap_sqrt,
    umap_tan,
    umap_tanh,
    umap_xisalnum,
    umap_xisalpha,
    umap_xisascii,
    umap_xiscntrl,
    umap_xisdigit,
    umap_xisgraph,
    umap_xislower,
    umap_xisprint,
    umap_xispunct,
    umap_xisspace,
    umap_xisupper,
    umap_xisxdigit,
    umap_xsignbit,
    umap_xtolower,
    umap_xtoupper,
    umap_unknown,
    num_unary_mappers = umap_unknown
  };
protected:
  octave::refcount<octave_idx_type> count;
private:
  static int curr_print_indent_level;
  static bool beginning_of_line;
  public: private: static int t_id; static const std::string t_name; static const std::string c_name;
};
extern bool Vsparse_auto_mutate;
class
octave_value
{
public:
  enum unary_op
  {
    op_not,
    op_uplus,
    op_uminus,
    op_transpose,
    op_hermitian,
    op_incr,
    op_decr,
    num_unary_ops,
    unknown_unary_op
  };
  enum binary_op
  {
    op_add,
    op_sub,
    op_mul,
    op_div,
    op_pow,
    op_ldiv,
    op_lt,
    op_le,
    op_eq,
    op_ge,
    op_gt,
    op_ne,
    op_el_mul,
    op_el_div,
    op_el_pow,
    op_el_ldiv,
    op_el_and,
    op_el_or,
    op_struct_ref,
    num_binary_ops,
    unknown_binary_op
  };
  enum compound_binary_op
  {
    op_trans_mul,
    op_mul_trans,
    op_herm_mul,
    op_mul_herm,
    op_trans_ldiv,
    op_herm_ldiv,
    op_el_not_and,
    op_el_not_or,
    op_el_and_not,
    op_el_or_not,
    num_compound_binary_ops,
    unknown_compound_binary_op
  };
  enum assign_op
  {
    op_asn_eq,
    op_add_eq,
    op_sub_eq,
    op_mul_eq,
    op_div_eq,
    op_ldiv_eq,
    op_pow_eq,
    op_el_mul_eq,
    op_el_div_eq,
    op_el_ldiv_eq,
    op_el_pow_eq,
    op_el_and_eq,
    op_el_or_eq,
    num_assign_ops,
    unknown_assign_op
  };
  enum magic_colon { magic_colon_t };
protected:
  octave_base_value *rep;
private:
};
;
class octave_value_list;
class
Cell : public Array<octave_value>
{
public:
  ;
  using Array<octave_value>::index;
  using Array<octave_value>::delete_elements;
  using Array<octave_value>::assign;
private:
  typedef octave_value (octave_value::*ctype_mapper) (void) const;
};
class
octave_value_list
{
public:
    ;
private:
  Array<octave_value> data;
  string_vector names;
};
;
class string_vector;
class
octave_fields
{
  class fields_rep : public std::map<std::string, octave_idx_type>
  {
  public:
    octave::refcount<int> count;
  private:
  };
  fields_rep *rep;
public:
  typedef std::map<std::string, octave_idx_type>::const_iterator const_iterator;
  typedef const_iterator iterator;
};
class
octave_scalar_map
{
public:
  typedef octave_fields::const_iterator const_iterator;
  typedef const_iterator iterator;
  friend class octave_map;
private:
  octave_fields xkeys;
  std::vector<octave_value> xvals;
};
class
octave_map
{
public:
  typedef octave_scalar_map element_type;
  typedef octave_fields::const_iterator const_iterator;
  typedef const_iterator iterator;
private:
  octave_fields xkeys;
  std::vector<Cell> xvals;
  dim_vector dimensions;
};
class string_vector;
namespace octave
{
  class type_info
  {
  public:
    typedef octave_value (*unary_class_op_fcn) (const octave_value&);
    typedef octave_value (*unary_op_fcn) (const octave_base_value&);
    typedef void (*non_const_unary_op_fcn) (octave_base_value&);
    typedef octave_value (*binary_class_op_fcn)
    (const octave_value&, const octave_value&);
    typedef octave_value (*binary_op_fcn)
    (const octave_base_value&, const octave_base_value&);
    typedef octave_value (*cat_op_fcn)
    (octave_base_value&, const octave_base_value&,
     const Array<octave_idx_type>& ra_idx);
    typedef octave_value (*assign_op_fcn)
    (octave_base_value&, const octave_value_list&, const octave_base_value&);
    typedef octave_value (*assignany_op_fcn)
    (octave_base_value&, const octave_value_list&, const octave_value&);
  private:
    int num_types;
    Array<std::string> types;
    Array<octave_value *> vals;
    Array<void *> unary_class_ops;
    Array<void *> unary_ops;
    Array<void *> non_const_unary_ops;
    Array<void *> binary_class_ops;
    Array<void *> binary_ops;
    Array<void *> compound_binary_class_ops;
    Array<void *> compound_binary_ops;
    Array<void *> cat_ops;
    Array<void *> assign_ops;
    Array<void *> assignany_ops;
    Array<int> pref_assign_conv;
    Array<void *> widening_ops;
  };
}
namespace octave_value_typeinfo
{
  typedef octave::type_info::unary_class_op_fcn unary_class_op_fcn;
  typedef octave::type_info::unary_op_fcn unary_op_fcn;
  typedef octave::type_info::non_const_unary_op_fcn non_const_unary_op_fcn;
  typedef octave::type_info::binary_class_op_fcn binary_class_op_fcn;
  typedef octave::type_info::binary_op_fcn binary_op_fcn;
  typedef octave::type_info::cat_op_fcn cat_op_fcn;
  typedef octave::type_info::assign_op_fcn assign_op_fcn;
  typedef octave::type_info::assignany_op_fcn assignany_op_fcn;
}
class
glob_match
{
public:
  enum opts
  {
    pathname = 1,
    noescape = 2,
    period = 4
  };
private:
  string_vector pat;
  int fnmatch_flags;
};
namespace octave
{
  template <typename elt_type>
  class
  base_list
  {
  public:
    typedef typename std::list<elt_type>::iterator iterator;
    typedef typename std::list<elt_type>::const_iterator const_iterator;
    typedef typename std::list<elt_type>::reverse_iterator reverse_iterator;
    typedef typename std::list<elt_type>::const_reverse_iterator
                                                     const_reverse_iterator;
    ;
  protected:
    std::list<elt_type> m_lst;
  };
}
namespace octave
{
  class
  regexp
  {
  public:
    class opts;
    class match_data;
    class opts
    {
    public:
    private:
      bool x_case_insensitive;
      bool x_dotexceptnewline;
      bool x_emptymatch;
      bool x_freespacing;
      bool x_lineanchors;
      bool x_once;
    };
    class match_element
    {
    public:
    private:
      std::string x_match_string;
      string_vector x_named_tokens;
      string_vector x_tokens;
      Matrix x_token_extents;
      double x_start;
      double x_end;
    };
    class match_data : public base_list<match_element>
    {
    public:
    private:
      string_vector named_pats;
    };
  private:
    std::string pattern;
    opts options;
    void *data;
    std::string m;
    string_vector named_pats;
    int nnames;
    Array<int> named_idx;
    std::string who;
  };
}
class tree_argument_list;
class octave_user_function;
class octave_user_function;
namespace octave
{
  class symbol_scope_rep;
  class symbol_record
  {
  public:
    typedef size_t context_id;
    static const unsigned int local = 1;
    static const unsigned int automatic = 2;
    static const unsigned int formal = 4;
    static const unsigned int hidden = 8;
    static const unsigned int inherited = 16;
    static const unsigned int global = 32;
    static const unsigned int persistent = 64;
    static const unsigned int added_static = 128;
  private:
    class symbol_record_rep
    {
    public:
    private:
      unsigned int m_storage_class;
      std::string m_name;
      std::weak_ptr<symbol_scope_rep> m_fwd_scope;
      std::weak_ptr<symbol_record_rep> m_fwd_rep;
      std::deque<octave_value> m_value_stack;
    };
  public:
  private:
    std::shared_ptr<symbol_record_rep> m_rep;
    static octave_value dummy_octave_value;
  };
}
namespace octave
{
  class symbol_scope;
  class symbol_scope_rep
    : public std::enable_shared_from_this<symbol_scope_rep>
  {
  public:
    typedef std::map<std::string, symbol_record>::const_iterator
    table_const_iterator;
    typedef std::map<std::string, symbol_record>::iterator
    table_iterator;
    typedef std::map<std::string, octave_value>::const_iterator
    subfunctions_const_iterator;
    typedef std::map<std::string, octave_value>::iterator
    subfunctions_iterator;
  private:
    std::string m_name;
    std::map<std::string, symbol_record> m_symbols;
    std::map<std::string, octave_value> m_subfunctions;
    std::list<std::string> m_subfunction_names;
    octave_user_function *m_fcn;
    std::weak_ptr<symbol_scope_rep> m_parent;
    std::weak_ptr<symbol_scope_rep> m_primary_parent;
    std::vector<symbol_scope> m_children;
    size_t m_nesting_depth;
    bool m_is_static;
    symbol_record::context_id m_context;
  };
  class symbol_scope
  {
  public:
  private:
    std::shared_ptr<symbol_scope_rep> m_rep;
  };
}
namespace octave
{
  class tree_evaluator;
  class tree_walker;
}
class
octave_function : public octave_base_value
{
public:
protected:
  bool relative;
  bool locked;
  bool private_function;
  std::string xdispatch_class;
  std::string xpackage_name;
  std::string my_name;
  std::string my_dir_name;
  std::string doc;
};
class octave_value;
class octave_value_list;
namespace octave
{
  class tree_evaluator;
  class interpreter;
  class jit_type;
}
class
octave_builtin : public octave_function
{
public:
  typedef octave_value_list (*meth) (octave::interpreter&,
                                     const octave_value_list&, int);
  typedef octave_value_list (*fcn) (const octave_value_list&, int);
protected:
  fcn f;
  meth m;
  std::string file;
  std::set<std::string> dispatch_classes;
  octave::jit_type *jtype;
private:
  public: private: static int t_id; static const std::string t_name; static const std::string c_name;
};
namespace octave
{
  class
  dynamic_library
  {
  public:
    typedef std::string (*name_mangler) (const std::string&);
    class dynlib_rep
    {
    public:
    protected:
    public:
    public:
      refcount<int> count;
    protected:
      std::string file;
      sys::time tm_loaded;
      typedef std::map<std::string, size_t>::iterator fcn_names_iterator;
      typedef std::map<std::string, size_t>::const_iterator fcn_names_const_iterator;
      std::map<std::string, size_t> fcn_names;
      static std::map<std::string, dynlib_rep *> instances;
      bool search_all_loaded;
    };
  private:
    static dynlib_rep nil_rep;
  public:
  private:
    dynlib_rep *rep;
  };
}
class octave_value;
class octave_value_list;
class
octave_dld_function : public octave_builtin
{
public:
private:
  octave::dynamic_library sh_lib;
  mutable octave::sys::time t_checked;
  bool system_fcn_file;
  public: private: static int t_id; static const std::string t_name; static const std::string c_name;
};
namespace octave
{
  class interpreter;
}
class octave_value;
namespace octave
{
  class auto_shlib : public dynamic_library
  {
  public:
  };
}
__attribute__ ((__deprecated__))
typedef octave::auto_shlib octave_auto_shlib;
typedef bool (*octave_dld_fcn_installer) (const octave::dynamic_library&, bool relative);
typedef octave_function *
  (*octave_dld_fcn_getter) (const octave::dynamic_library&, bool relative);
class octave_value;
namespace octave
{
  class execution_exception;
}
class string_vector;
class octave_value;
class octave_value_list;
namespace octave
{
  class interpreter;
  class help_system
  {
  public:
  private:
    interpreter& m_interpreter;
    std::string m_built_in_docstrings_file;
    std::string m_doc_cache_file;
    std::string m_info_file;
    std::string m_info_program;
    std::string m_makeinfo_program;
    bool m_suppress_verbose_help_message;
    std::string m_texi_macros_file;
    ;
  };
}
namespace std { inline namespace __1 {
class __iom_t1
{
    ios_base::fmtflags __mask_;
public:
     ;
     ;
};
class __iom_t2
{
    ios_base::fmtflags __mask_;
public:
     ;
     ;
};
class __iom_t3
{
    int __base_;
public:
     ;
     ;
};
template<class _CharT>
class __iom_t4
{
    _CharT __fill_;
public:
     ;
};
;
class __iom_t5
{
    int __n_;
public:
     ;
     ;
};
class __iom_t6
{
    int __n_;
public:
     ;
     ;
};
template <class _MoneyT> class __iom_t7;
;
template <class _MoneyT>
class __iom_t7
{
    _MoneyT& __mon_;
    bool __intl_;
public:
    ;
};
;
;
template <class _MoneyT> class __iom_t8;
;
template <class _MoneyT>
class __iom_t8
{
    const _MoneyT& __mon_;
    bool __intl_;
public:
    ;
};
;
;
template <class _CharT> class __iom_t9;
;
template <class _CharT>
class __iom_t9
{
    tm* __tm_;
    const _CharT* __fmt_;
public:
    ;
};
;
;
template <class _CharT> class __iom_t10;
;
template <class _CharT>
class __iom_t10
{
    const tm* __tm_;
    const _CharT* __fmt_;
public:
    ;
};
;
;
;
;
;
template <class _CharT, class _Traits, class _Allocator>
struct __quoted_proxy
{
    basic_string<_CharT, _Traits, _Allocator> &__string;
    _CharT __delim;
    _CharT __escape;
};
;
;
;
;
;
} }
namespace std { inline namespace __1 { namespace __fs { namespace filesystem {
typedef chrono::time_point<_FilesystemClock> file_time_type;
struct __attribute__ ((__visibility__("default"))) space_info {
  uintmax_t capacity;
  uintmax_t free;
  uintmax_t available;
};
enum class __attribute__ ((__type_visibility__("default"))) file_type : signed char {
  none = 0,
  not_found = -1,
  regular = 1,
  directory = 2,
  symlink = 3,
  block = 4,
  character = 5,
  fifo = 6,
  socket = 7,
  unknown = 8
};
enum class __attribute__ ((__type_visibility__("default"))) perms : unsigned {
  none = 0,
  owner_read = 0400,
  owner_write = 0200,
  owner_exec = 0100,
  owner_all = 0700,
  group_read = 040,
  group_write = 020,
  group_exec = 010,
  group_all = 070,
  others_read = 04,
  others_write = 02,
  others_exec = 01,
  others_all = 07,
  all = 0777,
  set_uid = 04000,
  set_gid = 02000,
  sticky_bit = 01000,
  mask = 07777,
  unknown = 0xFFFF,
};
enum class __attribute__ ((__type_visibility__("default"))) perm_options : unsigned char {
  replace = 1,
  add = 2,
  remove = 4,
  nofollow = 8
};
enum class __attribute__ ((__type_visibility__("default"))) copy_options : unsigned short {
  none = 0,
  skip_existing = 1,
  overwrite_existing = 2,
  update_existing = 4,
  recursive = 8,
  copy_symlinks = 16,
  skip_symlinks = 32,
  directories_only = 64,
  create_symlinks = 128,
  create_hard_links = 256,
  __in_recursive_copy = 512,
};
enum class __attribute__ ((__type_visibility__("default"))) directory_options : unsigned char {
  none = 0,
  follow_directory_symlink = 1,
  skip_permission_denied = 2
};
class __attribute__ ((__visibility__("default"))) file_status {
public:
private:
  file_type __ft_;
  perms __prms_;
};
class __attribute__ ((__visibility__("default"))) directory_entry;
template <class _Tp>
struct __can_convert_char {
  static const bool value = false;
};
template <class _Tp>
struct __can_convert_char<const _Tp> : public __can_convert_char<_Tp> {};
template <>
struct __can_convert_char<char> {
  static const bool value = true;
  using __char_type = char;
};
template <>
struct __can_convert_char<wchar_t> {
  static const bool value = true;
  using __char_type = wchar_t;
};
template <>
struct __can_convert_char<char16_t> {
  static const bool value = true;
  using __char_type = char16_t;
};
template <>
struct __can_convert_char<char32_t> {
  static const bool value = true;
  using __char_type = char32_t;
};
 ;
struct _NullSentinal {};
template <class _Tp>
using _Void = void;
template <class _Tp, class = void>
struct __is_pathable_string : public false_type {};
template <class _ECharT, class _Traits, class _Alloc>
struct __is_pathable_string<
    basic_string<_ECharT, _Traits, _Alloc>,
    _Void<typename __can_convert_char<_ECharT>::__char_type> >
    : public __can_convert_char<_ECharT> {
  using _Str = basic_string<_ECharT, _Traits, _Alloc>;
  using _Base = __can_convert_char<_ECharT>;
};
template <class _ECharT, class _Traits>
struct __is_pathable_string<
    basic_string_view<_ECharT, _Traits>,
    _Void<typename __can_convert_char<_ECharT>::__char_type> >
    : public __can_convert_char<_ECharT> {
  using _Str = basic_string_view<_ECharT, _Traits>;
  using _Base = __can_convert_char<_ECharT>;
};
template <class _Source, class _DS = typename decay<_Source>::type,
          class _UnqualPtrType =
              typename remove_const<typename remove_pointer<_DS>::type>::type,
          bool _IsCharPtr = is_pointer<_DS>::value&&
              __can_convert_char<_UnqualPtrType>::value>
struct __is_pathable_char_array : false_type {};
template <class _Source, class _ECharT, class _UPtr>
struct __is_pathable_char_array<_Source, _ECharT*, _UPtr, true>
    : __can_convert_char<typename remove_const<_ECharT>::type> {
  using _Base = __can_convert_char<typename remove_const<_ECharT>::type>;
};
template <class _Iter, bool _IsIt = __is_input_iterator<_Iter>::value,
          class = void>
struct __is_pathable_iter : false_type {};
template <class _Iter>
struct __is_pathable_iter<
    _Iter, true,
    _Void<typename __can_convert_char<
        typename iterator_traits<_Iter>::value_type>::__char_type> >
    : __can_convert_char<typename iterator_traits<_Iter>::value_type> {
  using _ECharT = typename iterator_traits<_Iter>::value_type;
  using _Base = __can_convert_char<_ECharT>;
};
template <class _Tp, bool _IsStringT = __is_pathable_string<_Tp>::value,
          bool _IsCharIterT = __is_pathable_char_array<_Tp>::value,
          bool _IsIterT = !_IsCharIterT && __is_pathable_iter<_Tp>::value>
struct __is_pathable : false_type {
  static_assert(!_IsStringT && !_IsCharIterT && !_IsIterT, "Must all be false");
};
template <class _Tp>
struct __is_pathable<_Tp, true, false, false> : __is_pathable_string<_Tp> {};
template <class _Tp>
struct __is_pathable<_Tp, false, true, false> : __is_pathable_char_array<_Tp> {
};
template <class _Tp>
struct __is_pathable<_Tp, false, false, true> : __is_pathable_iter<_Tp> {};
template <class _ECharT>
struct _PathCVT {
  static_assert(__can_convert_char<_ECharT>::value,
                "Char type not convertible");
  typedef __narrow_to_utf8<sizeof(_ECharT) * 8> _Narrower;
   ;
   ;
   ;
};
template <>
struct _PathCVT<char> {
   ;
   ;
   ;
   ;
};
class __attribute__ ((__visibility__("default"))) path {
  template <class _SourceOrIter, class _Tp = path&>
  using _EnableIfPathable =
      typename enable_if<__is_pathable<_SourceOrIter>::value, _Tp>::type;
  template <class _Tp>
  using _SourceChar = typename __is_pathable<_Tp>::__char_type;
  template <class _Tp>
  using _SourceCVT = _PathCVT<_SourceChar<_Tp> >;
public:
  typedef char value_type;
  typedef basic_string<value_type> string_type;
  typedef std::__1::string_view __string_view;
  static constexpr value_type preferred_separator = '/';
  enum class __attribute__ ((__type_visibility__("default"))) format : unsigned char {
    auto_format,
    native_format,
    generic_format
  };
   ;
   ;
  ;
  ;
   ;
   ;
   ;
   ;
private:
   ;
public:
   ;
   ;
   ;
   ;
   ;
   ;
   ;
   ;
   ;
private:
public:
  class __attribute__ ((__visibility__("default"))) iterator;
  typedef iterator const_iterator;
   ;
   ;
   ;
private:
  string_type __pn_;
};
 ;
 ;
class __attribute__ ((__visibility__("default"))) path::iterator {
public:
  enum _ParserState : unsigned char {
    _Singular,
    _BeforeBegin,
    _InRootName,
    _InRootDir,
    _InFilenames,
    _InTrailingSep,
    _AtEnd
  };
public:
  typedef bidirectional_iterator_tag iterator_category;
  typedef path value_type;
  typedef std::ptrdiff_t difference_type;
  typedef const path* pointer;
  typedef const path& reference;
  typedef void
      __stashing_iterator_tag;
public:
private:
  friend class path;
  path __stashed_elem_;
  const path* __path_ptr_;
  path::__string_view __entry_;
  _ParserState __state_;
};
class __attribute__((availability(macosx,strict,introduced=10.15))) __attribute__((availability(ios,strict,introduced=13.0))) __attribute__((availability(tvos,strict,introduced=13.0))) __attribute__((availability(watchos,strict,introduced=6.0))) __attribute__((availability(bridgeos,strict,introduced=4.0))) __attribute__ ((__visibility__("default"))) filesystem_error : public system_error {
public:
private:
  struct __attribute__ ((__visibility__("hidden"))) _Storage {
    path __p1_;
    path __p2_;
    string __what_;
  };
  shared_ptr<_Storage> __storage_;
};
 ;
class directory_iterator;
class recursive_directory_iterator;
class __attribute__ ((__visibility__("hidden"))) __dir_stream;
class directory_entry {
  typedef std::__1::__fs::filesystem::path _Path;
public:
private:
  friend class directory_iterator;
  friend class recursive_directory_iterator;
  friend class __dir_stream;
  enum _CacheType : unsigned char {
    _Empty,
    _IterSymlink,
    _IterNonSymlink,
    _RefreshSymlink,
    _RefreshSymlinkUnresolved,
    _RefreshNonSymlink
  };
  struct __cached_data {
    uintmax_t __size_;
    uintmax_t __nlink_;
    file_time_type __write_time_;
    perms __sym_perms_;
    perms __non_sym_perms_;
    file_type __type_;
    _CacheType __cache_type_;
  };
private:
  _Path __p_;
  __cached_data __data_;
};
class __dir_element_proxy {
public:
private:
  friend class directory_iterator;
  friend class recursive_directory_iterator;
  directory_entry __elem_;
};
class directory_iterator {
public:
  typedef directory_entry value_type;
  typedef ptrdiff_t difference_type;
  typedef value_type const* pointer;
  typedef value_type const& reference;
  typedef input_iterator_tag iterator_category;
public:
private:
private:
  shared_ptr<__dir_stream> __imp_;
};
class recursive_directory_iterator {
public:
  using value_type = directory_entry;
  using difference_type = std::ptrdiff_t;
  using pointer = directory_entry const*;
  using reference = directory_entry const&;
  using iterator_category = std::input_iterator_tag;
public:
private:
  struct __attribute__ ((__visibility__("hidden"))) __shared_imp;
  shared_ptr<__shared_imp> __imp_;
  bool __rec_;
};
} } } }
namespace std { inline namespace __1 {
template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) basic_filebuf
    : public basic_streambuf<_CharT, _Traits>
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;
    typedef typename traits_type::state_type state_type;
  protected:
private:
  char* __extbuf_;
  const char* __extbufnext_;
  const char* __extbufend_;
  char __extbuf_min_[8];
  size_t __ebs_;
  char_type* __intbuf_;
  size_t __ibs_;
  FILE* __file_;
  const codecvt<char_type, char, state_type>* __cv_;
  state_type __st_;
  state_type __st_last_;
  ios_base::openmode __om_;
  ios_base::openmode __cm_;
  bool __owns_eb_;
  bool __owns_ib_;
  bool __always_noconv_;
};
;
template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) basic_ifstream
    : public basic_istream<_CharT, _Traits>
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;
private:
    basic_filebuf<char_type, traits_type> __sb_;
};
;
template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) basic_ofstream
    : public basic_ostream<_CharT, _Traits>
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;
private:
    basic_filebuf<char_type, traits_type> __sb_;
};
;
template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) basic_fstream
    : public basic_iostream<_CharT, _Traits>
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;
private:
    basic_filebuf<char_type, traits_type> __sb_;
};
;
} }
class octave_value;
class octave_value_list;
class oprocstream;
namespace octave
{
  class interpreter;
  class
  pager_buf : public std::stringbuf
  {
  public:
  protected:
  private:
    size_t diary_skip;
  };
  class
  pager_stream : public std::ostream
  {
  public:
  private:
    pager_buf *pb;
  };
  class
  diary_buf : public std::stringbuf
  {
  public:
  protected:
  };
  class
  diary_stream : public std::ostream
  {
  public:
  private:
    diary_buf *db;
  };
  class output_system
  {
  public:
  private:
    interpreter& m_interpreter;
    pager_stream m_pager_stream;
    diary_stream m_diary_stream;
    oprocstream *m_external_pager = nullptr;
    std::ofstream m_external_diary_file;
    std::string m_diary_file_name;
    std::string m_PAGER;
    std::string m_PAGER_FLAGS;
    bool m_page_output_immediately;
    bool m_page_screen_output;
    bool m_write_to_diary_file;
    bool m_really_flush_to_pager;
    bool m_flushing_output_to_pager;
  };
}
__attribute__ ((__deprecated__))
typedef octave::diary_buf octave_diary_buf;
__attribute__ ((__deprecated__))
typedef octave::diary_stream octave_diary_stream;
__attribute__ ((__deprecated__))
typedef octave::pager_buf octave_pager_buf;
__attribute__ ((__deprecated__))
typedef octave::pager_stream octave_pager_stream;
class octave_value;
class octave_value_list;
class string_vector;
namespace octave
{
}
;
;
class octave_function;
class octave_user_function;
class octave_value;
class octave_value_list;
class octave_builtin;
class string_vector;
namespace octave
{
  class tree_identifier;
}
extern "C" int octave_value_list_create(octave_value_list* list, int n);
