namespace std {
   typedef long unsigned int size_t;
   typedef long int ptrdiff_t;
   typedef decltype(nullptr) nullptr_t;
 }
   namespace std {
   inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) {
 }
 }
   typedef unsigned char __u_char;
   typedef unsigned short int __u_short;
   typedef unsigned int __u_int;
   typedef unsigned long int __u_long;
   typedef signed char __int8_t;
   typedef unsigned char __uint8_t;
   typedef unsigned short int __uint16_t;
   typedef signed int __int32_t;
   typedef unsigned int __uint32_t;
   typedef signed long int __int64_t;
   typedef unsigned long int __uint64_t;
   typedef long int __quad_t;
   typedef unsigned long int __u_quad_t;
   typedef unsigned long int __dev_t;
    typedef unsigned int __uid_t;
    typedef unsigned int __gid_t;
    typedef unsigned long int __ino_t;
    typedef unsigned long int __ino64_t;
    typedef unsigned int __mode_t;
    typedef unsigned long int __nlink_t;
    typedef long int __off_t;
    typedef long int __off64_t;
    typedef int __pid_t;
    typedef struct {
 int __val[2];
 }
   __fsid_t;
    typedef long int __clock_t;
    typedef unsigned int __id_t;
    typedef long int __time_t;
    typedef unsigned int __useconds_t;
    typedef long int __suseconds_t;
    typedef int __daddr_t;
    typedef int __key_t;
    typedef int __clockid_t;
   typedef void * __timer_t;
   typedef long int __blksize_t;
   typedef long int __blkcnt_t;
   typedef long int __blkcnt64_t;
   typedef unsigned long int __fsblkcnt_t;
   typedef unsigned long int __fsblkcnt64_t;
   typedef unsigned long int __fsfilcnt_t;
   typedef unsigned long int __fsfilcnt64_t;
   typedef long int __ssize_t;
    typedef long int __syscall_slong_t;
   typedef __off64_t __loff_t;
    typedef char *__caddr_t;
   typedef __int32_t int32_t;
   typedef long unsigned int size_t;
    namespace std __attribute__ ((__visibility__ ("default"))) {
   template<typename _Tp, _Tp __v>     struct integral_constant     {
       static constexpr _Tp value = __v;
       typedef _Tp value_type;
       typedef integral_constant<_Tp, __v> type;
            };
   template<typename _Tp, _Tp __v>     constexpr _Tp integral_constant<_Tp, __v>::value;
   typedef integral_constant<bool, true> true_type;
   typedef integral_constant<bool, false> false_type;
   template<bool __v>     using __bool_constant = integral_constant<bool, __v>;
   template<bool, typename, typename>     struct conditional;
   template<typename...>     struct __or_;
   template<>     struct __or_<>     : public false_type     {
 };
   template<typename _B1>     struct __or_<_B1>     : public _B1     {
 };
   template<typename _B1, typename _B2>     struct __or_<_B1, _B2>     : public conditional<_B1::value, _B1, _B2>::type     {
 };
   template<typename _B1, typename _B2, typename _B3, typename... _Bn>     struct __or_<_B1, _B2, _B3, _Bn...>     : public conditional<_B1::value, _B1, __or_<_B2, _B3, _Bn...>>::type     {
 };
   template<typename...>     struct __and_;
   template<>     struct __and_<>     : public true_type     {
 };
   template<typename _B1>     struct __and_<_B1>     : public _B1     {
 };
   template<typename _B1, typename _B2>     struct __and_<_B1, _B2>     : public conditional<_B1::value, _B2, _B1>::type     {
 };
   template<typename _B1, typename _B2, typename _B3, typename... _Bn>     struct __and_<_B1, _B2, _B3, _Bn...>     : public conditional<_B1::value, __and_<_B2, _B3, _Bn...>, _B1>::type     {
 };
   template<typename _Pp>     struct __not_     : public __bool_constant<!bool(_Pp::value)>     {
 };
   template<typename _Tp>     struct __success_type     {
 typedef _Tp type;
 };
   struct __failure_type   {
 };
   template<typename>     struct remove_cv;
   template<typename>     struct __is_void_helper     : public false_type {
 };
   template<typename _Tp>     struct is_void     : public __is_void_helper<typename remove_cv<_Tp>::type>::type     {
 };
   template<typename>     struct __is_integral_helper     : public false_type {
 };
   template<>     struct __is_integral_helper<bool>     : public true_type {
 };
   template<>     struct __is_integral_helper<char>     : public true_type {
 };
   template<>     struct __is_integral_helper<signed char>     : public true_type {
 };
   template<>     struct __is_integral_helper<unsigned char>     : public true_type {
 };
   template<>     struct __is_integral_helper<wchar_t>     : public true_type {
 };
   template<>     struct __is_integral_helper<char16_t>     : public true_type {
 };
   template<>     struct __is_integral_helper<char32_t>     : public true_type {
 };
   template<>     struct __is_integral_helper<short>     : public true_type {
 };
   template<>     struct __is_integral_helper<unsigned short>     : public true_type {
 };
   template<>     struct __is_integral_helper<int>     : public true_type {
 };
   template<>     struct __is_integral_helper<unsigned int>     : public true_type {
 };
   template<>     struct __is_integral_helper<long>     : public true_type {
 };
   template<>     struct __is_integral_helper<unsigned long>     : public true_type {
 };
   template<>     struct __is_integral_helper<long long>     : public true_type {
 };
   template<>     struct __is_integral_helper<unsigned long long>     : public true_type {
 };
   template<>     struct __is_integral_helper<__int128>     : public true_type {
 };
   template<>     struct __is_integral_helper<unsigned __int128>     : public true_type {
 };
   template<typename _Tp>     struct is_integral     : public __is_integral_helper<typename remove_cv<_Tp>::type>::type     {
 };
   template<typename>     struct __is_floating_point_helper     : public false_type {
 };
   template<>     struct __is_floating_point_helper<float>     : public true_type {
 };
   template<>     struct __is_floating_point_helper<double>     : public true_type {
 };
   template<>     struct __is_floating_point_helper<long double>     : public true_type {
 };
   template<>     struct __is_floating_point_helper<__float128>     : public true_type {
 };
   template<typename _Tp>     struct is_floating_point     : public __is_floating_point_helper<typename remove_cv<_Tp>::type>::type     {
 };
   template<typename>     struct is_array     : public false_type {
 };
   template<typename _Tp, std::size_t _Size>     struct is_array<_Tp[_Size]>     : public true_type {
 };
   template<typename _Tp>     struct is_array<_Tp[]>     : public true_type {
 };
   template<typename>     struct __is_pointer_helper     : public false_type {
 };
   template<typename _Tp>     struct __is_pointer_helper<_Tp*>     : public true_type {
 };
   template<typename _Tp>     struct is_pointer     : public __is_pointer_helper<typename remove_cv<_Tp>::type>::type     {
 };
   template<typename>     struct is_lvalue_reference     : public false_type {
 };
   template<typename _Tp>     struct is_lvalue_reference<_Tp&>     : public true_type {
 };
   template<typename>     struct is_rvalue_reference     : public false_type {
 };
   template<typename _Tp>     struct is_rvalue_reference<_Tp&&>     : public true_type {
 };
   template<typename>     struct is_function;
   template<typename>     struct __is_member_object_pointer_helper     : public false_type {
 };
   template<typename _Tp>     struct is_member_object_pointer     : public __is_member_object_pointer_helper<     typename remove_cv<_Tp>::type>::type     {
 };
   template<typename>     struct __is_member_function_pointer_helper     : public false_type {
 };
   template<typename _Tp, typename _Cp>     struct __is_member_function_pointer_helper<_Tp _Cp::*>     : public is_function<_Tp>::type {
 };
   template<typename _Tp>     struct is_member_function_pointer     : public __is_member_function_pointer_helper<     typename remove_cv<_Tp>::type>::type     {
 };
   template<typename _Tp>     struct is_enum     : public integral_constant<bool, __is_enum(_Tp)>     {
 };
   template<typename _Tp>     struct is_union     : public integral_constant<bool, __is_union(_Tp)>     {
 };
   template<typename _Tp>     struct is_class     : public integral_constant<bool, __is_class(_Tp)>     {
 };
   template<typename>     struct is_function     : public false_type {
 };
   template<typename _Res, typename... _ArgTypes >     struct is_function<_Res(_ArgTypes...) >     : public true_type {
 };
   template<typename _Res, typename... _ArgTypes >     struct is_function<_Res(_ArgTypes...) & >     : public true_type {
 };
   template<typename _Res, typename... _ArgTypes >     struct is_function<_Res(_ArgTypes...) && >     : public true_type {
 };
   template<typename _Res, typename... _ArgTypes >     struct is_function<_Res(_ArgTypes......) >     : public true_type {
 };
   template<typename _Res, typename... _ArgTypes >     struct is_function<_Res(_ArgTypes......) & >     : public true_type {
 };
   template<typename _Res, typename... _ArgTypes >     struct is_function<_Res(_ArgTypes......) && >     : public true_type {
 };
   template<typename _Res, typename... _ArgTypes >     struct is_function<_Res(_ArgTypes...) const >     : public true_type {
 };
   template<typename _Res, typename... _ArgTypes >     struct is_function<_Res(_ArgTypes...) const & >     : public true_type {
 };
   template<typename _Res, typename... _ArgTypes >     struct is_function<_Res(_ArgTypes...) const && >     : public true_type {
 };
   template<typename _Res, typename... _ArgTypes >     struct is_function<_Res(_ArgTypes......) const & >     : public true_type {
 };
   template<typename _Res, typename... _ArgTypes >     struct is_function<_Res(_ArgTypes......) const && >     : public true_type {
 };
   template<typename _Res, typename... _ArgTypes >     struct is_function<_Res(_ArgTypes...) volatile >     : public true_type {
 };
   template<typename _Res, typename... _ArgTypes >     struct is_function<_Res(_ArgTypes...) volatile & >     : public true_type {
 };
   template<typename _Res, typename... _ArgTypes >     struct is_function<_Res(_ArgTypes...) volatile && >     : public true_type {
 };
   template<typename _Res, typename... _ArgTypes >     struct is_function<_Res(_ArgTypes......) volatile >     : public true_type {
 };
   template<typename _Res, typename... _ArgTypes >     struct is_function<_Res(_ArgTypes......) volatile & >     : public true_type {
 };
   template<typename _Res, typename... _ArgTypes >     struct is_function<_Res(_ArgTypes......) volatile && >     : public true_type {
 };
   template<typename _Res, typename... _ArgTypes >     struct is_function<_Res(_ArgTypes...) const volatile >     : public true_type {
 };
   template<typename _Res, typename... _ArgTypes >     struct is_function<_Res(_ArgTypes...) const volatile & >     : public true_type {
 };
   template<typename _Res, typename... _ArgTypes >     struct is_function<_Res(_ArgTypes...) const volatile && >     : public true_type {
 };
   template<typename _Res, typename... _ArgTypes >     struct is_function<_Res(_ArgTypes......) const volatile >     : public true_type {
 };
   template<typename _Res, typename... _ArgTypes >     struct is_function<_Res(_ArgTypes......) const volatile & >     : public true_type {
 };
   template<typename _Res, typename... _ArgTypes >     struct is_function<_Res(_ArgTypes......) const volatile && >     : public true_type {
 };
   template<typename>     struct __is_null_pointer_helper     : public false_type {
 };
   template<>     struct __is_null_pointer_helper<std::nullptr_t>     : public true_type {
 };
   template<typename _Tp>     struct is_null_pointer     : public __is_null_pointer_helper<typename remove_cv<_Tp>::type>::type     {
 };
   template<typename _Tp>     struct is_reference     : public __or_<is_lvalue_reference<_Tp>,                    is_rvalue_reference<_Tp>>::type     {
 };
   template<typename _Tp>     struct is_arithmetic     : public __or_<is_integral<_Tp>, is_floating_point<_Tp>>::type     {
 };
   template<typename _Tp>     struct is_fundamental     : public __or_<is_arithmetic<_Tp>, is_void<_Tp>,      is_null_pointer<_Tp>>::type     {
 };
   template<typename _Tp>     struct is_object     : public __not_<__or_<is_function<_Tp>, is_reference<_Tp>,                           is_void<_Tp>>>::type     {
 };
   template<typename>     struct is_member_pointer;
   template<typename _Tp>     struct is_scalar     : public __or_<is_arithmetic<_Tp>, is_enum<_Tp>, is_pointer<_Tp>,                    is_member_pointer<_Tp>, is_null_pointer<_Tp>>::type     {
 };
   template<typename _Tp>     struct is_compound     : public __not_<is_fundamental<_Tp>>::type {
 };
   template<typename _Tp>     struct __is_member_pointer_helper     : public false_type {
 };
   template<typename _Tp, typename _Cp>     struct __is_member_pointer_helper<_Tp _Cp::*>     : public true_type {
 };
   template<typename _Tp>     struct is_member_pointer     : public __is_member_pointer_helper<typename remove_cv<_Tp>::type>::type     {
 };
   template<typename _Tp>     struct __is_referenceable     : public __or_<is_object<_Tp>, is_reference<_Tp>>::type     {
 };
   template<typename _Res, typename... _Args >     struct __is_referenceable<_Res(_Args...) >     : public true_type     {
 };
   template<typename _Res, typename... _Args >     struct __is_referenceable<_Res(_Args......) >     : public true_type     {
 };
   template<typename>     struct is_const     : public false_type {
 };
   template<typename _Tp>     struct is_const<_Tp const>     : public true_type {
 };
   template<typename>     struct is_volatile     : public false_type {
 };
   template<typename _Tp>     struct is_volatile<_Tp volatile>     : public true_type {
 };
   template<typename _Tp>     struct is_trivial     : public integral_constant<bool, __is_trivial(_Tp)>     {
 };
   template<typename _Tp>     struct is_abstract     : public integral_constant<bool, __is_abstract(_Tp)>     {
 };
   template<typename _Tp,     bool = is_arithmetic<_Tp>::value>     struct __is_signed_helper     : public false_type {
 };
   template<typename _Tp>     struct __is_signed_helper<_Tp, true>     : public integral_constant<bool, _Tp(-1) < _Tp(0)>     {
 };
   template<typename _Tp>     struct is_signed     : public __is_signed_helper<_Tp>::type     {
 };
   template<typename _Tp>     struct is_unsigned     : public __and_<is_arithmetic<_Tp>, __not_<is_signed<_Tp>>>     {
 };
   template<typename _Tp, typename _Up = _Tp&&>     _Up     __declval(int);
   ;
   template<typename _Tp>     auto declval() noexcept -> decltype(__declval<_Tp>(0));
   template<typename, unsigned = 0>     struct extent;
   template<typename>     struct remove_all_extents;
   template<typename _Tp>     struct __is_array_known_bounds     : public integral_constant<bool, (extent<_Tp>::value > 0)>     {
 };
   template<typename _Tp>     struct __is_array_unknown_bounds     : public __and_<is_array<_Tp>, __not_<extent<_Tp>>>     {
 };
   struct __do_is_destructible_impl   {
     ;
     ;
   };
   template<typename _Tp>     struct __is_destructible_impl     : public __do_is_destructible_impl     {
     };
   template<typename _Tp,            bool = __or_<is_void<_Tp>,                         __is_array_unknown_bounds<_Tp>,                         is_function<_Tp>>::value,            bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>     struct __is_destructible_safe;
   template<typename _Tp>     struct __is_destructible_safe<_Tp, false, false>     : public __is_destructible_impl<typename                remove_all_extents<_Tp>::type>::type     {
 };
   template<typename _Tp>     struct __is_destructible_safe<_Tp, true, false>     : public false_type {
 };
   template<typename _Tp>     struct __is_destructible_safe<_Tp, false, true>     : public true_type {
 };
   template<typename _Tp>     struct is_destructible     : public __is_destructible_safe<_Tp>::type     {
 };
   struct __do_is_nt_destructible_impl   {
     ;
     ;
   };
   template<typename _Tp>     struct __is_nt_destructible_impl     : public __do_is_nt_destructible_impl     {
       typedef decltype(__test<_Tp>(0)) type;
     };
   template<typename _Tp,            bool = __or_<is_void<_Tp>,                         __is_array_unknown_bounds<_Tp>,                         is_function<_Tp>>::value,            bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>     struct __is_nt_destructible_safe;
   template<typename _Tp>     struct __is_nt_destructible_safe<_Tp, false, false>     : public __is_nt_destructible_impl<typename                remove_all_extents<_Tp>::type>::type     {
 };
   template<typename _Tp>     struct __is_nt_destructible_safe<_Tp, true, false>     : public false_type {
 };
   template<typename _Tp>     struct __is_nt_destructible_safe<_Tp, false, true>     : public true_type {
 };
   template<typename _Tp>     struct is_nothrow_destructible     : public __is_nt_destructible_safe<_Tp>::type     {
 };
   template<typename _Tp, typename... _Args>     struct is_constructible       : public __bool_constant<__is_constructible(_Tp, _Args...)>     {
 };
   template<typename _Tp>     struct is_default_constructible     : public is_constructible<_Tp>::type     {
 };
   template<typename _Tp, bool = __is_referenceable<_Tp>::value>     struct __is_copy_constructible_impl;
   template<typename _Tp>     struct __is_copy_constructible_impl<_Tp, false>     : public false_type {
 };
   template<typename _Tp>     struct __is_copy_constructible_impl<_Tp, true>     : public is_constructible<_Tp, const _Tp&>     {
 };
   template<typename _Tp>     struct is_copy_constructible     : public __is_copy_constructible_impl<_Tp>     {
 };
   template<typename _Tp, bool = __is_referenceable<_Tp>::value>     struct __is_move_constructible_impl;
   template<typename _Tp>     struct __is_move_constructible_impl<_Tp, false>     : public false_type {
 };
   template<typename _Tp>     struct __is_move_constructible_impl<_Tp, true>     : public is_constructible<_Tp, _Tp&&>     {
 };
   template<typename _Tp>     struct is_move_constructible     : public __is_move_constructible_impl<_Tp>     {
 };
   template<typename _Tp>     struct __is_nt_default_constructible_atom     : public integral_constant<bool, noexcept(_Tp())>     {
 };
   template<typename _Tp, bool = is_array<_Tp>::value>     struct __is_nt_default_constructible_impl;
   template<typename _Tp>     struct __is_nt_default_constructible_impl<_Tp, true>     : public __and_<__is_array_known_bounds<_Tp>,       __is_nt_default_constructible_atom<typename                       remove_all_extents<_Tp>::type>>     {
 };
   template<typename _Tp>     struct __is_nt_default_constructible_impl<_Tp, false>     : public __is_nt_default_constructible_atom<_Tp>     {
 };
   template<typename _Tp>     struct is_nothrow_default_constructible     : public __and_<is_default_constructible<_Tp>,                     __is_nt_default_constructible_impl<_Tp>>     {
 };
   template<typename _Tp, typename... _Args>     struct __is_nt_constructible_impl     : public integral_constant<bool, noexcept(_Tp(declval<_Args>()...))>     {
 };
   template<typename _Tp, typename _Arg>     struct __is_nt_constructible_impl<_Tp, _Arg>     : public integral_constant<bool,                                noexcept(static_cast<_Tp>(declval<_Arg>()))>     {
 };
   template<typename _Tp>     struct __is_nt_constructible_impl<_Tp>     : public is_nothrow_default_constructible<_Tp>     {
 };
   template<typename _Tp, typename... _Args>     struct is_nothrow_constructible     : public __and_<is_constructible<_Tp, _Args...>,       __is_nt_constructible_impl<_Tp, _Args...>>     {
 };
   template<typename _Tp, bool = __is_referenceable<_Tp>::value>     struct __is_nothrow_copy_constructible_impl;
   template<typename _Tp>     struct __is_nothrow_copy_constructible_impl<_Tp, false>     : public false_type {
 };
   template<typename _Tp>     struct __is_nothrow_copy_constructible_impl<_Tp, true>     : public is_nothrow_constructible<_Tp, const _Tp&>     {
 };
   template<typename _Tp>     struct is_nothrow_copy_constructible     : public __is_nothrow_copy_constructible_impl<_Tp>     {
 };
   template<typename _Tp, bool = __is_referenceable<_Tp>::value>     struct __is_nothrow_move_constructible_impl;
   template<typename _Tp>     struct __is_nothrow_move_constructible_impl<_Tp, false>     : public false_type {
 };
   template<typename _Tp>     struct __is_nothrow_move_constructible_impl<_Tp, true>     : public is_nothrow_constructible<_Tp, _Tp&&>     {
 };
   template<typename _Tp>     struct is_nothrow_move_constructible     : public __is_nothrow_move_constructible_impl<_Tp>     {
 };
   template<typename _Tp, typename _Up>     struct is_assignable       : public __bool_constant<__is_assignable(_Tp, _Up)>     {
 };
   template<typename _Tp, bool = __is_referenceable<_Tp>::value>     struct __is_copy_assignable_impl;
   template<typename _Tp>     struct __is_copy_assignable_impl<_Tp, false>     : public false_type {
 };
   template<typename _Tp>     struct __is_copy_assignable_impl<_Tp, true>     : public is_assignable<_Tp&, const _Tp&>     {
 };
   template<typename _Tp>     struct is_copy_assignable     : public __is_copy_assignable_impl<_Tp>     {
 };
   template<typename _Tp, bool = __is_referenceable<_Tp>::value>     struct __is_move_assignable_impl;
   template<typename _Tp>     struct __is_move_assignable_impl<_Tp, false>     : public false_type {
 };
   template<typename _Tp>     struct __is_move_assignable_impl<_Tp, true>     : public is_assignable<_Tp&, _Tp&&>     {
 };
   template<typename _Tp, typename _Up>     struct __is_nt_assignable_impl     : public integral_constant<bool, noexcept(declval<_Tp>() = declval<_Up>())>     {
 };
   template<typename _Tp, typename _Up>     struct is_nothrow_assignable     : public __and_<is_assignable<_Tp, _Up>,       __is_nt_assignable_impl<_Tp, _Up>>     {
 };
   template<typename _Tp, bool = __is_referenceable<_Tp>::value>     struct __is_nt_copy_assignable_impl;
   template<typename _Tp>     struct __is_nt_copy_assignable_impl<_Tp, false>     : public false_type {
 };
   template<typename _Tp>     struct __is_nt_copy_assignable_impl<_Tp, true>     : public is_nothrow_assignable<_Tp&, const _Tp&>     {
 };
   template<typename _Tp, typename... _Args>     struct is_trivially_constructible     : public __bool_constant<__is_trivially_constructible(_Tp, _Args...)>     {
 };
   template<typename _Tp>     struct is_trivially_default_constructible     : public is_trivially_constructible<_Tp>::type     {
 };
   struct __do_is_implicitly_default_constructible_impl   {
     ;
 };
   template<typename _Tp, bool = __is_referenceable<_Tp>::value>     struct __is_trivially_copy_assignable_impl;
   template<typename _Tp>     struct __is_trivially_copy_assignable_impl<_Tp, false>     : public false_type {
 };
   template<typename _Tp>     struct __is_trivially_copy_assignable_impl<_Tp, true>     : public __bool_constant<__is_trivially_assignable(_Tp&, const _Tp&)>     {
 };
   template<typename _Tp>     struct is_trivially_copy_assignable     : public __is_trivially_copy_assignable_impl<_Tp>     {
 };
   template<typename _Tp, bool = __is_referenceable<_Tp>::value>     struct __is_trivially_move_assignable_impl;
   template<typename _Tp>     struct __is_trivially_move_assignable_impl<_Tp, false>     : public false_type {
 };
   template<typename _Tp>     struct __is_trivially_move_assignable_impl<_Tp, true>     : public __bool_constant<__is_trivially_assignable(_Tp&, _Tp&&)>     {
 };
   template<typename _Tp>     struct is_trivially_move_assignable     : public __is_trivially_move_assignable_impl<_Tp>     {
 };
   template<typename _Tp>     struct is_trivially_destructible     : public __and_<is_destructible<_Tp>,       __bool_constant<__has_trivial_destructor(_Tp)>>     {
 };
   template<typename _Tp>     struct has_virtual_destructor     : public integral_constant<bool, __has_virtual_destructor(_Tp)>     {
 };
   template<typename _Tp>     struct alignment_of     : public integral_constant<std::size_t, alignof(_Tp)> {
 };
   template<typename>     struct rank     : public integral_constant<std::size_t, 0> {
 };
   template<typename _Tp, std::size_t _Size>     struct rank<_Tp[_Size]>     : public integral_constant<std::size_t, 1 + rank<_Tp>::value> {
 };
   template<typename _Tp>     struct rank<_Tp[]>     : public integral_constant<std::size_t, 1 + rank<_Tp>::value> {
 };
   template<typename, unsigned _Uint>     struct extent     : public integral_constant<std::size_t, 0> {
 };
   template<typename _Tp, unsigned _Uint, std::size_t _Size>     struct extent<_Tp[_Size], _Uint>     : public integral_constant<std::size_t,           _Uint == 0 ? _Size : extent<_Tp,           _Uint - 1>::value>     {
 };
   template<typename _Tp, unsigned _Uint>     struct extent<_Tp[], _Uint>     : public integral_constant<std::size_t,           _Uint == 0 ? 0 : extent<_Tp,              _Uint - 1>::value>     {
 };
   template<typename, typename>     struct is_same     : public false_type {
 };
   template<typename _Tp>     struct is_same<_Tp, _Tp>     : public true_type {
 };
   template<typename _Base, typename _Derived>     struct is_base_of     : public integral_constant<bool, __is_base_of(_Base, _Derived)>     {
 };
   template<typename _From, typename _To,            bool = __or_<is_void<_From>, is_function<_To>,                         is_array<_To>>::value>     struct __is_convertible_helper     {
       typedef typename is_void<_To>::type type;
     };
   template<typename _From, typename _To>     class __is_convertible_helper<_From, _To, false>     {
       ;
       ;
       ;
     public:       typedef decltype(__test<_From, _To>(0)) type;
     };
   template<typename _From, typename _To>     struct is_convertible     : public __is_convertible_helper<_From, _To>::type     {
 };
   template<typename _Tp>     struct remove_const     {
 typedef _Tp type;
 };
   template<typename _Tp>     struct remove_const<_Tp const>     {
 typedef _Tp type;
 };
   template<typename _Tp>     struct remove_volatile     {
 typedef _Tp type;
 };
   template<typename _Tp>     struct remove_volatile<_Tp volatile>     {
 typedef _Tp type;
 };
   template<typename _Tp>     struct remove_cv     {
       typedef typename       remove_const<typename remove_volatile<_Tp>::type>::type type;
     };
   template<typename _Tp>     struct add_const     {
 typedef _Tp const type;
 };
   template<typename _Tp>     struct add_volatile     {
 typedef _Tp volatile type;
 };
   template<typename _Tp>     struct add_cv     {
       typedef typename       add_const<typename add_volatile<_Tp>::type>::type type;
     };
   template<typename _Tp>     struct remove_reference     {
 typedef _Tp type;
 };
   template<typename _Tp>     struct remove_reference<_Tp&>     {
 typedef _Tp type;
 };
   template<typename _Tp>     struct remove_reference<_Tp&&>     {
 typedef _Tp type;
 };
   template<typename _Tp, bool = __is_referenceable<_Tp>::value>     struct __add_lvalue_reference_helper     {
 typedef _Tp type;
 };
   template<typename _Tp>     struct __add_lvalue_reference_helper<_Tp, true>     {
 typedef _Tp& type;
 };
   template<typename _Tp>     struct add_lvalue_reference     : public __add_lvalue_reference_helper<_Tp>     {
 };
   template<typename _Tp, bool = __is_referenceable<_Tp>::value>     struct __add_rvalue_reference_helper     {
 typedef _Tp type;
 };
   template<typename _Tp>     struct __add_rvalue_reference_helper<_Tp, true>     {
 typedef _Tp&& type;
 };
   template<typename _Tp>     struct add_rvalue_reference     : public __add_rvalue_reference_helper<_Tp>     {
 };
   template<typename _Unqualified, bool _IsConst, bool _IsVol>     struct __cv_selector;
   template<typename _Unqualified>     struct __cv_selector<_Unqualified, false, false>     {
 typedef _Unqualified __type;
 };
   template<typename _Unqualified>     struct __cv_selector<_Unqualified, false, true>     {
 typedef volatile _Unqualified __type;
 };
   template<typename _Unqualified>     struct __cv_selector<_Unqualified, true, false>     {
 typedef const _Unqualified __type;
 };
   template<typename _Unqualified>     struct __cv_selector<_Unqualified, true, true>     {
 };
   template<typename _Qualified, typename _Unqualified,     bool _IsConst = is_const<_Qualified>::value,     bool _IsVol = is_volatile<_Qualified>::value>     class __match_cv_qualifiers     {
       typedef __cv_selector<_Unqualified, _IsConst, _IsVol> __match;
     public:       typedef typename __match::__type __type;
     };
   template<typename _Tp>     struct __make_unsigned     {
 typedef _Tp __type;
 };
   template<>     struct __make_unsigned<char>     {
 typedef unsigned char __type;
 };
   template<>     struct __make_unsigned<signed char>     {
 typedef unsigned char __type;
 };
   template<>     struct __make_unsigned<short>     {
 typedef unsigned short __type;
 };
   template<>     struct __make_unsigned<int>     {
 typedef unsigned int __type;
 };
   template<>     struct __make_unsigned<long>     {
 typedef unsigned long __type;
 };
   template<>     struct __make_unsigned<long long>     {
 typedef unsigned long long __type;
 };
   template<>     struct __make_unsigned<__int128>     {
 typedef unsigned __int128 __type;
 };
   template<typename _Tp,     bool _IsInt = is_integral<_Tp>::value,     bool _IsEnum = is_enum<_Tp>::value>     class __make_unsigned_selector;
   template<typename _Tp>     class __make_unsigned_selector<_Tp, true, false>     {
       using __unsigned_type  = typename __make_unsigned<typename remove_cv<_Tp>::type>::__type;
     public:       using __type  = typename __match_cv_qualifiers<_Tp, __unsigned_type>::__type;
     };
   class __make_unsigned_selector_base   {
   protected:     template<typename...> struct _List {
 };
     template<typename _Tp, typename... _Up>       struct _List<_Tp, _Up...> : _List<_Up...>       {
 static constexpr size_t __size = sizeof(_Tp);
 };
     template<size_t _Sz, typename _Tp, bool = (_Sz <= _Tp::__size)>       struct __select;
     template<size_t _Sz, typename _Uint, typename... _UInts>       struct __select<_Sz, _List<_Uint, _UInts...>, true>       {
 using __type = _Uint;
 };
     template<size_t _Sz, typename _Uint, typename... _UInts>       struct __select<_Sz, _List<_Uint, _UInts...>, false>       : __select<_Sz, _List<_UInts...>>       {
 };
   };
   template<typename _Tp>     class __make_unsigned_selector<_Tp, false, true>     : __make_unsigned_selector_base     {
       using _UInts = _List<unsigned char, unsigned short, unsigned int,       unsigned long, unsigned long long>;
       using __unsigned_type = typename __select<sizeof(_Tp), _UInts>::__type;
     public:       using __type  = typename __match_cv_qualifiers<_Tp, __unsigned_type>::__type;
     };
   template<>     struct __make_unsigned<wchar_t>     {
       using __type  = typename __make_unsigned_selector<wchar_t, false, true>::__type;
     };
   template<>     struct __make_unsigned<char16_t>     {
       using __type  = typename __make_unsigned_selector<char16_t, false, true>::__type;
     };
   template<>     struct __make_unsigned<char32_t>     {
       using __type  = typename __make_unsigned_selector<char32_t, false, true>::__type;
     };
   template<typename _Tp>     struct make_unsigned     {
 typedef typename __make_unsigned_selector<_Tp>::__type type;
 };
   template<>     struct make_unsigned<bool>;
   template<typename _Tp>     struct __make_signed     {
 typedef _Tp __type;
 };
   template<>     struct __make_signed<char>     {
 typedef signed char __type;
 };
   template<>     struct __make_signed<unsigned char>     {
 typedef signed char __type;
 };
   template<>     struct __make_signed<unsigned short>     {
 typedef signed short __type;
 };
   template<>     struct __make_signed<unsigned int>     {
 typedef signed int __type;
 };
   template<>     struct __make_signed<unsigned long>     {
 typedef signed long __type;
 };
   template<>     struct __make_signed<unsigned long long>     {
 typedef signed long long __type;
 };
   template<>     struct __make_signed<unsigned __int128>     {
 typedef __int128 __type;
 };
   template<typename _Tp,     bool _IsInt = is_integral<_Tp>::value,     bool _IsEnum = is_enum<_Tp>::value>     class __make_signed_selector;
   template<typename _Tp>     class __make_signed_selector<_Tp, true, false>     {
       using __signed_type  = typename __make_signed<typename remove_cv<_Tp>::type>::__type;
     public:       using __type  = typename __match_cv_qualifiers<_Tp, __signed_type>::__type;
     };
   template<typename _Tp>     class __make_signed_selector<_Tp, false, true>     {
       typedef typename __make_unsigned_selector<_Tp>::__type __unsigned_type;
     public:       typedef typename __make_signed_selector<__unsigned_type>::__type __type;
     };
   template<>     struct __make_signed<wchar_t>     {
       using __type  = typename __make_signed_selector<wchar_t, false, true>::__type;
     };
   template<>     struct __make_signed<char16_t>     {
       using __type  = typename __make_signed_selector<char16_t, false, true>::__type;
     };
   template<>     struct __make_signed<char32_t>     {
     };
   template<typename _Tp>     struct make_signed     {
 typedef typename __make_signed_selector<_Tp>::__type type;
 };
   template<>     struct make_signed<bool>;
   template<typename _Tp>     struct remove_extent     {
 typedef _Tp type;
 };
   template<typename _Tp, std::size_t _Size>     struct remove_extent<_Tp[_Size]>     {
 typedef _Tp type;
 };
   template<typename _Tp>     struct remove_extent<_Tp[]>     {
 };
   template<typename _Tp, std::size_t _Size>     struct remove_all_extents<_Tp[_Size]>     {
 };
   template<typename _Tp>     struct remove_all_extents<_Tp[]>     {
 typedef typename remove_all_extents<_Tp>::type type;
 };
   template<typename _Tp, typename>     struct __remove_pointer_helper     {
 typedef _Tp type;
 };
   template<typename _Tp, typename _Up>     struct __remove_pointer_helper<_Tp, _Up*>     {
 typedef _Up type;
 };
   template<typename _Tp>     struct remove_pointer     : public __remove_pointer_helper<_Tp, typename remove_cv<_Tp>::type>     {
 };
   template<typename _Tp, bool = __or_<__is_referenceable<_Tp>,           is_void<_Tp>>::value>     struct __add_pointer_helper     {
 typedef _Tp type;
 };
   template<typename _Tp>     struct __add_pointer_helper<_Tp, true>     {
 typedef typename remove_reference<_Tp>::type* type;
 };
   template<typename _Tp>     struct add_pointer     : public __add_pointer_helper<_Tp>     {
 };
   template<std::size_t _Len>     struct __aligned_storage_msa     {
       union __type       {
  unsigned char __data[_Len];
  struct __attribute__((__aligned__)) {
 }
 __align;
       };
     };
   template<std::size_t _Len, std::size_t _Align =     __alignof__(typename __aligned_storage_msa<_Len>::__type)>     struct aligned_storage     {
       union type       {
  unsigned char __data[_Len];
  struct __attribute__((__aligned__((_Align)))) {
 }
 __align;
       };
     };
   template <typename... _Types>     struct __strictest_alignment     {
       static const size_t _S_alignment = 0;
     };
   template <typename _Tp, typename... _Types>     struct __strictest_alignment<_Tp, _Types...>     {
       static const size_t _S_alignment =         alignof(_Tp) > __strictest_alignment<_Types...>::_S_alignment  ? alignof(_Tp) : __strictest_alignment<_Types...>::_S_alignment;
       static const size_t _S_size =         sizeof(_Tp) > __strictest_alignment<_Types...>::_S_size  ? sizeof(_Tp) : __strictest_alignment<_Types...>::_S_size;
     };
   template <size_t _Len, typename... _Types>     struct aligned_union     {
     private:       static_assert(sizeof...(_Types) != 0, "At least one type is required");
       using __strictest = __strictest_alignment<_Types...>;
       static const size_t _S_len = _Len > __strictest::_S_size  ? _Len : __strictest::_S_size;
     public:       static const size_t alignment_value = __strictest::_S_alignment;
       typedef typename aligned_storage<_S_len, alignment_value>::type type;
     };
   template <size_t _Len, typename... _Types>     const size_t aligned_union<_Len, _Types...>::alignment_value;
   template<typename _Up,     bool _IsArray = is_array<_Up>::value,     bool _IsFunction = is_function<_Up>::value>     struct __decay_selector;
   template<typename _Up>     struct __decay_selector<_Up, false, false>     {
 };
   template<typename _Up>     struct __decay_selector<_Up, true, false>     {
 typedef typename remove_extent<_Up>::type* __type;
 };
   template<typename _Up>     struct __decay_selector<_Up, false, true>     {
 typedef typename add_pointer<_Up>::type __type;
 };
   template<typename _Tp>     class decay     {
       typedef typename remove_reference<_Tp>::type __remove_type;
     public:       typedef typename __decay_selector<__remove_type>::__type type;
     };
   template<typename _Tp>     class reference_wrapper;
   template<typename _Tp>     struct __strip_reference_wrapper     {
       typedef _Tp __type;
     };
   template<typename _Tp>     struct __strip_reference_wrapper<reference_wrapper<_Tp> >     {
     };
   template<typename _Tp>     struct __decay_and_strip     {
       typedef typename __strip_reference_wrapper<  typename decay<_Tp>::type>::__type __type;
     };
   template<bool, typename _Tp = void>     struct enable_if     {
 };
   template<typename _Tp>     struct enable_if<true, _Tp>     {
 typedef _Tp type;
 };
   template<typename... _Cond>     using _Require = typename enable_if<__and_<_Cond...>::value>::type;
   template<bool _Cond, typename _Iftrue, typename _Iffalse>     struct conditional     {
 typedef _Iftrue type;
 };
   template<typename _Iftrue, typename _Iffalse>     struct conditional<false, _Iftrue, _Iffalse>     {
 typedef _Iffalse type;
 };
   template<typename... _Tp>     struct common_type;
   struct __do_common_type_impl   {
     ;
   };
   template<typename _Tp, typename _Up>     struct __common_type_impl     : private __do_common_type_impl     {
       typedef decltype(_S_test<_Tp, _Up>(0)) type;
     };
   struct __do_member_type_wrapper   {
     ;
     ;
   };
   template<typename _Tp>     struct __member_type_wrapper     : private __do_member_type_wrapper     {
       typedef decltype(_S_test<_Tp>(0)) type;
     };
   template<typename _CTp, typename... _Args>     struct __expanded_common_type_wrapper     {
 };
   template<typename _Tp>     struct common_type<_Tp>     : common_type<_Tp, _Tp>     {
 };
   template<typename _Tp, typename _Up>     struct common_type<_Tp, _Up>     : public __common_type_impl<_Tp, _Up>::type     {
 };
   template<typename _Tp, typename _Up, typename... _Vp>     struct common_type<_Tp, _Up, _Vp...>     : public __expanded_common_type_wrapper<typename __member_type_wrapper<                common_type<_Tp, _Up>>::type, _Vp...>::type     {
 };
   template<typename _Tp, bool = is_enum<_Tp>::value>     struct __underlying_type_impl     {
       using type = __underlying_type(_Tp);
     };
   template<typename _Tp>     struct __underlying_type_impl<_Tp, false>     {
 };
   template<typename _Tp>     struct underlying_type     : public __underlying_type_impl<_Tp>     {
 };
   template<typename _Tp>     struct __declval_protector     {
       static const bool __stop = false;
     };
   template<typename _Tp>     auto declval() noexcept -> decltype(__declval<_Tp>(0))     ;
   template<typename _Tp>     using __remove_cvref_t      = typename remove_cv<typename remove_reference<_Tp>::type>::type;
   template<typename _Signature>     class result_of;
   struct __invoke_memfun_ref {
 };
   struct __invoke_memfun_deref {
 };
   struct __invoke_memobj_ref {
 };
   struct __invoke_memobj_deref {
 };
   struct __invoke_other {
 };
   template<typename _Tp, typename _Tag>     struct __result_of_success : __success_type<_Tp>     {
 using __invoke_type = _Tag;
 };
   struct __result_of_memfun_ref_impl   {
     ;
     ;
   };
   template<typename _MemPtr, typename _Arg, typename... _Args>     struct __result_of_memfun_ref     : private __result_of_memfun_ref_impl     {
     };
   struct __result_of_memfun_deref_impl   {
     ;
     ;
   };
   template<typename _MemPtr, typename _Arg, typename... _Args>     struct __result_of_memfun_deref     : private __result_of_memfun_deref_impl     {
       typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
     };
   struct __result_of_memobj_ref_impl   {
     ;
     ;
   };
   template<typename _MemPtr, typename _Arg>     struct __result_of_memobj_ref     : private __result_of_memobj_ref_impl     {
       typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
     };
   struct __result_of_memobj_deref_impl   {
     ;
   };
   template<typename _MemPtr, typename _Arg>     struct __result_of_memobj_deref     : private __result_of_memobj_deref_impl     {
       typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
     };
   template<typename _MemPtr, typename _Arg>     struct __result_of_memobj;
   template<typename _Res, typename _Class, typename _Arg>     struct __result_of_memobj<_Res _Class::*, _Arg>     {
       typedef __remove_cvref_t<_Arg> _Argval;
       typedef _Res _Class::* _MemPtr;
       typedef typename conditional<__or_<is_same<_Argval, _Class>,         is_base_of<_Class, _Argval>>::value,         __result_of_memobj_ref<_MemPtr, _Arg>,         __result_of_memobj_deref<_MemPtr, _Arg>       >::type::type type;
     };
   template<typename _MemPtr, typename _Arg, typename... _Args>     struct __result_of_memfun;
   template<typename _Res, typename _Class, typename _Arg, typename... _Args>     struct __result_of_memfun<_Res _Class::*, _Arg, _Args...>     {
       typedef typename remove_reference<_Arg>::type _Argval;
       typedef _Res _Class::* _MemPtr;
     };
   template<typename _Tp, typename _Up = __remove_cvref_t<_Tp>>     struct __inv_unwrap     {
       using type = _Tp;
     };
   template<typename _Tp, typename _Up>     struct __inv_unwrap<_Tp, reference_wrapper<_Up>>     {
       using type = _Up&;
     };
   template<bool, bool, typename _Functor, typename... _ArgTypes>     struct __result_of_impl     {
 };
   struct __result_of_other_impl   {
     ;
     ;
   };
   template<typename _Functor, typename... _ArgTypes>     struct __result_of_impl<false, false, _Functor, _ArgTypes...>     : private __result_of_other_impl     {
       typedef decltype(_S_test<_Functor, _ArgTypes...>(0)) type;
     };
   template<typename _Functor, typename... _ArgTypes>     struct __invoke_result     : public __result_of_impl<         is_member_object_pointer<           typename remove_reference<_Functor>::type         >::value,         is_member_function_pointer<           typename remove_reference<_Functor>::type         >::value,  _Functor, _ArgTypes...       >::type     {
 };
   template<typename _Functor, typename... _ArgTypes>     struct result_of<_Functor(_ArgTypes...)>     : public __invoke_result<_Functor, _ArgTypes...>     {
 };
   template<bool _Cond, typename _Tp = void>     using __enable_if_t = typename enable_if<_Cond, _Tp>::type;
   template<typename...> using __void_t = void;
   template<typename...> using void_t = void;
   template<typename _Default, typename _AlwaysVoid,     template<typename...> class _Op, typename... _Args>     struct __detector     {
       using value_t = false_type;
       using type = _Default;
     };
   template<typename _Default, template<typename...> class _Op,      typename... _Args>     struct __detector<_Default, __void_t<_Op<_Args...>>, _Op, _Args...>     {
       using value_t = true_type;
       using type = _Op<_Args...>;
     };
   template<typename _Default, template<typename...> class _Op,     typename... _Args>     using __detected_or = __detector<_Default, void, _Op, _Args...>;
   template<typename _Default, template<typename...> class _Op,     typename... _Args>     using __detected_or_t       = typename __detected_or<_Default, _Op, _Args...>::type;
   template<typename... _Elements>     class tuple;
   template<typename>     struct __is_tuple_like_impl : false_type     {
 };
   template<typename... _Tps>     struct __is_tuple_like_impl<tuple<_Tps...>> : true_type     {
 };
   template<typename _Tp>     struct __is_tuple_like     : public __is_tuple_like_impl<__remove_cvref_t<_Tp>>::type     {
 };
   ;
   ;
   namespace __swappable_details {
          struct __do_is_swappable_impl     {
       ;
       ;
     };
     struct __do_is_nothrow_swappable_impl     {
       ;
       ;
     };
   }
    template<typename _Tp>     struct __is_swappable_impl     : public __swappable_details::__do_is_swappable_impl     {
       typedef decltype(__test<_Tp>(0)) type;
     };
   template<typename _Tp>     struct __is_nothrow_swappable_impl     : public __swappable_details::__do_is_nothrow_swappable_impl     {
       typedef decltype(__test<_Tp>(0)) type;
     };
   template<typename _Tp>     struct __is_swappable     : public __is_swappable_impl<_Tp>::type     {
 };
   template<typename _Tp>     struct __is_nothrow_swappable     : public __is_nothrow_swappable_impl<_Tp>::type     {
 };
   namespace __swappable_with_details {
          struct __do_is_swappable_with_impl     {
       ;
       ;
     };
     struct __do_is_nothrow_swappable_with_impl     {
       ;
     };
   }
    template<typename _Tp, typename _Up>     struct __is_swappable_with_impl     : public __swappable_with_details::__do_is_swappable_with_impl     {
       typedef decltype(__test<_Tp, _Up>(0)) type;
     };
   template<typename _Tp>     struct __is_swappable_with_impl<_Tp&, _Tp&>     : public __swappable_details::__do_is_swappable_impl     {
       typedef decltype(__test<_Tp&>(0)) type;
     };
   template<typename _Tp, typename _Up>     struct __is_nothrow_swappable_with_impl     : public __swappable_with_details::__do_is_nothrow_swappable_with_impl     {
       typedef decltype(__test<_Tp, _Up>(0)) type;
     };
   template<typename _Tp>     struct __is_nothrow_swappable_with_impl<_Tp&, _Tp&>     : public __swappable_details::__do_is_nothrow_swappable_impl     {
       typedef decltype(__test<_Tp&>(0)) type;
     };
   template<typename _Tp, typename _Up>     struct is_swappable_with     : public __is_swappable_with_impl<_Tp, _Up>::type     {
 };
   template<typename _Tp, typename _Up>     struct is_nothrow_swappable_with     : public __is_nothrow_swappable_with_impl<_Tp, _Up>::type     {
 };
   template<typename _Result, typename _Ret, typename = void>     struct __is_invocable_impl : false_type {
 };
   template<typename _Result, typename _Ret>     struct __is_invocable_impl<_Result, _Ret, __void_t<typename _Result::type>>     : __or_<is_void<_Ret>, is_convertible<typename _Result::type, _Ret>>::type     {
 };
   template<typename _Fn, typename... _ArgTypes>     struct __is_invocable     : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>::type     {
 };
        ;
        ;
        ;
   template<typename _Fn, typename _Tp>     constexpr bool __call_is_nt(__invoke_memobj_deref)     ;
   template<typename _Fn, typename... _Args>     constexpr bool __call_is_nt(__invoke_other)     ;
   template<typename _Result, typename _Fn, typename... _Args>     struct __call_is_nothrow     : __bool_constant<  std::__call_is_nt<_Fn, _Args...>(typename _Result::__invoke_type{
}
)       >     {
 };
   template<typename _Fn, typename... _Args>     using __call_is_nothrow_       = __call_is_nothrow<__invoke_result<_Fn, _Args...>, _Fn, _Args...>;
   template<typename _Fn, typename... _Args>     struct __is_nothrow_invocable     : __and_<__is_invocable<_Fn, _Args...>,              __call_is_nothrow_<_Fn, _Args...>>::type     {
 };
   struct __nonesuch {
     __nonesuch() = delete;
     ~__nonesuch() = delete;
     __nonesuch(__nonesuch const&) = delete;
     void operator=(__nonesuch const&) = delete;
   };
 }
    namespace std __attribute__ ((__visibility__ ("default"))) {
   template<typename _Tp>     constexpr _Tp&&     forward(typename std::remove_reference<_Tp>::type& __t) noexcept     ;
   template<typename _Tp>     constexpr _Tp&&     forward(typename std::remove_reference<_Tp>::type&& __t) noexcept     ;
   template<typename _Tp>     constexpr typename std::remove_reference<_Tp>::type&&     move(_Tp&& __t) noexcept     ;
   template<typename _Tp>     struct __move_if_noexcept_cond     : public __and_<__not_<is_nothrow_move_constructible<_Tp>>,                     is_copy_constructible<_Tp>>::type {
 };
   template<typename _Tp>      _Tp*     addressof(_Tp& __r) noexcept     ;
   template<typename _Tp>     const _Tp* addressof(const _Tp&&) = delete;
   template <typename _Tp, typename _Up = _Tp>      _Tp     __exchange(_Tp& __obj, _Up&& __new_val)     ;
        ;
        ;
 }
  extern "C++" {
 namespace std __attribute__ ((__visibility__ ("default"))) {
   struct __true_type {
 };
   struct __false_type {
 };
   template<bool>     struct __truth_type     {
 typedef __false_type __type;
 };
   template<>     struct __truth_type<true>     {
 typedef __true_type __type;
 };
   template<class _Sp, class _Tp>     struct __traitor     {
       enum {
 __value = bool(_Sp::__value) || bool(_Tp::__value) };
       typedef typename __truth_type<__value>::__type __type;
     };
   template<typename, typename>     struct __are_same     {
       enum {
 __value = 0 };
       typedef __false_type __type;
     };
   template<typename _Tp>     struct __are_same<_Tp, _Tp>     {
       enum {
 __value = 1 };
       typedef __true_type __type;
     };
   template<typename _Tp>     struct __is_void     {
       enum {
 __value = 0 };
       typedef __false_type __type;
     };
   template<>     struct __is_void<void>     {
       enum {
 __value = 1 };
       typedef __true_type __type;
     };
   template<typename _Tp>     struct __is_integer     {
       enum {
 __value = 0 };
       typedef __false_type __type;
     };
   template<>     struct __is_integer<bool>     {
       enum {
 __value = 1 };
     };
   template<>     struct __is_integer<char>     {
       enum {
 __value = 1 };
       typedef __true_type __type;
     };
   template<>     struct __is_integer<signed char>     {
       enum {
 __value = 1 };
       typedef __true_type __type;
     };
   template<>     struct __is_integer<unsigned char>     {
       enum {
 __value = 1 };
     };
   template<>     struct __is_integer<wchar_t>     {
       enum {
 __value = 1 };
       typedef __true_type __type;
     };
   template<>     struct __is_integer<char32_t>     {
       enum {
 __value = 1 };
       typedef __true_type __type;
     };
   template<>     struct __is_integer<short>     {
       enum {
 __value = 1 };
       typedef __true_type __type;
     };
   template<>     struct __is_integer<unsigned short>     {
       enum {
 __value = 1 };
       typedef __true_type __type;
     };
   template<>     struct __is_integer<int>     {
       enum {
 __value = 1 };
       typedef __true_type __type;
     };
   template<>     struct __is_integer<unsigned int>     {
       enum {
 __value = 1 };
       typedef __true_type __type;
     };
   template<>     struct __is_integer<long>     {
       typedef __true_type __type;
     };
   template<>     struct __is_integer<unsigned long>     {
       enum {
 __value = 1 };
       typedef __true_type __type;
     };
   template<>     struct __is_integer<long long>     {
       enum {
 __value = 1 };
       typedef __true_type __type;
     };
   template<>     struct __is_integer<unsigned long long>     {
       enum {
 __value = 1 };
       typedef __true_type __type;
     };
 template<> struct __is_integer<__int128> {
 enum {
 __value = 1 };
 typedef __true_type __type;
 };
 template<> struct __is_integer<unsigned __int128> {
 enum {
 __value = 1 };
 typedef __true_type __type;
 };
   template<typename _Tp>     struct __is_floating     {
       enum {
 __value = 0 };
       typedef __false_type __type;
     };
   template<>     struct __is_floating<float>     {
       enum {
 __value = 1 };
       typedef __true_type __type;
     };
   template<>     struct __is_floating<long double>     {
       enum {
 __value = 1 };
       typedef __true_type __type;
     };
   template<typename _Tp>     struct __is_pointer     {
       enum {
 __value = 0 };
       typedef __false_type __type;
     };
   template<typename _Tp>     struct __is_pointer<_Tp*>     {
       enum {
 __value = 1 };
       typedef __true_type __type;
     };
   template<typename _Tp>     struct __is_arithmetic     : public __traitor<__is_integer<_Tp>, __is_floating<_Tp> >     {
 };
   template<typename _Tp>     struct __is_scalar     : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> >     {
 };
   template<typename _Tp>     struct __is_char     {
       enum {
 __value = 0 };
       typedef __false_type __type;
     };
   template<>     struct __is_char<char>     {
       enum {
 __value = 1 };
       typedef __true_type __type;
     };
   template<>     struct __is_char<wchar_t>     {
       enum {
 __value = 1 };
       typedef __true_type __type;
     };
   template<typename _Tp>     struct __is_byte     {
       enum {
 __value = 0 };
       typedef __false_type __type;
     };
   template<>     struct __is_byte<char>     {
       enum {
 __value = 1 };
       typedef __true_type __type;
     };
   template<>     struct __is_byte<signed char>     {
       enum {
 __value = 1 };
       typedef __true_type __type;
     };
   template<>     struct __is_byte<unsigned char>     {
       enum {
 __value = 1 };
       typedef __true_type __type;
     };
   template<typename _Tp>     struct __is_move_iterator     {
       enum {
 __value = 0 };
       typedef __false_type __type;
     };
   template<typename _Iterator>      _Iterator     __miter_base(_Iterator __it)     ;
 }
  }
    namespace std __attribute__ ((__visibility__ ("default"))) {
   struct input_iterator_tag {
 };
   struct output_iterator_tag {
 };
   struct forward_iterator_tag : public input_iterator_tag {
 };
   struct bidirectional_iterator_tag : public forward_iterator_tag {
 };
   struct random_access_iterator_tag : public bidirectional_iterator_tag {
 };
   template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,            typename _Pointer = _Tp*, typename _Reference = _Tp&>     struct iterator     {
       typedef _Category iterator_category;
       typedef _Tp value_type;
       typedef _Distance difference_type;
       typedef _Pointer pointer;
       typedef _Reference reference;
     };
   template<typename _Iterator, typename = __void_t<>>     struct __iterator_traits {
       typedef typename _Iterator::value_type value_type;
       typedef typename _Iterator::difference_type difference_type;
       typedef typename _Iterator::pointer pointer;
       typedef typename _Iterator::reference reference;
     };
   template<typename _Iterator>     struct iterator_traits     : public __iterator_traits<_Iterator> {
 };
   template<typename _Tp>     struct iterator_traits<_Tp*>     {
       typedef random_access_iterator_tag iterator_category;
       typedef _Tp value_type;
       typedef ptrdiff_t difference_type;
       typedef _Tp* pointer;
       typedef _Tp& reference;
     };
   template<typename _Tp>     struct iterator_traits<const _Tp*>     {
       typedef _Tp value_type;
       typedef ptrdiff_t difference_type;
       typedef const _Tp* pointer;
       typedef const _Tp& reference;
     };
        ;
   template<typename _InIter>     using _RequireInputIter = typename       enable_if<is_convertible<typename   iterator_traits<_InIter>::iterator_category,           input_iterator_tag>::value>::type;
 }
    namespace std __attribute__ ((__visibility__ ("default"))) {
   class __undefined;
   template<typename _Tp>     struct __get_first_arg     {
 using type = __undefined;
 };
   template<template<typename, typename...> class _Template, typename _Tp,            typename... _Types>     struct __get_first_arg<_Template<_Tp, _Types...>>     {
 using type = _Tp;
 };
   template<typename _Tp>     using __get_first_arg_t = typename __get_first_arg<_Tp>::type;
   template<typename _Tp, typename _Up>     struct __replace_first_arg     {
 };
   template<template<typename, typename...> class _Template, typename _Up,            typename _Tp, typename... _Types>     struct __replace_first_arg<_Template<_Tp, _Types...>, _Up>     {
 using type = _Template<_Up, _Types...>;
 };
   template<typename _Tp, typename _Up>     using __replace_first_arg_t = typename __replace_first_arg<_Tp, _Up>::type;
   template<typename _Tp>     using __make_not_void       = typename conditional<is_void<_Tp>::value, __undefined, _Tp>::type;
   template<typename _Ptr>     struct pointer_traits     {
     private:       template<typename _Tp>  using __element_type = typename _Tp::element_type;
       template<typename _Tp>  using __difference_type = typename _Tp::difference_type;
       template<typename _Tp, typename _Up, typename = void>  struct __rebind : __replace_first_arg<_Tp, _Up> {
 };
       template<typename _Tp, typename _Up>  struct __rebind<_Tp, _Up, __void_t<typename _Tp::template rebind<_Up>>>  {
 using type = typename _Tp::template rebind<_Up>;
 };
       template<typename _Up>         using rebind = _Up*;
            };
   template<typename _Ptr, typename _Tp>     using __ptr_rebind = typename pointer_traits<_Ptr>::template rebind<_Tp>;
        ;
        ;
 }
    namespace std __attribute__ ((__visibility__ ("default"))) {
   template<typename _Iterator>     class reverse_iterator     : public iterator<typename iterator_traits<_Iterator>::iterator_category,         typename iterator_traits<_Iterator>::value_type,         typename iterator_traits<_Iterator>::difference_type,         typename iterator_traits<_Iterator>::pointer,                       typename iterator_traits<_Iterator>::reference>     {
     protected:       _Iterator current;
       typedef iterator_traits<_Iterator> __traits_type;
     public:       typedef _Iterator iterator_type;
       typedef typename __traits_type::pointer pointer;
       typedef typename __traits_type::reference reference;
                                     ;
     };
        ;
        ;
        ;
        ;
   template<typename _IteratorL, typename _IteratorR>      bool     operator>(const reverse_iterator<_IteratorL>& __x,        const reverse_iterator<_IteratorR>& __y)     ;
   template<typename _IteratorL, typename _IteratorR>      bool     operator<=(const reverse_iterator<_IteratorL>& __x,         const reverse_iterator<_IteratorR>& __y)     ;
   template<typename _IteratorL, typename _IteratorR>      bool     operator>=(const reverse_iterator<_IteratorL>& __x,         const reverse_iterator<_IteratorR>& __y)     ;
   template<typename _IteratorL, typename _IteratorR>      auto     operator-(const reverse_iterator<_IteratorL>& __x,        const reverse_iterator<_IteratorR>& __y)     -> decltype(__y.base() - __x.base())     ;
   template<typename _Iterator>      reverse_iterator<_Iterator>     operator+(typename reverse_iterator<_Iterator>::difference_type __n,        const reverse_iterator<_Iterator>& __x)     ;
   template<typename _Iterator>      reverse_iterator<_Iterator>     __make_reverse_iterator(_Iterator __i)     ;
   template<typename _Iterator>     auto     __niter_base(reverse_iterator<_Iterator> __it)     -> decltype(__make_reverse_iterator(__niter_base(__it.base())))     ;
   template<typename _Iterator>     struct __is_move_iterator<reverse_iterator<_Iterator> >       : __is_move_iterator<_Iterator>     {
 };
   template<typename _Container>     class back_insert_iterator     : public iterator<output_iterator_tag, void, void, void, void>     {
     protected:       _Container* container;
     public:       typedef _Container container_type;
                                               };
        ;
   template<typename _Container>     class front_insert_iterator     : public iterator<output_iterator_tag, void, void, void, void>     {
     protected:       _Container* container;
     public:       typedef _Container container_type;
                                               };
        ;
   template<typename _Container>     class insert_iterator     : public iterator<output_iterator_tag, void, void, void, void>     {
     protected:       _Container* container;
       typename _Container::iterator iter;
     public:       typedef _Container container_type;
                                               };
        ;
 }
    namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {
   using std::iterator_traits;
   using std::iterator;
   template<typename _Iterator, typename _Container>     class __normal_iterator     {
     protected:       _Iterator _M_current;
       typedef iterator_traits<_Iterator> __traits_type;
     public:       typedef _Iterator iterator_type;
       typedef typename __traits_type::iterator_category iterator_category;
                       ;
                                                                                         };
        ;
        ;
        ;
        ;
        ;
        ;
        ;
        ;
        ;
        ;
        ;
   template<typename _IteratorL, typename _IteratorR, typename _Container>      auto     operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,        const __normal_iterator<_IteratorR, _Container>& __rhs) noexcept     -> decltype(__lhs.base() - __rhs.base())     ;
   template<typename _Iterator, typename _Container>      typename __normal_iterator<_Iterator, _Container>::difference_type     operator-(const __normal_iterator<_Iterator, _Container>& __lhs,        const __normal_iterator<_Iterator, _Container>& __rhs)     noexcept     ;
        ;
 }
   extern "C" {
 typedef enum {
   P_ALL,    P_PID,    P_PGID  }
 idtype_t;
 typedef float _Float32;
 typedef double _Float64;
 typedef struct   {
     int quot;
      int rem;
    }
 div_t;
 typedef struct   {
     long int quot;
      long int rem;
    }
 ldiv_t;
  ;
  ;
  ;
  ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 struct __locale_struct {
   const int *__ctype_tolower;
   const int *__ctype_toupper;
   const char *__names[13];
 };
 typedef struct __locale_struct *__locale_t;
 typedef __locale_t locale_t;
 ;
 ;
 ;
 ;
 ;
 ;
  ;
  ;
 extern "C" {
 typedef __u_char u_char;
 typedef __u_short u_short;
 typedef __u_int u_int;
 typedef __u_long u_long;
 typedef __quad_t quad_t;
 typedef __u_quad_t u_quad_t;
 typedef __loff_t loff_t;
 typedef __ino_t ino_t;
 typedef __ino64_t ino64_t;
 typedef __mode_t mode_t;
 typedef __nlink_t nlink_t;
 typedef __uid_t uid_t;
 typedef __off_t off_t;
 typedef __off64_t off64_t;
 typedef __pid_t pid_t;
 typedef __id_t id_t;
 typedef __ssize_t ssize_t;
 typedef __daddr_t daddr_t;
 typedef __caddr_t caddr_t;
 typedef __key_t key_t;
  ;
  ;
  ;
  ;
  ;
 typedef struct {
   unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
 }
 __sigset_t;
  typedef __fsblkcnt_t fsblkcnt_t;
  typedef __fsfilcnt_t fsfilcnt_t;
  typedef __blkcnt64_t blkcnt64_t;
  struct __pthread_rwlock_arch_t {
   unsigned int __readers;
   unsigned int __writers;
   unsigned int __wrphase_futex;
   unsigned int __writers_futex;
   unsigned int __pad4;
   int __cur_writer;
   int __shared;
   signed char __rwelision;
   unsigned char __pad1[7];
   unsigned long int __pad2;
   unsigned int __flags;
 };
 typedef struct __pthread_internal_list {
   struct __pthread_internal_list *__prev;
   struct __pthread_internal_list *__next;
 }
 __pthread_list_t;
 struct __pthread_mutex_s {
   int __lock ;
   int __owner;
   unsigned int __nusers;
   int __kind;
   short __spins;
 short __elision;
   __pthread_list_t __list;
 };
 struct __pthread_cond_s {
   __extension__ union   {
     __extension__ unsigned long long int __wseq;
     struct     {       unsigned int __low;       unsigned int __high;     }
 __wseq32;
   };
   unsigned int __g_refs[2] ;
   unsigned int __wrefs;
   unsigned int __g_signals[2];
 }
 pthread_mutexattr_t;
 typedef union {
   char __size[4];
   int __align;
 }
 pthread_condattr_t;
 typedef unsigned int pthread_key_t;
 typedef int pthread_once_t;
 union pthread_attr_t {
   char __size[56];
   long int __align;
 };
 typedef union {
   struct __pthread_mutex_s __data;
   char __size[40];
   long int __align;
 }
 pthread_mutex_t;
 typedef union {
   struct __pthread_cond_s __data;
   char __size[48];
   __extension__ long long int __align;
 }
 pthread_cond_t;
 typedef union {
   long int __align;
 }
 pthread_rwlock_t;
 typedef union {
   long int __align;
 }
 pthread_rwlockattr_t;
      int rand_deg;
      int rand_sep;
      int32_t *end_ptr;
    };
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 struct drand48_data   {
     unsigned short int __x[3];
      unsigned short int __old_x[3];
      unsigned short int __c;
    };
 ;
 ;
 ;
 ;
                                           ;
  ;
                                        ;
 ;
 extern "C" {
 ;
 }
 ;
 ;
 ;
 ;
 ;
  ;
  ;
 ;
 ;
 ;
 ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
  ;
  ;
 ;
 ;
  ;
 ;
 ;
 ;
 }
   extern "C++" {
 namespace std {
   class exception   {
   public:   };
 }
  }
   namespace std __attribute__ ((__visibility__ ("default"))) {
   template<typename>     class allocator;
   template<>     class allocator<void>;
   template<typename, typename>     struct uses_allocator;
 }
   namespace std __attribute__ ((__visibility__ ("default"))) {
   struct __allocator_traits_base   {
     template<typename _Tp, typename _Up, typename = void>       struct __rebind : __replace_first_arg<_Tp, _Up> {
 };
     template<typename _Tp, typename _Up>       struct __rebind<_Tp, _Up,         __void_t<typename _Tp::template rebind<_Up>::other>>       {
 using type = typename _Tp::template rebind<_Up>::other;
 };
   protected:     template<typename _Tp>       using __pointer = typename _Tp::pointer;
     template<typename _Tp>       using __c_pointer = typename _Tp::const_pointer;
     template<typename _Tp>       using __v_pointer = typename _Tp::void_pointer;
     template<typename _Tp>       using __cv_pointer = typename _Tp::const_void_pointer;
     template<typename _Tp>       using __pocca = typename _Tp::propagate_on_container_copy_assignment;
     template<typename _Tp>       using __pocma = typename _Tp::propagate_on_container_move_assignment;
     template<typename _Tp>       using __pocs = typename _Tp::propagate_on_container_swap;
     template<typename _Tp>       using __equal = typename _Tp::is_always_equal;
   };
   template<typename _Alloc, typename _Up>     using __alloc_rebind       = typename __allocator_traits_base::template __rebind<_Alloc, _Up>::type;
   template<typename _Alloc>     struct allocator_traits : __allocator_traits_base     {
       typedef typename _Alloc::value_type value_type;
             using pointer = __detected_or_t<value_type*, __pointer, _Alloc>;
     private:       template<template<typename> class _Func, typename _Tp, typename = void>  struct _Ptr  {
    using type = typename pointer_traits<pointer>::template rebind<_Tp>;
  };
       template<template<typename> class _Func, typename _Tp>  struct _Ptr<_Func, _Tp, __void_t<_Func<_Alloc>>>  {
    using type = _Func<_Alloc>;
  };
       template<typename _A2, typename _PtrT, typename = void>  struct _Diff  {
 using type = typename pointer_traits<_PtrT>::difference_type;
 };
       template<typename _A2, typename _PtrT>  struct _Diff<_A2, _PtrT, __void_t<typename _A2::difference_type>>  {
 using type = typename _A2::difference_type;
 };
       template<typename _A2, typename _DiffT, typename = void>  struct _Size : make_unsigned<_DiffT> {
 };
       template<typename _A2, typename _DiffT>  struct _Size<_A2, _DiffT, __void_t<typename _A2::size_type>>  {
 };
     public:              using const_pointer = typename _Ptr<__c_pointer, const value_type>::type;
             using void_pointer = typename _Ptr<__v_pointer, void>::type;
              using const_void_pointer = typename _Ptr<__cv_pointer, const void>::type;
             using difference_type = typename _Diff<_Alloc, pointer>::type;
              using size_type = typename _Size<_Alloc, difference_type>::type;
       using propagate_on_container_copy_assignment  = __detected_or_t<false_type, __pocca, _Alloc>;
       using propagate_on_container_move_assignment  = __detected_or_t<false_type, __pocma, _Alloc>;
       static size_type max_size(const _Alloc& __a) noexcept       ;
       static _Alloc       select_on_container_copy_construction(const _Alloc& __rhs)       ;
     };
   template<typename _Tp>     struct allocator_traits<allocator<_Tp>>     {
       using allocator_type = allocator<_Tp>;
       using value_type = _Tp;
       using pointer = _Tp*;
       using const_pointer = const _Tp*;
       using void_pointer = void*;
       using const_void_pointer = const void*;
       using difference_type = std::ptrdiff_t;
       using size_type = std::size_t;
       using propagate_on_container_copy_assignment = false_type;
       using propagate_on_container_move_assignment = true_type;
       using propagate_on_container_swap = false_type;
       using is_always_equal = true_type;
       template<typename _Up>  using rebind_alloc = allocator<_Up>;
                          static pointer       allocate(allocator_type& __a, size_type __n, const_void_pointer __hint)       ;
       static void       deallocate(allocator_type& __a, pointer __p, size_type __n)       ;
       template<typename _Up, typename... _Args>  static void  construct(allocator_type& __a, _Up* __p, _Args&&... __args)  noexcept(noexcept(__a.construct(__p, std::forward<_Args>(__args)...)))  ;
       template<typename _Up>  static void  destroy(allocator_type& __a, _Up* __p)  noexcept(noexcept(__a.destroy(__p)))  ;
       static size_type       max_size(const allocator_type& __a) noexcept       ;
       static allocator_type       select_on_container_copy_construction(const allocator_type& __rhs)       ;
     };
   template<typename _Alloc>      void     __do_alloc_on_copy(_Alloc& __one, const _Alloc& __two, true_type)     ;
     ;
     ;
     ;
     ;
     ;
     ;
     ;
     ;
   template<typename _Alloc, typename _Tp,     typename _ValueT = __remove_cvref_t<typename _Alloc::value_type>,     typename = void>     struct __is_alloc_insertable_impl     : false_type     {
 };
   template<typename _Alloc, typename _Tp, typename _ValueT>     struct __is_alloc_insertable_impl<_Alloc, _Tp, _ValueT,       __void_t<decltype(allocator_traits<_Alloc>::construct(      std::declval<_Alloc&>(), std::declval<_ValueT*>(),      std::declval<_Tp>()))>>     : true_type     {
 };
   template<typename _Alloc>     struct __is_copy_insertable     : __is_alloc_insertable_impl<_Alloc,      typename _Alloc::value_type const&>::type     {
 };
   template<typename _Tp>     struct __is_copy_insertable<allocator<_Tp>>     : is_copy_constructible<_Tp>     {
 };
   template<typename _Alloc>     struct __is_move_insertable     : __is_alloc_insertable_impl<_Alloc, typename _Alloc::value_type>::type     {
 };
   template<typename _Tp>     struct __is_move_insertable<allocator<_Tp>>     : is_move_constructible<_Tp>     {
 };
   template<typename _Alloc, typename = void>     struct __is_allocator : false_type {
 };
   template<typename _Alloc>     struct __is_allocator<_Alloc,       __void_t<typename _Alloc::value_type,         decltype(std::declval<_Alloc&>().allocate(size_t{
}
))>>     : true_type {
 };
   template<typename _Alloc>     using _RequireAllocator       = typename enable_if<__is_allocator<_Alloc>::value, _Alloc>::type;
   template<typename _Alloc>     using _RequireNotAllocator       = typename enable_if<!__is_allocator<_Alloc>::value, _Alloc>::type;
 }
   namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {
 template<typename _Alloc, typename = typename _Alloc::value_type>   struct __alloc_traits   : std::allocator_traits<_Alloc>   {
     typedef _Alloc allocator_type;
     typedef std::allocator_traits<_Alloc> _Base_type;
     typedef typename _Base_type::value_type value_type;
     typedef typename _Base_type::pointer pointer;
     typedef typename _Base_type::const_pointer const_pointer;
     typedef typename _Base_type::difference_type difference_type;
     typedef value_type& reference;
     template<typename _Tp>       struct rebind       {
 typedef typename _Base_type::template rebind_alloc<_Tp> other;
 };
   };
 }
   namespace std __attribute__ ((__visibility__ ("default"))) {
   template<class _CharT>     struct char_traits;
   template<> struct char_traits<char>;
   template<> struct char_traits<wchar_t>;
   template<> struct char_traits<char32_t>;
 namespace __cxx11 {
   template<typename _CharT, typename _Traits = char_traits<_CharT>,            typename _Alloc = allocator<_CharT> >     class basic_string;
 }
   typedef basic_string<char> string;
   typedef basic_string<wchar_t> wstring;
 }
  typedef unsigned int wint_t;
  typedef struct {
   int __count;
   union   {
     unsigned int __wch;
     char __wchb[4];
   }
 __value;
  }
  __mbstate_t;
  typedef __mbstate_t mbstate_t;
  typedef struct _IO_FILE FILE;
  namespace std {
   using ::mbstate_t;
 }
   namespace std __attribute__ ((__visibility__ ("default"))) {
   typedef long streamoff;
   typedef ptrdiff_t streamsize;
    template<typename _StateT>     class fpos     {
     private:       streamoff _M_off;
       _StateT _M_state;
     public:                                                                                                };
        ;
        ;
   typedef fpos<mbstate_t> streampos;
   typedef fpos<mbstate_t> wstreampos;
   typedef fpos<mbstate_t> u16streampos;
   typedef fpos<mbstate_t> u32streampos;
 }
   namespace std __attribute__ ((__visibility__ ("default"))) {
     class ios_base;
   template<typename _CharT, typename _Traits = char_traits<_CharT> >     class basic_ios;
   template<typename _CharT, typename _Traits = char_traits<_CharT> >     class basic_streambuf;
   template<typename _CharT, typename _Traits = char_traits<_CharT> >     class basic_istream;
   template<typename _CharT, typename _Traits = char_traits<_CharT> >     class basic_ostream;
   template<typename _CharT, typename _Traits = char_traits<_CharT> >     class basic_iostream;
 namespace __cxx11 {
   template<typename _CharT, typename _Traits = char_traits<_CharT>,      typename _Alloc = allocator<_CharT> >     class basic_stringbuf;
   template<typename _CharT, typename _Traits = char_traits<_CharT>,     typename _Alloc = allocator<_CharT> >     class basic_istringstream;
   template<typename _CharT, typename _Traits = char_traits<_CharT>,     typename _Alloc = allocator<_CharT> >     class basic_ostringstream;
   template<typename _CharT, typename _Traits = char_traits<_CharT>,     typename _Alloc = allocator<_CharT> >     class basic_stringstream;
 }
   template<typename _CharT, typename _Traits = char_traits<_CharT> >     class basic_filebuf;
   template<typename _CharT, typename _Traits = char_traits<_CharT> >     class basic_ifstream;
   template<typename _CharT, typename _Traits = char_traits<_CharT> >     class basic_ofstream;
   template<typename _CharT, typename _Traits = char_traits<_CharT> >     class basic_fstream;
   template<typename _CharT, typename _Traits = char_traits<_CharT> >     class istreambuf_iterator;
   template<typename _CharT, typename _Traits = char_traits<_CharT> >     class ostreambuf_iterator;
   typedef basic_ios<char> ios;
   typedef basic_streambuf<char> streambuf;
   typedef basic_istream<char> istream;
   typedef basic_ostream<char> ostream;
   typedef basic_stringbuf<char> stringbuf;
   typedef basic_istringstream<char> istringstream;
   typedef basic_ostringstream<char> ostringstream;
   typedef basic_stringstream<char> stringstream;
   typedef basic_filebuf<char> filebuf;
   typedef basic_ifstream<char> ifstream;
   typedef basic_ofstream<char> ofstream;
   typedef basic_fstream<char> fstream;
   typedef basic_ios<wchar_t> wios;
   typedef basic_streambuf<wchar_t> wstreambuf;
   typedef basic_istream<wchar_t> wistream;
   typedef basic_ostream<wchar_t> wostream;
   typedef basic_iostream<wchar_t> wiostream;
   typedef basic_stringbuf<wchar_t> wstringbuf;
   typedef basic_stringstream<wchar_t> wstringstream;
   typedef basic_filebuf<wchar_t> wfilebuf;
   typedef basic_ifstream<wchar_t> wifstream;
   typedef basic_ofstream<wchar_t> wofstream;
   }
   namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {
      template<typename _CharT>     struct _Char_types     {
       typedef unsigned long int_type;
       typedef std::streampos pos_type;
       typedef std::streamoff off_type;
       typedef std::mbstate_t state_type;
     };
   template<typename _CharT>     struct char_traits     {
       typedef _CharT char_type;
       typedef typename _Char_types<_CharT>::int_type int_type;
       typedef typename _Char_types<_CharT>::pos_type pos_type;
       typedef typename _Char_types<_CharT>::off_type off_type;
       typedef typename _Char_types<_CharT>::state_type state_type;
     };
 }
   namespace std __attribute__ ((__visibility__ ("default"))) {
   template<class _CharT>     struct char_traits : public __gnu_cxx::char_traits<_CharT>     {
 };
   template<>     struct char_traits<char>     {
       typedef char char_type;
       typedef int int_type;
       typedef streampos pos_type;
       typedef streamoff off_type;
       typedef mbstate_t state_type;
   };
   template<>     struct char_traits<wchar_t>     {
       typedef wchar_t char_type;
       typedef wint_t int_type;
       typedef streamoff off_type;
       typedef wstreampos pos_type;
       typedef mbstate_t state_type;
   };
 }
   namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {
   using std::size_t;
   using std::ptrdiff_t;
   template<typename _Tp>     class new_allocator     {
     public:       typedef size_t size_type;
       typedef ptrdiff_t difference_type;
       typedef _Tp* pointer;
       typedef const _Tp* const_pointer;
       typedef _Tp& reference;
       typedef const _Tp& const_reference;
       typedef _Tp value_type;
       template<typename _Tp1>  struct rebind  {
 typedef new_allocator<_Tp1> other;
 };
       typedef std::true_type propagate_on_container_move_assignment;
        ;
  ;
  ;
        ;
     };
 }
   namespace std {
   template<typename _Tp>     using __allocator_base = __gnu_cxx::new_allocator<_Tp>;
 }
  namespace std __attribute__ ((__visibility__ ("default"))) {
   template<>     class allocator<void>     {
     public:       typedef size_t size_type;
       typedef ptrdiff_t difference_type;
       typedef void* pointer;
       typedef const void* const_pointer;
       typedef void value_type;
       template<typename _Tp1>  struct rebind  {
 typedef allocator<_Tp1> other;
 };
       typedef true_type propagate_on_container_move_assignment;
  ;
  ;
     };
   template<typename _Tp>     class allocator : public __allocator_base<_Tp>     {
    public:       typedef size_t size_type;
       typedef ptrdiff_t difference_type;
       typedef _Tp* pointer;
       typedef const _Tp* const_pointer;
        ;
     };
   template<typename _Tp>     class allocator<const volatile _Tp>     {
     public:       typedef _Tp value_type;
        ;
     };
   extern template class allocator<char>;
   extern template class allocator<wchar_t>;
   template<typename _Alloc, bool = __is_empty(_Alloc)>     struct __alloc_swap     {
  };
   template<typename _Alloc>     struct __alloc_swap<_Alloc, false>     {
     };
   template<typename _Alloc, bool = __is_empty(_Alloc)>     struct __alloc_neq     {
     };
   template<typename _Alloc>     struct __alloc_neq<_Alloc, false>     {
     };
   template<typename _Tp, bool     = __or_<is_copy_constructible<typename _Tp::value_type>,             is_nothrow_move_constructible<typename _Tp::value_type>>::value>     struct __shrink_to_fit_aux     {
  };
   template<typename _Tp>     struct __shrink_to_fit_aux<_Tp, true>     {
     };
 }
    namespace std __attribute__ ((__visibility__ ("default"))) {
   typedef __locale_t __c_locale;
     }
    namespace std __attribute__ ((__visibility__ ("default"))) {
   class locale;
   ;
   ;
   ;
   ;
   ;
   ;
   ;
   ;
   ;
   ;
   ;
   ;
   ;
   class ctype_base;
   template<typename _CharT>     class ctype;
   template<> class ctype<char>;
   template<> class ctype<wchar_t>;
   template<typename _CharT>     class ctype_byname;
   template<typename _InternT, typename _ExternT, typename _StateT>     class codecvt;
   template<> class codecvt<char, char, mbstate_t>;
   template<> class codecvt<wchar_t, char, mbstate_t>;
   template<> class codecvt<char16_t, char, mbstate_t>;
   template<> class codecvt<char32_t, char, mbstate_t>;
   template<typename _InternT, typename _ExternT, typename _StateT>     class codecvt_byname;
   template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >     class num_get;
   template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >     class num_put;
 namespace __cxx11 {
   template<typename _CharT>     class collate;
   template<typename _CharT>     class collate_byname;
 }
   class time_base;
 namespace __cxx11 {
   template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >     class time_get_byname;
 }
   template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >     class time_put;
   template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >     class time_put_byname;
   class money_base;
 namespace __cxx11 {
   template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >     class money_get;
   template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >     class money_put;
 }
 namespace __cxx11 {
   template<typename _CharT, bool _Intl = false>     class moneypunct;
   template<typename _CharT, bool _Intl = false>     class moneypunct_byname;
 }
   class messages_base;
 namespace __cxx11 {
   template<typename _CharT>     class messages_byname;
 }
 }
   typedef pthread_once_t __gthread_once_t;
   typedef pthread_mutex_t __gthread_mutex_t;
  typedef int _Atomic_word;
    namespace std __attribute__ ((__visibility__ ("default"))) {
 namespace __cxx11 {
   template<typename _CharT, typename _Traits, typename _Alloc>     class basic_string     {
       typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template  rebind<_CharT>::other _Char_alloc_type;
       typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;
     public:       typedef _Traits traits_type;
       typedef typename _Traits::char_type value_type;
       typedef _Char_alloc_type allocator_type;
       typedef typename _Alloc_traits::size_type size_type;
       typedef typename _Alloc_traits::difference_type difference_type;
       typedef typename _Alloc_traits::reference reference;
       typedef typename _Alloc_traits::pointer pointer;
       typedef typename _Alloc_traits::const_pointer const_pointer;
       typedef __gnu_cxx::__normal_iterator<pointer, basic_string> iterator;
       typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>        const_iterator;
       typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
     protected:       typedef const_iterator __const_iterator;
     private:       struct _Alloc_hider : allocator_type        {
      pointer _M_p;
        };
       _Alloc_hider _M_dataplus;
       size_type _M_string_length;
       enum {
 _S_local_capacity = 15 / sizeof(_CharT) };
       union       {
  _CharT _M_local_buf[_S_local_capacity + 1];
  size_type _M_allocated_capacity;
       };
         ;
                ;
       ;
       ;
                          private:                                                                 ;
                                                             public:                                                                                                                                                                             ;
     private:         ;
       ;
     public:       template<typename, typename, typename> friend class basic_stringbuf;
     };
 }
   ;
     ;
     ;
     ;
     ;
   template<typename _CharT, typename _Traits, typename _Alloc>      bool     operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,         const basic_string<_CharT, _Traits, _Alloc>& __rhs)     noexcept     ;
   template<typename _CharT, typename _Traits, typename _Alloc>      bool     operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,         const _CharT* __rhs)     ;
   template<typename _CharT, typename _Traits, typename _Alloc>      bool     operator>=(const _CharT* __lhs,       const basic_string<_CharT, _Traits, _Alloc>& __rhs)     ;
   template<typename _CharT, typename _Traits, typename _Alloc>      void     swap(basic_string<_CharT, _Traits, _Alloc>& __lhs,   basic_string<_CharT, _Traits, _Alloc>& __rhs)     noexcept(noexcept(__lhs.swap(__rhs)))     ;
   template<typename _CharT, typename _Traits, typename _Alloc>     basic_istream<_CharT, _Traits>&     operator>>(basic_istream<_CharT, _Traits>& __is,         basic_string<_CharT, _Traits, _Alloc>& __str);
   template<>     basic_istream<char>&     operator>>(basic_istream<char>& __is, basic_string<char>& __str);
   template<typename _CharT, typename _Traits, typename _Alloc>     basic_istream<_CharT, _Traits>&     getline(basic_istream<_CharT, _Traits>& __is,      basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim);
   template<typename _CharT, typename _Traits, typename _Alloc>      basic_istream<_CharT, _Traits>&     getline(basic_istream<_CharT, _Traits>& __is,      basic_string<_CharT, _Traits, _Alloc>& __str)     ;
     ;
     ;
   template<>     basic_istream<char>&     getline(basic_istream<char>& __in, basic_string<char>& __str,      char __delim);
   template<>     basic_istream<wchar_t>&     getline(basic_istream<wchar_t>& __in, basic_string<wchar_t>& __str,      wchar_t __delim);
 }
   namespace std __attribute__ ((__visibility__ ("default"))) {
   struct __cow_string   {
     union {
       const char* _M_p;
       char _M_bytes[sizeof(const char*)];
     };
        };
   typedef basic_string<char> __sso_string;
   class logic_error : public exception   {
   public:   };
   class domain_error : public logic_error   {
   public:   };
   class invalid_argument : public logic_error   {
   public:   };
   class length_error : public logic_error   {
   public:   };
   class runtime_error : public exception   {
     __cow_string _M_msg;
   public:   };
   class range_error : public runtime_error   {
   public:   };
   class overflow_error : public runtime_error   {
   public:   };
   class underflow_error : public runtime_error   {
   public:             };
 }
   namespace std __attribute__ ((__visibility__ ("default"))) {
   class locale   {
   public:     typedef int category;
     class facet;
     class id;
     class _Impl;
     friend class facet;
     friend class _Impl;
     ;
     ;
     template<typename _Cache>       friend struct __use_cache;
     static const category none = 0;
     static const category ctype = 1L << 0;
     static _Impl* _S_classic;
     static _Impl* _S_global;
                              static const id* const _S_twinned_facets[];
   };
   class locale::facet   {
   private:     friend class locale;
     friend class locale::_Impl;
     mutable _Atomic_word _M_refcount;
     static __c_locale _S_c_locale;
     static const char _S_c_name[2];
        protected:                                                     private:                       protected:     class __shim;
    };
   class locale::id   {
   private:     friend class locale;
     friend class locale::_Impl;
     ;
     ;
     mutable size_t _M_index;
     static _Atomic_word _S_refcount;
               public:     id() ;
        };
   class locale::_Impl   {
   public:     friend class locale;
     friend class locale::facet;
     ;
     ;
     template<typename _Cache>       friend struct __use_cache;
     const facet** _M_facets;
     size_t _M_facets_size;
     const facet** _M_caches;
     char** _M_names;
     static const locale::id* const _S_id_ctype[];
     static const locale::id* const _S_id_numeric[];
     static const locale::id* const _S_id_collate[];
     static const locale::id* const _S_id_time[];
     static const locale::id* const _S_id_monetary[];
                                                                              ;
            ;
                  };
   template<typename _CharT>     class __cxx11:: collate : public locale::facet     {
     public:       typedef _CharT char_type;
 };
   inline namespace _V2 {
   class error_category   {
   public:                            private:        public:        public:                                 };
         }
       template<typename _Tp>     struct hash;
   struct error_code   {
                      ;
                      ;
                            private:     friend class hash<error_code>;
     int _M_value;
     const error_category* _M_cat;
   };
                ;
      struct error_condition   {
                 ;
                            private:     int _M_value;
     const error_category* _M_cat;
   };
                                           class system_error : public std::runtime_error   {
   private:     error_code _M_code;
   public:                                                     };
 }
   namespace std __attribute__ ((__visibility__ ("default"))) {
   enum _Ios_Fmtflags     {
       _S_boolalpha = 1L << 0,       _S_dec = 1L << 1,       _S_fixed = 1L << 2,       _S_hex = 1L << 3,       _S_internal = 1L << 4,       _S_left = 1L << 5,       _S_oct = 1L << 6,       _S_right = 1L << 7,       _S_scientific = 1L << 8,       _S_showbase = 1L << 9,       _S_showpoint = 1L << 10,       _S_showpos = 1L << 11,       _S_skipws = 1L << 12,       _S_unitbuf = 1L << 13,       _S_uppercase = 1L << 14,       _S_adjustfield = _S_left | _S_right | _S_internal,       _S_basefield = _S_dec | _S_oct | _S_hex,       _S_floatfield = _S_scientific | _S_fixed,       _S_ios_fmtflags_end = 1L << 16,       _S_ios_fmtflags_max = 2147483647,       _S_ios_fmtflags_min = ~2147483647     };
                               enum _Ios_Openmode     {
       _S_app = 1L << 0,       _S_ate = 1L << 1,       _S_bin = 1L << 2,       _S_in = 1L << 3,       _S_out = 1L << 4,       _S_trunc = 1L << 5,       _S_ios_openmode_end = 1L << 16,       _S_ios_openmode_max = 2147483647,       _S_ios_openmode_min = ~2147483647     };
        constexpr _Ios_Openmode   operator|(_Ios_Openmode __a, _Ios_Openmode __b)   ;
                       enum _Ios_Iostate     {
       _S_goodbit = 0,       _S_badbit = 1L << 0,       _S_eofbit = 1L << 1,       _S_failbit = 1L << 2,       _S_ios_iostate_end = 1L << 16,       _S_ios_iostate_max = 2147483647,       _S_ios_iostate_min = ~2147483647     };
                               enum _Ios_Seekdir     {
       _S_beg = 0,       _S_cur = 1,       _S_end = 2,       _S_ios_seekdir_end = 1L << 16     };
   enum class io_errc {
 stream = 1 };
              class ios_base   {
   public:     class __attribute ((__abi_tag__ ("cxx11"))) failure : public system_error     {
     public:                                        };
     typedef _Ios_Fmtflags fmtflags;
     static const fmtflags boolalpha = _S_boolalpha;
     static const fmtflags dec = _S_dec;
     static const fmtflags fixed = _S_fixed;
     static const fmtflags hex = _S_hex;
     static const fmtflags internal = _S_internal;
     static const fmtflags left = _S_left;
     static const fmtflags oct = _S_oct;
     static const fmtflags right = _S_right;
     static const fmtflags scientific = _S_scientific;
     static const fmtflags showbase = _S_showbase;
     static const fmtflags showpoint = _S_showpoint;
     static const fmtflags skipws = _S_skipws;
     static const fmtflags unitbuf = _S_unitbuf;
     static const fmtflags uppercase = _S_uppercase;
     static const fmtflags adjustfield = _S_adjustfield;
     static const fmtflags basefield = _S_basefield;
     static const fmtflags floatfield = _S_floatfield;
     typedef _Ios_Iostate iostate;
     static const iostate badbit = _S_badbit;
     static const iostate eofbit = _S_eofbit;
     static const iostate failbit = _S_failbit;
     static const iostate goodbit = _S_goodbit;
     typedef _Ios_Openmode openmode;
     static const openmode app = _S_app;
     static const openmode ate = _S_ate;
     static const openmode binary = _S_bin;
     static const openmode in = _S_in;
     typedef _Ios_Seekdir seekdir;
     static const seekdir beg = _S_beg;
     static const seekdir cur = _S_cur;
     typedef int io_state;
     typedef int open_mode;
     typedef int seek_dir;
     typedef std::streampos streampos;
     typedef std::streamoff streamoff;
     enum event     {
       erase_event,       imbue_event,       copyfmt_event     };
     typedef void (*event_callback) (event __e, ios_base& __b, int __i);
        protected:     streamsize _M_precision;
     streamsize _M_width;
     fmtflags _M_flags;
     iostate _M_exception;
     iostate _M_streambuf_state;
     struct _Callback_list     {
       _Callback_list* _M_next;
       ios_base::event_callback _M_fn;
       int _M_index;
                           };
      _Callback_list* _M_callbacks;
          locale _M_ios_locale;
        public:     class Init     {
       friend class ios_base;
     public:                                 private:       static _Atomic_word _S_refcount;
       static bool _S_synced_with_stdio;
     };
                                                                                        protected:        public:             protected:             };
                                                                                        ios_base&   scientific(ios_base& __base)   ;
    ios_base&   hexfloat(ios_base& __base)   ;
    ios_base&   defaultfloat(ios_base& __base)   ;
   template<typename _CharT, typename _Traits>     streamsize     __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>*,      basic_streambuf<_CharT, _Traits>*, bool&);
   template<typename _CharT, typename _Traits>     class basic_streambuf     {
     public:       typedef _CharT char_type;
       typedef _Traits traits_type;
       typedef typename traits_type::pos_type pos_type;
       typedef typename traits_type::off_type off_type;
       typedef basic_streambuf<char_type, traits_type> __streambuf_type;
       friend class basic_ios<char_type, traits_type>;
       friend class basic_istream<char_type, traits_type>;
       friend class basic_ostream<char_type, traits_type>;
        char_type* _M_in_cur;
        char_type* _M_in_end;
        char_type* _M_out_beg;
        char_type* _M_out_cur;
        char_type* _M_out_end;
        locale _M_buf_locale;
   public:       virtual       ~basic_streambuf()       ;
                                                                                                              protected:                                                                                                                                                                      public:       [[__deprecated__("stossc is deprecated, use sbumpc instead")]]       void       stossc()       {
  if (this->gptr() < this->egptr())    this->gbump(1);
  else    this->uflow();
       }
       void       __safe_gbump(streamsize __n) {
 _M_in_cur += __n;
 _M_out_cur += __n;
 }
     protected:       basic_streambuf(const basic_streambuf&);
                   };
         template<>     streamsize     __copy_streambufs_eof(basic_streambuf<char>* __sbin,      basic_streambuf<char>* __sbout, bool& __ineof);
 }
   namespace std __attribute__ ((__visibility__ ("default"))) {
     ;
   template<typename _CharT, typename _Traits>     class basic_ios : public ios_base     {
     public:       typedef _CharT char_type;
     };
 }
   namespace std __attribute__ ((__visibility__ ("default"))) {
   template<typename _CharT, typename _Traits>     class basic_ostream : virtual public basic_ios<_CharT, _Traits>     {
     public:       typedef _CharT char_type;
       typedef typename _Traits::int_type int_type;
       typedef typename _Traits::pos_type pos_type;
       typedef typename _Traits::off_type off_type;
       typedef _Traits traits_type;
       typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
       typedef basic_ostream<_CharT, _Traits> __ostream_type;
       typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >              __num_put_type;
       typedef ctype<_CharT> __ctype_type;
             explicit       basic_ostream(__streambuf_type* __sb)       ;
       virtual       ~basic_ostream() ;
       class sentry;
       friend class sentry;
       __ostream_type&       operator<<(__ostream_type& (*__pf)(__ostream_type&))       ;
       basic_ostream<_CharT, _Traits>& _M_os;
     public:                     };
          ;
        ;
        ;
        ;
        ;
          ;
   ;
        ;
        ;
          ;
          ;
        ;
   ;
   template<typename _Tp, typename = void>     struct __is_convertible_to_basic_ostream_impl     {
       using __ostream_type = void;
     };
   template<typename _Tp>     using __do_is_convertible_to_basic_ostream_impl =     decltype(__is_convertible_to_basic_ostream_test       (declval<typename remove_reference<_Tp>::type*>()));
   template<typename _Tp>     struct __is_convertible_to_basic_ostream_impl     <_Tp,      __void_t<__do_is_convertible_to_basic_ostream_impl<_Tp>>>     {
       using __ostream_type =  __do_is_convertible_to_basic_ostream_impl<_Tp>;
     };
   template<typename _Tp>     struct __is_convertible_to_basic_ostream     : __is_convertible_to_basic_ostream_impl<_Tp>     {
     public:       using type = __not_<is_void<         typename __is_convertible_to_basic_ostream_impl<_Tp>::__ostream_type>>;
       constexpr static bool value = type::value;
     };
   template<typename _Ostream, typename _Tp, typename = void>     struct __is_insertable : false_type {
};
   template<typename _Ostream, typename _Tp>     struct __is_insertable<_Ostream, _Tp,       __void_t<decltype(declval<_Ostream&>()           << declval<const _Tp&>())>>         : true_type {
};
   template<typename _Ostream>     using __rvalue_ostream_type =       typename __is_convertible_to_basic_ostream<  _Ostream>::__ostream_type;
     ;
 }
   namespace std __attribute__ ((__visibility__ ("default"))) {
 namespace __cxx11 {
   template<typename _CharT, typename _Traits, typename _Alloc>     class basic_stringbuf : public basic_streambuf<_CharT, _Traits>     {
       struct __xfer_bufptrs;
     public:       typedef _CharT char_type;
       typedef _Traits traits_type;
       typedef _Alloc allocator_type;
       typedef typename traits_type::int_type int_type;
       typedef typename traits_type::pos_type pos_type;
       typedef typename traits_type::off_type off_type;
       typedef basic_streambuf<char_type, traits_type> __streambuf_type;
       typedef basic_string<char_type, _Traits, _Alloc> __string_type;
       typedef typename __string_type::size_type __size_type;
       __string_type _M_string;
     public:     protected:     private:       struct __xfer_bufptrs       {
  basic_stringbuf* _M_to;
  off_type _M_goff[3];
  off_type _M_poff[3];
       };
     };
   template<typename _CharT, typename _Traits, typename _Alloc>     class basic_istringstream : public basic_istream<_CharT, _Traits>     {
     public:                                                                                               };
   template <typename _CharT, typename _Traits, typename _Alloc>     class basic_ostringstream : public basic_ostream<_CharT, _Traits>     {
     public:       typedef _CharT char_type;
       typedef _Traits traits_type;
       typedef _Alloc allocator_type;
       typedef typename traits_type::int_type int_type;
       typedef typename traits_type::pos_type pos_type;
       typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
       typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
       typedef basic_ostream<char_type, traits_type> __ostream_type;
     private:       __stringbuf_type _M_stringbuf;
     public:                                                                                         };
   template <typename _CharT, typename _Traits, typename _Alloc>     class basic_stringstream : public basic_iostream<_CharT, _Traits>     {
     public:       typedef _CharT char_type;
       typedef _Traits traits_type;
       typedef _Alloc allocator_type;
       typedef typename traits_type::int_type int_type;
       typedef typename traits_type::pos_type pos_type;
       typedef typename traits_type::off_type off_type;
       typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
       typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
       typedef basic_iostream<char_type, traits_type> __iostream_type;
     public:                                                                                         };
        ;
        ;
        ;
        ;
 }
 }
   namespace std __attribute__ ((__visibility__ ("default"))) {
   typedef __gthread_mutex_t __c_lock;
   typedef FILE __c_file;
 }
   namespace std __attribute__ ((__visibility__ ("default"))) {
   template<typename _CharT>     class __basic_file;
   template<>     class __basic_file<char>     {
       __c_file* _M_cfile;
     public:                                                                                                                                          };
 }
   namespace std __attribute__ ((__visibility__ ("default"))) {
   template<typename _CharT, typename _Traits>     class basic_filebuf : public basic_streambuf<_CharT, _Traits>     {
       template<typename _Tp>  using __chk_state = __and_<is_copy_assignable<_Tp>,        is_copy_constructible<_Tp>,        is_default_constructible<_Tp>>;
       static_assert(__chk_state<typename _Traits::state_type>::value,       "state_type must be CopyAssignable, CopyConstructible"       " and DefaultConstructible");
       static_assert(is_same<typename _Traits::pos_type,        fpos<typename _Traits::state_type>>::value,       "pos_type must be fpos<state_type>");
     public:       typedef _CharT char_type;
       typedef _Traits traits_type;
       typedef typename traits_type::int_type int_type;
       typedef basic_streambuf<char_type, traits_type> __streambuf_type;
       typedef basic_filebuf<char_type, traits_type> __filebuf_type;
       typedef __basic_file<char> __file_type;
       typedef typename traits_type::state_type __state_type;
       typedef codecvt<char_type, char, __state_type> __codecvt_type;
       friend class ios_base;
       __file_type _M_file;
       ios_base::openmode _M_mode;
       __state_type _M_state_beg;
       __state_type _M_state_cur;
       __state_type _M_state_last;
       char_type* _M_buf;
       size_t _M_buf_size;
       bool _M_buf_allocated;
       bool _M_reading;
       bool _M_writing;
       char_type _M_pback;
       char_type* _M_pback_cur_save;
       char_type* _M_pback_end_save;
       bool _M_pback_init;
       const __codecvt_type* _M_codecvt;
       char* _M_ext_buf;
       streamsize _M_ext_buf_size;
       char* _M_ext_end;
                   public:                                                                                  protected:                                                                                                                                   };
   template<typename _CharT, typename _Traits>     class basic_ifstream : public basic_istream<_CharT, _Traits>     {
     public:       typedef _CharT char_type;
       typedef _Traits traits_type;
       typedef typename traits_type::int_type int_type;
       typedef typename traits_type::pos_type pos_type;
       typedef typename traits_type::off_type off_type;
       typedef basic_filebuf<char_type, traits_type> __filebuf_type;
     public:                                                                                                              };
   template<typename _CharT, typename _Traits>     class basic_ofstream : public basic_ostream<_CharT,_Traits>     {
     public:       typedef _CharT char_type;
       typedef _Traits traits_type;
       typedef typename traits_type::int_type int_type;
       typedef typename traits_type::pos_type pos_type;
       typedef typename traits_type::off_type off_type;
       typedef basic_filebuf<char_type, traits_type> __filebuf_type;
     private:       __filebuf_type _M_filebuf;
     public:                                                                                                              };
   template<typename _CharT, typename _Traits>     class basic_fstream : public basic_iostream<_CharT, _Traits>     {
     public:       typedef _CharT char_type;
       typedef _Traits traits_type;
       typedef typename traits_type::int_type int_type;
       typedef typename traits_type::pos_type pos_type;
     public:                                                                                                              };
        ;
        ;
        ;
        ;
 }
  class oprocstream;
  namespace octave {
   class interpreter;
   class   pager_buf : public std::stringbuf   {
   };
   class   pager_stream : public std::ostream   {
   public:                                           private:     pager_buf *pb;
   };
   class   diary_buf : public std::stringbuf   {
   public:        protected:        };
   class   diary_stream : public std::ostream   {
     ~diary_stream (void);
     std::ostream& stream (void);
        private:     diary_buf *db;
   };
      class output_system   {
   public:                                                                                                                                                                                       private:     interpreter& m_interpreter;
     pager_stream m_pager_stream;
     diary_stream m_diary_stream;
     oprocstream *m_external_pager = nullptr;
     std::ofstream m_external_diary_file;
     std::string m_diary_file_name;
     std::string m_PAGER_FLAGS;
     bool m_page_output_immediately;
     bool m_page_screen_output;
     bool m_write_to_diary_file;
     bool m_really_flush_to_pager;
     bool m_flushing_output_to_pager;
             };
       }
