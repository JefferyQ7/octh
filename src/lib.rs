/* automatically generated by rust-bindgen */

pub type std_nullptr_t = *const ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug)]
pub struct std_allocator {
    pub _address: u8,
}
pub type std_allocator_size_type = usize;
pub type std_allocator_difference_type = isize;
pub type std_allocator_pointer<_Tp> = *mut _Tp;
pub type std_allocator_const_pointer<_Tp> = *mut _Tp;
pub type std_allocator_reference<_Tp> = *mut _Tp;
pub type std_allocator_const_reference<_Tp> = *mut _Tp;
pub type std_allocator_value_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_rebind {
    pub _address: u8,
}
pub type std_allocator_rebind_other = std_allocator;
pub type std_allocator_propagate_on_container_move_assignment = std_true_type;
#[test]
fn __bindgen_test_layout_std_allocator_instantiation_374() {
    assert_eq!(::std::mem::size_of::<std_allocator>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std_allocator ) ));
    assert_eq!(::std::mem::align_of::<std_allocator>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_allocator ) ));
}
#[repr(C)]
pub struct std_uses_allocator {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_char_traits {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug)]
pub struct std_basic_string<_CharT, _Alloc> {
    pub _M_dataplus: std_basic_string__Alloc_hider<_CharT, _Alloc>,
}
pub type std_basic_string__CharT_alloc_type = [u8; 0usize];
pub type std_basic_string_traits_type<_Traits> = _Traits;
pub type std_basic_string_value_type = [u8; 0usize];
pub type std_basic_string_allocator_type<_Alloc> = _Alloc;
pub type std_basic_string_size_type = [u8; 0usize];
pub type std_basic_string_difference_type = [u8; 0usize];
pub type std_basic_string_reference = [u8; 0usize];
pub type std_basic_string_const_reference = [u8; 0usize];
pub type std_basic_string_pointer = [u8; 0usize];
pub type std_basic_string_const_pointer = [u8; 0usize];
pub type std_basic_string_iterator =
    __gnu_cxx___normal_iterator<std_basic_string_pointer>;
pub type std_basic_string_const_iterator =
    __gnu_cxx___normal_iterator<std_basic_string_const_pointer>;
pub type std_basic_string_const_reverse_iterator =
    std_reverse_iterator<std_basic_string_const_iterator>;
pub type std_basic_string_reverse_iterator =
    std_reverse_iterator<std_basic_string_iterator>;
#[repr(C)]
pub struct std_basic_string__Rep_base {
    pub _M_length: std_basic_string_size_type,
    pub _M_capacity: std_basic_string_size_type,
    pub _M_refcount: std__Atomic_word,
}
#[repr(C)]
pub struct std_basic_string__Rep {
    pub _base: std_basic_string__Rep_base,
}
pub type std_basic_string__Rep__Raw_bytes_alloc = [u8; 0usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_string__Alloc_hider<_CharT, _Alloc> {
    pub _base: _Alloc,
    pub _M_p: *mut _CharT,
}
#[test]
fn __bindgen_test_layout_std_char_traits_instantiation_513() {
    assert_eq!(::std::mem::size_of::<std_char_traits>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std_char_traits ) ));
    assert_eq!(::std::mem::align_of::<std_char_traits>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_char_traits ) ));
}
pub type std_string = std_basic_string<::std::os::raw::c_char, std_allocator>;
#[test]
fn __bindgen_test_layout_std_char_traits_instantiation_519() {
    assert_eq!(::std::mem::size_of::<std_char_traits>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std_char_traits ) ));
    assert_eq!(::std::mem::align_of::<std_char_traits>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_char_traits ) ));
}
pub type std_wstring = std_basic_string<u16, std_allocator>;
#[test]
fn __bindgen_test_layout_std_char_traits_instantiation_525() {
    assert_eq!(::std::mem::size_of::<std_char_traits>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std_char_traits ) ));
    assert_eq!(::std::mem::align_of::<std_char_traits>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_char_traits ) ));
}
#[test]
fn __bindgen_test_layout_std_char_traits_instantiation_529() {
    assert_eq!(::std::mem::size_of::<std_char_traits>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std_char_traits ) ));
    assert_eq!(::std::mem::align_of::<std_char_traits>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_char_traits ) ));
}
pub type std_u16string = std_basic_string<u16, std_allocator>;
pub type std_u32string = std_basic_string<u32, std_allocator>;
extern "C" {
    #[link_name = "?__throw_bad_exception@std@@YAXXZ"]
    pub fn std___throw_bad_exception();
}
extern "C" {
    #[link_name = "?__throw_bad_alloc@std@@YAXXZ"]
    pub fn std___throw_bad_alloc();
}
extern "C" {
    #[link_name = "?__throw_bad_cast@std@@YAXXZ"]
    pub fn std___throw_bad_cast();
}
extern "C" {
    #[link_name = "?__throw_bad_typeid@std@@YAXXZ"]
    pub fn std___throw_bad_typeid();
}
extern "C" {
    #[link_name = "?__throw_logic_error@std@@YAXPEBD@Z"]
    pub fn std___throw_logic_error(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "?__throw_domain_error@std@@YAXPEBD@Z"]
    pub fn std___throw_domain_error(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "?__throw_invalid_argument@std@@YAXPEBD@Z"]
    pub fn std___throw_invalid_argument(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "?__throw_length_error@std@@YAXPEBD@Z"]
    pub fn std___throw_length_error(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "?__throw_out_of_range@std@@YAXPEBD@Z"]
    pub fn std___throw_out_of_range(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "?__throw_out_of_range_fmt@std@@YAXPEBDZZ"]
    pub fn std___throw_out_of_range_fmt(arg1:
                                            *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[link_name = "?__throw_runtime_error@std@@YAXPEBD@Z"]
    pub fn std___throw_runtime_error(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "?__throw_range_error@std@@YAXPEBD@Z"]
    pub fn std___throw_range_error(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "?__throw_overflow_error@std@@YAXPEBD@Z"]
    pub fn std___throw_overflow_error(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "?__throw_underflow_error@std@@YAXPEBD@Z"]
    pub fn std___throw_underflow_error(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "?__throw_ios_failure@std@@YAXPEBD@Z"]
    pub fn std___throw_ios_failure(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "?__throw_system_error@std@@YAXH@Z"]
    pub fn std___throw_system_error(arg1: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "?__throw_future_error@std@@YAXH@Z"]
    pub fn std___throw_future_error(arg1: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "?__throw_bad_function_call@std@@YAXXZ"]
    pub fn std___throw_bad_function_call();
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct std___true_type {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___true_type() {
    assert_eq!(::std::mem::size_of::<std___true_type>() , 1usize , concat ! (
               "Size of: " , stringify ! ( std___true_type ) ));
    assert_eq! (::std::mem::align_of::<std___true_type>() , 1usize , concat !
                ( "Alignment of " , stringify ! ( std___true_type ) ));
}
impl Clone for std___true_type {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct std___false_type {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___false_type() {
    assert_eq!(::std::mem::size_of::<std___false_type>() , 1usize , concat ! (
               "Size of: " , stringify ! ( std___false_type ) ));
    assert_eq! (::std::mem::align_of::<std___false_type>() , 1usize , concat !
                ( "Alignment of " , stringify ! ( std___false_type ) ));
}
impl Clone for std___false_type {
    fn clone(&self) -> Self { *self }
}
#[test]
fn __bindgen_test_layout_std___truth_type_instantiation_648() {
    assert_eq!(::std::mem::size_of::<u8>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! ( u8 ) ));
    assert_eq!(::std::mem::align_of::<u8>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! ( u8 )
               ));
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___traitor {
    pub _address: u8,
}
pub const std___traitor___value: std___traitor__bindgen_ty_1 =
    std___traitor__bindgen_ty_1::__value;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum std___traitor__bindgen_ty_1 { __value = 0, }
pub type std___traitor___type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___are_same {
    pub _address: u8,
}
pub const std___are_same___value: std___are_same__bindgen_ty_1 =
    std___are_same__bindgen_ty_1::__value;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum std___are_same__bindgen_ty_1 { __value = 0, }
pub type std___are_same___type = std___false_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_void {
    pub _address: u8,
}
pub const std___is_void___value: std___is_void__bindgen_ty_1 =
    std___is_void__bindgen_ty_1::__value;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum std___is_void__bindgen_ty_1 { __value = 0, }
pub type std___is_void___type = std___false_type;
#[test]
fn __bindgen_test_layout_std___is_void_instantiation_674() {
    assert_eq!(::std::mem::size_of::<std___is_void>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std___is_void ) ));
    assert_eq!(::std::mem::align_of::<std___is_void>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std___is_void ) ));
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_integer {
    pub _address: u8,
}
pub const std___is_integer___value: std___is_integer__bindgen_ty_1 =
    std___is_integer__bindgen_ty_1::__value;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum std___is_integer__bindgen_ty_1 { __value = 0, }
pub type std___is_integer___type = std___false_type;
#[test]
fn __bindgen_test_layout_std___is_integer_instantiation_685() {
    assert_eq!(::std::mem::size_of::<std___is_integer>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std___is_integer ) ));
    assert_eq!(::std::mem::align_of::<std___is_integer>() , 1usize , concat !
               (
               "Alignment of template specialization: " , stringify ! (
               std___is_integer ) ));
}
#[test]
fn __bindgen_test_layout_std___is_integer_instantiation_689() {
    assert_eq!(::std::mem::size_of::<std___is_integer>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std___is_integer ) ));
    assert_eq!(::std::mem::align_of::<std___is_integer>() , 1usize , concat !
               (
               "Alignment of template specialization: " , stringify ! (
               std___is_integer ) ));
}
#[test]
fn __bindgen_test_layout_std___is_integer_instantiation_693() {
    assert_eq!(::std::mem::size_of::<std___is_integer>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std___is_integer ) ));
    assert_eq!(::std::mem::align_of::<std___is_integer>() , 1usize , concat !
               (
               "Alignment of template specialization: " , stringify ! (
               std___is_integer ) ));
}
#[test]
fn __bindgen_test_layout_std___is_integer_instantiation_697() {
    assert_eq!(::std::mem::size_of::<std___is_integer>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std___is_integer ) ));
    assert_eq!(::std::mem::align_of::<std___is_integer>() , 1usize , concat !
               (
               "Alignment of template specialization: " , stringify ! (
               std___is_integer ) ));
}
#[test]
fn __bindgen_test_layout_std___is_integer_instantiation_701() {
    assert_eq!(::std::mem::size_of::<std___is_integer>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std___is_integer ) ));
    assert_eq!(::std::mem::align_of::<std___is_integer>() , 1usize , concat !
               (
               "Alignment of template specialization: " , stringify ! (
               std___is_integer ) ));
}
#[test]
fn __bindgen_test_layout_std___is_integer_instantiation_705() {
    assert_eq!(::std::mem::size_of::<std___is_integer>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std___is_integer ) ));
    assert_eq!(::std::mem::align_of::<std___is_integer>() , 1usize , concat !
               (
               "Alignment of template specialization: " , stringify ! (
               std___is_integer ) ));
}
#[test]
fn __bindgen_test_layout_std___is_integer_instantiation_709() {
    assert_eq!(::std::mem::size_of::<std___is_integer>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std___is_integer ) ));
    assert_eq!(::std::mem::align_of::<std___is_integer>() , 1usize , concat !
               (
               "Alignment of template specialization: " , stringify ! (
               std___is_integer ) ));
}
#[test]
fn __bindgen_test_layout_std___is_integer_instantiation_713() {
    assert_eq!(::std::mem::size_of::<std___is_integer>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std___is_integer ) ));
    assert_eq!(::std::mem::align_of::<std___is_integer>() , 1usize , concat !
               (
               "Alignment of template specialization: " , stringify ! (
               std___is_integer ) ));
}
#[test]
fn __bindgen_test_layout_std___is_integer_instantiation_717() {
    assert_eq!(::std::mem::size_of::<std___is_integer>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std___is_integer ) ));
    assert_eq!(::std::mem::align_of::<std___is_integer>() , 1usize , concat !
               (
               "Alignment of template specialization: " , stringify ! (
               std___is_integer ) ));
}
#[test]
fn __bindgen_test_layout_std___is_integer_instantiation_721() {
    assert_eq!(::std::mem::size_of::<std___is_integer>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std___is_integer ) ));
    assert_eq!(::std::mem::align_of::<std___is_integer>() , 1usize , concat !
               (
               "Alignment of template specialization: " , stringify ! (
               std___is_integer ) ));
}
#[test]
fn __bindgen_test_layout_std___is_integer_instantiation_725() {
    assert_eq!(::std::mem::size_of::<std___is_integer>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std___is_integer ) ));
    assert_eq!(::std::mem::align_of::<std___is_integer>() , 1usize , concat !
               (
               "Alignment of template specialization: " , stringify ! (
               std___is_integer ) ));
}
#[test]
fn __bindgen_test_layout_std___is_integer_instantiation_729() {
    assert_eq!(::std::mem::size_of::<std___is_integer>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std___is_integer ) ));
    assert_eq!(::std::mem::align_of::<std___is_integer>() , 1usize , concat !
               (
               "Alignment of template specialization: " , stringify ! (
               std___is_integer ) ));
}
#[test]
fn __bindgen_test_layout_std___is_integer_instantiation_733() {
    assert_eq!(::std::mem::size_of::<std___is_integer>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std___is_integer ) ));
    assert_eq!(::std::mem::align_of::<std___is_integer>() , 1usize , concat !
               (
               "Alignment of template specialization: " , stringify ! (
               std___is_integer ) ));
}
#[test]
fn __bindgen_test_layout_std___is_integer_instantiation_737() {
    assert_eq!(::std::mem::size_of::<std___is_integer>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std___is_integer ) ));
    assert_eq!(::std::mem::align_of::<std___is_integer>() , 1usize , concat !
               (
               "Alignment of template specialization: " , stringify ! (
               std___is_integer ) ));
}
#[test]
fn __bindgen_test_layout_std___is_integer_instantiation_741() {
    assert_eq!(::std::mem::size_of::<std___is_integer>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std___is_integer ) ));
    assert_eq!(::std::mem::align_of::<std___is_integer>() , 1usize , concat !
               (
               "Alignment of template specialization: " , stringify ! (
               std___is_integer ) ));
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_floating {
    pub _address: u8,
}
pub const std___is_floating___value: std___is_floating__bindgen_ty_1 =
    std___is_floating__bindgen_ty_1::__value;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum std___is_floating__bindgen_ty_1 { __value = 0, }
pub type std___is_floating___type = std___false_type;
#[test]
fn __bindgen_test_layout_std___is_floating_instantiation_752() {
    assert_eq!(::std::mem::size_of::<std___is_floating>() , 1usize , concat !
               (
               "Size of template specialization: " , stringify ! (
               std___is_floating ) ));
    assert_eq!(::std::mem::align_of::<std___is_floating>() , 1usize , concat !
               (
               "Alignment of template specialization: " , stringify ! (
               std___is_floating ) ));
}
#[test]
fn __bindgen_test_layout_std___is_floating_instantiation_756() {
    assert_eq!(::std::mem::size_of::<std___is_floating>() , 1usize , concat !
               (
               "Size of template specialization: " , stringify ! (
               std___is_floating ) ));
    assert_eq!(::std::mem::align_of::<std___is_floating>() , 1usize , concat !
               (
               "Alignment of template specialization: " , stringify ! (
               std___is_floating ) ));
}
#[test]
fn __bindgen_test_layout_std___is_floating_instantiation_760() {
    assert_eq!(::std::mem::size_of::<std___is_floating>() , 1usize , concat !
               (
               "Size of template specialization: " , stringify ! (
               std___is_floating ) ));
    assert_eq!(::std::mem::align_of::<std___is_floating>() , 1usize , concat !
               (
               "Alignment of template specialization: " , stringify ! (
               std___is_floating ) ));
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_pointer {
    pub _address: u8,
}
pub const std___is_pointer___value: std___is_pointer__bindgen_ty_1 =
    std___is_pointer__bindgen_ty_1::__value;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum std___is_pointer__bindgen_ty_1 { __value = 0, }
pub type std___is_pointer___type = std___false_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_normal_iterator {
    pub _address: u8,
}
pub const std___is_normal_iterator___value:
          std___is_normal_iterator__bindgen_ty_1 =
    std___is_normal_iterator__bindgen_ty_1::__value;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum std___is_normal_iterator__bindgen_ty_1 { __value = 0, }
pub type std___is_normal_iterator___type = std___false_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_arithmetic {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_scalar {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_char {
    pub _address: u8,
}
pub const std___is_char___value: std___is_char__bindgen_ty_1 =
    std___is_char__bindgen_ty_1::__value;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum std___is_char__bindgen_ty_1 { __value = 0, }
pub type std___is_char___type = std___false_type;
#[test]
fn __bindgen_test_layout_std___is_char_instantiation_801() {
    assert_eq!(::std::mem::size_of::<std___is_char>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std___is_char ) ));
    assert_eq!(::std::mem::align_of::<std___is_char>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std___is_char ) ));
}
#[test]
fn __bindgen_test_layout_std___is_char_instantiation_805() {
    assert_eq!(::std::mem::size_of::<std___is_char>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std___is_char ) ));
    assert_eq!(::std::mem::align_of::<std___is_char>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std___is_char ) ));
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_byte {
    pub _address: u8,
}
pub const std___is_byte___value: std___is_byte__bindgen_ty_1 =
    std___is_byte__bindgen_ty_1::__value;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum std___is_byte__bindgen_ty_1 { __value = 0, }
pub type std___is_byte___type = std___false_type;
#[test]
fn __bindgen_test_layout_std___is_byte_instantiation_816() {
    assert_eq!(::std::mem::size_of::<std___is_byte>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std___is_byte ) ));
    assert_eq!(::std::mem::align_of::<std___is_byte>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std___is_byte ) ));
}
#[test]
fn __bindgen_test_layout_std___is_byte_instantiation_820() {
    assert_eq!(::std::mem::size_of::<std___is_byte>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std___is_byte ) ));
    assert_eq!(::std::mem::align_of::<std___is_byte>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std___is_byte ) ));
}
#[test]
fn __bindgen_test_layout_std___is_byte_instantiation_824() {
    assert_eq!(::std::mem::size_of::<std___is_byte>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std___is_byte ) ));
    assert_eq!(::std::mem::align_of::<std___is_byte>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std___is_byte ) ));
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_move_iterator {
    pub _address: u8,
}
pub const std___is_move_iterator___value: std___is_move_iterator__bindgen_ty_1
          =
    std___is_move_iterator__bindgen_ty_1::__value;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum std___is_move_iterator__bindgen_ty_1 { __value = 0, }
pub type std___is_move_iterator___type = std___false_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_move_iterator<_Iterator> {
    pub _M_current: _Iterator,
}
pub type std_move_iterator___traits_type = std_iterator_traits;
pub type std_move_iterator_iterator_type<_Iterator> = _Iterator;
pub type std_move_iterator_iterator_category =
    std_move_iterator___traits_type;
pub type std_move_iterator_value_type = std_move_iterator___traits_type;
pub type std_move_iterator_difference_type = std_move_iterator___traits_type;
pub type std_move_iterator_pointer<_Iterator> = _Iterator;
pub type std_move_iterator_reference = *mut std_move_iterator_value_type;
extern "C" {
    #[link_name = "value"]
    pub static std_value: _Tp;
}
pub type std_true_type = u8;
pub type std_false_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___or_ {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std___or__instantiation_1083() {
    assert_eq!(::std::mem::size_of::<std___or_>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! ( std___or_ )
               ));
    assert_eq!(::std::mem::align_of::<std___or_>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std___or_ ) ));
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___and_ {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std___and__instantiation_1090() {
    assert_eq!(::std::mem::size_of::<std___and_>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! ( std___and_
               ) ));
    assert_eq!(::std::mem::align_of::<std___and_>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std___and_ ) ));
}
#[repr(C)]
pub struct std___not_ {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___success_type {
    pub _address: u8,
}
pub type std___success_type_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct std___failure_type {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___failure_type() {
    assert_eq!(::std::mem::size_of::<std___failure_type>() , 1usize , concat !
               ( "Size of: " , stringify ! ( std___failure_type ) ));
    assert_eq! (::std::mem::align_of::<std___failure_type>() , 1usize , concat
                ! ( "Alignment of " , stringify ! ( std___failure_type ) ));
}
impl Clone for std___failure_type {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_cv {
    pub _address: u8,
}
pub type std_remove_cv_type = std_remove_const;
#[repr(C)]
pub struct std___is_void_helper {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std___is_void_helper_instantiation_1110() {
    assert_eq!(::std::mem::size_of::<std___is_void_helper>() , 1usize , concat
               ! (
               "Size of template specialization: " , stringify ! (
               std___is_void_helper ) ));
    assert_eq!(::std::mem::align_of::<std___is_void_helper>() , 1usize ,
               concat ! (
               "Alignment of template specialization: " , stringify ! (
               std___is_void_helper ) ));
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_void {
    pub _address: u8,
}
#[repr(C)]
pub struct std___is_integral_helper {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std___is_integral_helper_instantiation_1120() {
    assert_eq!(::std::mem::size_of::<std___is_integral_helper>() , 1usize ,
               concat ! (
               "Size of template specialization: " , stringify ! (
               std___is_integral_helper ) ));
    assert_eq!(::std::mem::align_of::<std___is_integral_helper>() , 1usize ,
               concat ! (
               "Alignment of template specialization: " , stringify ! (
               std___is_integral_helper ) ));
}
#[test]
fn __bindgen_test_layout_std___is_integral_helper_instantiation_1124() {
    assert_eq!(::std::mem::size_of::<std___is_integral_helper>() , 1usize ,
               concat ! (
               "Size of template specialization: " , stringify ! (
               std___is_integral_helper ) ));
    assert_eq!(::std::mem::align_of::<std___is_integral_helper>() , 1usize ,
               concat ! (
               "Alignment of template specialization: " , stringify ! (
               std___is_integral_helper ) ));
}
#[test]
fn __bindgen_test_layout_std___is_integral_helper_instantiation_1128() {
    assert_eq!(::std::mem::size_of::<std___is_integral_helper>() , 1usize ,
               concat ! (
               "Size of template specialization: " , stringify ! (
               std___is_integral_helper ) ));
    assert_eq!(::std::mem::align_of::<std___is_integral_helper>() , 1usize ,
               concat ! (
               "Alignment of template specialization: " , stringify ! (
               std___is_integral_helper ) ));
}
#[test]
fn __bindgen_test_layout_std___is_integral_helper_instantiation_1132() {
    assert_eq!(::std::mem::size_of::<std___is_integral_helper>() , 1usize ,
               concat ! (
               "Size of template specialization: " , stringify ! (
               std___is_integral_helper ) ));
    assert_eq!(::std::mem::align_of::<std___is_integral_helper>() , 1usize ,
               concat ! (
               "Alignment of template specialization: " , stringify ! (
               std___is_integral_helper ) ));
}
#[test]
fn __bindgen_test_layout_std___is_integral_helper_instantiation_1136() {
    assert_eq!(::std::mem::size_of::<std___is_integral_helper>() , 1usize ,
               concat ! (
               "Size of template specialization: " , stringify ! (
               std___is_integral_helper ) ));
    assert_eq!(::std::mem::align_of::<std___is_integral_helper>() , 1usize ,
               concat ! (
               "Alignment of template specialization: " , stringify ! (
               std___is_integral_helper ) ));
}
#[test]
fn __bindgen_test_layout_std___is_integral_helper_instantiation_1140() {
    assert_eq!(::std::mem::size_of::<std___is_integral_helper>() , 1usize ,
               concat ! (
               "Size of template specialization: " , stringify ! (
               std___is_integral_helper ) ));
    assert_eq!(::std::mem::align_of::<std___is_integral_helper>() , 1usize ,
               concat ! (
               "Alignment of template specialization: " , stringify ! (
               std___is_integral_helper ) ));
}
#[test]
fn __bindgen_test_layout_std___is_integral_helper_instantiation_1144() {
    assert_eq!(::std::mem::size_of::<std___is_integral_helper>() , 1usize ,
               concat ! (
               "Size of template specialization: " , stringify ! (
               std___is_integral_helper ) ));
    assert_eq!(::std::mem::align_of::<std___is_integral_helper>() , 1usize ,
               concat ! (
               "Alignment of template specialization: " , stringify ! (
               std___is_integral_helper ) ));
}
#[test]
fn __bindgen_test_layout_std___is_integral_helper_instantiation_1148() {
    assert_eq!(::std::mem::size_of::<std___is_integral_helper>() , 1usize ,
               concat ! (
               "Size of template specialization: " , stringify ! (
               std___is_integral_helper ) ));
    assert_eq!(::std::mem::align_of::<std___is_integral_helper>() , 1usize ,
               concat ! (
               "Alignment of template specialization: " , stringify ! (
               std___is_integral_helper ) ));
}
#[test]
fn __bindgen_test_layout_std___is_integral_helper_instantiation_1152() {
    assert_eq!(::std::mem::size_of::<std___is_integral_helper>() , 1usize ,
               concat ! (
               "Size of template specialization: " , stringify ! (
               std___is_integral_helper ) ));
    assert_eq!(::std::mem::align_of::<std___is_integral_helper>() , 1usize ,
               concat ! (
               "Alignment of template specialization: " , stringify ! (
               std___is_integral_helper ) ));
}
#[test]
fn __bindgen_test_layout_std___is_integral_helper_instantiation_1156() {
    assert_eq!(::std::mem::size_of::<std___is_integral_helper>() , 1usize ,
               concat ! (
               "Size of template specialization: " , stringify ! (
               std___is_integral_helper ) ));
    assert_eq!(::std::mem::align_of::<std___is_integral_helper>() , 1usize ,
               concat ! (
               "Alignment of template specialization: " , stringify ! (
               std___is_integral_helper ) ));
}
#[test]
fn __bindgen_test_layout_std___is_integral_helper_instantiation_1160() {
    assert_eq!(::std::mem::size_of::<std___is_integral_helper>() , 1usize ,
               concat ! (
               "Size of template specialization: " , stringify ! (
               std___is_integral_helper ) ));
    assert_eq!(::std::mem::align_of::<std___is_integral_helper>() , 1usize ,
               concat ! (
               "Alignment of template specialization: " , stringify ! (
               std___is_integral_helper ) ));
}
#[test]
fn __bindgen_test_layout_std___is_integral_helper_instantiation_1164() {
    assert_eq!(::std::mem::size_of::<std___is_integral_helper>() , 1usize ,
               concat ! (
               "Size of template specialization: " , stringify ! (
               std___is_integral_helper ) ));
    assert_eq!(::std::mem::align_of::<std___is_integral_helper>() , 1usize ,
               concat ! (
               "Alignment of template specialization: " , stringify ! (
               std___is_integral_helper ) ));
}
#[test]
fn __bindgen_test_layout_std___is_integral_helper_instantiation_1168() {
    assert_eq!(::std::mem::size_of::<std___is_integral_helper>() , 1usize ,
               concat ! (
               "Size of template specialization: " , stringify ! (
               std___is_integral_helper ) ));
    assert_eq!(::std::mem::align_of::<std___is_integral_helper>() , 1usize ,
               concat ! (
               "Alignment of template specialization: " , stringify ! (
               std___is_integral_helper ) ));
}
#[test]
fn __bindgen_test_layout_std___is_integral_helper_instantiation_1172() {
    assert_eq!(::std::mem::size_of::<std___is_integral_helper>() , 1usize ,
               concat ! (
               "Size of template specialization: " , stringify ! (
               std___is_integral_helper ) ));
    assert_eq!(::std::mem::align_of::<std___is_integral_helper>() , 1usize ,
               concat ! (
               "Alignment of template specialization: " , stringify ! (
               std___is_integral_helper ) ));
}
#[test]
fn __bindgen_test_layout_std___is_integral_helper_instantiation_1176() {
    assert_eq!(::std::mem::size_of::<std___is_integral_helper>() , 1usize ,
               concat ! (
               "Size of template specialization: " , stringify ! (
               std___is_integral_helper ) ));
    assert_eq!(::std::mem::align_of::<std___is_integral_helper>() , 1usize ,
               concat ! (
               "Alignment of template specialization: " , stringify ! (
               std___is_integral_helper ) ));
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_integral {
    pub _address: u8,
}
#[repr(C)]
pub struct std___is_floating_point_helper {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std___is_floating_point_helper_instantiation_1186() {
    assert_eq!(::std::mem::size_of::<std___is_floating_point_helper>() ,
               1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std___is_floating_point_helper ) ));
    assert_eq!(::std::mem::align_of::<std___is_floating_point_helper>() ,
               1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std___is_floating_point_helper ) ));
}
#[test]
fn __bindgen_test_layout_std___is_floating_point_helper_instantiation_1190() {
    assert_eq!(::std::mem::size_of::<std___is_floating_point_helper>() ,
               1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std___is_floating_point_helper ) ));
    assert_eq!(::std::mem::align_of::<std___is_floating_point_helper>() ,
               1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std___is_floating_point_helper ) ));
}
#[test]
fn __bindgen_test_layout_std___is_floating_point_helper_instantiation_1194() {
    assert_eq!(::std::mem::size_of::<std___is_floating_point_helper>() ,
               1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std___is_floating_point_helper ) ));
    assert_eq!(::std::mem::align_of::<std___is_floating_point_helper>() ,
               1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std___is_floating_point_helper ) ));
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_floating_point {
    pub _address: u8,
}
#[repr(C)]
pub struct std_is_array {
    pub _address: u8,
}
#[repr(C)]
pub struct std___is_pointer_helper {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_pointer {
    pub _address: u8,
}
#[repr(C)]
pub struct std_is_lvalue_reference {
    pub _address: u8,
}
#[repr(C)]
pub struct std_is_rvalue_reference {
    pub _address: u8,
}
#[repr(C)]
pub struct std_is_function {
    pub _address: u8,
}
#[repr(C)]
pub struct std___is_member_object_pointer_helper {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_member_object_pointer {
    pub _address: u8,
}
#[repr(C)]
pub struct std___is_member_function_pointer_helper {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_member_function_pointer {
    pub _address: u8,
}
#[repr(C)]
pub struct std_is_enum {
    pub _address: u8,
}
#[repr(C)]
pub struct std_is_union {
    pub _address: u8,
}
#[repr(C)]
pub struct std_is_class {
    pub _address: u8,
}
#[repr(C)]
pub struct std___is_null_pointer_helper {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std___is_null_pointer_helper_instantiation_1275() {
    assert_eq!(::std::mem::size_of::<std___is_null_pointer_helper>() , 1usize
               , concat ! (
               "Size of template specialization: " , stringify ! (
               std___is_null_pointer_helper ) ));
    assert_eq!(::std::mem::align_of::<std___is_null_pointer_helper>() , 1usize
               , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std___is_null_pointer_helper ) ));
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_null_pointer {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nullptr_t {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_reference {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_arithmetic {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_fundamental {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_object {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_member_pointer {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_scalar {
    pub _address: u8,
}
#[repr(C)]
pub struct std_is_compound {
    pub _address: u8,
}
#[repr(C)]
pub struct std___is_member_pointer_helper {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_referenceable {
    pub _address: u8,
}
#[repr(C)]
pub struct std_is_const {
    pub _address: u8,
}
#[repr(C)]
pub struct std_is_volatile {
    pub _address: u8,
}
#[repr(C)]
pub struct std_is_trivial {
    pub _address: u8,
}
#[repr(C)]
pub struct std_is_standard_layout {
    pub _address: u8,
}
#[repr(C)]
pub struct std_is_pod {
    pub _address: u8,
}
#[repr(C)]
pub struct std_is_literal_type {
    pub _address: u8,
}
#[repr(C)]
pub struct std_is_empty {
    pub _address: u8,
}
#[repr(C)]
pub struct std_is_polymorphic {
    pub _address: u8,
}
#[repr(C)]
pub struct std_is_abstract {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_signed {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_unsigned {
    pub _address: u8,
}
#[repr(C)]
pub struct std_add_rvalue_reference {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_all_extents {
    pub _address: u8,
}
pub type std_remove_all_extents_type<_Tp> = _Tp;
#[repr(C)]
pub struct std___is_array_known_bounds {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_array_unknown_bounds {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct std___do_is_destructible_impl {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___do_is_destructible_impl() {
    assert_eq!(::std::mem::size_of::<std___do_is_destructible_impl>() , 1usize
               , concat ! (
               "Size of: " , stringify ! ( std___do_is_destructible_impl ) ));
    assert_eq! (::std::mem::align_of::<std___do_is_destructible_impl>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! ( std___do_is_destructible_impl
                ) ));
}
impl Clone for std___do_is_destructible_impl {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_destructible_impl {
    pub _address: u8,
}
pub type std___is_destructible_impl_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_destructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct std___do_is_nt_destructible_impl {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___do_is_nt_destructible_impl() {
    assert_eq!(::std::mem::size_of::<std___do_is_nt_destructible_impl>() ,
               1usize , concat ! (
               "Size of: " , stringify ! ( std___do_is_nt_destructible_impl )
               ));
    assert_eq! (::std::mem::align_of::<std___do_is_nt_destructible_impl>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! (
                std___do_is_nt_destructible_impl ) ));
}
impl Clone for std___do_is_nt_destructible_impl {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nt_destructible_impl {
    pub _address: u8,
}
pub type std___is_nt_destructible_impl_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_destructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct std___do_is_default_constructible_impl {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___do_is_default_constructible_impl() {
    assert_eq!(::std::mem::size_of::<std___do_is_default_constructible_impl>()
               , 1usize , concat ! (
               "Size of: " , stringify ! (
               std___do_is_default_constructible_impl ) ));
    assert_eq! (::std::mem::align_of::<std___do_is_default_constructible_impl>()
                , 1usize , concat ! (
                "Alignment of " , stringify ! (
                std___do_is_default_constructible_impl ) ));
}
impl Clone for std___do_is_default_constructible_impl {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_default_constructible_impl {
    pub _address: u8,
}
pub type std___is_default_constructible_impl_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_default_constructible_atom {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_default_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct std___do_is_static_castable_impl {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___do_is_static_castable_impl() {
    assert_eq!(::std::mem::size_of::<std___do_is_static_castable_impl>() ,
               1usize , concat ! (
               "Size of: " , stringify ! ( std___do_is_static_castable_impl )
               ));
    assert_eq! (::std::mem::align_of::<std___do_is_static_castable_impl>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! (
                std___do_is_static_castable_impl ) ));
}
impl Clone for std___do_is_static_castable_impl {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_static_castable_impl {
    pub _address: u8,
}
pub type std___is_static_castable_impl_type<_From> = _From;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_static_castable_safe {
    pub _address: u8,
}
#[repr(C)]
pub struct std___is_static_castable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct std___do_is_direct_constructible_impl {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___do_is_direct_constructible_impl() {
    assert_eq!(::std::mem::size_of::<std___do_is_direct_constructible_impl>()
               , 1usize , concat ! (
               "Size of: " , stringify ! (
               std___do_is_direct_constructible_impl ) ));
    assert_eq! (::std::mem::align_of::<std___do_is_direct_constructible_impl>()
                , 1usize , concat ! (
                "Alignment of " , stringify ! (
                std___do_is_direct_constructible_impl ) ));
}
impl Clone for std___do_is_direct_constructible_impl {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_direct_constructible_impl {
    pub _address: u8,
}
pub type std___is_direct_constructible_impl_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_direct_constructible_new_safe {
    pub _address: u8,
}
#[repr(C)]
pub struct std_is_same {
    pub _address: u8,
}
#[repr(C)]
pub struct std_is_base_of {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_reference {
    pub _address: u8,
}
pub type std_remove_reference_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_direct_constructible_ref_cast {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_direct_constructible_new {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_direct_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct std___do_is_nary_constructible_impl {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___do_is_nary_constructible_impl() {
    assert_eq!(::std::mem::size_of::<std___do_is_nary_constructible_impl>() ,
               1usize , concat ! (
               "Size of: " , stringify ! ( std___do_is_nary_constructible_impl
               ) ));
    assert_eq! (::std::mem::align_of::<std___do_is_nary_constructible_impl>()
                , 1usize , concat ! (
                "Alignment of " , stringify ! (
                std___do_is_nary_constructible_impl ) ));
}
impl Clone for std___do_is_nary_constructible_impl {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nary_constructible_impl {
    pub _address: u8,
}
pub type std___is_nary_constructible_impl_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nary_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_constructible_impl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_constructible {
    pub _address: u8,
}
#[repr(C)]
pub struct std_is_copy_constructible {
    pub _address: u8,
}
#[repr(C)]
pub struct std_is_move_constructible {
    pub _address: u8,
}
#[repr(C)]
pub struct std___is_nt_default_constructible_atom {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_default_constructible {
    pub _address: u8,
}
#[repr(C)]
pub struct std___is_nt_constructible_impl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_constructible {
    pub _address: u8,
}
#[repr(C)]
pub struct std_is_nothrow_copy_constructible {
    pub _address: u8,
}
#[repr(C)]
pub struct std_is_nothrow_move_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_assignable_helper {
    pub _address: u8,
}
pub type std___is_assignable_helper_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_assignable {
    pub _address: u8,
}
#[repr(C)]
pub struct std_is_copy_assignable {
    pub _address: u8,
}
#[repr(C)]
pub struct std_is_move_assignable {
    pub _address: u8,
}
#[repr(C)]
pub struct std___is_nt_assignable_impl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_assignable {
    pub _address: u8,
}
#[repr(C)]
pub struct std_is_nothrow_copy_assignable {
    pub _address: u8,
}
#[repr(C)]
pub struct std_is_nothrow_move_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_destructible {
    pub _address: u8,
}
#[repr(C)]
pub struct std_has_trivial_default_constructor {
    pub _address: u8,
}
#[repr(C)]
pub struct std_has_trivial_copy_constructor {
    pub _address: u8,
}
#[repr(C)]
pub struct std_has_trivial_copy_assign {
    pub _address: u8,
}
#[repr(C)]
pub struct std_has_virtual_destructor {
    pub _address: u8,
}
#[repr(C)]
pub struct std_alignment_of {
    pub _address: u8,
}
#[repr(C)]
pub struct std_rank {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_convertible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_const {
    pub _address: u8,
}
pub type std_remove_const_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_volatile {
    pub _address: u8,
}
pub type std_remove_volatile_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_add_const {
    pub _address: u8,
}
pub type std_add_const_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_add_volatile {
    pub _address: u8,
}
pub type std_add_volatile_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_add_cv {
    pub _address: u8,
}
pub type std_add_cv_type = std_add_const;
#[repr(C)]
pub struct std_add_lvalue_reference {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___make_unsigned {
    pub _address: u8,
}
pub type std___make_unsigned___type<_Tp> = _Tp;
#[test]
fn __bindgen_test_layout_std___make_unsigned_instantiation_1701() {
    assert_eq!(::std::mem::size_of::<std___make_unsigned>() , 1usize , concat
               ! (
               "Size of template specialization: " , stringify ! (
               std___make_unsigned ) ));
    assert_eq!(::std::mem::align_of::<std___make_unsigned>() , 1usize , concat
               ! (
               "Alignment of template specialization: " , stringify ! (
               std___make_unsigned ) ));
}
#[test]
fn __bindgen_test_layout_std___make_unsigned_instantiation_1705() {
    assert_eq!(::std::mem::size_of::<std___make_unsigned>() , 1usize , concat
               ! (
               "Size of template specialization: " , stringify ! (
               std___make_unsigned ) ));
    assert_eq!(::std::mem::align_of::<std___make_unsigned>() , 1usize , concat
               ! (
               "Alignment of template specialization: " , stringify ! (
               std___make_unsigned ) ));
}
#[test]
fn __bindgen_test_layout_std___make_unsigned_instantiation_1709() {
    assert_eq!(::std::mem::size_of::<std___make_unsigned>() , 1usize , concat
               ! (
               "Size of template specialization: " , stringify ! (
               std___make_unsigned ) ));
    assert_eq!(::std::mem::align_of::<std___make_unsigned>() , 1usize , concat
               ! (
               "Alignment of template specialization: " , stringify ! (
               std___make_unsigned ) ));
}
#[test]
fn __bindgen_test_layout_std___make_unsigned_instantiation_1713() {
    assert_eq!(::std::mem::size_of::<std___make_unsigned>() , 1usize , concat
               ! (
               "Size of template specialization: " , stringify ! (
               std___make_unsigned ) ));
    assert_eq!(::std::mem::align_of::<std___make_unsigned>() , 1usize , concat
               ! (
               "Alignment of template specialization: " , stringify ! (
               std___make_unsigned ) ));
}
#[test]
fn __bindgen_test_layout_std___make_unsigned_instantiation_1717() {
    assert_eq!(::std::mem::size_of::<std___make_unsigned>() , 1usize , concat
               ! (
               "Size of template specialization: " , stringify ! (
               std___make_unsigned ) ));
    assert_eq!(::std::mem::align_of::<std___make_unsigned>() , 1usize , concat
               ! (
               "Alignment of template specialization: " , stringify ! (
               std___make_unsigned ) ));
}
#[test]
fn __bindgen_test_layout_std___make_unsigned_instantiation_1721() {
    assert_eq!(::std::mem::size_of::<std___make_unsigned>() , 1usize , concat
               ! (
               "Size of template specialization: " , stringify ! (
               std___make_unsigned ) ));
    assert_eq!(::std::mem::align_of::<std___make_unsigned>() , 1usize , concat
               ! (
               "Alignment of template specialization: " , stringify ! (
               std___make_unsigned ) ));
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_make_unsigned {
    pub _address: u8,
}
pub type std_make_unsigned_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___make_signed {
    pub _address: u8,
}
pub type std___make_signed___type<_Tp> = _Tp;
#[test]
fn __bindgen_test_layout_std___make_signed_instantiation_1741() {
    assert_eq!(::std::mem::size_of::<std___make_signed>() , 1usize , concat !
               (
               "Size of template specialization: " , stringify ! (
               std___make_signed ) ));
    assert_eq!(::std::mem::align_of::<std___make_signed>() , 1usize , concat !
               (
               "Alignment of template specialization: " , stringify ! (
               std___make_signed ) ));
}
#[test]
fn __bindgen_test_layout_std___make_signed_instantiation_1745() {
    assert_eq!(::std::mem::size_of::<std___make_signed>() , 1usize , concat !
               (
               "Size of template specialization: " , stringify ! (
               std___make_signed ) ));
    assert_eq!(::std::mem::align_of::<std___make_signed>() , 1usize , concat !
               (
               "Alignment of template specialization: " , stringify ! (
               std___make_signed ) ));
}
#[test]
fn __bindgen_test_layout_std___make_signed_instantiation_1749() {
    assert_eq!(::std::mem::size_of::<std___make_signed>() , 1usize , concat !
               (
               "Size of template specialization: " , stringify ! (
               std___make_signed ) ));
    assert_eq!(::std::mem::align_of::<std___make_signed>() , 1usize , concat !
               (
               "Alignment of template specialization: " , stringify ! (
               std___make_signed ) ));
}
#[test]
fn __bindgen_test_layout_std___make_signed_instantiation_1753() {
    assert_eq!(::std::mem::size_of::<std___make_signed>() , 1usize , concat !
               (
               "Size of template specialization: " , stringify ! (
               std___make_signed ) ));
    assert_eq!(::std::mem::align_of::<std___make_signed>() , 1usize , concat !
               (
               "Alignment of template specialization: " , stringify ! (
               std___make_signed ) ));
}
#[test]
fn __bindgen_test_layout_std___make_signed_instantiation_1757() {
    assert_eq!(::std::mem::size_of::<std___make_signed>() , 1usize , concat !
               (
               "Size of template specialization: " , stringify ! (
               std___make_signed ) ));
    assert_eq!(::std::mem::align_of::<std___make_signed>() , 1usize , concat !
               (
               "Alignment of template specialization: " , stringify ! (
               std___make_signed ) ));
}
#[test]
fn __bindgen_test_layout_std___make_signed_instantiation_1761() {
    assert_eq!(::std::mem::size_of::<std___make_signed>() , 1usize , concat !
               (
               "Size of template specialization: " , stringify ! (
               std___make_signed ) ));
    assert_eq!(::std::mem::align_of::<std___make_signed>() , 1usize , concat !
               (
               "Alignment of template specialization: " , stringify ! (
               std___make_signed ) ));
}
#[test]
fn __bindgen_test_layout_std___make_signed_instantiation_1765() {
    assert_eq!(::std::mem::size_of::<std___make_signed>() , 1usize , concat !
               (
               "Size of template specialization: " , stringify ! (
               std___make_signed ) ));
    assert_eq!(::std::mem::align_of::<std___make_signed>() , 1usize , concat !
               (
               "Alignment of template specialization: " , stringify ! (
               std___make_signed ) ));
}
#[test]
fn __bindgen_test_layout_std___make_signed_instantiation_1769() {
    assert_eq!(::std::mem::size_of::<std___make_signed>() , 1usize , concat !
               (
               "Size of template specialization: " , stringify ! (
               std___make_signed ) ));
    assert_eq!(::std::mem::align_of::<std___make_signed>() , 1usize , concat !
               (
               "Alignment of template specialization: " , stringify ! (
               std___make_signed ) ));
}
#[test]
fn __bindgen_test_layout_std___make_signed_instantiation_1773() {
    assert_eq!(::std::mem::size_of::<std___make_signed>() , 1usize , concat !
               (
               "Size of template specialization: " , stringify ! (
               std___make_signed ) ));
    assert_eq!(::std::mem::align_of::<std___make_signed>() , 1usize , concat !
               (
               "Alignment of template specialization: " , stringify ! (
               std___make_signed ) ));
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_make_signed {
    pub _address: u8,
}
pub type std_make_signed_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_extent {
    pub _address: u8,
}
pub type std_remove_extent_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___remove_pointer_helper {
    pub _address: u8,
}
pub type std___remove_pointer_helper_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_pointer {
    pub _address: u8,
}
#[repr(C)]
pub struct std_add_pointer {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_decay {
    pub _address: u8,
}
pub type std_decay___remove_type = std_remove_reference;
pub type std_decay_type = u8;
#[repr(C)]
pub struct std_reference_wrapper<_Tp> {
    pub _M_data: *mut _Tp,
}
pub type std_reference_wrapper_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___strip_reference_wrapper {
    pub _address: u8,
}
pub type std___strip_reference_wrapper___type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___decay_and_strip {
    pub _address: u8,
}
pub type std___decay_and_strip___type = std___strip_reference_wrapper;
pub type std__Require = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_common_type {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct std___do_common_type_impl {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___do_common_type_impl() {
    assert_eq!(::std::mem::size_of::<std___do_common_type_impl>() , 1usize ,
               concat ! (
               "Size of: " , stringify ! ( std___do_common_type_impl ) ));
    assert_eq! (::std::mem::align_of::<std___do_common_type_impl>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( std___do_common_type_impl )
                ));
}
impl Clone for std___do_common_type_impl {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___common_type_impl {
    pub _address: u8,
}
pub type std___common_type_impl_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct std___do_member_type_wrapper {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___do_member_type_wrapper() {
    assert_eq!(::std::mem::size_of::<std___do_member_type_wrapper>() , 1usize
               , concat ! (
               "Size of: " , stringify ! ( std___do_member_type_wrapper ) ));
    assert_eq! (::std::mem::align_of::<std___do_member_type_wrapper>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! ( std___do_member_type_wrapper )
                ));
}
impl Clone for std___do_member_type_wrapper {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___member_type_wrapper {
    pub _address: u8,
}
pub type std___member_type_wrapper_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___expanded_common_type_wrapper {
    pub _address: u8,
}
pub type std___expanded_common_type_wrapper_type = std_common_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_underlying_type {
    pub _address: u8,
}
pub type std_underlying_type_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___declval_protector {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_result_of {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct std___result_of_memfun_ref_impl {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___result_of_memfun_ref_impl() {
    assert_eq!(::std::mem::size_of::<std___result_of_memfun_ref_impl>() ,
               1usize , concat ! (
               "Size of: " , stringify ! ( std___result_of_memfun_ref_impl )
               ));
    assert_eq! (::std::mem::align_of::<std___result_of_memfun_ref_impl>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! (
                std___result_of_memfun_ref_impl ) ));
}
impl Clone for std___result_of_memfun_ref_impl {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memfun_ref {
    pub _address: u8,
}
pub type std___result_of_memfun_ref_type<_MemPtr> = _MemPtr;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct std___result_of_memfun_deref_impl {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___result_of_memfun_deref_impl() {
    assert_eq!(::std::mem::size_of::<std___result_of_memfun_deref_impl>() ,
               1usize , concat ! (
               "Size of: " , stringify ! ( std___result_of_memfun_deref_impl )
               ));
    assert_eq! (::std::mem::align_of::<std___result_of_memfun_deref_impl>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! (
                std___result_of_memfun_deref_impl ) ));
}
impl Clone for std___result_of_memfun_deref_impl {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memfun_deref {
    pub _address: u8,
}
pub type std___result_of_memfun_deref_type<_MemPtr> = _MemPtr;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct std___result_of_memobj_ref_impl {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___result_of_memobj_ref_impl() {
    assert_eq!(::std::mem::size_of::<std___result_of_memobj_ref_impl>() ,
               1usize , concat ! (
               "Size of: " , stringify ! ( std___result_of_memobj_ref_impl )
               ));
    assert_eq! (::std::mem::align_of::<std___result_of_memobj_ref_impl>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! (
                std___result_of_memobj_ref_impl ) ));
}
impl Clone for std___result_of_memobj_ref_impl {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memobj_ref {
    pub _address: u8,
}
pub type std___result_of_memobj_ref_type<_MemPtr> = _MemPtr;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct std___result_of_memobj_deref_impl {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___result_of_memobj_deref_impl() {
    assert_eq!(::std::mem::size_of::<std___result_of_memobj_deref_impl>() ,
               1usize , concat ! (
               "Size of: " , stringify ! ( std___result_of_memobj_deref_impl )
               ));
    assert_eq! (::std::mem::align_of::<std___result_of_memobj_deref_impl>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! (
                std___result_of_memobj_deref_impl ) ));
}
impl Clone for std___result_of_memobj_deref_impl {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memobj_deref {
    pub _address: u8,
}
pub type std___result_of_memobj_deref_type<_MemPtr> = _MemPtr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memobj {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memfun {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct std___result_of_other_impl {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___result_of_other_impl() {
    assert_eq!(::std::mem::size_of::<std___result_of_other_impl>() , 1usize ,
               concat ! (
               "Size of: " , stringify ! ( std___result_of_other_impl ) ));
    assert_eq! (::std::mem::align_of::<std___result_of_other_impl>() , 1usize
                , concat ! (
                "Alignment of " , stringify ! ( std___result_of_other_impl )
                ));
}
impl Clone for std___result_of_other_impl {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___move_if_noexcept_cond {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct std_piecewise_construct_t {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_piecewise_construct_t() {
    assert_eq!(::std::mem::size_of::<std_piecewise_construct_t>() , 1usize ,
               concat ! (
               "Size of: " , stringify ! ( std_piecewise_construct_t ) ));
    assert_eq! (::std::mem::align_of::<std_piecewise_construct_t>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( std_piecewise_construct_t )
                ));
}
impl Clone for std_piecewise_construct_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "?piecewise_construct@std@@3Upiecewise_construct_t@1@B"]
    pub static std_piecewise_construct: std_piecewise_construct_t;
}
#[repr(C)]
pub struct std_tuple {
    pub _address: u8,
}
pub type std_tuple__Inherited = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pair<_T1, _T2> {
    pub first: _T1,
    pub second: _T2,
}
pub type std_pair_first_type<_T1> = _T1;
pub type std_pair_second_type<_T2> = _T2;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct std_input_iterator_tag {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_input_iterator_tag() {
    assert_eq!(::std::mem::size_of::<std_input_iterator_tag>() , 1usize ,
               concat ! ( "Size of: " , stringify ! ( std_input_iterator_tag )
               ));
    assert_eq! (::std::mem::align_of::<std_input_iterator_tag>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( std_input_iterator_tag ) ));
}
impl Clone for std_input_iterator_tag {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct std_output_iterator_tag {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_output_iterator_tag() {
    assert_eq!(::std::mem::size_of::<std_output_iterator_tag>() , 1usize ,
               concat ! (
               "Size of: " , stringify ! ( std_output_iterator_tag ) ));
    assert_eq! (::std::mem::align_of::<std_output_iterator_tag>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( std_output_iterator_tag ) ));
}
impl Clone for std_output_iterator_tag {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct std_forward_iterator_tag {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_forward_iterator_tag() {
    assert_eq!(::std::mem::size_of::<std_forward_iterator_tag>() , 1usize ,
               concat ! (
               "Size of: " , stringify ! ( std_forward_iterator_tag ) ));
    assert_eq! (::std::mem::align_of::<std_forward_iterator_tag>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( std_forward_iterator_tag ) ));
}
impl Clone for std_forward_iterator_tag {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct std_bidirectional_iterator_tag {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_bidirectional_iterator_tag() {
    assert_eq!(::std::mem::size_of::<std_bidirectional_iterator_tag>() ,
               1usize , concat ! (
               "Size of: " , stringify ! ( std_bidirectional_iterator_tag )
               ));
    assert_eq! (::std::mem::align_of::<std_bidirectional_iterator_tag>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! ( std_bidirectional_iterator_tag
                ) ));
}
impl Clone for std_bidirectional_iterator_tag {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct std_random_access_iterator_tag {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_random_access_iterator_tag() {
    assert_eq!(::std::mem::size_of::<std_random_access_iterator_tag>() ,
               1usize , concat ! (
               "Size of: " , stringify ! ( std_random_access_iterator_tag )
               ));
    assert_eq! (::std::mem::align_of::<std_random_access_iterator_tag>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! ( std_random_access_iterator_tag
                ) ));
}
impl Clone for std_random_access_iterator_tag {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_iterator {
    pub _address: u8,
}
pub type std_iterator_iterator_category<_Category> = _Category;
pub type std_iterator_value_type<_Tp> = _Tp;
pub type std_iterator_difference_type<_Distance> = _Distance;
pub type std_iterator_pointer<_Pointer> = _Pointer;
pub type std_iterator_reference<_Reference> = _Reference;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_iterator_category_helper {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_iterator_category_helper__Wrap_type {
    pub _address: u8,
}
pub type std___has_iterator_category_helper_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_iterator_category {
    pub _address: u8,
}
#[repr(C)]
pub struct std_iterator_traits {
    pub _address: u8,
}
pub type std__RequireInputIter = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_element_type_helper {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_element_type_helper__Wrap_type {
    pub _address: u8,
}
pub type std___has_element_type_helper_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_element_type {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_difference_type_helper {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_difference_type_helper__Wrap_type {
    pub _address: u8,
}
pub type std___has_difference_type_helper_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_difference_type {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___ptrtr_rebind_helper {
    pub _address: u8,
}
pub type std___ptrtr_rebind_helper___type<_Ptr> = _Ptr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___ptrtr_not_void {
    pub _address: u8,
}
pub type std___ptrtr_not_void___type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___ptrtr_pointer_to {
    pub _address: u8,
}
pub type std___ptrtr_pointer_to___orig_type = u8;
pub type std___ptrtr_pointer_to___element_type = std___ptrtr_not_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pointer_traits {
    pub _address: u8,
}
pub type std_pointer_traits_pointer<_Ptr> = _Ptr;
pub type std_pointer_traits_element_type = u8;
pub type std_pointer_traits_difference_type = u8;
pub type std_pointer_traits_rebind = u8;
#[repr(C)]
pub struct std_reverse_iterator<_Iterator> {
    pub current: _Iterator,
}
pub type std_reverse_iterator___traits_type = std_iterator_traits;
pub type std_reverse_iterator_iterator_type<_Iterator> = _Iterator;
pub type std_reverse_iterator_difference_type =
    std_reverse_iterator___traits_type;
pub type std_reverse_iterator_pointer = std_reverse_iterator___traits_type;
pub type std_reverse_iterator_reference = std_reverse_iterator___traits_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_back_insert_iterator<_Container> {
    pub container: *mut _Container,
}
pub type std_back_insert_iterator_container_type<_Container> = _Container;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_front_insert_iterator<_Container> {
    pub container: *mut _Container,
}
pub type std_front_insert_iterator_container_type<_Container> = _Container;
#[repr(C)]
pub struct std_insert_iterator<_Container> {
    pub container: *mut _Container,
    pub iter: [u8; 0usize],
}
pub type std_insert_iterator_container_type<_Container> = _Container;
#[repr(C)]
pub struct std__Niter_base {
    pub _address: u8,
}
#[repr(C)]
pub struct std__Miter_base {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std___copy_move_instantiation_2312() {
    assert_eq!(::std::mem::size_of::<u8>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! ( u8 ) ));
    assert_eq!(::std::mem::align_of::<u8>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! ( u8 )
               ));
}
#[test]
fn __bindgen_test_layout_std___copy_move_instantiation_2315() {
    assert_eq!(::std::mem::size_of::<u8>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! ( u8 ) ));
    assert_eq!(::std::mem::align_of::<u8>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! ( u8 )
               ));
}
#[repr(C)]
pub struct std_istreambuf_iterator<_CharT> {
    pub _M_sbuf: *mut std_istreambuf_iterator_streambuf_type<_CharT>,
    pub _M_c: std_istreambuf_iterator_int_type,
}
pub type std_istreambuf_iterator_char_type<_CharT> = _CharT;
pub type std_istreambuf_iterator_traits_type<_Traits> = _Traits;
pub type std_istreambuf_iterator_int_type = [u8; 0usize];
pub type std_istreambuf_iterator_streambuf_type<_CharT> =
    std_basic_streambuf<_CharT>;
pub type std_istreambuf_iterator_istream_type<_CharT> =
    std_basic_istream<_CharT>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ostreambuf_iterator<_CharT> {
    pub _M_sbuf: *mut std_ostreambuf_iterator_streambuf_type<_CharT>,
    pub _M_failed: bool,
}
pub type std_ostreambuf_iterator_char_type<_CharT> = _CharT;
pub type std_ostreambuf_iterator_traits_type<_Traits> = _Traits;
pub type std_ostreambuf_iterator_streambuf_type<_CharT> =
    std_basic_streambuf<_CharT>;
pub type std_ostreambuf_iterator_ostream_type<_CharT> =
    std_basic_ostream<_CharT>;
#[test]
fn __bindgen_test_layout_std___copy_move_backward_instantiation_2366() {
    assert_eq!(::std::mem::size_of::<u8>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! ( u8 ) ));
    assert_eq!(::std::mem::align_of::<u8>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! ( u8 )
               ));
}
#[test]
fn __bindgen_test_layout_std___copy_move_backward_instantiation_2369() {
    assert_eq!(::std::mem::size_of::<u8>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! ( u8 ) ));
    assert_eq!(::std::mem::align_of::<u8>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! ( u8 )
               ));
}
#[test]
fn __bindgen_test_layout_std___equal_instantiation_2386() {
    assert_eq!(::std::mem::size_of::<u8>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! ( u8 ) ));
    assert_eq!(::std::mem::align_of::<u8>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! ( u8 )
               ));
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___lc_rai {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std___lc_rai_instantiation_2392() {
    assert_eq!(::std::mem::size_of::<std___lc_rai>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std___lc_rai ) ));
    assert_eq!(::std::mem::align_of::<std___lc_rai>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std___lc_rai ) ));
}
#[test]
fn __bindgen_test_layout_std___lexicographical_compare_instantiation_2399() {
    assert_eq!(::std::mem::size_of::<u8>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! ( u8 ) ));
    assert_eq!(::std::mem::align_of::<u8>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! ( u8 )
               ));
}
pub type std_streamoff = ::std::os::raw::c_longlong;
pub type std_streamsize = isize;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_fpos<_StateT> {
    pub _M_off: std_streamoff,
    pub _M_state: _StateT,
}
pub type std_streampos = std_fpos<::std::os::raw::c_int>;
pub type std_wstreampos = std_fpos<::std::os::raw::c_int>;
pub type std_u16streampos = std_fpos<::std::os::raw::c_int>;
pub type std_u32streampos = std_fpos<::std::os::raw::c_int>;
#[repr(C)]
pub struct std_exception__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct std_exception {
    pub vtable_: *const std_exception__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_std_exception() {
    assert_eq!(::std::mem::size_of::<std_exception>() , 8usize , concat ! (
               "Size of: " , stringify ! ( std_exception ) ));
    assert_eq! (::std::mem::align_of::<std_exception>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( std_exception ) ));
}
#[repr(C)]
#[derive(Debug)]
pub struct std_bad_exception {
    pub _base: std_exception,
}
#[test]
fn bindgen_test_layout_std_bad_exception() {
    assert_eq!(::std::mem::size_of::<std_bad_exception>() , 8usize , concat !
               ( "Size of: " , stringify ! ( std_bad_exception ) ));
    assert_eq! (::std::mem::align_of::<std_bad_exception>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( std_bad_exception ) ));
}
pub type std_terminate_handler =
    ::std::option::Option<unsafe extern "C" fn()>;
pub type std_unexpected_handler =
    ::std::option::Option<unsafe extern "C" fn()>;
extern "C" {
    #[link_name = "?set_terminate@std@@YAP6AXXZP6AXXZ@Z"]
    pub fn std_set_terminate(arg1: std_terminate_handler)
     -> std_terminate_handler;
}
extern "C" {
    #[link_name = "?get_terminate@std@@YAP6AXXZXZ"]
    pub fn std_get_terminate() -> std_terminate_handler;
}
extern "C" {
    #[link_name = "?terminate@std@@YAXXZ"]
    pub fn std_terminate();
}
extern "C" {
    #[link_name = "?set_unexpected@std@@YAP6AXXZP6AXXZ@Z"]
    pub fn std_set_unexpected(arg1: std_unexpected_handler)
     -> std_unexpected_handler;
}
extern "C" {
    #[link_name = "?get_unexpected@std@@YAP6AXXZXZ"]
    pub fn std_get_unexpected() -> std_unexpected_handler;
}
extern "C" {
    #[link_name = "?unexpected@std@@YAXXZ"]
    pub fn std_unexpected();
}
extern "C" {
    #[link_name = "?uncaught_exception@std@@YA_NXZ"]
    pub fn std_uncaught_exception() -> bool;
}
#[repr(C)]
pub struct std_type_info__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct std_type_info {
    pub vtable_: *const std_type_info__bindgen_vtable,
    pub __name: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_std_type_info() {
    assert_eq!(::std::mem::size_of::<std_type_info>() , 16usize , concat ! (
               "Size of: " , stringify ! ( std_type_info ) ));
    assert_eq! (::std::mem::align_of::<std_type_info>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( std_type_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const std_type_info ) ) . __name as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( std_type_info ) , "::"
                , stringify ! ( __name ) ));
}
extern "C" {
    #[link_name = "?before@type_info@std@@QEBA_NAEBV12@@Z"]
    pub fn std_type_info_before(this: *const std_type_info,
                                __arg: *const std_type_info) -> bool;
}
impl std_type_info {
    #[inline]
    pub unsafe fn before(&self, __arg: *const std_type_info) -> bool {
        std_type_info_before(self, __arg)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct std___exception_ptr_exception_ptr {
    pub _M_exception_object: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_std___exception_ptr_exception_ptr() {
    assert_eq!(::std::mem::size_of::<std___exception_ptr_exception_ptr>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( std___exception_ptr_exception_ptr )
               ));
    assert_eq! (::std::mem::align_of::<std___exception_ptr_exception_ptr>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                std___exception_ptr_exception_ptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const std___exception_ptr_exception_ptr ) ) .
                _M_exception_object as * const _ as usize } , 0usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                std___exception_ptr_exception_ptr ) , "::" , stringify ! (
                _M_exception_object ) ));
}
extern "C" {
    #[link_name = "?swap@exception_ptr@__exception_ptr@std@@QEAAXAEAV123@@Z"]
    pub fn std___exception_ptr_exception_ptr_swap(this:
                                                      *mut std___exception_ptr_exception_ptr,
                                                  arg1:
                                                      *mut std___exception_ptr_exception_ptr);
}
extern "C" {
    #[link_name =
          "?__cxa_exception_type@exception_ptr@__exception_ptr@std@@QEBAPEBVtype_info@3@XZ"]
    pub fn std___exception_ptr_exception_ptr___cxa_exception_type(this:
                                                                      *const std___exception_ptr_exception_ptr)
     -> *const std_type_info;
}
extern "C" {
    #[link_name = "??0exception_ptr@__exception_ptr@std@@QEAA@XZ"]
    pub fn std___exception_ptr_exception_ptr_exception_ptr(this:
                                                               *mut std___exception_ptr_exception_ptr);
}
extern "C" {
    #[link_name = "??0exception_ptr@__exception_ptr@std@@QEAA@AEBV012@@Z"]
    pub fn std___exception_ptr_exception_ptr_exception_ptr1(this:
                                                                *mut std___exception_ptr_exception_ptr,
                                                            arg1:
                                                                *const std___exception_ptr_exception_ptr);
}
extern "C" {
    #[link_name = "??_Dexception_ptr@__exception_ptr@std@@QEAA@XZ"]
    pub fn std___exception_ptr_exception_ptr_exception_ptr_destructor(this:
                                                                          *mut std___exception_ptr_exception_ptr);
}
impl std___exception_ptr_exception_ptr {
    #[inline]
    pub unsafe fn swap(&mut self,
                       arg1: *mut std___exception_ptr_exception_ptr) {
        std___exception_ptr_exception_ptr_swap(self, arg1)
    }
    #[inline]
    pub unsafe fn __cxa_exception_type(&self) -> *const std_type_info {
        std___exception_ptr_exception_ptr___cxa_exception_type(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        std___exception_ptr_exception_ptr_exception_ptr(&mut __bindgen_tmp);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(arg1: *const std___exception_ptr_exception_ptr)
     -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        std___exception_ptr_exception_ptr_exception_ptr1(&mut __bindgen_tmp,
                                                         arg1);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        std___exception_ptr_exception_ptr_exception_ptr_destructor(self)
    }
}
extern "C" {
    #[link_name =
          "?current_exception@std@@YA?AVexception_ptr@__exception_ptr@1@XZ"]
    pub fn std_current_exception() -> std___exception_ptr_exception_ptr;
}
extern "C" {
    #[link_name =
          "?rethrow_exception@std@@YAXVexception_ptr@__exception_ptr@1@@Z"]
    pub fn std_rethrow_exception(arg1: std___exception_ptr_exception_ptr);
}
#[repr(C)]
pub struct std_nested_exception__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct std_nested_exception {
    pub vtable_: *const std_nested_exception__bindgen_vtable,
    pub _M_ptr: std___exception_ptr_exception_ptr,
}
#[test]
fn bindgen_test_layout_std_nested_exception() {
    assert_eq!(::std::mem::size_of::<std_nested_exception>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( std_nested_exception )
               ));
    assert_eq! (::std::mem::align_of::<std_nested_exception>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( std_nested_exception ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const std_nested_exception ) ) . _M_ptr as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( std_nested_exception )
                , "::" , stringify ! ( _M_ptr ) ));
}
#[repr(C)]
#[derive(Debug)]
pub struct std__Nested_exception<_Except> {
    pub _base: _Except,
    pub _base_1: std_nested_exception,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___get_nested_helper {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug)]
pub struct std_bad_alloc {
    pub _base: std_exception,
}
#[test]
fn bindgen_test_layout_std_bad_alloc() {
    assert_eq!(::std::mem::size_of::<std_bad_alloc>() , 8usize , concat ! (
               "Size of: " , stringify ! ( std_bad_alloc ) ));
    assert_eq! (::std::mem::align_of::<std_bad_alloc>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( std_bad_alloc ) ));
}
#[repr(C)]
#[derive(Debug)]
pub struct std_bad_array_new_length {
    pub _base: std_bad_alloc,
}
#[test]
fn bindgen_test_layout_std_bad_array_new_length() {
    assert_eq!(::std::mem::size_of::<std_bad_array_new_length>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( std_bad_array_new_length ) ));
    assert_eq! (::std::mem::align_of::<std_bad_array_new_length>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( std_bad_array_new_length ) ));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct std_nothrow_t {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_nothrow_t() {
    assert_eq!(::std::mem::size_of::<std_nothrow_t>() , 1usize , concat ! (
               "Size of: " , stringify ! ( std_nothrow_t ) ));
    assert_eq! (::std::mem::align_of::<std_nothrow_t>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( std_nothrow_t ) ));
}
impl Clone for std_nothrow_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "?nothrow@std@@3Unothrow_t@1@B"]
    pub static std_nothrow: std_nothrow_t;
}
pub type std_new_handler = ::std::option::Option<unsafe extern "C" fn()>;
extern "C" {
    #[link_name = "?set_new_handler@std@@YAP6AXXZP6AXXZ@Z"]
    pub fn std_set_new_handler(arg1: std_new_handler) -> std_new_handler;
}
extern "C" {
    #[link_name = "?get_new_handler@std@@YAP6AXXZXZ"]
    pub fn std_get_new_handler() -> std_new_handler;
}
pub type std___allocator_base = __gnu_cxx_new_allocator;
#[test]
fn __bindgen_test_layout_std_allocator_instantiation_5094() {
    assert_eq!(::std::mem::size_of::<std_allocator>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std_allocator ) ));
    assert_eq!(::std::mem::align_of::<std_allocator>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_allocator ) ));
}
#[test]
fn __bindgen_test_layout_std_allocator_instantiation_5098() {
    assert_eq!(::std::mem::size_of::<std_allocator>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std_allocator ) ));
    assert_eq!(::std::mem::align_of::<std_allocator>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_allocator ) ));
}
pub type std___c_locale = *mut ::std::os::raw::c_int;
pub type std__Atomic_word = ::std::os::raw::c_int;
#[repr(C)]
pub struct std_ios_base__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct std_ios_base {
    pub vtable_: *const std_ios_base__bindgen_vtable,
    pub _M_precision: std_streamsize,
    pub _M_width: std_streamsize,
    pub _M_flags: std_ios_base_fmtflags,
    pub _M_exception: std_ios_base_iostate,
    pub _M_streambuf_state: std_ios_base_iostate,
    pub _M_callbacks: *mut std_ios_base__Callback_list,
    pub _M_word_zero: std_ios_base__Words,
    pub _M_local_word: [std_ios_base__Words; 8usize],
    pub _M_word_size: ::std::os::raw::c_int,
    pub _M_word: *mut std_ios_base__Words,
    pub _M_ios_locale: std_locale,
}
#[repr(C)]
#[derive(Debug)]
pub struct std_ios_base_failure {
    pub _base: std_exception,
    pub _M_msg: std_string,
}
#[test]
fn bindgen_test_layout_std_ios_base_failure() {
    assert_eq!(::std::mem::size_of::<std_ios_base_failure>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( std_ios_base_failure )
               ));
    assert_eq! (::std::mem::align_of::<std_ios_base_failure>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( std_ios_base_failure ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const std_ios_base_failure ) ) . _M_msg as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( std_ios_base_failure )
                , "::" , stringify ! ( _M_msg ) ));
}
extern "C" {
    #[link_name =
          "??0failure@ios_base@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z"]
    pub fn std_ios_base_failure_failure(this: *mut std_ios_base_failure,
                                        __str: *const std_string);
}
impl std_ios_base_failure {
    #[inline]
    pub unsafe fn new(__str: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        std_ios_base_failure_failure(&mut __bindgen_tmp, __str);
        __bindgen_tmp
    }
}
pub use self::std__Ios_Fmtflags as std_ios_base_fmtflags;
pub use self::std__Ios_Iostate as std_ios_base_iostate;
pub use self::std__Ios_Openmode as std_ios_base_openmode;
pub use self::std__Ios_Seekdir as std_ios_base_seekdir;
pub type std_ios_base_io_state = ::std::os::raw::c_int;
pub type std_ios_base_open_mode = ::std::os::raw::c_int;
pub type std_ios_base_seek_dir = ::std::os::raw::c_int;
pub type std_ios_base_streampos = std_streampos;
pub type std_ios_base_streamoff = std_streamoff;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum std_ios_base_event {
    erase_event = 0,
    imbue_event = 1,
    copyfmt_event = 2,
}
pub type std_ios_base_event_callback =
    ::std::option::Option<unsafe extern "C" fn(__e: std_ios_base_event,
                                               __b: *mut std_ios_base,
                                               __i: ::std::os::raw::c_int)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct std_ios_base__Callback_list {
    pub _M_next: *mut std_ios_base__Callback_list,
    pub _M_fn: std_ios_base_event_callback,
    pub _M_index: ::std::os::raw::c_int,
    pub _M_refcount: std__Atomic_word,
}
#[test]
fn bindgen_test_layout_std_ios_base__Callback_list() {
    assert_eq!(::std::mem::size_of::<std_ios_base__Callback_list>() , 24usize
               , concat ! (
               "Size of: " , stringify ! ( std_ios_base__Callback_list ) ));
    assert_eq! (::std::mem::align_of::<std_ios_base__Callback_list>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( std_ios_base__Callback_list )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const std_ios_base__Callback_list ) ) . _M_next
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                std_ios_base__Callback_list ) , "::" , stringify ! ( _M_next )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const std_ios_base__Callback_list ) ) . _M_fn
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                std_ios_base__Callback_list ) , "::" , stringify ! ( _M_fn )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const std_ios_base__Callback_list ) ) .
                _M_index as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                std_ios_base__Callback_list ) , "::" , stringify ! ( _M_index
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const std_ios_base__Callback_list ) ) .
                _M_refcount as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                std_ios_base__Callback_list ) , "::" , stringify ! (
                _M_refcount ) ));
}
impl Clone for std_ios_base__Callback_list {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct std_ios_base__Words {
    pub _M_pword: *mut ::std::os::raw::c_void,
    pub _M_iword: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_std_ios_base__Words() {
    assert_eq!(::std::mem::size_of::<std_ios_base__Words>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( std_ios_base__Words ) ));
    assert_eq! (::std::mem::align_of::<std_ios_base__Words>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( std_ios_base__Words ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const std_ios_base__Words ) ) . _M_pword as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( std_ios_base__Words ) ,
                "::" , stringify ! ( _M_pword ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const std_ios_base__Words ) ) . _M_iword as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( std_ios_base__Words ) ,
                "::" , stringify ! ( _M_iword ) ));
}
impl Clone for std_ios_base__Words {
    fn clone(&self) -> Self { *self }
}
pub const std_ios_base__S_local_word_size: std_ios_base__bindgen_ty_1 =
    std_ios_base__bindgen_ty_1::_S_local_word_size;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum std_ios_base__bindgen_ty_1 { _S_local_word_size = 8, }
#[repr(C)]
#[derive(Debug)]
pub struct std_ios_base_Init {
    pub _address: u8,
}
extern "C" {
    #[link_name = "?_S_refcount@Init@ios_base@std@@0HA"]
    pub static mut std_ios_base_Init__S_refcount: std__Atomic_word;
}
extern "C" {
    #[link_name = "?_S_synced_with_stdio@Init@ios_base@std@@0_NA"]
    pub static mut std_ios_base_Init__S_synced_with_stdio: bool;
}
#[test]
fn bindgen_test_layout_std_ios_base_Init() {
    assert_eq!(::std::mem::size_of::<std_ios_base_Init>() , 1usize , concat !
               ( "Size of: " , stringify ! ( std_ios_base_Init ) ));
    assert_eq! (::std::mem::align_of::<std_ios_base_Init>() , 1usize , concat
                ! ( "Alignment of " , stringify ! ( std_ios_base_Init ) ));
}
extern "C" {
    #[link_name = "??0Init@ios_base@std@@QEAA@XZ"]
    pub fn std_ios_base_Init_Init(this: *mut std_ios_base_Init);
}
extern "C" {
    #[link_name = "??_DInit@ios_base@std@@QEAA@XZ"]
    pub fn std_ios_base_Init_Init_destructor(this: *mut std_ios_base_Init);
}
impl std_ios_base_Init {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        std_ios_base_Init_Init(&mut __bindgen_tmp);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        std_ios_base_Init_Init_destructor(self)
    }
}
extern "C" {
    #[link_name = "?boolalpha@ios_base@std@@2W4_Ios_Fmtflags@2@B"]
    pub static std_ios_base_boolalpha: std_ios_base_fmtflags;
}
extern "C" {
    #[link_name = "?dec@ios_base@std@@2W4_Ios_Fmtflags@2@B"]
    pub static std_ios_base_dec: std_ios_base_fmtflags;
}
extern "C" {
    #[link_name = "?fixed@ios_base@std@@2W4_Ios_Fmtflags@2@B"]
    pub static std_ios_base_fixed: std_ios_base_fmtflags;
}
extern "C" {
    #[link_name = "?hex@ios_base@std@@2W4_Ios_Fmtflags@2@B"]
    pub static std_ios_base_hex: std_ios_base_fmtflags;
}
extern "C" {
    #[link_name = "?internal@ios_base@std@@2W4_Ios_Fmtflags@2@B"]
    pub static std_ios_base_internal: std_ios_base_fmtflags;
}
extern "C" {
    #[link_name = "?left@ios_base@std@@2W4_Ios_Fmtflags@2@B"]
    pub static std_ios_base_left: std_ios_base_fmtflags;
}
extern "C" {
    #[link_name = "?oct@ios_base@std@@2W4_Ios_Fmtflags@2@B"]
    pub static std_ios_base_oct: std_ios_base_fmtflags;
}
extern "C" {
    #[link_name = "?right@ios_base@std@@2W4_Ios_Fmtflags@2@B"]
    pub static std_ios_base_right: std_ios_base_fmtflags;
}
extern "C" {
    #[link_name = "?scientific@ios_base@std@@2W4_Ios_Fmtflags@2@B"]
    pub static std_ios_base_scientific: std_ios_base_fmtflags;
}
extern "C" {
    #[link_name = "?showbase@ios_base@std@@2W4_Ios_Fmtflags@2@B"]
    pub static std_ios_base_showbase: std_ios_base_fmtflags;
}
extern "C" {
    #[link_name = "?showpoint@ios_base@std@@2W4_Ios_Fmtflags@2@B"]
    pub static std_ios_base_showpoint: std_ios_base_fmtflags;
}
extern "C" {
    #[link_name = "?showpos@ios_base@std@@2W4_Ios_Fmtflags@2@B"]
    pub static std_ios_base_showpos: std_ios_base_fmtflags;
}
extern "C" {
    #[link_name = "?skipws@ios_base@std@@2W4_Ios_Fmtflags@2@B"]
    pub static std_ios_base_skipws: std_ios_base_fmtflags;
}
extern "C" {
    #[link_name = "?unitbuf@ios_base@std@@2W4_Ios_Fmtflags@2@B"]
    pub static std_ios_base_unitbuf: std_ios_base_fmtflags;
}
extern "C" {
    #[link_name = "?uppercase@ios_base@std@@2W4_Ios_Fmtflags@2@B"]
    pub static std_ios_base_uppercase: std_ios_base_fmtflags;
}
extern "C" {
    #[link_name = "?adjustfield@ios_base@std@@2W4_Ios_Fmtflags@2@B"]
    pub static std_ios_base_adjustfield: std_ios_base_fmtflags;
}
extern "C" {
    #[link_name = "?basefield@ios_base@std@@2W4_Ios_Fmtflags@2@B"]
    pub static std_ios_base_basefield: std_ios_base_fmtflags;
}
extern "C" {
    #[link_name = "?floatfield@ios_base@std@@2W4_Ios_Fmtflags@2@B"]
    pub static std_ios_base_floatfield: std_ios_base_fmtflags;
}
extern "C" {
    #[link_name = "?badbit@ios_base@std@@2W4_Ios_Iostate@2@B"]
    pub static std_ios_base_badbit: std_ios_base_iostate;
}
extern "C" {
    #[link_name = "?eofbit@ios_base@std@@2W4_Ios_Iostate@2@B"]
    pub static std_ios_base_eofbit: std_ios_base_iostate;
}
extern "C" {
    #[link_name = "?failbit@ios_base@std@@2W4_Ios_Iostate@2@B"]
    pub static std_ios_base_failbit: std_ios_base_iostate;
}
extern "C" {
    #[link_name = "?goodbit@ios_base@std@@2W4_Ios_Iostate@2@B"]
    pub static std_ios_base_goodbit: std_ios_base_iostate;
}
extern "C" {
    #[link_name = "?app@ios_base@std@@2W4_Ios_Openmode@2@B"]
    pub static std_ios_base_app: std_ios_base_openmode;
}
extern "C" {
    #[link_name = "?ate@ios_base@std@@2W4_Ios_Openmode@2@B"]
    pub static std_ios_base_ate: std_ios_base_openmode;
}
extern "C" {
    #[link_name = "?binary@ios_base@std@@2W4_Ios_Openmode@2@B"]
    pub static std_ios_base_binary: std_ios_base_openmode;
}
extern "C" {
    #[link_name = "?in@ios_base@std@@2W4_Ios_Openmode@2@B"]
    pub static std_ios_base_in: std_ios_base_openmode;
}
extern "C" {
    #[link_name = "?out@ios_base@std@@2W4_Ios_Openmode@2@B"]
    pub static std_ios_base_out: std_ios_base_openmode;
}
extern "C" {
    #[link_name = "?trunc@ios_base@std@@2W4_Ios_Openmode@2@B"]
    pub static std_ios_base_trunc: std_ios_base_openmode;
}
extern "C" {
    #[link_name = "?beg@ios_base@std@@2W4_Ios_Seekdir@2@B"]
    pub static std_ios_base_beg: std_ios_base_seekdir;
}
extern "C" {
    #[link_name = "?cur@ios_base@std@@2W4_Ios_Seekdir@2@B"]
    pub static std_ios_base_cur: std_ios_base_seekdir;
}
extern "C" {
    #[link_name = "?end@ios_base@std@@2W4_Ios_Seekdir@2@B"]
    pub static std_ios_base_end: std_ios_base_seekdir;
}
#[test]
fn bindgen_test_layout_std_ios_base() {
    assert_eq!(::std::mem::size_of::<std_ios_base>() , 216usize , concat ! (
               "Size of: " , stringify ! ( std_ios_base ) ));
    assert_eq! (::std::mem::align_of::<std_ios_base>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( std_ios_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const std_ios_base ) ) . _M_precision as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( std_ios_base ) , "::" ,
                stringify ! ( _M_precision ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const std_ios_base ) ) . _M_width as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( std_ios_base ) , "::" ,
                stringify ! ( _M_width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const std_ios_base ) ) . _M_flags as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( std_ios_base ) , "::" ,
                stringify ! ( _M_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const std_ios_base ) ) . _M_exception as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( std_ios_base ) , "::" ,
                stringify ! ( _M_exception ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const std_ios_base ) ) . _M_streambuf_state as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( std_ios_base ) , "::" ,
                stringify ! ( _M_streambuf_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const std_ios_base ) ) . _M_callbacks as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( std_ios_base ) , "::" ,
                stringify ! ( _M_callbacks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const std_ios_base ) ) . _M_word_zero as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( std_ios_base ) , "::" ,
                stringify ! ( _M_word_zero ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const std_ios_base ) ) . _M_local_word as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( std_ios_base ) , "::" ,
                stringify ! ( _M_local_word ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const std_ios_base ) ) . _M_word_size as *
                const _ as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( std_ios_base ) , "::" ,
                stringify ! ( _M_word_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const std_ios_base ) ) . _M_word as * const _
                as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( std_ios_base ) , "::" ,
                stringify ! ( _M_word ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const std_ios_base ) ) . _M_ios_locale as *
                const _ as usize } , 208usize , concat ! (
                "Alignment of field: " , stringify ! ( std_ios_base ) , "::" ,
                stringify ! ( _M_ios_locale ) ));
}
extern "C" {
    #[link_name =
          "?register_callback@ios_base@std@@QEAAXP6AXW4event@12@AEAV12@H@ZH@Z"]
    pub fn std_ios_base_register_callback(this: *mut std_ios_base,
                                          __fn: std_ios_base_event_callback,
                                          __index: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "?_M_call_callbacks@ios_base@std@@IEAAXW4event@12@@Z"]
    pub fn std_ios_base__M_call_callbacks(this: *mut std_ios_base,
                                          __ev: std_ios_base_event);
}
extern "C" {
    #[link_name = "?_M_dispose_callbacks@ios_base@std@@IEAAXXZ"]
    pub fn std_ios_base__M_dispose_callbacks(this: *mut std_ios_base);
}
extern "C" {
    #[link_name = "?_M_grow_words@ios_base@std@@IEAAAEAU_Words@12@H_N@Z"]
    pub fn std_ios_base__M_grow_words(this: *mut std_ios_base,
                                      __index: ::std::os::raw::c_int,
                                      __iword: bool)
     -> *mut std_ios_base__Words;
}
extern "C" {
    #[link_name = "?_M_init@ios_base@std@@IEAAXXZ"]
    pub fn std_ios_base__M_init(this: *mut std_ios_base);
}
extern "C" {
    #[link_name = "?sync_with_stdio@ios_base@std@@SA_N_N@Z"]
    pub fn std_ios_base_sync_with_stdio(__sync: bool) -> bool;
}
extern "C" {
    #[link_name = "?imbue@ios_base@std@@QEAA?AVlocale@2@AEBV32@@Z"]
    pub fn std_ios_base_imbue(this: *mut std_ios_base,
                              __loc: *const std_locale) -> std_locale;
}
extern "C" {
    #[link_name = "?xalloc@ios_base@std@@SAHXZ"]
    pub fn std_ios_base_xalloc() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "??0ios_base@std@@IEAA@XZ"]
    pub fn std_ios_base_ios_base(this: *mut std_ios_base);
}
impl std_ios_base {
    #[inline]
    pub unsafe fn register_callback(&mut self,
                                    __fn: std_ios_base_event_callback,
                                    __index: ::std::os::raw::c_int) {
        std_ios_base_register_callback(self, __fn, __index)
    }
    #[inline]
    pub unsafe fn _M_call_callbacks(&mut self, __ev: std_ios_base_event) {
        std_ios_base__M_call_callbacks(self, __ev)
    }
    #[inline]
    pub unsafe fn _M_dispose_callbacks(&mut self) {
        std_ios_base__M_dispose_callbacks(self)
    }
    #[inline]
    pub unsafe fn _M_grow_words(&mut self, __index: ::std::os::raw::c_int,
                                __iword: bool) -> *mut std_ios_base__Words {
        std_ios_base__M_grow_words(self, __index, __iword)
    }
    #[inline]
    pub unsafe fn _M_init(&mut self) { std_ios_base__M_init(self) }
    #[inline]
    pub unsafe fn sync_with_stdio(__sync: bool) -> bool {
        std_ios_base_sync_with_stdio(__sync)
    }
    #[inline]
    pub unsafe fn imbue(&mut self, __loc: *const std_locale) -> std_locale {
        std_ios_base_imbue(self, __loc)
    }
    #[inline]
    pub unsafe fn xalloc() -> ::std::os::raw::c_int { std_ios_base_xalloc() }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        std_ios_base_ios_base(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct std_basic_ios<_CharT> {
    pub _base: std_ios_base,
    pub _M_tie: *mut std_basic_ostream<_CharT>,
    pub _M_fill: std_basic_ios_char_type<_CharT>,
    pub _M_fill_init: bool,
    pub _M_streambuf: *mut std_basic_streambuf<_CharT>,
    pub _M_ctype: *const std_basic_ios___ctype_type,
    pub _M_num_put: *const std_basic_ios___num_put_type,
    pub _M_num_get: *const std_basic_ios___num_get_type,
}
pub type std_basic_ios_char_type<_CharT> = _CharT;
pub type std_basic_ios_int_type = [u8; 0usize];
pub type std_basic_ios_pos_type = [u8; 0usize];
pub type std_basic_ios_off_type = [u8; 0usize];
pub type std_basic_ios_traits_type<_Traits> = _Traits;
pub type std_basic_ios___ctype_type = std_ctype;
pub type std_basic_ios___num_put_type = std_num_put;
pub type std_basic_ios___num_get_type = std_num_get;
#[repr(C)]
pub struct std_basic_streambuf__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct std_basic_streambuf<_CharT> {
    pub vtable_: *const std_basic_streambuf__bindgen_vtable,
    pub _M_in_beg: *mut std_basic_streambuf_char_type<_CharT>,
    pub _M_in_cur: *mut std_basic_streambuf_char_type<_CharT>,
    pub _M_in_end: *mut std_basic_streambuf_char_type<_CharT>,
    pub _M_out_beg: *mut std_basic_streambuf_char_type<_CharT>,
    pub _M_out_cur: *mut std_basic_streambuf_char_type<_CharT>,
    pub _M_out_end: *mut std_basic_streambuf_char_type<_CharT>,
    pub _M_buf_locale: std_locale,
}
pub type std_basic_streambuf_char_type<_CharT> = _CharT;
pub type std_basic_streambuf_traits_type<_Traits> = _Traits;
pub type std_basic_streambuf_int_type = [u8; 0usize];
pub type std_basic_streambuf_pos_type = [u8; 0usize];
pub type std_basic_streambuf_off_type = [u8; 0usize];
pub type std_basic_streambuf___streambuf_type =
    std_basic_streambuf<std_basic_streambuf_char_type<_CharT>>;
#[repr(C)]
#[derive(Debug)]
pub struct std_basic_istream<_CharT> {
    pub _M_gcount: std_streamsize,
}
pub type std_basic_istream_char_type<_CharT> = _CharT;
pub type std_basic_istream_int_type = [u8; 0usize];
pub type std_basic_istream_pos_type = [u8; 0usize];
pub type std_basic_istream_off_type = [u8; 0usize];
pub type std_basic_istream_traits_type<_Traits> = _Traits;
pub type std_basic_istream___streambuf_type<_CharT> =
    std_basic_streambuf<_CharT>;
pub type std_basic_istream___ios_type<_CharT> = std_basic_ios<_CharT>;
pub type std_basic_istream___istream_type<_CharT> = std_basic_istream<_CharT>;
pub type std_basic_istream___num_get_type = std_num_get;
pub type std_basic_istream___ctype_type = std_ctype;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_istream_sentry {
    pub _M_ok: bool,
}
pub type std_basic_istream_sentry_traits_type = _Traits;
pub type std_basic_istream_sentry___streambuf_type =
    std_basic_streambuf<_CharT>;
pub type std_basic_istream_sentry___istream_type = std_basic_istream<_CharT>;
pub type std_basic_istream_sentry___ctype_type =
    std_basic_istream___ctype_type;
pub type std_basic_istream_sentry___int_type = [u8; 0usize];
#[repr(C)]
#[derive(Debug)]
pub struct std_basic_ostream<_CharT> {
}
pub type std_basic_ostream_char_type<_CharT> = _CharT;
pub type std_basic_ostream_int_type = [u8; 0usize];
pub type std_basic_ostream_pos_type = [u8; 0usize];
pub type std_basic_ostream_off_type = [u8; 0usize];
pub type std_basic_ostream_traits_type<_Traits> = _Traits;
pub type std_basic_ostream___streambuf_type<_CharT> =
    std_basic_streambuf<_CharT>;
pub type std_basic_ostream___ios_type<_CharT> = std_basic_ios<_CharT>;
pub type std_basic_ostream___ostream_type<_CharT> = std_basic_ostream<_CharT>;
pub type std_basic_ostream___num_put_type = std_num_put;
pub type std_basic_ostream___ctype_type = std_ctype;
#[repr(C)]
#[derive(Debug)]
pub struct std_basic_ostream_sentry {
    pub _M_ok: bool,
    pub _M_os: *mut std_basic_ostream<_CharT>,
}
#[repr(C)]
#[derive(Debug)]
pub struct std_basic_iostream<_CharT> {
    pub _base: std_basic_istream<_CharT>,
    pub _base_1: std_basic_ostream<_CharT>,
}
pub type std_basic_iostream_char_type<_CharT> = _CharT;
pub type std_basic_iostream_int_type = [u8; 0usize];
pub type std_basic_iostream_pos_type = [u8; 0usize];
pub type std_basic_iostream_off_type = [u8; 0usize];
pub type std_basic_iostream_traits_type<_Traits> = _Traits;
pub type std_basic_iostream___istream_type<_CharT> =
    std_basic_istream<_CharT>;
pub type std_basic_iostream___ostream_type<_CharT> =
    std_basic_ostream<_CharT>;
#[repr(C)]
#[derive(Debug)]
pub struct std_basic_stringbuf<_CharT, _Alloc> {
    pub _base: std_basic_streambuf<_CharT>,
    pub _M_mode: std_ios_base_openmode,
    pub _M_string: std_basic_stringbuf___string_type<_Alloc>,
}
pub type std_basic_stringbuf_char_type<_CharT> = _CharT;
pub type std_basic_stringbuf_traits_type<_Traits> = _Traits;
pub type std_basic_stringbuf_allocator_type<_Alloc> = _Alloc;
pub type std_basic_stringbuf_int_type = [u8; 0usize];
pub type std_basic_stringbuf_pos_type = [u8; 0usize];
pub type std_basic_stringbuf_off_type = [u8; 0usize];
pub type std_basic_stringbuf___streambuf_type =
    std_basic_streambuf<std_basic_stringbuf_char_type<_CharT>>;
pub type std_basic_stringbuf___string_type<_Alloc> =
    std_basic_string<std_basic_stringbuf_char_type<_CharT>, _Alloc>;
pub type std_basic_stringbuf___size_type<_Alloc> =
    std_basic_stringbuf___string_type<_Alloc>;
#[repr(C)]
#[derive(Debug)]
pub struct std_basic_istringstream<_CharT, _Alloc> {
    pub _base: std_basic_istream<_CharT>,
    pub _M_stringbuf: std_basic_istringstream___stringbuf_type<_CharT,
                                                               _Alloc>,
}
pub type std_basic_istringstream_char_type<_CharT> = _CharT;
pub type std_basic_istringstream_traits_type<_Traits> = _Traits;
pub type std_basic_istringstream_allocator_type<_Alloc> = _Alloc;
pub type std_basic_istringstream_int_type = [u8; 0usize];
pub type std_basic_istringstream_pos_type = [u8; 0usize];
pub type std_basic_istringstream_off_type = [u8; 0usize];
pub type std_basic_istringstream___string_type<_CharT, _Alloc> =
    std_basic_string<_CharT, _Alloc>;
pub type std_basic_istringstream___stringbuf_type<_CharT, _Alloc> =
    std_basic_stringbuf<_CharT, _Alloc>;
pub type std_basic_istringstream___istream_type =
    std_basic_istream<std_basic_istringstream_char_type<_CharT>>;
#[repr(C)]
#[derive(Debug)]
pub struct std_basic_ostringstream<_CharT, _Alloc> {
    pub _base: std_basic_ostream<_CharT>,
    pub _M_stringbuf: std_basic_ostringstream___stringbuf_type<_CharT,
                                                               _Alloc>,
}
pub type std_basic_ostringstream_char_type<_CharT> = _CharT;
pub type std_basic_ostringstream_traits_type<_Traits> = _Traits;
pub type std_basic_ostringstream_allocator_type<_Alloc> = _Alloc;
pub type std_basic_ostringstream_int_type = [u8; 0usize];
pub type std_basic_ostringstream_pos_type = [u8; 0usize];
pub type std_basic_ostringstream_off_type = [u8; 0usize];
pub type std_basic_ostringstream___string_type<_CharT, _Alloc> =
    std_basic_string<_CharT, _Alloc>;
pub type std_basic_ostringstream___stringbuf_type<_CharT, _Alloc> =
    std_basic_stringbuf<_CharT, _Alloc>;
pub type std_basic_ostringstream___ostream_type =
    std_basic_ostream<std_basic_ostringstream_char_type<_CharT>>;
#[repr(C)]
#[derive(Debug)]
pub struct std_basic_stringstream<_CharT, _Alloc> {
    pub _base: std_basic_iostream<_CharT>,
    pub _M_stringbuf: std_basic_stringstream___stringbuf_type<_CharT, _Alloc>,
}
pub type std_basic_stringstream_char_type<_CharT> = _CharT;
pub type std_basic_stringstream_traits_type<_Traits> = _Traits;
pub type std_basic_stringstream_allocator_type<_Alloc> = _Alloc;
pub type std_basic_stringstream_int_type = [u8; 0usize];
pub type std_basic_stringstream_pos_type = [u8; 0usize];
pub type std_basic_stringstream_off_type = [u8; 0usize];
pub type std_basic_stringstream___string_type<_CharT, _Alloc> =
    std_basic_string<_CharT, _Alloc>;
pub type std_basic_stringstream___stringbuf_type<_CharT, _Alloc> =
    std_basic_stringbuf<_CharT, _Alloc>;
pub type std_basic_stringstream___iostream_type =
    std_basic_iostream<std_basic_stringstream_char_type<_CharT>>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_filebuf {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_ifstream {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_ofstream {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_fstream {
    pub _address: u8,
}
pub type std_ios = std_basic_ios<::std::os::raw::c_char>;
pub type std_streambuf = std_basic_streambuf<::std::os::raw::c_char>;
pub type std_istream = std_basic_istream<::std::os::raw::c_char>;
pub type std_ostream = std_basic_ostream<::std::os::raw::c_char>;
pub type std_iostream = std_basic_iostream<::std::os::raw::c_char>;
pub type std_stringbuf =
    std_basic_stringbuf<::std::os::raw::c_char, std_allocator>;
pub type std_istringstream =
    std_basic_istringstream<::std::os::raw::c_char, std_allocator>;
pub type std_ostringstream =
    std_basic_ostringstream<::std::os::raw::c_char, std_allocator>;
pub type std_stringstream =
    std_basic_stringstream<::std::os::raw::c_char, std_allocator>;
pub type std_filebuf = std_basic_filebuf;
pub type std_ifstream = std_basic_ifstream;
pub type std_ofstream = std_basic_ofstream;
pub type std_fstream = std_basic_fstream;
pub type std_wios = std_basic_ios<u16>;
pub type std_wstreambuf = std_basic_streambuf<u16>;
pub type std_wistream = std_basic_istream<u16>;
pub type std_wostream = std_basic_ostream<u16>;
pub type std_wiostream = std_basic_iostream<u16>;
pub type std_wstringbuf = std_basic_stringbuf<u16, std_allocator>;
pub type std_wistringstream = std_basic_istringstream<u16, std_allocator>;
pub type std_wostringstream = std_basic_ostringstream<u16, std_allocator>;
pub type std_wstringstream = std_basic_stringstream<u16, std_allocator>;
pub type std_wfilebuf = std_basic_filebuf;
pub type std_wifstream = std_basic_ifstream;
pub type std_wofstream = std_basic_ofstream;
pub type std_wfstream = std_basic_fstream;
pub type std___gthread_once_t = __gthread_once_t;
#[repr(C)]
#[derive(Debug)]
pub struct std_locale {
    pub _M_impl: *mut std_locale__Impl,
}
pub type std_locale_category = ::std::os::raw::c_int;
#[repr(C)]
pub struct std_locale_facet__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct std_locale_facet {
    pub vtable_: *const std_locale_facet__bindgen_vtable,
    pub _M_refcount: std__Atomic_word,
}
extern "C" {
    #[link_name = "?_S_c_locale@facet@locale@std@@0PEAHEA"]
    pub static mut std_locale_facet__S_c_locale: std___c_locale;
}
extern "C" {
    #[link_name = "?_S_c_name@facet@locale@std@@0QBDB"]
    pub static mut std_locale_facet__S_c_name:
               [::std::os::raw::c_char; 2usize];
}
extern "C" {
    #[link_name = "?_S_once@facet@locale@std@@0U__gthread_once_t@@A"]
    pub static mut std_locale_facet__S_once: std___gthread_once_t;
}
#[test]
fn bindgen_test_layout_std_locale_facet() {
    assert_eq!(::std::mem::size_of::<std_locale_facet>() , 16usize , concat !
               ( "Size of: " , stringify ! ( std_locale_facet ) ));
    assert_eq! (::std::mem::align_of::<std_locale_facet>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( std_locale_facet ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const std_locale_facet ) ) . _M_refcount as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( std_locale_facet ) ,
                "::" , stringify ! ( _M_refcount ) ));
}
extern "C" {
    #[link_name =
          "?_S_create_c_locale@facet@locale@std@@KAXAEAPEAHPEBDPEAH@Z"]
    pub fn std_locale_facet__S_create_c_locale(__cloc: *mut std___c_locale,
                                               __s:
                                                   *const ::std::os::raw::c_char,
                                               __old: std___c_locale);
}
extern "C" {
    #[link_name = "?_S_clone_c_locale@facet@locale@std@@KAPEAHAEAPEAH@Z"]
    pub fn std_locale_facet__S_clone_c_locale(__cloc: *mut std___c_locale)
     -> std___c_locale;
}
extern "C" {
    #[link_name = "?_S_destroy_c_locale@facet@locale@std@@KAXAEAPEAH@Z"]
    pub fn std_locale_facet__S_destroy_c_locale(__cloc: *mut std___c_locale);
}
extern "C" {
    #[link_name = "?_S_lc_ctype_c_locale@facet@locale@std@@KAPEAHPEAHPEBD@Z"]
    pub fn std_locale_facet__S_lc_ctype_c_locale(__cloc: std___c_locale,
                                                 __s:
                                                     *const ::std::os::raw::c_char)
     -> std___c_locale;
}
extern "C" {
    #[link_name = "?_S_get_c_locale@facet@locale@std@@KAPEAHXZ"]
    pub fn std_locale_facet__S_get_c_locale() -> std___c_locale;
}
extern "C" {
    #[link_name = "?_S_get_c_name@facet@locale@std@@KAPEBDXZ"]
    pub fn std_locale_facet__S_get_c_name() -> *const ::std::os::raw::c_char;
}
impl std_locale_facet {
    #[inline]
    pub unsafe fn _S_create_c_locale(__cloc: *mut std___c_locale,
                                     __s: *const ::std::os::raw::c_char,
                                     __old: std___c_locale) {
        std_locale_facet__S_create_c_locale(__cloc, __s, __old)
    }
    #[inline]
    pub unsafe fn _S_clone_c_locale(__cloc: *mut std___c_locale)
     -> std___c_locale {
        std_locale_facet__S_clone_c_locale(__cloc)
    }
    #[inline]
    pub unsafe fn _S_destroy_c_locale(__cloc: *mut std___c_locale) {
        std_locale_facet__S_destroy_c_locale(__cloc)
    }
    #[inline]
    pub unsafe fn _S_lc_ctype_c_locale(__cloc: std___c_locale,
                                       __s: *const ::std::os::raw::c_char)
     -> std___c_locale {
        std_locale_facet__S_lc_ctype_c_locale(__cloc, __s)
    }
    #[inline]
    pub unsafe fn _S_get_c_locale() -> std___c_locale {
        std_locale_facet__S_get_c_locale()
    }
    #[inline]
    pub unsafe fn _S_get_c_name() -> *const ::std::os::raw::c_char {
        std_locale_facet__S_get_c_name()
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct std_locale_id {
    pub _M_index: usize,
}
extern "C" {
    #[link_name = "?_S_refcount@id@locale@std@@0HA"]
    pub static mut std_locale_id__S_refcount: std__Atomic_word;
}
#[test]
fn bindgen_test_layout_std_locale_id() {
    assert_eq!(::std::mem::size_of::<std_locale_id>() , 8usize , concat ! (
               "Size of: " , stringify ! ( std_locale_id ) ));
    assert_eq! (::std::mem::align_of::<std_locale_id>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( std_locale_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const std_locale_id ) ) . _M_index as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( std_locale_id ) , "::"
                , stringify ! ( _M_index ) ));
}
extern "C" {
    #[link_name = "?_M_id@id@locale@std@@QEBA_KXZ"]
    pub fn std_locale_id__M_id(this: *const std_locale_id) -> usize;
}
impl Clone for std_locale_id {
    fn clone(&self) -> Self { *self }
}
impl std_locale_id {
    #[inline]
    pub unsafe fn _M_id(&self) -> usize { std_locale_id__M_id(self) }
}
#[repr(C)]
#[derive(Debug)]
pub struct std_locale__Impl {
    pub _M_refcount: std__Atomic_word,
    pub _M_facets: *mut *const std_locale_facet,
    pub _M_facets_size: usize,
    pub _M_caches: *mut *const std_locale_facet,
    pub _M_names: *mut *mut ::std::os::raw::c_char,
}
extern "C" {
    #[link_name = "?_S_id_ctype@_Impl@locale@std@@0QBQEBVid@23@B"]
    pub static mut std_locale__Impl__S_id_ctype:
               [*const std_locale_id; 0usize];
}
extern "C" {
    #[link_name = "?_S_id_numeric@_Impl@locale@std@@0QBQEBVid@23@B"]
    pub static mut std_locale__Impl__S_id_numeric:
               [*const std_locale_id; 0usize];
}
extern "C" {
    #[link_name = "?_S_id_collate@_Impl@locale@std@@0QBQEBVid@23@B"]
    pub static mut std_locale__Impl__S_id_collate:
               [*const std_locale_id; 0usize];
}
extern "C" {
    #[link_name = "?_S_id_time@_Impl@locale@std@@0QBQEBVid@23@B"]
    pub static mut std_locale__Impl__S_id_time:
               [*const std_locale_id; 0usize];
}
extern "C" {
    #[link_name = "?_S_id_monetary@_Impl@locale@std@@0QBQEBVid@23@B"]
    pub static mut std_locale__Impl__S_id_monetary:
               [*const std_locale_id; 0usize];
}
extern "C" {
    #[link_name = "?_S_id_messages@_Impl@locale@std@@0QBQEBVid@23@B"]
    pub static mut std_locale__Impl__S_id_messages:
               [*const std_locale_id; 0usize];
}
extern "C" {
    #[link_name = "?_S_facet_categories@_Impl@locale@std@@0QBQEBQEBVid@23@B"]
    pub static mut std_locale__Impl__S_facet_categories:
               [*const *const std_locale_id; 0usize];
}
#[test]
fn bindgen_test_layout_std_locale__Impl() {
    assert_eq!(::std::mem::size_of::<std_locale__Impl>() , 40usize , concat !
               ( "Size of: " , stringify ! ( std_locale__Impl ) ));
    assert_eq! (::std::mem::align_of::<std_locale__Impl>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( std_locale__Impl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const std_locale__Impl ) ) . _M_refcount as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( std_locale__Impl ) ,
                "::" , stringify ! ( _M_refcount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const std_locale__Impl ) ) . _M_facets as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( std_locale__Impl ) ,
                "::" , stringify ! ( _M_facets ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const std_locale__Impl ) ) . _M_facets_size as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( std_locale__Impl ) ,
                "::" , stringify ! ( _M_facets_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const std_locale__Impl ) ) . _M_caches as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( std_locale__Impl ) ,
                "::" , stringify ! ( _M_caches ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const std_locale__Impl ) ) . _M_names as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( std_locale__Impl ) ,
                "::" , stringify ! ( _M_names ) ));
}
pub const std_locale__S_categories_size: std_locale__bindgen_ty_1 =
    std_locale__bindgen_ty_1::_S_categories_size;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum std_locale__bindgen_ty_1 { _S_categories_size = 6, }
pub const std_locale_none: std_locale_category = 0;
pub const std_locale_ctype: std_locale_category = 1;
pub const std_locale_numeric: std_locale_category = 2;
pub const std_locale_collate: std_locale_category = 4;
pub const std_locale_time: std_locale_category = 8;
pub const std_locale_monetary: std_locale_category = 16;
pub const std_locale_messages: std_locale_category = 32;
pub const std_locale_all: std_locale_category = 63;
extern "C" {
    #[link_name = "?_S_classic@locale@std@@0PEAV_Impl@12@EA"]
    pub static mut std_locale__S_classic: *mut std_locale__Impl;
}
extern "C" {
    #[link_name = "?_S_global@locale@std@@0PEAV_Impl@12@EA"]
    pub static mut std_locale__S_global: *mut std_locale__Impl;
}
extern "C" {
    #[link_name = "?_S_categories@locale@std@@0QEBQEBDEB"]
    pub static std_locale__S_categories: *const *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "?_S_once@locale@std@@0U__gthread_once_t@@A"]
    pub static mut std_locale__S_once: std___gthread_once_t;
}
#[test]
fn bindgen_test_layout_std_locale() {
    assert_eq!(::std::mem::size_of::<std_locale>() , 8usize , concat ! (
               "Size of: " , stringify ! ( std_locale ) ));
    assert_eq! (::std::mem::align_of::<std_locale>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( std_locale ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const std_locale ) ) . _M_impl as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( std_locale ) , "::" ,
                stringify ! ( _M_impl ) ));
}
extern "C" {
    #[link_name =
          "?name@locale@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ"]
    pub fn std_locale_name(this: *const std_locale) -> std_string;
}
extern "C" {
    #[link_name = "?global@locale@std@@SA?AV12@AEBV12@@Z"]
    pub fn std_locale_global(__loc: *const std_locale) -> std_locale;
}
extern "C" {
    #[link_name = "?classic@locale@std@@SAAEBV12@XZ"]
    pub fn std_locale_classic() -> *const std_locale;
}
extern "C" {
    #[link_name = "??0locale@std@@QEAA@XZ"]
    pub fn std_locale_locale(this: *mut std_locale);
}
extern "C" {
    #[link_name = "??0locale@std@@QEAA@AEBV01@@Z"]
    pub fn std_locale_locale1(this: *mut std_locale,
                              __other: *const std_locale);
}
extern "C" {
    #[link_name = "??0locale@std@@QEAA@PEBD@Z"]
    pub fn std_locale_locale2(this: *mut std_locale,
                              __s: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "??0locale@std@@QEAA@AEBV01@PEBDH@Z"]
    pub fn std_locale_locale3(this: *mut std_locale,
                              __base: *const std_locale,
                              __s: *const ::std::os::raw::c_char,
                              __cat: std_locale_category);
}
extern "C" {
    #[link_name = "??0locale@std@@QEAA@AEBV01@0H@Z"]
    pub fn std_locale_locale4(this: *mut std_locale,
                              __base: *const std_locale,
                              __add: *const std_locale,
                              __cat: std_locale_category);
}
extern "C" {
    #[link_name = "??_Dlocale@std@@QEAA@XZ"]
    pub fn std_locale_locale_destructor(this: *mut std_locale);
}
impl std_locale {
    #[inline]
    pub unsafe fn name(&self) -> std_string { std_locale_name(self) }
    #[inline]
    pub unsafe fn global(__loc: *const std_locale) -> std_locale {
        std_locale_global(__loc)
    }
    #[inline]
    pub unsafe fn classic() -> *const std_locale { std_locale_classic() }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        std_locale_locale(&mut __bindgen_tmp);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(__other: *const std_locale) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        std_locale_locale1(&mut __bindgen_tmp, __other);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new2(__s: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        std_locale_locale2(&mut __bindgen_tmp, __s);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new3(__base: *const std_locale,
                       __s: *const ::std::os::raw::c_char,
                       __cat: std_locale_category) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        std_locale_locale3(&mut __bindgen_tmp, __base, __s, __cat);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new4(__base: *const std_locale, __add: *const std_locale,
                       __cat: std_locale_category) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        std_locale_locale4(&mut __bindgen_tmp, __base, __add, __cat);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn destruct(&mut self) { std_locale_locale_destructor(self) }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct std_ctype_base {
    pub _address: u8,
}
pub type std_ctype_base___to_type = *const ::std::os::raw::c_int;
pub type std_ctype_base_mask = ::std::os::raw::c_ushort;
pub const std_ctype_base_upper: std_ctype_base_mask = 1;
pub const std_ctype_base_lower: std_ctype_base_mask = 2;
pub const std_ctype_base_alpha: std_ctype_base_mask = 4;
pub const std_ctype_base_digit: std_ctype_base_mask = 8;
pub const std_ctype_base_xdigit: std_ctype_base_mask = 16;
pub const std_ctype_base_space: std_ctype_base_mask = 32;
pub const std_ctype_base_print: std_ctype_base_mask = 64;
pub const std_ctype_base_graph: std_ctype_base_mask = 524;
pub const std_ctype_base_cntrl: std_ctype_base_mask = 256;
pub const std_ctype_base_punct: std_ctype_base_mask = 512;
pub const std_ctype_base_alnum: std_ctype_base_mask = 12;
#[test]
fn bindgen_test_layout_std_ctype_base() {
    assert_eq!(::std::mem::size_of::<std_ctype_base>() , 1usize , concat ! (
               "Size of: " , stringify ! ( std_ctype_base ) ));
    assert_eq! (::std::mem::align_of::<std_ctype_base>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( std_ctype_base ) ));
}
impl Clone for std_ctype_base {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug)]
pub struct std_ctype {
    pub _base: std___ctype_abstract_base,
}
pub type std_ctype_char_type<_CharT> = _CharT;
pub type std_ctype_mask = std___ctype_abstract_base;
#[test]
fn __bindgen_test_layout_std_ctype_instantiation_7264() {
    assert_eq!(::std::mem::size_of::<std_ctype>() , 576usize , concat ! (
               "Size of template specialization: " , stringify ! ( std_ctype )
               ));
    assert_eq!(::std::mem::align_of::<std_ctype>() , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_ctype ) ));
}
#[test]
fn __bindgen_test_layout_std_ctype_instantiation_7268() {
    assert_eq!(::std::mem::size_of::<std_ctype>() , 736usize , concat ! (
               "Size of template specialization: " , stringify ! ( std_ctype )
               ));
    assert_eq!(::std::mem::align_of::<std_ctype>() , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_ctype ) ));
}
#[repr(C)]
#[derive(Debug)]
pub struct std_ctype_byname {
    pub _base: std_ctype,
}
pub type std_ctype_byname_mask = std_ctype;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_codecvt_base([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_codecvt {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_codecvt_byname {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug)]
pub struct std_num_get {
    pub _base: std_locale_facet,
}
pub type std_num_get_char_type<_CharT> = _CharT;
pub type std_num_get_iter_type<_InIter> = _InIter;
#[repr(C)]
#[derive(Debug)]
pub struct std_num_put {
    pub _base: std_locale_facet,
}
pub type std_num_put_char_type<_CharT> = _CharT;
pub type std_num_put_iter_type<_OutIter> = _OutIter;
#[repr(C)]
#[derive(Debug)]
pub struct std_numpunct<_CharT> {
    pub _base: std_locale_facet,
    pub _M_data: *mut std_numpunct___cache_type<_CharT>,
}
pub type std_numpunct_char_type<_CharT> = _CharT;
pub type std_numpunct_string_type = std_basic_string<_CharT, _Alloc>;
pub type std_numpunct___cache_type<_CharT> = std___numpunct_cache<_CharT>;
#[repr(C)]
#[derive(Debug)]
pub struct std_numpunct_byname<_CharT> {
    pub _base: std_numpunct<_CharT>,
}
pub type std_numpunct_byname_char_type<_CharT> = _CharT;
pub type std_numpunct_byname_string_type = std_basic_string<_CharT, _Alloc>;
#[repr(C)]
#[derive(Debug)]
pub struct std_collate {
    pub _base: std_locale_facet,
    pub _M_c_locale_collate: std___c_locale,
}
pub type std_collate_char_type<_CharT> = _CharT;
pub type std_collate_string_type = std_basic_string<_CharT, _Alloc>;
#[repr(C)]
#[derive(Debug)]
pub struct std_collate_byname {
    pub _base: std_collate,
}
pub type std_collate_byname_char_type<_CharT> = _CharT;
pub type std_collate_byname_string_type = std_basic_string<_CharT, _Alloc>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_time_base([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_time_get {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_time_get_byname {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_time_put {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_time_put_byname {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_money_base([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_money_get {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_money_put {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_messages_base([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_messages {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_messages_byname {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_unary_function {
    pub _address: u8,
}
pub type std_unary_function_argument_type<_Arg> = _Arg;
pub type std_unary_function_result_type<_Result> = _Result;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_binary_function {
    pub _address: u8,
}
pub type std_binary_function_first_argument_type<_Arg1> = _Arg1;
pub type std_binary_function_second_argument_type<_Arg2> = _Arg2;
pub type std_binary_function_result_type<_Result> = _Result;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_plus {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_minus {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_multiplies {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_divides {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_modulus {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_negate {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_equal_to {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_not_equal_to {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_greater {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_less {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_greater_equal {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_less_equal {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_logical_and {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_logical_or {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_logical_not {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_bit_and {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_bit_or {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_bit_xor {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_bit_not {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_unary_negate<_Predicate> {
    pub _M_pred: _Predicate,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_binary_negate<_Predicate> {
    pub _M_pred: _Predicate,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pointer_to_unary_function<_Arg, _Result> {
    pub _M_ptr: ::std::option::Option<unsafe extern "C" fn(arg1: _Arg)
                                          -> _Result>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pointer_to_binary_function<_Arg1, _Arg2, _Result> {
    pub _M_ptr: ::std::option::Option<unsafe extern "C" fn(arg1: _Arg1,
                                                           arg2: _Arg2)
                                          -> _Result>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Identity {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Select1st {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Select2nd {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_mem_fun_t<_Ret> {
    pub _M_f: ::std::option::Option<unsafe extern "C" fn() -> _Ret>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_const_mem_fun_t<_Ret> {
    pub _M_f: ::std::option::Option<unsafe extern "C" fn() -> _Ret>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_mem_fun_ref_t<_Ret> {
    pub _M_f: ::std::option::Option<unsafe extern "C" fn() -> _Ret>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_const_mem_fun_ref_t<_Ret> {
    pub _M_f: ::std::option::Option<unsafe extern "C" fn() -> _Ret>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_mem_fun1_t<_Ret, _Arg> {
    pub _M_f: ::std::option::Option<unsafe extern "C" fn(arg1: _Arg) -> _Ret>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_const_mem_fun1_t<_Ret, _Arg> {
    pub _M_f: ::std::option::Option<unsafe extern "C" fn(arg1: _Arg) -> _Ret>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_mem_fun1_ref_t<_Ret, _Arg> {
    pub _M_f: ::std::option::Option<unsafe extern "C" fn(arg1: _Arg) -> _Ret>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_const_mem_fun1_ref_t<_Ret, _Arg> {
    pub _M_f: ::std::option::Option<unsafe extern "C" fn(arg1: _Arg) -> _Ret>,
}
#[repr(C)]
pub struct std_binder1st<_Operation> {
    pub op: _Operation,
    pub value: [u8; 0usize],
}
#[repr(C)]
pub struct std_binder2nd<_Operation> {
    pub op: _Operation,
    pub value: [u8; 0usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_initializer_list<_E> {
    pub _M_array: std_initializer_list_iterator<_E>,
    pub _M_len: std_initializer_list_size_type,
}
pub type std_initializer_list_value_type<_E> = _E;
pub type std_initializer_list_reference<_E> = *mut _E;
pub type std_initializer_list_const_reference<_E> = *mut _E;
pub type std_initializer_list_size_type = usize;
pub type std_initializer_list_iterator<_E> = *mut _E;
pub type std_initializer_list_const_iterator<_E> = *mut _E;
extern "C" {
    #[link_name =
          "??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@AEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z"]
    pub fn std_getline(__in: *mut std_basic_istream<::std::os::raw::c_char>,
                       __str:
                           *mut std_basic_string<::std::os::raw::c_char,
                                                 std_allocator>,
                       __delim: ::std::os::raw::c_char)
     -> *mut std_basic_istream<::std::os::raw::c_char>;
}
extern "C" {
    #[link_name =
          "??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAEAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AEAV10@AEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z"]
    pub fn std_getline1(__in: *mut std_basic_istream<u16>,
                        __str: *mut std_basic_string<u16, std_allocator>,
                        __delim: u16) -> *mut std_basic_istream<u16>;
}
extern "C" {
    #[link_name = "?_Hash_bytes@std@@YA_KPEBX_K1@Z"]
    pub fn std__Hash_bytes(__ptr: *const ::std::os::raw::c_void, __len: usize,
                           __seed: usize) -> usize;
}
extern "C" {
    #[link_name = "?_Fnv_hash_bytes@std@@YA_KPEBX_K1@Z"]
    pub fn std__Fnv_hash_bytes(__ptr: *const ::std::os::raw::c_void,
                               __len: usize, __seed: usize) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___hash_base {
    pub _address: u8,
}
pub type std___hash_base_result_type<_Result> = _Result;
pub type std___hash_base_argument_type<_Arg> = _Arg;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_hash {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std_hash_instantiation_9327() {
    assert_eq!(::std::mem::size_of::<std_hash>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! ( std_hash )
               ));
    assert_eq!(::std::mem::align_of::<std_hash>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_hash ) ));
}
#[test]
fn __bindgen_test_layout_std_hash_instantiation_9331() {
    assert_eq!(::std::mem::size_of::<std_hash>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! ( std_hash )
               ));
    assert_eq!(::std::mem::align_of::<std_hash>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_hash ) ));
}
#[test]
fn __bindgen_test_layout_std_hash_instantiation_9335() {
    assert_eq!(::std::mem::size_of::<std_hash>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! ( std_hash )
               ));
    assert_eq!(::std::mem::align_of::<std_hash>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_hash ) ));
}
#[test]
fn __bindgen_test_layout_std_hash_instantiation_9339() {
    assert_eq!(::std::mem::size_of::<std_hash>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! ( std_hash )
               ));
    assert_eq!(::std::mem::align_of::<std_hash>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_hash ) ));
}
#[test]
fn __bindgen_test_layout_std_hash_instantiation_9343() {
    assert_eq!(::std::mem::size_of::<std_hash>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! ( std_hash )
               ));
    assert_eq!(::std::mem::align_of::<std_hash>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_hash ) ));
}
#[test]
fn __bindgen_test_layout_std_hash_instantiation_9347() {
    assert_eq!(::std::mem::size_of::<std_hash>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! ( std_hash )
               ));
    assert_eq!(::std::mem::align_of::<std_hash>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_hash ) ));
}
#[test]
fn __bindgen_test_layout_std_hash_instantiation_9351() {
    assert_eq!(::std::mem::size_of::<std_hash>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! ( std_hash )
               ));
    assert_eq!(::std::mem::align_of::<std_hash>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_hash ) ));
}
#[test]
fn __bindgen_test_layout_std_hash_instantiation_9355() {
    assert_eq!(::std::mem::size_of::<std_hash>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! ( std_hash )
               ));
    assert_eq!(::std::mem::align_of::<std_hash>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_hash ) ));
}
#[test]
fn __bindgen_test_layout_std_hash_instantiation_9359() {
    assert_eq!(::std::mem::size_of::<std_hash>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! ( std_hash )
               ));
    assert_eq!(::std::mem::align_of::<std_hash>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_hash ) ));
}
#[test]
fn __bindgen_test_layout_std_hash_instantiation_9363() {
    assert_eq!(::std::mem::size_of::<std_hash>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! ( std_hash )
               ));
    assert_eq!(::std::mem::align_of::<std_hash>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_hash ) ));
}
#[test]
fn __bindgen_test_layout_std_hash_instantiation_9367() {
    assert_eq!(::std::mem::size_of::<std_hash>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! ( std_hash )
               ));
    assert_eq!(::std::mem::align_of::<std_hash>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_hash ) ));
}
#[test]
fn __bindgen_test_layout_std_hash_instantiation_9371() {
    assert_eq!(::std::mem::size_of::<std_hash>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! ( std_hash )
               ));
    assert_eq!(::std::mem::align_of::<std_hash>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_hash ) ));
}
#[test]
fn __bindgen_test_layout_std_hash_instantiation_9375() {
    assert_eq!(::std::mem::size_of::<std_hash>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! ( std_hash )
               ));
    assert_eq!(::std::mem::align_of::<std_hash>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_hash ) ));
}
#[test]
fn __bindgen_test_layout_std_hash_instantiation_9379() {
    assert_eq!(::std::mem::size_of::<std_hash>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! ( std_hash )
               ));
    assert_eq!(::std::mem::align_of::<std_hash>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_hash ) ));
}
#[test]
fn __bindgen_test_layout_std_hash_instantiation_9383() {
    assert_eq!(::std::mem::size_of::<std_hash>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! ( std_hash )
               ));
    assert_eq!(::std::mem::align_of::<std_hash>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_hash ) ));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct std__Hash_impl {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std__Hash_impl() {
    assert_eq!(::std::mem::size_of::<std__Hash_impl>() , 1usize , concat ! (
               "Size of: " , stringify ! ( std__Hash_impl ) ));
    assert_eq! (::std::mem::align_of::<std__Hash_impl>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( std__Hash_impl ) ));
}
impl Clone for std__Hash_impl {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct std__Fnv_hash_impl {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std__Fnv_hash_impl() {
    assert_eq!(::std::mem::size_of::<std__Fnv_hash_impl>() , 1usize , concat !
               ( "Size of: " , stringify ! ( std__Fnv_hash_impl ) ));
    assert_eq! (::std::mem::align_of::<std__Fnv_hash_impl>() , 1usize , concat
                ! ( "Alignment of " , stringify ! ( std__Fnv_hash_impl ) ));
}
impl Clone for std__Fnv_hash_impl {
    fn clone(&self) -> Self { *self }
}
#[test]
fn __bindgen_test_layout_std_hash_instantiation_9399() {
    assert_eq!(::std::mem::size_of::<std_hash>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! ( std_hash )
               ));
    assert_eq!(::std::mem::align_of::<std_hash>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_hash ) ));
}
#[test]
fn __bindgen_test_layout_std_hash_instantiation_9403() {
    assert_eq!(::std::mem::size_of::<std_hash>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! ( std_hash )
               ));
    assert_eq!(::std::mem::align_of::<std_hash>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_hash ) ));
}
#[test]
fn __bindgen_test_layout_std_hash_instantiation_9407() {
    assert_eq!(::std::mem::size_of::<std_hash>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! ( std_hash )
               ));
    assert_eq!(::std::mem::align_of::<std_hash>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_hash ) ));
}
#[repr(C)]
pub struct std___is_fast_hash {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std___is_fast_hash_instantiation_9414() {
    assert_eq!(::std::mem::size_of::<std___is_fast_hash>() , 1usize , concat !
               (
               "Size of template specialization: " , stringify ! (
               std___is_fast_hash ) ));
    assert_eq!(::std::mem::align_of::<std___is_fast_hash>() , 1usize , concat
               ! (
               "Alignment of template specialization: " , stringify ! (
               std___is_fast_hash ) ));
}
#[test]
fn __bindgen_test_layout_std_hash_instantiation_9417() {
    assert_eq!(::std::mem::size_of::<std_hash>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! ( std_hash )
               ));
    assert_eq!(::std::mem::align_of::<std_hash>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_hash ) ));
}
#[test]
fn __bindgen_test_layout_std___is_fast_hash_instantiation_9420() {
    assert_eq!(::std::mem::size_of::<std___is_fast_hash>() , 1usize , concat !
               (
               "Size of template specialization: " , stringify ! (
               std___is_fast_hash ) ));
    assert_eq!(::std::mem::align_of::<std___is_fast_hash>() , 1usize , concat
               ! (
               "Alignment of template specialization: " , stringify ! (
               std___is_fast_hash ) ));
}
#[test]
fn __bindgen_test_layout_std_hash_instantiation_9423() {
    assert_eq!(::std::mem::size_of::<std_hash>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! ( std_hash )
               ));
    assert_eq!(::std::mem::align_of::<std_hash>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_hash ) ));
}
#[test]
fn __bindgen_test_layout_std___is_fast_hash_instantiation_9426() {
    assert_eq!(::std::mem::size_of::<std___is_fast_hash>() , 1usize , concat !
               (
               "Size of template specialization: " , stringify ! (
               std___is_fast_hash ) ));
    assert_eq!(::std::mem::align_of::<std___is_fast_hash>() , 1usize , concat
               ! (
               "Alignment of template specialization: " , stringify ! (
               std___is_fast_hash ) ));
}
#[test]
fn __bindgen_test_layout_std_hash_instantiation_9429() {
    assert_eq!(::std::mem::size_of::<std_hash>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! ( std_hash )
               ));
    assert_eq!(::std::mem::align_of::<std_hash>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_hash ) ));
}
#[test]
fn __bindgen_test_layout_std___is_fast_hash_instantiation_9432() {
    assert_eq!(::std::mem::size_of::<std___is_fast_hash>() , 1usize , concat !
               (
               "Size of template specialization: " , stringify ! (
               std___is_fast_hash ) ));
    assert_eq!(::std::mem::align_of::<std___is_fast_hash>() , 1usize , concat
               ! (
               "Alignment of template specialization: " , stringify ! (
               std___is_fast_hash ) ));
}
#[test]
fn __bindgen_test_layout_std_hash_instantiation_9435() {
    assert_eq!(::std::mem::size_of::<std_hash>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! ( std_hash )
               ));
    assert_eq!(::std::mem::align_of::<std_hash>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_hash ) ));
}
#[test]
fn __bindgen_test_layout_std___is_fast_hash_instantiation_9438() {
    assert_eq!(::std::mem::size_of::<std___is_fast_hash>() , 1usize , concat !
               (
               "Size of template specialization: " , stringify ! (
               std___is_fast_hash ) ));
    assert_eq!(::std::mem::align_of::<std___is_fast_hash>() , 1usize , concat
               ! (
               "Alignment of template specialization: " , stringify ! (
               std___is_fast_hash ) ));
}
extern "C" {
    #[link_name = "_S_max_size"]
    pub static std__S_max_size: std_basic_string_size_type;
}
extern "C" {
    #[link_name = "_S_terminal"]
    pub static std__S_terminal: _CharT;
}
extern "C" {
    #[link_name = "npos"]
    pub static std_npos: std_basic_string_size_type;
}
extern "C" {
    #[link_name = "_S_empty_rep_storage"]
    pub static mut std__S_empty_rep_storage: *mut std_basic_string_size_type;
}
#[test]
fn __bindgen_test_layout_std_basic_string_instantiation_9745() {
    assert_eq!(::std::mem::size_of::<std_basic_string<::std::os::raw::c_char,
                                       std_allocator>>()
               , 8usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std_basic_string<::std::os::raw::c_char, std_allocator> ) ));
    assert_eq!(::std::mem::align_of::<std_basic_string<::std::os::raw::c_char,
                                        std_allocator>>()
               , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_basic_string<::std::os::raw::c_char, std_allocator> ) ));
}
#[test]
fn __bindgen_test_layout_std_basic_string_instantiation_9751() {
    assert_eq!(::std::mem::size_of::<std_basic_string<u16, std_allocator>>() ,
               8usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std_basic_string<u16, std_allocator> ) ));
    assert_eq!(::std::mem::align_of::<std_basic_string<u16, std_allocator>>()
               , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_basic_string<u16, std_allocator> ) ));
}
pub type std_size_type = size_type;
pub type std_size_type = size_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_tuple_size {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std___pair_get_instantiation_10020() {
    assert_eq!(::std::mem::size_of::<u8>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! ( u8 ) ));
    assert_eq!(::std::mem::align_of::<u8>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! ( u8 )
               ));
}
#[test]
fn __bindgen_test_layout_std___pair_get_instantiation_10022() {
    assert_eq!(::std::mem::size_of::<u8>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! ( u8 ) ));
    assert_eq!(::std::mem::align_of::<u8>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! ( u8 )
               ));
}
#[test]
fn __bindgen_test_layout_std__Build_index_tuple_instantiation_10031() {
    assert_eq!(::std::mem::size_of::<u8>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! ( u8 ) ));
    assert_eq!(::std::mem::align_of::<u8>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! ( u8 )
               ));
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___alloctr_rebind_helper {
    pub _address: u8,
}
pub type std___alloctr_rebind_helper___type<_Alloc> = _Alloc;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits {
    pub _address: u8,
}
pub type std_allocator_traits_allocator_type<_Alloc> = _Alloc;
pub type std_allocator_traits_value_type = [u8; 0usize];
pub type std_allocator_traits___pointer<_Alloc> = _Alloc;
pub type std_allocator_traits_pointer<_Alloc> =
    std_allocator_traits___pointer<_Alloc>;
pub type std_allocator_traits___const_pointer<_Alloc> = _Alloc;
pub type std_allocator_traits_const_pointer<_Alloc> =
    std_allocator_traits___const_pointer<_Alloc>;
pub type std_allocator_traits___void_pointer<_Alloc> = _Alloc;
pub type std_allocator_traits_void_pointer<_Alloc> =
    std_allocator_traits___void_pointer<_Alloc>;
pub type std_allocator_traits___const_void_pointer<_Alloc> = _Alloc;
pub type std_allocator_traits_const_void_pointer<_Alloc> =
    std_allocator_traits___const_void_pointer<_Alloc>;
pub type std_allocator_traits___difference_type<_Alloc> = _Alloc;
pub type std_allocator_traits_difference_type<_Alloc> =
    std_allocator_traits___difference_type<_Alloc>;
pub type std_allocator_traits___size_type<_Alloc> = _Alloc;
pub type std_allocator_traits_size_type<_Alloc> =
    std_allocator_traits___size_type<_Alloc>;
pub type std_allocator_traits___propagate_on_container_copy_assignment<_Alloc>
    = _Alloc;
pub type std_allocator_traits_propagate_on_container_copy_assignment<_Alloc> =
    std_allocator_traits___propagate_on_container_copy_assignment<_Alloc>;
pub type std_allocator_traits___propagate_on_container_move_assignment<_Alloc>
    = _Alloc;
pub type std_allocator_traits_propagate_on_container_move_assignment<_Alloc> =
    std_allocator_traits___propagate_on_container_move_assignment<_Alloc>;
pub type std_allocator_traits___propagate_on_container_swap<_Alloc> = _Alloc;
pub type std_allocator_traits_propagate_on_container_swap<_Alloc> =
    std_allocator_traits___propagate_on_container_swap<_Alloc>;
pub type std_allocator_traits_rebind_alloc = u8;
pub type std_allocator_traits_rebind_traits = std_allocator_traits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits___allocate_helper {
    pub _address: u8,
}
pub type std_allocator_traits___allocate_helper_type<_Alloc> = _Alloc;
pub type std_allocator_traits___has_allocate =
    std_allocator_traits___allocate_helper;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits___construct_helper {
    pub _address: u8,
}
pub type std_allocator_traits___construct_helper_type<_Alloc> = _Alloc;
pub type std_allocator_traits___has_construct =
    std_allocator_traits___construct_helper;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits___destroy_helper {
    pub _address: u8,
}
pub type std_allocator_traits___destroy_helper_type<_Alloc> = _Alloc;
pub type std_allocator_traits___has_destroy =
    std_allocator_traits___destroy_helper;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits___maxsize_helper {
    pub _address: u8,
}
pub type std_allocator_traits___maxsize_helper_type<_Alloc2> = _Alloc2;
pub type std_allocator_traits___has_max_size =
    std_allocator_traits___maxsize_helper;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits___select_helper {
    pub _address: u8,
}
pub type std_allocator_traits___select_helper_type<_Alloc2> = _Alloc2;
pub type std_allocator_traits___has_soccc =
    std_allocator_traits___select_helper;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_copy_insertable_impl {
    pub _address: u8,
}
pub type std___is_copy_insertable_impl__Traits = std_allocator_traits;
pub type std___is_copy_insertable_impl_type<_Alloc> = _Alloc;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_copy_insertable {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std__Destroy_aux_instantiation_10368() {
    assert_eq!(::std::mem::size_of::<u8>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! ( u8 ) ));
    assert_eq!(::std::mem::align_of::<u8>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! ( u8 )
               ));
}
#[repr(C)]
#[derive(Debug)]
pub struct std__Temporary_buffer<_Tp> {
    pub _M_original_len: std__Temporary_buffer_size_type,
    pub _M_len: std__Temporary_buffer_size_type,
    pub _M_buffer: std__Temporary_buffer_pointer<_Tp>,
}
pub type std__Temporary_buffer_value_type<_Tp> = _Tp;
pub type std__Temporary_buffer_pointer<_Tp> =
    *mut std__Temporary_buffer_value_type<_Tp>;
pub type std__Temporary_buffer_iterator<_Tp> =
    std__Temporary_buffer_pointer<_Tp>;
pub type std__Temporary_buffer_size_type = isize;
#[test]
fn __bindgen_test_layout_std___uninitialized_construct_buf_dispatch_instantiation_10390() {
    assert_eq!(::std::mem::size_of::<u8>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! ( u8 ) ));
    assert_eq!(::std::mem::align_of::<u8>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! ( u8 )
               ));
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum std_float_round_style {
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum std_float_denorm_style {
    denorm_indeterminate = -1,
    denorm_absent = 0,
    denorm_present = 1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct std___numeric_limits_base {
    pub _address: u8,
}
pub const std___numeric_limits_base_is_specialized: bool = false;
pub const std___numeric_limits_base_digits: ::std::os::raw::c_int = 0;
pub const std___numeric_limits_base_digits10: ::std::os::raw::c_int = 0;
pub const std___numeric_limits_base_max_digits10: ::std::os::raw::c_int = 0;
pub const std___numeric_limits_base_is_signed: bool = false;
pub const std___numeric_limits_base_is_integer: bool = false;
pub const std___numeric_limits_base_is_exact: bool = false;
pub const std___numeric_limits_base_radix: ::std::os::raw::c_int = 0;
pub const std___numeric_limits_base_min_exponent: ::std::os::raw::c_int = 0;
pub const std___numeric_limits_base_min_exponent10: ::std::os::raw::c_int = 0;
pub const std___numeric_limits_base_max_exponent: ::std::os::raw::c_int = 0;
pub const std___numeric_limits_base_max_exponent10: ::std::os::raw::c_int = 0;
pub const std___numeric_limits_base_has_infinity: bool = false;
pub const std___numeric_limits_base_has_quiet_NaN: bool = false;
pub const std___numeric_limits_base_has_signaling_NaN: bool = false;
extern "C" {
    #[link_name =
          "?has_denorm@__numeric_limits_base@std@@2W4float_denorm_style@2@B"]
    pub static std___numeric_limits_base_has_denorm: std_float_denorm_style;
}
pub const std___numeric_limits_base_has_denorm_loss: bool = false;
pub const std___numeric_limits_base_is_iec559: bool = false;
pub const std___numeric_limits_base_is_bounded: bool = false;
pub const std___numeric_limits_base_is_modulo: bool = false;
pub const std___numeric_limits_base_traps: bool = false;
pub const std___numeric_limits_base_tinyness_before: bool = false;
extern "C" {
    #[link_name =
          "?round_style@__numeric_limits_base@std@@2W4float_round_style@2@B"]
    pub static std___numeric_limits_base_round_style: std_float_round_style;
}
#[test]
fn bindgen_test_layout_std___numeric_limits_base() {
    assert_eq!(::std::mem::size_of::<std___numeric_limits_base>() , 1usize ,
               concat ! (
               "Size of: " , stringify ! ( std___numeric_limits_base ) ));
    assert_eq! (::std::mem::align_of::<std___numeric_limits_base>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( std___numeric_limits_base )
                ));
}
impl Clone for std___numeric_limits_base {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_numeric_limits {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std_numeric_limits_instantiation_12903() {
    assert_eq!(::std::mem::size_of::<std_numeric_limits>() , 1usize , concat !
               (
               "Size of template specialization: " , stringify ! (
               std_numeric_limits ) ));
    assert_eq!(::std::mem::align_of::<std_numeric_limits>() , 1usize , concat
               ! (
               "Alignment of template specialization: " , stringify ! (
               std_numeric_limits ) ));
}
#[test]
fn __bindgen_test_layout_std_numeric_limits_instantiation_12907() {
    assert_eq!(::std::mem::size_of::<std_numeric_limits>() , 1usize , concat !
               (
               "Size of template specialization: " , stringify ! (
               std_numeric_limits ) ));
    assert_eq!(::std::mem::align_of::<std_numeric_limits>() , 1usize , concat
               ! (
               "Alignment of template specialization: " , stringify ! (
               std_numeric_limits ) ));
}
#[test]
fn __bindgen_test_layout_std_numeric_limits_instantiation_12911() {
    assert_eq!(::std::mem::size_of::<std_numeric_limits>() , 1usize , concat !
               (
               "Size of template specialization: " , stringify ! (
               std_numeric_limits ) ));
    assert_eq!(::std::mem::align_of::<std_numeric_limits>() , 1usize , concat
               ! (
               "Alignment of template specialization: " , stringify ! (
               std_numeric_limits ) ));
}
#[test]
fn __bindgen_test_layout_std_numeric_limits_instantiation_12915() {
    assert_eq!(::std::mem::size_of::<std_numeric_limits>() , 1usize , concat !
               (
               "Size of template specialization: " , stringify ! (
               std_numeric_limits ) ));
    assert_eq!(::std::mem::align_of::<std_numeric_limits>() , 1usize , concat
               ! (
               "Alignment of template specialization: " , stringify ! (
               std_numeric_limits ) ));
}
#[test]
fn __bindgen_test_layout_std_numeric_limits_instantiation_12919() {
    assert_eq!(::std::mem::size_of::<std_numeric_limits>() , 1usize , concat !
               (
               "Size of template specialization: " , stringify ! (
               std_numeric_limits ) ));
    assert_eq!(::std::mem::align_of::<std_numeric_limits>() , 1usize , concat
               ! (
               "Alignment of template specialization: " , stringify ! (
               std_numeric_limits ) ));
}
#[test]
fn __bindgen_test_layout_std_numeric_limits_instantiation_12923() {
    assert_eq!(::std::mem::size_of::<std_numeric_limits>() , 1usize , concat !
               (
               "Size of template specialization: " , stringify ! (
               std_numeric_limits ) ));
    assert_eq!(::std::mem::align_of::<std_numeric_limits>() , 1usize , concat
               ! (
               "Alignment of template specialization: " , stringify ! (
               std_numeric_limits ) ));
}
#[test]
fn __bindgen_test_layout_std_numeric_limits_instantiation_12927() {
    assert_eq!(::std::mem::size_of::<std_numeric_limits>() , 1usize , concat !
               (
               "Size of template specialization: " , stringify ! (
               std_numeric_limits ) ));
    assert_eq!(::std::mem::align_of::<std_numeric_limits>() , 1usize , concat
               ! (
               "Alignment of template specialization: " , stringify ! (
               std_numeric_limits ) ));
}
#[test]
fn __bindgen_test_layout_std_numeric_limits_instantiation_12931() {
    assert_eq!(::std::mem::size_of::<std_numeric_limits>() , 1usize , concat !
               (
               "Size of template specialization: " , stringify ! (
               std_numeric_limits ) ));
    assert_eq!(::std::mem::align_of::<std_numeric_limits>() , 1usize , concat
               ! (
               "Alignment of template specialization: " , stringify ! (
               std_numeric_limits ) ));
}
#[test]
fn __bindgen_test_layout_std_numeric_limits_instantiation_12935() {
    assert_eq!(::std::mem::size_of::<std_numeric_limits>() , 1usize , concat !
               (
               "Size of template specialization: " , stringify ! (
               std_numeric_limits ) ));
    assert_eq!(::std::mem::align_of::<std_numeric_limits>() , 1usize , concat
               ! (
               "Alignment of template specialization: " , stringify ! (
               std_numeric_limits ) ));
}
#[test]
fn __bindgen_test_layout_std_numeric_limits_instantiation_12939() {
    assert_eq!(::std::mem::size_of::<std_numeric_limits>() , 1usize , concat !
               (
               "Size of template specialization: " , stringify ! (
               std_numeric_limits ) ));
    assert_eq!(::std::mem::align_of::<std_numeric_limits>() , 1usize , concat
               ! (
               "Alignment of template specialization: " , stringify ! (
               std_numeric_limits ) ));
}
#[test]
fn __bindgen_test_layout_std_numeric_limits_instantiation_12943() {
    assert_eq!(::std::mem::size_of::<std_numeric_limits>() , 1usize , concat !
               (
               "Size of template specialization: " , stringify ! (
               std_numeric_limits ) ));
    assert_eq!(::std::mem::align_of::<std_numeric_limits>() , 1usize , concat
               ! (
               "Alignment of template specialization: " , stringify ! (
               std_numeric_limits ) ));
}
#[test]
fn __bindgen_test_layout_std_numeric_limits_instantiation_12947() {
    assert_eq!(::std::mem::size_of::<std_numeric_limits>() , 1usize , concat !
               (
               "Size of template specialization: " , stringify ! (
               std_numeric_limits ) ));
    assert_eq!(::std::mem::align_of::<std_numeric_limits>() , 1usize , concat
               ! (
               "Alignment of template specialization: " , stringify ! (
               std_numeric_limits ) ));
}
#[test]
fn __bindgen_test_layout_std_numeric_limits_instantiation_12951() {
    assert_eq!(::std::mem::size_of::<std_numeric_limits>() , 1usize , concat !
               (
               "Size of template specialization: " , stringify ! (
               std_numeric_limits ) ));
    assert_eq!(::std::mem::align_of::<std_numeric_limits>() , 1usize , concat
               ! (
               "Alignment of template specialization: " , stringify ! (
               std_numeric_limits ) ));
}
#[test]
fn __bindgen_test_layout_std_numeric_limits_instantiation_12955() {
    assert_eq!(::std::mem::size_of::<std_numeric_limits>() , 1usize , concat !
               (
               "Size of template specialization: " , stringify ! (
               std_numeric_limits ) ));
    assert_eq!(::std::mem::align_of::<std_numeric_limits>() , 1usize , concat
               ! (
               "Alignment of template specialization: " , stringify ! (
               std_numeric_limits ) ));
}
#[test]
fn __bindgen_test_layout_std_numeric_limits_instantiation_12959() {
    assert_eq!(::std::mem::size_of::<std_numeric_limits>() , 1usize , concat !
               (
               "Size of template specialization: " , stringify ! (
               std_numeric_limits ) ));
    assert_eq!(::std::mem::align_of::<std_numeric_limits>() , 1usize , concat
               ! (
               "Alignment of template specialization: " , stringify ! (
               std_numeric_limits ) ));
}
#[test]
fn __bindgen_test_layout_std_numeric_limits_instantiation_12963() {
    assert_eq!(::std::mem::size_of::<std_numeric_limits>() , 1usize , concat !
               (
               "Size of template specialization: " , stringify ! (
               std_numeric_limits ) ));
    assert_eq!(::std::mem::align_of::<std_numeric_limits>() , 1usize , concat
               ! (
               "Alignment of template specialization: " , stringify ! (
               std_numeric_limits ) ));
}
#[test]
fn __bindgen_test_layout_std_numeric_limits_instantiation_12967() {
    assert_eq!(::std::mem::size_of::<std_numeric_limits>() , 1usize , concat !
               (
               "Size of template specialization: " , stringify ! (
               std_numeric_limits ) ));
    assert_eq!(::std::mem::align_of::<std_numeric_limits>() , 1usize , concat
               ! (
               "Alignment of template specialization: " , stringify ! (
               std_numeric_limits ) ));
}
#[test]
fn __bindgen_test_layout_std_numeric_limits_instantiation_12971() {
    assert_eq!(::std::mem::size_of::<std_numeric_limits>() , 1usize , concat !
               (
               "Size of template specialization: " , stringify ! (
               std_numeric_limits ) ));
    assert_eq!(::std::mem::align_of::<std_numeric_limits>() , 1usize , concat
               ! (
               "Alignment of template specialization: " , stringify ! (
               std_numeric_limits ) ));
}
#[test]
fn __bindgen_test_layout_std___uninitialized_copy_instantiation_12976() {
    assert_eq!(::std::mem::size_of::<u8>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! ( u8 ) ));
    assert_eq!(::std::mem::align_of::<u8>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! ( u8 )
               ));
}
#[test]
fn __bindgen_test_layout_std___uninitialized_fill_instantiation_12980() {
    assert_eq!(::std::mem::size_of::<u8>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! ( u8 ) ));
    assert_eq!(::std::mem::align_of::<u8>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! ( u8 )
               ));
}
#[test]
fn __bindgen_test_layout_std___uninitialized_fill_n_instantiation_12984() {
    assert_eq!(::std::mem::size_of::<u8>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! ( u8 ) ));
    assert_eq!(::std::mem::align_of::<u8>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! ( u8 )
               ));
}
#[test]
fn __bindgen_test_layout_std___uninitialized_default_1_instantiation_13000() {
    assert_eq!(::std::mem::size_of::<u8>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! ( u8 ) ));
    assert_eq!(::std::mem::align_of::<u8>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! ( u8 )
               ));
}
#[test]
fn __bindgen_test_layout_std___uninitialized_default_n_1_instantiation_13003() {
    assert_eq!(::std::mem::size_of::<u8>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! ( u8 ) ));
    assert_eq!(::std::mem::align_of::<u8>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! ( u8 )
               ));
}
#[repr(C)]
#[derive(Debug)]
pub struct std__Vector_base {
    pub _M_impl: std__Vector_base__Vector_impl,
}
pub type std__Vector_base__Tp_alloc_type = __gnu_cxx___alloc_traits;
pub type std__Vector_base_pointer = __gnu_cxx___alloc_traits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Vector_base__Vector_impl {
    pub _M_start: std__Vector_base_pointer,
    pub _M_finish: std__Vector_base_pointer,
    pub _M_end_of_storage: std__Vector_base_pointer,
}
pub type std__Vector_base_allocator_type<_Alloc> = _Alloc;
#[repr(C)]
#[derive(Debug)]
pub struct std_vector {
    pub _base: std__Vector_base,
}
pub type std_vector__Alloc_value_type = [u8; 0usize];
pub type std_vector__Base = std__Vector_base;
pub type std_vector__Tp_alloc_type = std_vector__Base;
pub type std_vector__Alloc_traits = __gnu_cxx___alloc_traits;
pub type std_vector_value_type<_Tp> = _Tp;
pub type std_vector_pointer = std_vector__Base;
pub type std_vector_const_pointer = std_vector__Alloc_traits;
pub type std_vector_reference = std_vector__Alloc_traits;
pub type std_vector_const_reference = std_vector__Alloc_traits;
pub type std_vector_iterator =
    __gnu_cxx___normal_iterator<std_vector_pointer>;
pub type std_vector_const_iterator =
    __gnu_cxx___normal_iterator<std_vector_const_pointer>;
pub type std_vector_const_reverse_iterator =
    std_reverse_iterator<std_vector_const_iterator>;
pub type std_vector_reverse_iterator =
    std_reverse_iterator<std_vector_iterator>;
pub type std_vector_size_type = usize;
pub type std_vector_difference_type = isize;
pub type std_vector_allocator_type<_Alloc> = _Alloc;
pub type std__Bit_type = ::std::os::raw::c_ulong;
pub const _S_word_bit: std__bindgen_ty_1 = std__bindgen_ty_1::_S_word_bit;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum std__bindgen_ty_1 { _S_word_bit = 32, }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct std__Bit_reference {
    pub _M_p: *mut std__Bit_type,
    pub _M_mask: std__Bit_type,
}
#[test]
fn bindgen_test_layout_std__Bit_reference() {
    assert_eq!(::std::mem::size_of::<std__Bit_reference>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( std__Bit_reference ) ));
    assert_eq! (::std::mem::align_of::<std__Bit_reference>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( std__Bit_reference ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const std__Bit_reference ) ) . _M_p as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( std__Bit_reference ) ,
                "::" , stringify ! ( _M_p ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const std__Bit_reference ) ) . _M_mask as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( std__Bit_reference ) ,
                "::" , stringify ! ( _M_mask ) ));
}
impl Clone for std__Bit_reference {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct std__Bit_iterator_base {
    pub _M_p: *mut std__Bit_type,
    pub _M_offset: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_std__Bit_iterator_base() {
    assert_eq!(::std::mem::size_of::<std__Bit_iterator_base>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( std__Bit_iterator_base )
               ));
    assert_eq! (::std::mem::align_of::<std__Bit_iterator_base>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( std__Bit_iterator_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const std__Bit_iterator_base ) ) . _M_p as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( std__Bit_iterator_base
                ) , "::" , stringify ! ( _M_p ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const std__Bit_iterator_base ) ) . _M_offset as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( std__Bit_iterator_base
                ) , "::" , stringify ! ( _M_offset ) ));
}
impl Clone for std__Bit_iterator_base {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct std__Bit_iterator {
    pub _base: std__Bit_iterator_base,
}
pub type std__Bit_iterator_reference = std__Bit_reference;
pub type std__Bit_iterator_pointer = *mut std__Bit_reference;
pub type std__Bit_iterator_iterator = std__Bit_iterator;
#[test]
fn bindgen_test_layout_std__Bit_iterator() {
    assert_eq!(::std::mem::size_of::<std__Bit_iterator>() , 16usize , concat !
               ( "Size of: " , stringify ! ( std__Bit_iterator ) ));
    assert_eq! (::std::mem::align_of::<std__Bit_iterator>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( std__Bit_iterator ) ));
}
impl Clone for std__Bit_iterator {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct std__Bit_const_iterator {
    pub _base: std__Bit_iterator_base,
}
pub type std__Bit_const_iterator_reference = bool;
pub type std__Bit_const_iterator_const_reference = bool;
pub type std__Bit_const_iterator_pointer = *const bool;
pub type std__Bit_const_iterator_const_iterator = std__Bit_const_iterator;
#[test]
fn bindgen_test_layout_std__Bit_const_iterator() {
    assert_eq!(::std::mem::size_of::<std__Bit_const_iterator>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( std__Bit_const_iterator ) ));
    assert_eq! (::std::mem::align_of::<std__Bit_const_iterator>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( std__Bit_const_iterator ) ));
}
impl Clone for std__Bit_const_iterator {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct std__Bvector_base {
    pub _M_impl: std__Bvector_base__Bvector_impl,
}
pub type std__Bvector_base__Bit_alloc_type = [u8; 0usize];
#[repr(C)]
pub struct std__Bvector_base__Bvector_impl {
    pub _M_start: std__Bit_iterator,
    pub _M_finish: std__Bit_iterator,
    pub _M_end_of_storage: *mut std__Bit_type,
}
pub type std__Bvector_base_allocator_type<_Alloc> = _Alloc;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail__Adaptor<_Engine> {
    pub _M_g: *mut _Engine,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct std___detail__List_node_base {
    pub _M_next: *mut std___detail__List_node_base,
    pub _M_prev: *mut std___detail__List_node_base,
}
#[test]
fn bindgen_test_layout_std___detail__List_node_base() {
    assert_eq!(::std::mem::size_of::<std___detail__List_node_base>() , 16usize
               , concat ! (
               "Size of: " , stringify ! ( std___detail__List_node_base ) ));
    assert_eq! (::std::mem::align_of::<std___detail__List_node_base>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( std___detail__List_node_base )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const std___detail__List_node_base ) ) .
                _M_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                std___detail__List_node_base ) , "::" , stringify ! ( _M_next
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const std___detail__List_node_base ) ) .
                _M_prev as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                std___detail__List_node_base ) , "::" , stringify ! ( _M_prev
                ) ));
}
extern "C" {
    #[link_name = "?swap@_List_node_base@__detail@std@@SAXAEAU123@0@Z"]
    pub fn std___detail__List_node_base_swap(__x:
                                                 *mut std___detail__List_node_base,
                                             __y:
                                                 *mut std___detail__List_node_base);
}
extern "C" {
    #[link_name =
          "?_M_transfer@_List_node_base@__detail@std@@QEAAXQEAU123@0@Z"]
    pub fn std___detail__List_node_base__M_transfer(this:
                                                        *mut std___detail__List_node_base,
                                                    __first:
                                                        *const std___detail__List_node_base,
                                                    __last:
                                                        *const std___detail__List_node_base);
}
extern "C" {
    #[link_name = "?_M_reverse@_List_node_base@__detail@std@@QEAAXXZ"]
    pub fn std___detail__List_node_base__M_reverse(this:
                                                       *mut std___detail__List_node_base);
}
extern "C" {
    #[link_name = "?_M_hook@_List_node_base@__detail@std@@QEAAXQEAU123@@Z"]
    pub fn std___detail__List_node_base__M_hook(this:
                                                    *mut std___detail__List_node_base,
                                                __position:
                                                    *const std___detail__List_node_base);
}
extern "C" {
    #[link_name = "?_M_unhook@_List_node_base@__detail@std@@QEAAXXZ"]
    pub fn std___detail__List_node_base__M_unhook(this:
                                                      *mut std___detail__List_node_base);
}
impl Clone for std___detail__List_node_base {
    fn clone(&self) -> Self { *self }
}
impl std___detail__List_node_base {
    #[inline]
    pub unsafe fn swap(__x: *mut std___detail__List_node_base,
                       __y: *mut std___detail__List_node_base) {
        std___detail__List_node_base_swap(__x, __y)
    }
    #[inline]
    pub unsafe fn _M_transfer(&mut self,
                              __first: *const std___detail__List_node_base,
                              __last: *const std___detail__List_node_base) {
        std___detail__List_node_base__M_transfer(self, __first, __last)
    }
    #[inline]
    pub unsafe fn _M_reverse(&mut self) {
        std___detail__List_node_base__M_reverse(self)
    }
    #[inline]
    pub unsafe fn _M_hook(&mut self,
                          __position: *const std___detail__List_node_base) {
        std___detail__List_node_base__M_hook(self, __position)
    }
    #[inline]
    pub unsafe fn _M_unhook(&mut self) {
        std___detail__List_node_base__M_unhook(self)
    }
}
pub type std_minstd_rand0 = u8;
pub type std_minstd_rand = u8;
pub type std_mt19937 = [u64; 313usize];
pub type std_mt19937_64 = u8;
pub type std_ranlux24_base = u8;
pub type std_ranlux48_base = u8;
pub type std_ranlux24 = u8;
pub type std_ranlux48 = u8;
pub type std_knuth_b = u8;
pub type std_default_random_engine = std_minstd_rand0;
#[repr(C)]
pub struct std_random_device {
    pub __bindgen_anon_1: std_random_device__bindgen_ty_1,
}
pub type std_random_device_result_type = ::std::os::raw::c_uint;
#[repr(C)]
pub union std_random_device__bindgen_ty_1 {
    pub _M_file: *mut ::std::os::raw::c_void,
    pub _M_mt: std_mt19937,
}
#[test]
fn bindgen_test_layout_std_random_device__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<std_random_device__bindgen_ty_1>() ,
               2504usize , concat ! (
               "Size of: " , stringify ! ( std_random_device__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<std_random_device__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                std_random_device__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const std_random_device__bindgen_ty_1 ) ) .
                _M_file as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                std_random_device__bindgen_ty_1 ) , "::" , stringify ! (
                _M_file ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const std_random_device__bindgen_ty_1 ) ) .
                _M_mt as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                std_random_device__bindgen_ty_1 ) , "::" , stringify ! ( _M_mt
                ) ));
}
#[test]
fn bindgen_test_layout_std_random_device() {
    assert_eq!(::std::mem::size_of::<std_random_device>() , 2504usize , concat
               ! ( "Size of: " , stringify ! ( std_random_device ) ));
    assert_eq! (::std::mem::align_of::<std_random_device>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( std_random_device ) ));
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_uniform_int_distribution<_IntType> {
    pub _M_param: std_uniform_int_distribution_param_type<_IntType>,
}
pub type std_uniform_int_distribution_result_type<_IntType> = _IntType;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_uniform_int_distribution_param_type<_IntType> {
    pub _M_a: _IntType,
    pub _M_b: _IntType,
}
pub type std_uniform_int_distribution_param_type_distribution_type<_IntType> =
    std_uniform_int_distribution<_IntType>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_uniform_real_distribution<_RealType> {
    pub _M_param: std_uniform_real_distribution_param_type<_RealType>,
}
pub type std_uniform_real_distribution_result_type<_RealType> = _RealType;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_uniform_real_distribution_param_type<_RealType> {
    pub _M_a: _RealType,
    pub _M_b: _RealType,
}
pub type std_uniform_real_distribution_param_type_distribution_type<_RealType>
    = std_uniform_real_distribution<_RealType>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_normal_distribution<_RealType> {
    pub _M_param: std_normal_distribution_param_type<_RealType>,
    pub _M_saved: std_normal_distribution_result_type<_RealType>,
    pub _M_saved_available: bool,
}
pub type std_normal_distribution_result_type<_RealType> = _RealType;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_normal_distribution_param_type<_RealType> {
    pub _M_mean: _RealType,
    pub _M_stddev: _RealType,
}
pub type std_normal_distribution_param_type_distribution_type<_RealType> =
    std_normal_distribution<_RealType>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_lognormal_distribution<_RealType> {
    pub _M_param: std_lognormal_distribution_param_type<_RealType>,
    pub _M_nd: std_normal_distribution<std_lognormal_distribution_result_type<_RealType>>,
}
pub type std_lognormal_distribution_result_type<_RealType> = _RealType;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_lognormal_distribution_param_type<_RealType> {
    pub _M_m: _RealType,
    pub _M_s: _RealType,
}
pub type std_lognormal_distribution_param_type_distribution_type<_RealType> =
    std_lognormal_distribution<_RealType>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_gamma_distribution<_RealType> {
    pub _M_param: std_gamma_distribution_param_type<_RealType>,
    pub _M_nd: std_normal_distribution<std_gamma_distribution_result_type<_RealType>>,
}
pub type std_gamma_distribution_result_type<_RealType> = _RealType;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_gamma_distribution_param_type<_RealType> {
    pub _M_alpha: _RealType,
    pub _M_beta: _RealType,
    pub _M_malpha: _RealType,
    pub _M_a2: _RealType,
}
pub type std_gamma_distribution_param_type_distribution_type<_RealType> =
    std_gamma_distribution<_RealType>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_chi_squared_distribution<_RealType> {
    pub _M_param: std_chi_squared_distribution_param_type<_RealType>,
    pub _M_gd: std_gamma_distribution<std_chi_squared_distribution_result_type<_RealType>>,
}
pub type std_chi_squared_distribution_result_type<_RealType> = _RealType;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_chi_squared_distribution_param_type<_RealType> {
    pub _M_n: _RealType,
}
pub type std_chi_squared_distribution_param_type_distribution_type<_RealType>
    = std_chi_squared_distribution<_RealType>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_cauchy_distribution<_RealType> {
    pub _M_param: std_cauchy_distribution_param_type<_RealType>,
}
pub type std_cauchy_distribution_result_type<_RealType> = _RealType;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_cauchy_distribution_param_type<_RealType> {
    pub _M_a: _RealType,
    pub _M_b: _RealType,
}
pub type std_cauchy_distribution_param_type_distribution_type<_RealType> =
    std_cauchy_distribution<_RealType>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_fisher_f_distribution<_RealType> {
    pub _M_param: std_fisher_f_distribution_param_type<_RealType>,
    pub _M_gd_x: std_gamma_distribution<std_fisher_f_distribution_result_type<_RealType>>,
    pub _M_gd_y: std_gamma_distribution<std_fisher_f_distribution_result_type<_RealType>>,
}
pub type std_fisher_f_distribution_result_type<_RealType> = _RealType;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_fisher_f_distribution_param_type<_RealType> {
    pub _M_m: _RealType,
    pub _M_n: _RealType,
}
pub type std_fisher_f_distribution_param_type_distribution_type<_RealType> =
    std_fisher_f_distribution<_RealType>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_student_t_distribution<_RealType> {
    pub _M_param: std_student_t_distribution_param_type<_RealType>,
    pub _M_nd: std_normal_distribution<std_student_t_distribution_result_type<_RealType>>,
    pub _M_gd: std_gamma_distribution<std_student_t_distribution_result_type<_RealType>>,
}
pub type std_student_t_distribution_result_type<_RealType> = _RealType;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_student_t_distribution_param_type<_RealType> {
    pub _M_n: _RealType,
}
pub type std_student_t_distribution_param_type_distribution_type<_RealType> =
    std_student_t_distribution<_RealType>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct std_bernoulli_distribution {
    pub _M_param: std_bernoulli_distribution_param_type,
}
pub type std_bernoulli_distribution_result_type = bool;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct std_bernoulli_distribution_param_type {
    pub _M_p: f64,
}
pub type std_bernoulli_distribution_param_type_distribution_type =
    std_bernoulli_distribution;
#[test]
fn bindgen_test_layout_std_bernoulli_distribution_param_type() {
    assert_eq!(::std::mem::size_of::<std_bernoulli_distribution_param_type>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               std_bernoulli_distribution_param_type ) ));
    assert_eq! (::std::mem::align_of::<std_bernoulli_distribution_param_type>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                std_bernoulli_distribution_param_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const std_bernoulli_distribution_param_type ) )
                . _M_p as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                std_bernoulli_distribution_param_type ) , "::" , stringify ! (
                _M_p ) ));
}
impl Clone for std_bernoulli_distribution_param_type {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_std_bernoulli_distribution() {
    assert_eq!(::std::mem::size_of::<std_bernoulli_distribution>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( std_bernoulli_distribution ) ));
    assert_eq! (::std::mem::align_of::<std_bernoulli_distribution>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( std_bernoulli_distribution )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const std_bernoulli_distribution ) ) . _M_param
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                std_bernoulli_distribution ) , "::" , stringify ! ( _M_param )
                ));
}
impl Clone for std_bernoulli_distribution {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_binomial_distribution<_IntType> {
    pub _M_param: std_binomial_distribution_param_type<_IntType>,
    pub _M_nd: std_normal_distribution<f64>,
}
pub type std_binomial_distribution_result_type<_IntType> = _IntType;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_binomial_distribution_param_type<_IntType> {
    pub _M_t: _IntType,
    pub _M_p: f64,
    pub _M_q: f64,
    pub _M_d1: f64,
    pub _M_d2: f64,
    pub _M_s1: f64,
    pub _M_s2: f64,
    pub _M_c: f64,
    pub _M_a1: f64,
    pub _M_a123: f64,
    pub _M_s: f64,
    pub _M_lf: f64,
    pub _M_lp1p: f64,
    pub _M_easy: bool,
}
pub type std_binomial_distribution_param_type_distribution_type<_IntType> =
    std_binomial_distribution<_IntType>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_geometric_distribution {
    pub _M_param: std_geometric_distribution_param_type,
}
pub type std_geometric_distribution_result_type<_IntType> = _IntType;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_geometric_distribution_param_type {
    pub _M_p: f64,
    pub _M_log_1_p: f64,
}
pub type std_geometric_distribution_param_type_distribution_type =
    std_geometric_distribution;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_negative_binomial_distribution<_IntType> {
    pub _M_param: std_negative_binomial_distribution_param_type<_IntType>,
    pub _M_gd: std_gamma_distribution<f64>,
}
pub type std_negative_binomial_distribution_result_type<_IntType> = _IntType;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_negative_binomial_distribution_param_type<_IntType> {
    pub _M_k: _IntType,
    pub _M_p: f64,
}
pub type std_negative_binomial_distribution_param_type_distribution_type<_IntType>
    = std_negative_binomial_distribution<_IntType>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_poisson_distribution {
    pub _M_param: std_poisson_distribution_param_type,
    pub _M_nd: std_normal_distribution<f64>,
}
pub type std_poisson_distribution_result_type<_IntType> = _IntType;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_poisson_distribution_param_type {
    pub _M_mean: f64,
    pub _M_lm_thr: f64,
    pub _M_lfm: f64,
    pub _M_sm: f64,
    pub _M_d: f64,
    pub _M_scx: f64,
    pub _M_1cx: f64,
    pub _M_c2b: f64,
    pub _M_cb: f64,
}
pub type std_poisson_distribution_param_type_distribution_type =
    std_poisson_distribution;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_exponential_distribution<_RealType> {
    pub _M_param: std_exponential_distribution_param_type<_RealType>,
}
pub type std_exponential_distribution_result_type<_RealType> = _RealType;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_exponential_distribution_param_type<_RealType> {
    pub _M_lambda: _RealType,
}
pub type std_exponential_distribution_param_type_distribution_type<_RealType>
    = std_exponential_distribution<_RealType>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_weibull_distribution<_RealType> {
    pub _M_param: std_weibull_distribution_param_type<_RealType>,
}
pub type std_weibull_distribution_result_type<_RealType> = _RealType;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_weibull_distribution_param_type<_RealType> {
    pub _M_a: _RealType,
    pub _M_b: _RealType,
}
pub type std_weibull_distribution_param_type_distribution_type<_RealType> =
    std_weibull_distribution<_RealType>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_extreme_value_distribution<_RealType> {
    pub _M_param: std_extreme_value_distribution_param_type<_RealType>,
}
pub type std_extreme_value_distribution_result_type<_RealType> = _RealType;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_extreme_value_distribution_param_type<_RealType> {
    pub _M_a: _RealType,
    pub _M_b: _RealType,
}
pub type std_extreme_value_distribution_param_type_distribution_type<_RealType>
    = std_extreme_value_distribution<_RealType>;
#[repr(C)]
#[derive(Debug)]
pub struct std_discrete_distribution {
    pub _M_param: std_discrete_distribution_param_type,
}
pub type std_discrete_distribution_result_type<_IntType> = _IntType;
#[repr(C)]
#[derive(Debug)]
pub struct std_discrete_distribution_param_type {
    pub _M_prob: std_vector,
    pub _M_cp: std_vector,
}
pub type std_discrete_distribution_param_type_distribution_type =
    std_discrete_distribution;
#[repr(C)]
#[derive(Debug)]
pub struct std_piecewise_constant_distribution {
    pub _M_param: std_piecewise_constant_distribution_param_type,
}
pub type std_piecewise_constant_distribution_result_type<_RealType> =
    _RealType;
#[repr(C)]
#[derive(Debug)]
pub struct std_piecewise_constant_distribution_param_type {
    pub _M_int: std_vector,
    pub _M_den: std_vector,
    pub _M_cp: std_vector,
}
pub type std_piecewise_constant_distribution_param_type_distribution_type =
    std_piecewise_constant_distribution;
#[repr(C)]
#[derive(Debug)]
pub struct std_piecewise_linear_distribution {
    pub _M_param: std_piecewise_linear_distribution_param_type,
}
pub type std_piecewise_linear_distribution_result_type<_RealType> = _RealType;
#[repr(C)]
#[derive(Debug)]
pub struct std_piecewise_linear_distribution_param_type {
    pub _M_int: std_vector,
    pub _M_den: std_vector,
    pub _M_cp: std_vector,
    pub _M_m: std_vector,
}
pub type std_piecewise_linear_distribution_param_type_distribution_type =
    std_piecewise_linear_distribution;
#[repr(C)]
#[derive(Debug)]
pub struct std_seed_seq {
    pub _M_v: std_vector,
}
pub type std_seed_seq_result_type = uint_least32_t;
#[test]
fn bindgen_test_layout_std_seed_seq() {
    assert_eq!(::std::mem::size_of::<std_seed_seq>() , 24usize , concat ! (
               "Size of: " , stringify ! ( std_seed_seq ) ));
    assert_eq! (::std::mem::align_of::<std_seed_seq>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( std_seed_seq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const std_seed_seq ) ) . _M_v as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( std_seed_seq ) , "::" ,
                stringify ! ( _M_v ) ));
}
extern "C" {
    #[link_name = "multiplier"]
    pub static std_multiplier: _UIntType;
}
extern "C" {
    #[link_name = "increment"]
    pub static std_increment: _UIntType;
}
extern "C" {
    #[link_name = "modulus"]
    pub static std_modulus: _UIntType;
}
extern "C" {
    #[link_name = "default_seed"]
    pub static std_default_seed: _UIntType;
}
extern "C" {
    #[link_name = "word_size"]
    pub static std_word_size: usize;
}
extern "C" {
    #[link_name = "state_size"]
    pub static std_state_size: usize;
}
extern "C" {
    #[link_name = "shift_size"]
    pub static std_shift_size: usize;
}
extern "C" {
    #[link_name = "mask_bits"]
    pub static std_mask_bits: usize;
}
extern "C" {
    #[link_name = "xor_mask"]
    pub static std_xor_mask: _UIntType;
}
extern "C" {
    #[link_name = "tempering_u"]
    pub static std_tempering_u: usize;
}
extern "C" {
    #[link_name = "tempering_d"]
    pub static std_tempering_d: _UIntType;
}
extern "C" {
    #[link_name = "tempering_s"]
    pub static std_tempering_s: usize;
}
extern "C" {
    #[link_name = "tempering_b"]
    pub static std_tempering_b: _UIntType;
}
extern "C" {
    #[link_name = "tempering_t"]
    pub static std_tempering_t: usize;
}
extern "C" {
    #[link_name = "tempering_c"]
    pub static std_tempering_c: _UIntType;
}
extern "C" {
    #[link_name = "tempering_l"]
    pub static std_tempering_l: usize;
}
extern "C" {
    #[link_name = "initialization_multiplier"]
    pub static std_initialization_multiplier: _UIntType;
}
extern "C" {
    #[link_name = "short_lag"]
    pub static std_short_lag: usize;
}
extern "C" {
    #[link_name = "long_lag"]
    pub static std_long_lag: usize;
}
extern "C" {
    #[link_name = "block_size"]
    pub static std_block_size: usize;
}
extern "C" {
    #[link_name = "used_block"]
    pub static std_used_block: usize;
}
extern "C" {
    #[link_name = "table_size"]
    pub static std_table_size: usize;
}
pub const _S_threshold: std__bindgen_ty_2 = std__bindgen_ty_2::_S_threshold;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum std__bindgen_ty_2 { _S_threshold = 16, }
pub const _S_chunk_size: std__bindgen_ty_3 = std__bindgen_ty_3::_S_chunk_size;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum std__bindgen_ty_3 { _S_chunk_size = 7, }
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_raw_storage_iterator<_OutputIterator> {
    pub _M_iter: _OutputIterator,
}
#[repr(C)]
#[derive(Debug)]
pub struct std_bad_cast {
    pub _base: std_exception,
}
#[test]
fn bindgen_test_layout_std_bad_cast() {
    assert_eq!(::std::mem::size_of::<std_bad_cast>() , 8usize , concat ! (
               "Size of: " , stringify ! ( std_bad_cast ) ));
    assert_eq! (::std::mem::align_of::<std_bad_cast>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( std_bad_cast ) ));
}
#[repr(C)]
#[derive(Debug)]
pub struct std_bad_typeid {
    pub _base: std_exception,
}
#[test]
fn bindgen_test_layout_std_bad_typeid() {
    assert_eq!(::std::mem::size_of::<std_bad_typeid>() , 8usize , concat ! (
               "Size of: " , stringify ! ( std_bad_typeid ) ));
    assert_eq! (::std::mem::align_of::<std_bad_typeid>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( std_bad_typeid ) ));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct std_allocator_arg_t {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_allocator_arg_t() {
    assert_eq!(::std::mem::size_of::<std_allocator_arg_t>() , 1usize , concat
               ! ( "Size of: " , stringify ! ( std_allocator_arg_t ) ));
    assert_eq! (::std::mem::align_of::<std_allocator_arg_t>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( std_allocator_arg_t ) ));
}
impl Clone for std_allocator_arg_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "?allocator_arg@std@@3Uallocator_arg_t@1@B"]
    pub static std_allocator_arg: std_allocator_arg_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_allocator_type_helper {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_allocator_type_helper__Wrap_type {
    pub _address: u8,
}
pub type std___has_allocator_type_helper_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_allocator_type {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___uses_allocator_arg {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct std___uses_alloc_base {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___uses_alloc_base() {
    assert_eq!(::std::mem::size_of::<std___uses_alloc_base>() , 1usize ,
               concat ! ( "Size of: " , stringify ! ( std___uses_alloc_base )
               ));
    assert_eq! (::std::mem::align_of::<std___uses_alloc_base>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( std___uses_alloc_base ) ));
}
impl Clone for std___uses_alloc_base {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct std___uses_alloc0 {
    pub _M_a: std___uses_alloc0__Anything,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct std___uses_alloc0__Anything {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___uses_alloc0__Anything() {
    assert_eq!(::std::mem::size_of::<std___uses_alloc0__Anything>() , 1usize ,
               concat ! (
               "Size of: " , stringify ! ( std___uses_alloc0__Anything ) ));
    assert_eq! (::std::mem::align_of::<std___uses_alloc0__Anything>() , 1usize
                , concat ! (
                "Alignment of " , stringify ! ( std___uses_alloc0__Anything )
                ));
}
impl Clone for std___uses_alloc0__Anything {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_std___uses_alloc0() {
    assert_eq!(::std::mem::size_of::<std___uses_alloc0>() , 1usize , concat !
               ( "Size of: " , stringify ! ( std___uses_alloc0 ) ));
    assert_eq! (::std::mem::align_of::<std___uses_alloc0>() , 1usize , concat
                ! ( "Alignment of " , stringify ! ( std___uses_alloc0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const std___uses_alloc0 ) ) . _M_a as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( std___uses_alloc0 ) ,
                "::" , stringify ! ( _M_a ) ));
}
impl Clone for std___uses_alloc0 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___uses_alloc1<_Alloc> {
    pub _M_a: *mut _Alloc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___uses_alloc2<_Alloc> {
    pub _M_a: *mut _Alloc,
}
#[repr(C)]
pub struct std___uses_alloc_impl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug)]
pub struct std_logic_error {
    pub _base: std_exception,
    pub _M_msg: std_string,
}
#[test]
fn bindgen_test_layout_std_logic_error() {
    assert_eq!(::std::mem::size_of::<std_logic_error>() , 16usize , concat ! (
               "Size of: " , stringify ! ( std_logic_error ) ));
    assert_eq! (::std::mem::align_of::<std_logic_error>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( std_logic_error ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const std_logic_error ) ) . _M_msg as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( std_logic_error ) ,
                "::" , stringify ! ( _M_msg ) ));
}
extern "C" {
    #[link_name =
          "??0logic_error@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z"]
    pub fn std_logic_error_logic_error(this: *mut std_logic_error,
                                       __arg: *const std_string);
}
impl std_logic_error {
    #[inline]
    pub unsafe fn new(__arg: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        std_logic_error_logic_error(&mut __bindgen_tmp, __arg);
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct std_domain_error {
    pub _base: std_logic_error,
}
#[test]
fn bindgen_test_layout_std_domain_error() {
    assert_eq!(::std::mem::size_of::<std_domain_error>() , 16usize , concat !
               ( "Size of: " , stringify ! ( std_domain_error ) ));
    assert_eq! (::std::mem::align_of::<std_domain_error>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( std_domain_error ) ));
}
extern "C" {
    #[link_name =
          "??0domain_error@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z"]
    pub fn std_domain_error_domain_error(this: *mut std_domain_error,
                                         __arg: *const std_string);
}
impl std_domain_error {
    #[inline]
    pub unsafe fn new(__arg: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        std_domain_error_domain_error(&mut __bindgen_tmp, __arg);
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct std_invalid_argument {
    pub _base: std_logic_error,
}
#[test]
fn bindgen_test_layout_std_invalid_argument() {
    assert_eq!(::std::mem::size_of::<std_invalid_argument>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( std_invalid_argument )
               ));
    assert_eq! (::std::mem::align_of::<std_invalid_argument>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( std_invalid_argument ) ));
}
extern "C" {
    #[link_name =
          "??0invalid_argument@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z"]
    pub fn std_invalid_argument_invalid_argument(this:
                                                     *mut std_invalid_argument,
                                                 __arg: *const std_string);
}
impl std_invalid_argument {
    #[inline]
    pub unsafe fn new(__arg: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        std_invalid_argument_invalid_argument(&mut __bindgen_tmp, __arg);
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct std_length_error {
    pub _base: std_logic_error,
}
#[test]
fn bindgen_test_layout_std_length_error() {
    assert_eq!(::std::mem::size_of::<std_length_error>() , 16usize , concat !
               ( "Size of: " , stringify ! ( std_length_error ) ));
    assert_eq! (::std::mem::align_of::<std_length_error>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( std_length_error ) ));
}
extern "C" {
    #[link_name =
          "??0length_error@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z"]
    pub fn std_length_error_length_error(this: *mut std_length_error,
                                         __arg: *const std_string);
}
impl std_length_error {
    #[inline]
    pub unsafe fn new(__arg: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        std_length_error_length_error(&mut __bindgen_tmp, __arg);
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct std_out_of_range {
    pub _base: std_logic_error,
}
#[test]
fn bindgen_test_layout_std_out_of_range() {
    assert_eq!(::std::mem::size_of::<std_out_of_range>() , 16usize , concat !
               ( "Size of: " , stringify ! ( std_out_of_range ) ));
    assert_eq! (::std::mem::align_of::<std_out_of_range>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( std_out_of_range ) ));
}
extern "C" {
    #[link_name =
          "??0out_of_range@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z"]
    pub fn std_out_of_range_out_of_range(this: *mut std_out_of_range,
                                         __arg: *const std_string);
}
impl std_out_of_range {
    #[inline]
    pub unsafe fn new(__arg: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        std_out_of_range_out_of_range(&mut __bindgen_tmp, __arg);
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct std_runtime_error {
    pub _base: std_exception,
    pub _M_msg: std_string,
}
#[test]
fn bindgen_test_layout_std_runtime_error() {
    assert_eq!(::std::mem::size_of::<std_runtime_error>() , 16usize , concat !
               ( "Size of: " , stringify ! ( std_runtime_error ) ));
    assert_eq! (::std::mem::align_of::<std_runtime_error>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( std_runtime_error ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const std_runtime_error ) ) . _M_msg as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( std_runtime_error ) ,
                "::" , stringify ! ( _M_msg ) ));
}
extern "C" {
    #[link_name =
          "??0runtime_error@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z"]
    pub fn std_runtime_error_runtime_error(this: *mut std_runtime_error,
                                           __arg: *const std_string);
}
impl std_runtime_error {
    #[inline]
    pub unsafe fn new(__arg: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        std_runtime_error_runtime_error(&mut __bindgen_tmp, __arg);
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct std_range_error {
    pub _base: std_runtime_error,
}
#[test]
fn bindgen_test_layout_std_range_error() {
    assert_eq!(::std::mem::size_of::<std_range_error>() , 16usize , concat ! (
               "Size of: " , stringify ! ( std_range_error ) ));
    assert_eq! (::std::mem::align_of::<std_range_error>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( std_range_error ) ));
}
extern "C" {
    #[link_name =
          "??0range_error@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z"]
    pub fn std_range_error_range_error(this: *mut std_range_error,
                                       __arg: *const std_string);
}
impl std_range_error {
    #[inline]
    pub unsafe fn new(__arg: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        std_range_error_range_error(&mut __bindgen_tmp, __arg);
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct std_overflow_error {
    pub _base: std_runtime_error,
}
#[test]
fn bindgen_test_layout_std_overflow_error() {
    assert_eq!(::std::mem::size_of::<std_overflow_error>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( std_overflow_error ) ));
    assert_eq! (::std::mem::align_of::<std_overflow_error>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( std_overflow_error ) ));
}
extern "C" {
    #[link_name =
          "??0overflow_error@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z"]
    pub fn std_overflow_error_overflow_error(this: *mut std_overflow_error,
                                             __arg: *const std_string);
}
impl std_overflow_error {
    #[inline]
    pub unsafe fn new(__arg: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        std_overflow_error_overflow_error(&mut __bindgen_tmp, __arg);
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct std_underflow_error {
    pub _base: std_runtime_error,
}
#[test]
fn bindgen_test_layout_std_underflow_error() {
    assert_eq!(::std::mem::size_of::<std_underflow_error>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( std_underflow_error ) ));
    assert_eq! (::std::mem::align_of::<std_underflow_error>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( std_underflow_error ) ));
}
extern "C" {
    #[link_name =
          "??0underflow_error@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z"]
    pub fn std_underflow_error_underflow_error(this: *mut std_underflow_error,
                                               __arg: *const std_string);
}
impl std_underflow_error {
    #[inline]
    pub unsafe fn new(__arg: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        std_underflow_error_underflow_error(&mut __bindgen_tmp, __arg);
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___add_c_ref {
    pub _address: u8,
}
pub type std___add_c_ref_type<_Tp> = *mut _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___add_ref {
    pub _address: u8,
}
pub type std___add_ref_type<_Tp> = *mut _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___add_r_ref {
    pub _address: u8,
}
pub type std___add_r_ref_type<_Tp> = *mut _Tp;
#[repr(C)]
pub struct std___is_empty_non_tuple {
    pub _address: u8,
}
pub type std___empty_not_final = u8;
#[test]
fn __bindgen_test_layout_std_tuple_instantiation_15814() {
    assert_eq!(::std::mem::size_of::<std_tuple>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! ( std_tuple )
               ));
    assert_eq!(::std::mem::align_of::<std_tuple>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_tuple ) ));
}
#[repr(C)]
pub struct std___is_tuple_like_impl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_tuple_like {
    pub _address: u8,
}
#[repr(C)]
pub struct std___do_make_tuple {
    pub _address: u8,
}
#[repr(C)]
pub struct std___make_tuple {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___combine_tuples {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std___combine_tuples_instantiation_15873() {
    assert_eq!(::std::mem::size_of::<std___combine_tuples>() , 1usize , concat
               ! (
               "Size of template specialization: " , stringify ! (
               std___combine_tuples ) ));
    assert_eq!(::std::mem::align_of::<std___combine_tuples>() , 1usize ,
               concat ! (
               "Alignment of template specialization: " , stringify ! (
               std___combine_tuples ) ));
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___tuple_cat_result {
    pub _address: u8,
}
pub type std___tuple_cat_result___type = std___combine_tuples;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___make_1st_indices {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std___make_1st_indices_instantiation_15883() {
    assert_eq!(::std::mem::size_of::<std___make_1st_indices>() , 1usize ,
               concat ! (
               "Size of template specialization: " , stringify ! (
               std___make_1st_indices ) ));
    assert_eq!(::std::mem::align_of::<std___make_1st_indices>() , 1usize ,
               concat ! (
               "Alignment of template specialization: " , stringify ! (
               std___make_1st_indices ) ));
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___tuple_concater {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct std__Swallow_assign {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std__Swallow_assign() {
    assert_eq!(::std::mem::size_of::<std__Swallow_assign>() , 1usize , concat
               ! ( "Size of: " , stringify ! ( std__Swallow_assign ) ));
    assert_eq! (::std::mem::align_of::<std__Swallow_assign>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( std__Swallow_assign ) ));
}
impl Clone for std__Swallow_assign {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "?ignore@std@@3U_Swallow_assign@1@B"]
    pub static std_ignore: std__Swallow_assign;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Mem_fn {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_result_type_helper {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_result_type_helper__Wrap_type {
    pub _address: u8,
}
pub type std___has_result_type_helper_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_result_type {
    pub _address: u8,
}
#[repr(C)]
pub struct std__Weak_result_type_impl {
    pub _address: u8,
}
#[repr(C)]
pub struct std__Weak_result_type {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_argument_type_helper {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_argument_type_helper__Wrap_type {
    pub _address: u8,
}
pub type std___has_argument_type_helper_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_argument_type {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_first_argument_type_helper {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_first_argument_type_helper__Wrap_type {
    pub _address: u8,
}
pub type std___has_first_argument_type_helper_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_first_argument_type {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_second_argument_type_helper {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_second_argument_type_helper__Wrap_type {
    pub _address: u8,
}
pub type std___has_second_argument_type_helper_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_second_argument_type {
    pub _address: u8,
}
#[repr(C)]
pub struct std__Reference_wrapper_base {
    pub _address: u8,
}
#[repr(C)]
pub struct std__Pack {
    pub _address: u8,
}
pub type std__NotSame = std___not_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Maybe_unary_or_binary_function {
    pub _address: u8,
}
#[repr(C)]
pub struct std_is_bind_expression {
    pub _address: u8,
}
#[repr(C)]
pub struct std_is_placeholder {
    pub _address: u8,
}
extern "C" {
    #[link_name = "?_1@placeholders@std@@3U?$_Placeholder@$00@2@B"]
    pub static std_placeholders__1: u8;
}
extern "C" {
    #[link_name = "?_2@placeholders@std@@3U?$_Placeholder@$01@2@B"]
    pub static std_placeholders__2: u8;
}
extern "C" {
    #[link_name = "?_3@placeholders@std@@3U?$_Placeholder@$02@2@B"]
    pub static std_placeholders__3: u8;
}
extern "C" {
    #[link_name = "?_4@placeholders@std@@3U?$_Placeholder@$03@2@B"]
    pub static std_placeholders__4: u8;
}
extern "C" {
    #[link_name = "?_5@placeholders@std@@3U?$_Placeholder@$04@2@B"]
    pub static std_placeholders__5: u8;
}
extern "C" {
    #[link_name = "?_6@placeholders@std@@3U?$_Placeholder@$05@2@B"]
    pub static std_placeholders__6: u8;
}
extern "C" {
    #[link_name = "?_7@placeholders@std@@3U?$_Placeholder@$06@2@B"]
    pub static std_placeholders__7: u8;
}
extern "C" {
    #[link_name = "?_8@placeholders@std@@3U?$_Placeholder@$07@2@B"]
    pub static std_placeholders__8: u8;
}
extern "C" {
    #[link_name = "?_9@placeholders@std@@3U?$_Placeholder@$08@2@B"]
    pub static std_placeholders__9: u8;
}
extern "C" {
    #[link_name = "?_10@placeholders@std@@3U?$_Placeholder@$09@2@B"]
    pub static std_placeholders__10: u8;
}
extern "C" {
    #[link_name = "?_11@placeholders@std@@3U?$_Placeholder@$0L@@2@B"]
    pub static std_placeholders__11: u8;
}
extern "C" {
    #[link_name = "?_12@placeholders@std@@3U?$_Placeholder@$0M@@2@B"]
    pub static std_placeholders__12: u8;
}
extern "C" {
    #[link_name = "?_13@placeholders@std@@3U?$_Placeholder@$0N@@2@B"]
    pub static std_placeholders__13: u8;
}
extern "C" {
    #[link_name = "?_14@placeholders@std@@3U?$_Placeholder@$0O@@2@B"]
    pub static std_placeholders__14: u8;
}
extern "C" {
    #[link_name = "?_15@placeholders@std@@3U?$_Placeholder@$0P@@2@B"]
    pub static std_placeholders__15: u8;
}
extern "C" {
    #[link_name = "?_16@placeholders@std@@3U?$_Placeholder@$0BA@@2@B"]
    pub static std_placeholders__16: u8;
}
extern "C" {
    #[link_name = "?_17@placeholders@std@@3U?$_Placeholder@$0BB@@2@B"]
    pub static std_placeholders__17: u8;
}
extern "C" {
    #[link_name = "?_18@placeholders@std@@3U?$_Placeholder@$0BC@@2@B"]
    pub static std_placeholders__18: u8;
}
extern "C" {
    #[link_name = "?_19@placeholders@std@@3U?$_Placeholder@$0BD@@2@B"]
    pub static std_placeholders__19: u8;
}
extern "C" {
    #[link_name = "?_20@placeholders@std@@3U?$_Placeholder@$0BE@@2@B"]
    pub static std_placeholders__20: u8;
}
extern "C" {
    #[link_name = "?_21@placeholders@std@@3U?$_Placeholder@$0BF@@2@B"]
    pub static std_placeholders__21: u8;
}
extern "C" {
    #[link_name = "?_22@placeholders@std@@3U?$_Placeholder@$0BG@@2@B"]
    pub static std_placeholders__22: u8;
}
extern "C" {
    #[link_name = "?_23@placeholders@std@@3U?$_Placeholder@$0BH@@2@B"]
    pub static std_placeholders__23: u8;
}
extern "C" {
    #[link_name = "?_24@placeholders@std@@3U?$_Placeholder@$0BI@@2@B"]
    pub static std_placeholders__24: u8;
}
extern "C" {
    #[link_name = "?_25@placeholders@std@@3U?$_Placeholder@$0BJ@@2@B"]
    pub static std_placeholders__25: u8;
}
extern "C" {
    #[link_name = "?_26@placeholders@std@@3U?$_Placeholder@$0BK@@2@B"]
    pub static std_placeholders__26: u8;
}
extern "C" {
    #[link_name = "?_27@placeholders@std@@3U?$_Placeholder@$0BL@@2@B"]
    pub static std_placeholders__27: u8;
}
extern "C" {
    #[link_name = "?_28@placeholders@std@@3U?$_Placeholder@$0BM@@2@B"]
    pub static std_placeholders__28: u8;
}
extern "C" {
    #[link_name = "?_29@placeholders@std@@3U?$_Placeholder@$0BN@@2@B"]
    pub static std_placeholders__29: u8;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__No_tuple_element([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Maybe_wrap_member_pointer {
    pub _address: u8,
}
pub type std__Maybe_wrap_member_pointer_type<_Tp> = _Tp;
#[test]
fn __bindgen_test_layout_std__Maybe_wrap_member_pointer_instantiation_16166() {
    assert_eq!(::std::mem::size_of::<std__Maybe_wrap_member_pointer>() ,
               1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std__Maybe_wrap_member_pointer ) ));
    assert_eq!(::std::mem::align_of::<std__Maybe_wrap_member_pointer>() ,
               1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std__Maybe_wrap_member_pointer ) ));
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Bind {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Bind_result {
    pub _address: u8,
}
pub type std___is_socketlike = std___or_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Bindres_helper {
    pub _address: u8,
}
pub type std__Bindres_helper___maybe_type = std__Maybe_wrap_member_pointer;
pub type std__Bindres_helper___functor_type =
    std__Bindres_helper___maybe_type;
pub type std__Bindres_helper_type = std__Bind_result;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Bind_simple {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Bind_simple_helper {
    pub _address: u8,
}
pub type std__Bind_simple_helper___maybe_type =
    std__Maybe_wrap_member_pointer;
pub type std__Bind_simple_helper___func_type =
    std__Bind_simple_helper___maybe_type;
pub type std__Bind_simple_helper___type = std__Bind_simple;
#[repr(C)]
#[derive(Debug)]
pub struct std_bad_function_call {
    pub _base: std_exception,
}
#[test]
fn bindgen_test_layout_std_bad_function_call() {
    assert_eq!(::std::mem::size_of::<std_bad_function_call>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( std_bad_function_call )
               ));
    assert_eq! (::std::mem::align_of::<std_bad_function_call>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( std_bad_function_call ) ));
}
#[repr(C)]
pub struct std___is_location_invariant {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Undefined_class([u8; 0]);
#[repr(C)]
#[derive(Copy)]
pub union std__Nocopy_types {
    pub _M_object: *mut ::std::os::raw::c_void,
    pub _M_const_object: *const ::std::os::raw::c_void,
    pub _M_function_pointer: ::std::option::Option<unsafe extern "C" fn()>,
    pub _M_member_pointer: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout_std__Nocopy_types() {
    assert_eq!(::std::mem::size_of::<std__Nocopy_types>() , 24usize , concat !
               ( "Size of: " , stringify ! ( std__Nocopy_types ) ));
    assert_eq! (::std::mem::align_of::<std__Nocopy_types>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( std__Nocopy_types ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const std__Nocopy_types ) ) . _M_object as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( std__Nocopy_types ) ,
                "::" , stringify ! ( _M_object ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const std__Nocopy_types ) ) . _M_const_object
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( std__Nocopy_types ) ,
                "::" , stringify ! ( _M_const_object ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const std__Nocopy_types ) ) .
                _M_function_pointer as * const _ as usize } , 0usize , concat
                ! (
                "Alignment of field: " , stringify ! ( std__Nocopy_types ) ,
                "::" , stringify ! ( _M_function_pointer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const std__Nocopy_types ) ) . _M_member_pointer
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( std__Nocopy_types ) ,
                "::" , stringify ! ( _M_member_pointer ) ));
}
impl Clone for std__Nocopy_types {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union std__Any_data {
    pub _M_unused: std__Nocopy_types,
    pub _M_pod_data: [::std::os::raw::c_char; 24usize],
}
#[test]
fn bindgen_test_layout_std__Any_data() {
    assert_eq!(::std::mem::size_of::<std__Any_data>() , 24usize , concat ! (
               "Size of: " , stringify ! ( std__Any_data ) ));
    assert_eq! (::std::mem::align_of::<std__Any_data>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( std__Any_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const std__Any_data ) ) . _M_unused as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( std__Any_data ) , "::"
                , stringify ! ( _M_unused ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const std__Any_data ) ) . _M_pod_data as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( std__Any_data ) , "::"
                , stringify ! ( _M_pod_data ) ));
}
impl Clone for std__Any_data {
    fn clone(&self) -> Self { *self }
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum std__Manager_operation {
    __get_type_info = 0,
    __get_functor_ptr = 1,
    __clone_functor = 2,
    __destroy_functor = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Simple_type_wrapper<_Tp> {
    pub __value: _Tp,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_function {
    pub _address: u8,
}
#[repr(C)]
pub struct std__Function_base {
    pub _M_functor: std__Any_data,
    pub _M_manager: std__Function_base__Manager_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Function_base__Base_manager {
    pub _address: u8,
}
pub type std__Function_base__Base_manager__Local_storage = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Function_base__Ref_manager {
    pub _address: u8,
}
pub type std__Function_base__Ref_manager__Base =
    std__Function_base__Base_manager;
pub type std__Function_base__Manager_type =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut std__Any_data,
                                               arg2: *const std__Any_data,
                                               arg3: std__Manager_operation)
                              -> bool>;
pub const std__Function_base__M_max_size: usize = 24;
pub const std__Function_base__M_max_align: usize = 8;
#[test]
fn bindgen_test_layout_std__Function_base() {
    assert_eq!(::std::mem::size_of::<std__Function_base>() , 32usize , concat
               ! ( "Size of: " , stringify ! ( std__Function_base ) ));
    assert_eq! (::std::mem::align_of::<std__Function_base>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( std__Function_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const std__Function_base ) ) . _M_functor as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( std__Function_base ) ,
                "::" , stringify ! ( _M_functor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const std__Function_base ) ) . _M_manager as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( std__Function_base ) ,
                "::" , stringify ! ( _M_manager ) ));
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Function_handler {
    pub _address: u8,
}
pub type std___check_func_return_type = std___or_;
#[repr(C)]
#[derive(Debug)]
pub struct std_auto_ptr<_Tp> {
    pub _M_ptr: *mut _Tp,
}
pub type std_auto_ptr_element_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_default_delete {
    pub _address: u8,
}
#[repr(C)]
pub struct std_unique_ptr {
    pub _M_t: std_unique_ptr___tuple_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_unique_ptr__Pointer {
    pub _address: u8,
}
pub type std_unique_ptr__Pointer__Del = std_remove_reference;
pub type std_unique_ptr__Pointer_type = std_unique_ptr__Pointer__Del;
pub type std_unique_ptr___tuple_type = std_tuple;
pub type std_unique_ptr_pointer = std_unique_ptr__Pointer;
pub type std_unique_ptr_element_type<_Tp> = _Tp;
pub type std_unique_ptr_deleter_type<_Dp> = _Dp;
#[repr(C)]
#[derive(Debug)]
pub struct std_bad_weak_ptr {
    pub _base: std_exception,
}
#[test]
fn bindgen_test_layout_std_bad_weak_ptr() {
    assert_eq!(::std::mem::size_of::<std_bad_weak_ptr>() , 8usize , concat ! (
               "Size of: " , stringify ! ( std_bad_weak_ptr ) ));
    assert_eq! (::std::mem::align_of::<std_bad_weak_ptr>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( std_bad_weak_ptr ) ));
}
#[test]
fn __bindgen_test_layout_std__Mutex_base_instantiation_16443() {
    assert_eq!(::std::mem::size_of::<[u64; 2usize]>() , 16usize , concat ! (
               "Size of template specialization: " , stringify ! (
               [u64; 2usize] ) ));
    assert_eq!(::std::mem::align_of::<[u64; 2usize]>() , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               [u64; 2usize] ) ));
}
#[repr(C)]
pub struct std_shared_ptr<_Tp> {
    pub _base: u8,
}
#[repr(C)]
pub struct std_weak_ptr<_Tp> {
    pub _base: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_owner_less {
    pub _address: u8,
}
#[repr(C)]
pub struct std_enable_shared_from_this<_Tp> {
    pub _M_weak_this: std_weak_ptr<_Tp>,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct std__Sp_make_shared_tag {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std__Sp_make_shared_tag() {
    assert_eq!(::std::mem::size_of::<std__Sp_make_shared_tag>() , 1usize ,
               concat ! (
               "Size of: " , stringify ! ( std__Sp_make_shared_tag ) ));
    assert_eq! (::std::mem::align_of::<std__Sp_make_shared_tag>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( std__Sp_make_shared_tag ) ));
}
impl Clone for std__Sp_make_shared_tag {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Sp_less {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Sp_owner_less {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_auto_ptr_ref<_Tp1> {
    pub _M_ptr: *mut _Tp1,
}
#[test]
fn __bindgen_test_layout_std_auto_ptr_instantiation_16840() {
    assert_eq!(::std::mem::size_of::<std_auto_ptr<::std::os::raw::c_void>>() ,
               1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std_auto_ptr<::std::os::raw::c_void> ) ));
    assert_eq!(::std::mem::align_of::<std_auto_ptr<::std::os::raw::c_void>>()
               , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_auto_ptr<::std::os::raw::c_void> ) ));
}
extern "C" {
    #[link_name = "id"]
    pub static mut std_id: std_locale_id;
}
#[test]
fn __bindgen_test_layout_std_collate_instantiation_18357() {
    assert_eq!(::std::mem::size_of::<std_collate>() , 24usize , concat ! (
               "Size of template specialization: " , stringify ! ( std_collate
               ) ));
    assert_eq!(::std::mem::align_of::<std_collate>() , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_collate ) ));
}
#[test]
fn __bindgen_test_layout_std_collate_byname_instantiation_18361() {
    assert_eq!(::std::mem::size_of::<std_collate_byname>() , 24usize , concat
               ! (
               "Size of template specialization: " , stringify ! (
               std_collate_byname ) ));
    assert_eq!(::std::mem::align_of::<std_collate_byname>() , 8usize , concat
               ! (
               "Alignment of template specialization: " , stringify ! (
               std_collate_byname ) ));
}
#[test]
fn __bindgen_test_layout_std_collate_instantiation_18365() {
    assert_eq!(::std::mem::size_of::<std_collate>() , 24usize , concat ! (
               "Size of template specialization: " , stringify ! ( std_collate
               ) ));
    assert_eq!(::std::mem::align_of::<std_collate>() , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_collate ) ));
}
#[test]
fn __bindgen_test_layout_std_collate_byname_instantiation_18369() {
    assert_eq!(::std::mem::size_of::<std_collate_byname>() , 24usize , concat
               ! (
               "Size of template specialization: " , stringify ! (
               std_collate_byname ) ));
    assert_eq!(::std::mem::align_of::<std_collate_byname>() , 8usize , concat
               ! (
               "Alignment of template specialization: " , stringify ! (
               std_collate_byname ) ));
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum std__Ios_Fmtflags {
    _S_boolalpha = 1,
    _S_dec = 2,
    _S_fixed = 4,
    _S_hex = 8,
    _S_internal = 16,
    _S_left = 32,
    _S_oct = 64,
    _S_right = 128,
    _S_scientific = 256,
    _S_showbase = 512,
    _S_showpoint = 1024,
    _S_showpos = 2048,
    _S_skipws = 4096,
    _S_unitbuf = 8192,
    _S_uppercase = 16384,
    _S_adjustfield = 176,
    _S_basefield = 74,
    _S_floatfield = 260,
    _S_ios_fmtflags_end = 65536,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum std__Ios_Openmode {
    _S_app = 1,
    _S_ate = 2,
    _S_bin = 4,
    _S_in = 8,
    _S_out = 16,
    _S_trunc = 32,
    _S_ios_openmode_end = 65536,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum std__Ios_Iostate {
    _S_goodbit = 0,
    _S_badbit = 1,
    _S_eofbit = 2,
    _S_failbit = 4,
    _S_ios_iostate_end = 65536,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum std__Ios_Seekdir {
    _S_beg = 0,
    _S_cur = 1,
    _S_end = 2,
    _S_ios_seekdir_end = 65536,
}
extern "C" {
    #[link_name =
          "??$__copy_streambufs_eof@DU?$char_traits@D@std@@@std@@YA_JPEAV?$basic_streambuf@DU?$char_traits@D@std@@@0@0AEA_N@Z"]
    pub fn std___copy_streambufs_eof(__sbin:
                                         *mut std_basic_streambuf<::std::os::raw::c_char>,
                                     __sbout:
                                         *mut std_basic_streambuf<::std::os::raw::c_char>,
                                     __ineof: *mut bool) -> std_streamsize;
}
extern "C" {
    #[link_name =
          "??$__copy_streambufs_eof@_WU?$char_traits@_W@std@@@std@@YA_JPEAV?$basic_streambuf@_WU?$char_traits@_W@std@@@0@0AEA_N@Z"]
    pub fn std___copy_streambufs_eof1(__sbin: *mut std_basic_streambuf<u16>,
                                      __sbout: *mut std_basic_streambuf<u16>,
                                      __ineof: *mut bool) -> std_streamsize;
}
#[test]
fn __bindgen_test_layout_std_basic_streambuf_instantiation_18501() {
    assert_eq!(::std::mem::size_of::<std_basic_streambuf<::std::os::raw::c_char>>()
               , 64usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std_basic_streambuf<::std::os::raw::c_char> ) ));
    assert_eq!(::std::mem::align_of::<std_basic_streambuf<::std::os::raw::c_char>>()
               , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_basic_streambuf<::std::os::raw::c_char> ) ));
}
#[test]
fn __bindgen_test_layout_std_basic_streambuf_instantiation_18506() {
    assert_eq!(::std::mem::size_of::<std_basic_streambuf<u16>>() , 64usize ,
               concat ! (
               "Size of template specialization: " , stringify ! (
               std_basic_streambuf<u16> ) ));
    assert_eq!(::std::mem::align_of::<std_basic_streambuf<u16>>() , 8usize ,
               concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_basic_streambuf<u16> ) ));
}
extern "C" {
    #[link_name =
          "??$__convert_to_v@M@std@@YAXPEBDAEAMAEAW4_Ios_Iostate@0@AEBQEAH@Z"]
    pub fn std___convert_to_v(arg1: *const ::std::os::raw::c_char,
                              arg2: *mut f32, arg3: *mut std_ios_base_iostate,
                              arg4: *const std___c_locale);
}
extern "C" {
    #[link_name =
          "??$__convert_to_v@N@std@@YAXPEBDAEANAEAW4_Ios_Iostate@0@AEBQEAH@Z"]
    pub fn std___convert_to_v1(arg1: *const ::std::os::raw::c_char,
                               arg2: *mut f64,
                               arg3: *mut std_ios_base_iostate,
                               arg4: *const std___c_locale);
}
extern "C" {
    #[link_name =
          "??$__convert_to_v@O@std@@YAXPEBDAEAOAEAW4_Ios_Iostate@0@AEBQEAH@Z"]
    pub fn std___convert_to_v2(arg1: *const ::std::os::raw::c_char,
                               arg2: *mut f64,
                               arg3: *mut std_ios_base_iostate,
                               arg4: *const std___c_locale);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___pad {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug)]
pub struct std___ctype_abstract_base {
    pub _base: std_locale_facet,
}
pub type std___ctype_abstract_base_char_type<_CharT> = _CharT;
#[test]
fn __bindgen_test_layout_std_ctype_byname_instantiation_18602() {
    assert_eq!(::std::mem::size_of::<std_ctype_byname>() , 576usize , concat !
               (
               "Size of template specialization: " , stringify ! (
               std_ctype_byname ) ));
    assert_eq!(::std::mem::align_of::<std_ctype_byname>() , 8usize , concat !
               (
               "Alignment of template specialization: " , stringify ! (
               std_ctype_byname ) ));
}
#[test]
fn __bindgen_test_layout_std_ctype_byname_instantiation_18606() {
    assert_eq!(::std::mem::size_of::<std_ctype_byname>() , 736usize , concat !
               (
               "Size of template specialization: " , stringify ! (
               std_ctype_byname ) ));
    assert_eq!(::std::mem::align_of::<std_ctype_byname>() , 8usize , concat !
               (
               "Alignment of template specialization: " , stringify ! (
               std_ctype_byname ) ));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct std___num_base {
    pub _address: u8,
}
pub const std___num_base__S_ominus: std___num_base__bindgen_ty_1 =
    std___num_base__bindgen_ty_1::_S_ominus;
pub const std___num_base__S_oplus: std___num_base__bindgen_ty_1 =
    std___num_base__bindgen_ty_1::_S_oplus;
pub const std___num_base__S_ox: std___num_base__bindgen_ty_1 =
    std___num_base__bindgen_ty_1::_S_ox;
pub const std___num_base__S_oX: std___num_base__bindgen_ty_1 =
    std___num_base__bindgen_ty_1::_S_oX;
pub const std___num_base__S_odigits: std___num_base__bindgen_ty_1 =
    std___num_base__bindgen_ty_1::_S_odigits;
pub const std___num_base__S_odigits_end: std___num_base__bindgen_ty_1 =
    std___num_base__bindgen_ty_1::_S_odigits_end;
pub const std___num_base__S_oudigits: std___num_base__bindgen_ty_1 =
    std___num_base__bindgen_ty_1::_S_odigits_end;
pub const std___num_base__S_oudigits_end: std___num_base__bindgen_ty_1 =
    std___num_base__bindgen_ty_1::_S_oudigits_end;
pub const std___num_base__S_oe: std___num_base__bindgen_ty_1 =
    std___num_base__bindgen_ty_1::_S_oe;
pub const std___num_base__S_oE: std___num_base__bindgen_ty_1 =
    std___num_base__bindgen_ty_1::_S_oE;
pub const std___num_base__S_oend: std___num_base__bindgen_ty_1 =
    std___num_base__bindgen_ty_1::_S_oudigits_end;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum std___num_base__bindgen_ty_1 {
    _S_ominus = 0,
    _S_oplus = 1,
    _S_ox = 2,
    _S_oX = 3,
    _S_odigits = 4,
    _S_odigits_end = 20,
    _S_oudigits_end = 36,
    _S_oe = 18,
    _S_oE = 34,
}
pub const std___num_base__S_iminus: std___num_base__bindgen_ty_2 =
    std___num_base__bindgen_ty_2::_S_iminus;
pub const std___num_base__S_iplus: std___num_base__bindgen_ty_2 =
    std___num_base__bindgen_ty_2::_S_iplus;
pub const std___num_base__S_ix: std___num_base__bindgen_ty_2 =
    std___num_base__bindgen_ty_2::_S_ix;
pub const std___num_base__S_iX: std___num_base__bindgen_ty_2 =
    std___num_base__bindgen_ty_2::_S_iX;
pub const std___num_base__S_izero: std___num_base__bindgen_ty_2 =
    std___num_base__bindgen_ty_2::_S_izero;
pub const std___num_base__S_ie: std___num_base__bindgen_ty_2 =
    std___num_base__bindgen_ty_2::_S_ie;
pub const std___num_base__S_iE: std___num_base__bindgen_ty_2 =
    std___num_base__bindgen_ty_2::_S_iE;
pub const std___num_base__S_iend: std___num_base__bindgen_ty_2 =
    std___num_base__bindgen_ty_2::_S_iend;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum std___num_base__bindgen_ty_2 {
    _S_iminus = 0,
    _S_iplus = 1,
    _S_ix = 2,
    _S_iX = 3,
    _S_izero = 4,
    _S_ie = 18,
    _S_iE = 24,
    _S_iend = 26,
}
extern "C" {
    #[link_name = "?_S_atoms_out@__num_base@std@@2PEBDEB"]
    pub static mut std___num_base__S_atoms_out: *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "?_S_atoms_in@__num_base@std@@2PEBDEB"]
    pub static mut std___num_base__S_atoms_in: *const ::std::os::raw::c_char;
}
#[test]
fn bindgen_test_layout_std___num_base() {
    assert_eq!(::std::mem::size_of::<std___num_base>() , 1usize , concat ! (
               "Size of: " , stringify ! ( std___num_base ) ));
    assert_eq! (::std::mem::align_of::<std___num_base>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( std___num_base ) ));
}
extern "C" {
    #[link_name =
          "?_S_format_float@__num_base@std@@SAXAEBVios_base@2@PEADD@Z"]
    pub fn std___num_base__S_format_float(__io: *const std_ios_base,
                                          __fptr: *mut ::std::os::raw::c_char,
                                          __mod: ::std::os::raw::c_char);
}
impl Clone for std___num_base {
    fn clone(&self) -> Self { *self }
}
impl std___num_base {
    #[inline]
    pub unsafe fn _S_format_float(__io: *const std_ios_base,
                                  __fptr: *mut ::std::os::raw::c_char,
                                  __mod: ::std::os::raw::c_char) {
        std___num_base__S_format_float(__io, __fptr, __mod)
    }
}
#[repr(C)]
pub struct std___numpunct_cache<_CharT> {
    pub _base: std_locale_facet,
    pub _M_grouping: *const ::std::os::raw::c_char,
    pub _M_grouping_size: usize,
    pub _M_use_grouping: bool,
    pub _M_truename: *mut _CharT,
    pub _M_truename_size: usize,
    pub _M_falsename: *mut _CharT,
    pub _M_falsename_size: usize,
    pub _M_decimal_point: _CharT,
    pub _M_thousands_sep: _CharT,
    pub _M_atoms_out: [_CharT; 36usize],
    pub _M_atoms_in: [_CharT; 26usize],
    pub _M_allocated: bool,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___use_cache {
    pub _address: u8,
}
extern "C" {
    #[link_name =
          "?__verify_grouping@std@@YA_NPEBD_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z"]
    pub fn std___verify_grouping(__grouping: *const ::std::os::raw::c_char,
                                 __grouping_size: usize,
                                 __grouping_tmp: *const std_string) -> bool;
}
#[test]
fn __bindgen_test_layout_std_numpunct_instantiation_18900() {
    assert_eq!(::std::mem::size_of::<std_numpunct<::std::os::raw::c_char>>() ,
               24usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std_numpunct<::std::os::raw::c_char> ) ));
    assert_eq!(::std::mem::align_of::<std_numpunct<::std::os::raw::c_char>>()
               , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_numpunct<::std::os::raw::c_char> ) ));
}
#[test]
fn __bindgen_test_layout_std_numpunct_byname_instantiation_18904() {
    assert_eq!(::std::mem::size_of::<std_numpunct_byname<::std::os::raw::c_char>>()
               , 24usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std_numpunct_byname<::std::os::raw::c_char> ) ));
    assert_eq!(::std::mem::align_of::<std_numpunct_byname<::std::os::raw::c_char>>()
               , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_numpunct_byname<::std::os::raw::c_char> ) ));
}
#[test]
fn __bindgen_test_layout_std_num_get_instantiation_18908() {
    assert_eq!(::std::mem::size_of::<std_num_get>() , 16usize , concat ! (
               "Size of template specialization: " , stringify ! ( std_num_get
               ) ));
    assert_eq!(::std::mem::align_of::<std_num_get>() , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_num_get ) ));
}
#[test]
fn __bindgen_test_layout_std_num_put_instantiation_18913() {
    assert_eq!(::std::mem::size_of::<std_num_put>() , 16usize , concat ! (
               "Size of template specialization: " , stringify ! ( std_num_put
               ) ));
    assert_eq!(::std::mem::align_of::<std_num_put>() , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_num_put ) ));
}
#[test]
fn __bindgen_test_layout_std_numpunct_instantiation_18919() {
    assert_eq!(::std::mem::size_of::<std_numpunct<u16>>() , 24usize , concat !
               (
               "Size of template specialization: " , stringify ! (
               std_numpunct<u16> ) ));
    assert_eq!(::std::mem::align_of::<std_numpunct<u16>>() , 8usize , concat !
               (
               "Alignment of template specialization: " , stringify ! (
               std_numpunct<u16> ) ));
}
#[test]
fn __bindgen_test_layout_std_numpunct_byname_instantiation_18923() {
    assert_eq!(::std::mem::size_of::<std_numpunct_byname<u16>>() , 24usize ,
               concat ! (
               "Size of template specialization: " , stringify ! (
               std_numpunct_byname<u16> ) ));
    assert_eq!(::std::mem::align_of::<std_numpunct_byname<u16>>() , 8usize ,
               concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_numpunct_byname<u16> ) ));
}
#[test]
fn __bindgen_test_layout_std_num_get_instantiation_18927() {
    assert_eq!(::std::mem::size_of::<std_num_get>() , 16usize , concat ! (
               "Size of template specialization: " , stringify ! ( std_num_get
               ) ));
    assert_eq!(::std::mem::align_of::<std_num_get>() , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_num_get ) ));
}
#[test]
fn __bindgen_test_layout_std_num_put_instantiation_18932() {
    assert_eq!(::std::mem::size_of::<std_num_put>() , 16usize , concat ! (
               "Size of template specialization: " , stringify ! ( std_num_put
               ) ));
    assert_eq!(::std::mem::align_of::<std_num_put>() , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_num_put ) ));
}
#[test]
fn __bindgen_test_layout_std_basic_ios_instantiation_18964() {
    assert_eq!(::std::mem::size_of::<std_basic_ios<::std::os::raw::c_char>>()
               , 264usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std_basic_ios<::std::os::raw::c_char> ) ));
    assert_eq!(::std::mem::align_of::<std_basic_ios<::std::os::raw::c_char>>()
               , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_basic_ios<::std::os::raw::c_char> ) ));
}
#[test]
fn __bindgen_test_layout_std_basic_ios_instantiation_18969() {
    assert_eq!(::std::mem::size_of::<std_basic_ios<u16>>() , 264usize , concat
               ! (
               "Size of template specialization: " , stringify ! (
               std_basic_ios<u16> ) ));
    assert_eq!(::std::mem::align_of::<std_basic_ios<u16>>() , 8usize , concat
               ! (
               "Alignment of template specialization: " , stringify ! (
               std_basic_ios<u16> ) ));
}
#[test]
fn __bindgen_test_layout_std_basic_ostream_instantiation_19026() {
    assert_eq!(::std::mem::size_of::<std_basic_ostream<::std::os::raw::c_char>>()
               , 272usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std_basic_ostream<::std::os::raw::c_char> ) ));
    assert_eq!(::std::mem::align_of::<std_basic_ostream<::std::os::raw::c_char>>()
               , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_basic_ostream<::std::os::raw::c_char> ) ));
}
#[test]
fn __bindgen_test_layout_std_basic_ostream_instantiation_19031() {
    assert_eq!(::std::mem::size_of::<std_basic_ostream<u16>>() , 272usize ,
               concat ! (
               "Size of template specialization: " , stringify ! (
               std_basic_ostream<u16> ) ));
    assert_eq!(::std::mem::align_of::<std_basic_ostream<u16>>() , 8usize ,
               concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_basic_ostream<u16> ) ));
}
#[test]
fn __bindgen_test_layout_std_basic_istream_instantiation_19177() {
    assert_eq!(::std::mem::size_of::<std_basic_istream<::std::os::raw::c_char>>()
               , 280usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std_basic_istream<::std::os::raw::c_char> ) ));
    assert_eq!(::std::mem::align_of::<std_basic_istream<::std::os::raw::c_char>>()
               , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_basic_istream<::std::os::raw::c_char> ) ));
}
#[test]
fn __bindgen_test_layout_std_basic_iostream_instantiation_19182() {
    assert_eq!(::std::mem::size_of::<std_basic_iostream<::std::os::raw::c_char>>()
               , 288usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std_basic_iostream<::std::os::raw::c_char> ) ));
    assert_eq!(::std::mem::align_of::<std_basic_iostream<::std::os::raw::c_char>>()
               , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_basic_iostream<::std::os::raw::c_char> ) ));
}
#[test]
fn __bindgen_test_layout_std_basic_istream_instantiation_19187() {
    assert_eq!(::std::mem::size_of::<std_basic_istream<u16>>() , 280usize ,
               concat ! (
               "Size of template specialization: " , stringify ! (
               std_basic_istream<u16> ) ));
    assert_eq!(::std::mem::align_of::<std_basic_istream<u16>>() , 8usize ,
               concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_basic_istream<u16> ) ));
}
#[test]
fn __bindgen_test_layout_std_basic_iostream_instantiation_19192() {
    assert_eq!(::std::mem::size_of::<std_basic_iostream<u16>>() , 288usize ,
               concat ! (
               "Size of template specialization: " , stringify ! (
               std_basic_iostream<u16> ) ));
    assert_eq!(::std::mem::align_of::<std_basic_iostream<u16>>() , 8usize ,
               concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_basic_iostream<u16> ) ));
}
extern "C" {
    #[link_name = "?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A"]
    pub static mut std_cin: std_istream;
}
extern "C" {
    #[link_name = "?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A"]
    pub static mut std_cout: std_ostream;
}
extern "C" {
    #[link_name = "?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A"]
    pub static mut std_cerr: std_ostream;
}
extern "C" {
    #[link_name = "?clog@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A"]
    pub static mut std_clog: std_ostream;
}
extern "C" {
    #[link_name =
          "?wcin@std@@3V?$basic_istream@_WU?$char_traits@_W@std@@@1@A"]
    pub static mut std_wcin: std_wistream;
}
extern "C" {
    #[link_name =
          "?wcout@std@@3V?$basic_ostream@_WU?$char_traits@_W@std@@@1@A"]
    pub static mut std_wcout: std_wostream;
}
extern "C" {
    #[link_name =
          "?wcerr@std@@3V?$basic_ostream@_WU?$char_traits@_W@std@@@1@A"]
    pub static mut std_wcerr: std_wostream;
}
extern "C" {
    #[link_name =
          "?wclog@std@@3V?$basic_ostream@_WU?$char_traits@_W@std@@@1@A"]
    pub static mut std_wclog: std_wostream;
}
extern "C" {
    #[link_name = "?__ioinit@std@@3VInit@ios_base@1@A"]
    pub static mut std___ioinit: std_ios_base_Init;
}
#[test]
fn __bindgen_test_layout_std_basic_stringbuf_instantiation_19304() {
    assert_eq!(::std::mem::size_of::<std_basic_stringbuf<::std::os::raw::c_char,
                                          std_allocator>>()
               , 80usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std_basic_stringbuf<::std::os::raw::c_char, std_allocator> )
               ));
    assert_eq!(::std::mem::align_of::<std_basic_stringbuf<::std::os::raw::c_char,
                                           std_allocator>>()
               , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_basic_stringbuf<::std::os::raw::c_char, std_allocator> )
               ));
}
#[test]
fn __bindgen_test_layout_std_basic_istringstream_instantiation_19310() {
    assert_eq!(::std::mem::size_of::<std_basic_istringstream<::std::os::raw::c_char,
                                              std_allocator>>()
               , 360usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std_basic_istringstream<::std::os::raw::c_char, std_allocator>
               ) ));
    assert_eq!(::std::mem::align_of::<std_basic_istringstream<::std::os::raw::c_char,
                                               std_allocator>>()
               , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_basic_istringstream<::std::os::raw::c_char, std_allocator>
               ) ));
}
#[test]
fn __bindgen_test_layout_std_basic_ostringstream_instantiation_19316() {
    assert_eq!(::std::mem::size_of::<std_basic_ostringstream<::std::os::raw::c_char,
                                              std_allocator>>()
               , 352usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std_basic_ostringstream<::std::os::raw::c_char, std_allocator>
               ) ));
    assert_eq!(::std::mem::align_of::<std_basic_ostringstream<::std::os::raw::c_char,
                                               std_allocator>>()
               , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_basic_ostringstream<::std::os::raw::c_char, std_allocator>
               ) ));
}
#[test]
fn __bindgen_test_layout_std_basic_stringstream_instantiation_19322() {
    assert_eq!(::std::mem::size_of::<std_basic_stringstream<::std::os::raw::c_char,
                                             std_allocator>>()
               , 368usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std_basic_stringstream<::std::os::raw::c_char, std_allocator> )
               ));
    assert_eq!(::std::mem::align_of::<std_basic_stringstream<::std::os::raw::c_char,
                                              std_allocator>>()
               , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_basic_stringstream<::std::os::raw::c_char, std_allocator> )
               ));
}
#[test]
fn __bindgen_test_layout_std_basic_stringbuf_instantiation_19328() {
    assert_eq!(::std::mem::size_of::<std_basic_stringbuf<u16, std_allocator>>()
               , 80usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std_basic_stringbuf<u16, std_allocator> ) ));
    assert_eq!(::std::mem::align_of::<std_basic_stringbuf<u16, std_allocator>>()
               , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_basic_stringbuf<u16, std_allocator> ) ));
}
#[test]
fn __bindgen_test_layout_std_basic_istringstream_instantiation_19334() {
    assert_eq!(::std::mem::size_of::<std_basic_istringstream<u16, std_allocator>>()
               , 360usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std_basic_istringstream<u16, std_allocator> ) ));
    assert_eq!(::std::mem::align_of::<std_basic_istringstream<u16, std_allocator>>()
               , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_basic_istringstream<u16, std_allocator> ) ));
}
#[test]
fn __bindgen_test_layout_std_basic_ostringstream_instantiation_19340() {
    assert_eq!(::std::mem::size_of::<std_basic_ostringstream<u16, std_allocator>>()
               , 352usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std_basic_ostringstream<u16, std_allocator> ) ));
    assert_eq!(::std::mem::align_of::<std_basic_ostringstream<u16, std_allocator>>()
               , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_basic_ostringstream<u16, std_allocator> ) ));
}
#[test]
fn __bindgen_test_layout_std_basic_stringstream_instantiation_19346() {
    assert_eq!(::std::mem::size_of::<std_basic_stringstream<u16, std_allocator>>()
               , 368usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std_basic_stringstream<u16, std_allocator> ) ));
    assert_eq!(::std::mem::align_of::<std_basic_stringstream<u16, std_allocator>>()
               , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_basic_stringstream<u16, std_allocator> ) ));
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_complex<_Tp> {
    pub _M_real: _Tp,
    pub _M_imag: _Tp,
}
pub type std_complex_value_type<_Tp> = _Tp;
#[test]
fn __bindgen_test_layout_std_complex_instantiation_19358() {
    assert_eq!(::std::mem::size_of::<std_complex<f32>>() , 8usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std_complex<f32> ) ));
    assert_eq!(::std::mem::align_of::<std_complex<f32>>() , 4usize , concat !
               (
               "Alignment of template specialization: " , stringify ! (
               std_complex<f32> ) ));
}
#[test]
fn __bindgen_test_layout_std_complex_instantiation_19362() {
    assert_eq!(::std::mem::size_of::<std_complex<f64>>() , 16usize , concat !
               (
               "Size of template specialization: " , stringify ! (
               std_complex<f64> ) ));
    assert_eq!(::std::mem::align_of::<std_complex<f64>>() , 8usize , concat !
               (
               "Alignment of template specialization: " , stringify ! (
               std_complex<f64> ) ));
}
#[test]
fn __bindgen_test_layout_std_complex_instantiation_19366() {
    assert_eq!(::std::mem::size_of::<std_complex<f64>>() , 16usize , concat !
               (
               "Size of template specialization: " , stringify ! (
               std_complex<f64> ) ));
    assert_eq!(::std::mem::align_of::<std_complex<f64>>() , 8usize , concat !
               (
               "Alignment of template specialization: " , stringify ! (
               std_complex<f64> ) ));
}
#[test]
fn __bindgen_test_layout_std__Norm_helper_instantiation_19458() {
    assert_eq!(::std::mem::size_of::<u8>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! ( u8 ) ));
    assert_eq!(::std::mem::align_of::<u8>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! ( u8 )
               ));
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__List_node<_Tp> {
    pub _base: std___detail__List_node_base,
    pub _M_data: _Tp,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__List_iterator {
    pub _M_node: *mut std___detail__List_node_base,
}
pub type std__List_iterator__Self = std__List_iterator;
pub type std__List_iterator__Node<_Tp> = std__List_node<_Tp>;
pub type std__List_iterator_difference_type = isize;
pub type std__List_iterator_iterator_category =
    std_bidirectional_iterator_tag;
pub type std__List_iterator_value_type<_Tp> = _Tp;
pub type std__List_iterator_pointer<_Tp> = *mut _Tp;
pub type std__List_iterator_reference<_Tp> = *mut _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__List_const_iterator {
    pub _M_node: *const std___detail__List_node_base,
}
pub type std__List_const_iterator__Self = std__List_const_iterator;
pub type std__List_const_iterator__Node<_Tp> = std__List_node<_Tp>;
pub type std__List_const_iterator_iterator = std__List_iterator;
pub type std__List_const_iterator_difference_type = isize;
pub type std__List_const_iterator_iterator_category =
    std_bidirectional_iterator_tag;
pub type std__List_const_iterator_value_type<_Tp> = _Tp;
pub type std__List_const_iterator_pointer<_Tp> = *mut _Tp;
pub type std__List_const_iterator_reference<_Tp> = *mut _Tp;
#[repr(C)]
pub struct std__List_base {
    pub _M_impl: std__List_base__List_impl,
}
pub type std__List_base__Node_alloc_type = [u8; 0usize];
pub type std__List_base__Tp_alloc_type = [u8; 0usize];
#[repr(C)]
pub struct std__List_base__List_impl {
    pub _M_node: std___detail__List_node_base,
}
pub type std__List_base_allocator_type<_Alloc> = _Alloc;
#[repr(C)]
pub struct std_list {
    pub _base: std__List_base,
}
pub type std_list__Alloc_value_type = [u8; 0usize];
pub type std_list__Base = std__List_base;
pub type std_list__Tp_alloc_type = std_list__Base;
pub type std_list__Node_alloc_type = std_list__Base;
pub type std_list_value_type<_Tp> = _Tp;
pub type std_list_pointer = std_list__Tp_alloc_type;
pub type std_list_const_pointer = std_list__Tp_alloc_type;
pub type std_list_reference = std_list__Tp_alloc_type;
pub type std_list_const_reference = std_list__Tp_alloc_type;
pub type std_list_iterator = std__List_iterator;
pub type std_list_const_iterator = std__List_const_iterator;
pub type std_list_const_reverse_iterator =
    std_reverse_iterator<std_list_const_iterator>;
pub type std_list_reverse_iterator = std_reverse_iterator<std_list_iterator>;
pub type std_list_size_type = usize;
pub type std_list_difference_type = isize;
pub type std_list_allocator_type<_Alloc> = _Alloc;
pub type std_list__Node<_Tp> = std__List_node<_Tp>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Deque_iterator<_Tp> {
    pub _M_cur: *mut _Tp,
    pub _M_first: *mut _Tp,
    pub _M_last: *mut _Tp,
    pub _M_node: std__Deque_iterator__Map_pointer<_Tp>,
}
pub type std__Deque_iterator_iterator<_Tp> = std__Deque_iterator<_Tp>;
pub type std__Deque_iterator_const_iterator<_Tp> = std__Deque_iterator<_Tp>;
pub type std__Deque_iterator_iterator_category =
    std_random_access_iterator_tag;
pub type std__Deque_iterator_value_type<_Tp> = _Tp;
pub type std__Deque_iterator_pointer<_Ptr> = _Ptr;
pub type std__Deque_iterator_reference<_Ref> = _Ref;
pub type std__Deque_iterator_size_type = usize;
pub type std__Deque_iterator_difference_type = isize;
pub type std__Deque_iterator__Map_pointer<_Tp> = *mut *mut _Tp;
pub type std__Deque_iterator__Self<_Tp> = std__Deque_iterator<_Tp>;
#[repr(C)]
pub struct std__Deque_base<_Tp> {
    pub _M_impl: std__Deque_base__Deque_impl<_Tp>,
}
pub type std__Deque_base_allocator_type<_Alloc> = _Alloc;
pub type std__Deque_base_iterator<_Tp> = std__Deque_iterator<_Tp>;
pub type std__Deque_base_const_iterator<_Tp> = std__Deque_iterator<_Tp>;
pub type std__Deque_base__Map_alloc_type = [u8; 0usize];
pub type std__Deque_base__Tp_alloc_type = [u8; 0usize];
#[repr(C)]
pub struct std__Deque_base__Deque_impl<_Tp> {
    pub _M_map: *mut *mut _Tp,
    pub _M_map_size: usize,
    pub _M_start: std__Deque_base_iterator<_Tp>,
    pub _M_finish: std__Deque_base_iterator<_Tp>,
}
pub const std__Deque_base__S_initial_map_size: std__Deque_base__bindgen_ty_1 =
    std__Deque_base__bindgen_ty_1::_S_initial_map_size;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum std__Deque_base__bindgen_ty_1 { _S_initial_map_size = 0, }
#[repr(C)]
pub struct std_deque<_Tp> {
    pub _base: std__Deque_base<_Tp>,
}
pub type std_deque__Alloc_value_type = [u8; 0usize];
pub type std_deque__Base<_Tp> = std__Deque_base<_Tp>;
pub type std_deque__Tp_alloc_type<_Tp> = std_deque__Base<_Tp>;
pub type std_deque_value_type<_Tp> = _Tp;
pub type std_deque_pointer<_Tp> = std_deque__Tp_alloc_type<_Tp>;
pub type std_deque_const_pointer<_Tp> = std_deque__Tp_alloc_type<_Tp>;
pub type std_deque_reference<_Tp> = std_deque__Tp_alloc_type<_Tp>;
pub type std_deque_const_reference<_Tp> = std_deque__Tp_alloc_type<_Tp>;
pub type std_deque_iterator<_Tp> = std_deque__Base<_Tp>;
pub type std_deque_const_iterator<_Tp> = std_deque__Base<_Tp>;
pub type std_deque_const_reverse_iterator =
    std_reverse_iterator<std_deque_const_iterator<_Tp>>;
pub type std_deque_reverse_iterator =
    std_reverse_iterator<std_deque_iterator<_Tp>>;
pub type std_deque_size_type = usize;
pub type std_deque_difference_type = isize;
pub type std_deque_allocator_type<_Alloc> = _Alloc;
pub type std_deque__Map_pointer<_Tp> = *mut std_deque_pointer<_Tp>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_stack<_Sequence> {
    pub c: _Sequence,
}
pub type std_stack__Sequence_value_type = [u8; 0usize];
pub type std_stack_value_type = [u8; 0usize];
pub type std_stack_reference = [u8; 0usize];
pub type std_stack_const_reference = [u8; 0usize];
pub type std_stack_size_type = [u8; 0usize];
pub type std_stack_container_type<_Sequence> = _Sequence;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum std__Rb_tree_color { _S_red = 0, _S_black = 1, }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct std__Rb_tree_node_base {
    pub _M_color: std__Rb_tree_color,
    pub _M_parent: std__Rb_tree_node_base__Base_ptr,
    pub _M_left: std__Rb_tree_node_base__Base_ptr,
    pub _M_right: std__Rb_tree_node_base__Base_ptr,
}
pub type std__Rb_tree_node_base__Base_ptr = *mut std__Rb_tree_node_base;
pub type std__Rb_tree_node_base__Const_Base_ptr =
    *const std__Rb_tree_node_base;
#[test]
fn bindgen_test_layout_std__Rb_tree_node_base() {
    assert_eq!(::std::mem::size_of::<std__Rb_tree_node_base>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( std__Rb_tree_node_base )
               ));
    assert_eq! (::std::mem::align_of::<std__Rb_tree_node_base>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( std__Rb_tree_node_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const std__Rb_tree_node_base ) ) . _M_color as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( std__Rb_tree_node_base
                ) , "::" , stringify ! ( _M_color ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const std__Rb_tree_node_base ) ) . _M_parent as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( std__Rb_tree_node_base
                ) , "::" , stringify ! ( _M_parent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const std__Rb_tree_node_base ) ) . _M_left as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( std__Rb_tree_node_base
                ) , "::" , stringify ! ( _M_left ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const std__Rb_tree_node_base ) ) . _M_right as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( std__Rb_tree_node_base
                ) , "::" , stringify ! ( _M_right ) ));
}
impl Clone for std__Rb_tree_node_base {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct std__Rb_tree_node {
    pub _base: std__Rb_tree_node_base,
    pub _M_storage: __gnu_cxx___aligned_buffer,
}
pub type std__Rb_tree_node__Link_type = *mut std__Rb_tree_node;
extern "C" {
    #[link_name =
          "?_Rb_tree_increment@std@@YAPEAU_Rb_tree_node_base@1@PEAU21@@Z"]
    pub fn std__Rb_tree_increment(__x: *mut std__Rb_tree_node_base)
     -> *mut std__Rb_tree_node_base;
}
extern "C" {
    #[link_name =
          "?_Rb_tree_increment@std@@YAPEBU_Rb_tree_node_base@1@PEBU21@@Z"]
    pub fn std__Rb_tree_increment1(__x: *const std__Rb_tree_node_base)
     -> *const std__Rb_tree_node_base;
}
extern "C" {
    #[link_name =
          "?_Rb_tree_decrement@std@@YAPEAU_Rb_tree_node_base@1@PEAU21@@Z"]
    pub fn std__Rb_tree_decrement(__x: *mut std__Rb_tree_node_base)
     -> *mut std__Rb_tree_node_base;
}
extern "C" {
    #[link_name =
          "?_Rb_tree_decrement@std@@YAPEBU_Rb_tree_node_base@1@PEBU21@@Z"]
    pub fn std__Rb_tree_decrement1(__x: *const std__Rb_tree_node_base)
     -> *const std__Rb_tree_node_base;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Rb_tree_iterator {
    pub _M_node: std__Rb_tree_iterator__Base_ptr,
}
pub type std__Rb_tree_iterator_value_type<_Tp> = _Tp;
pub type std__Rb_tree_iterator_reference<_Tp> = *mut _Tp;
pub type std__Rb_tree_iterator_pointer<_Tp> = *mut _Tp;
pub type std__Rb_tree_iterator_iterator_category =
    std_bidirectional_iterator_tag;
pub type std__Rb_tree_iterator_difference_type = isize;
pub type std__Rb_tree_iterator__Self = std__Rb_tree_iterator;
pub type std__Rb_tree_iterator__Base_ptr = std__Rb_tree_node_base__Base_ptr;
pub type std__Rb_tree_iterator__Link_type = *mut std__Rb_tree_node;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Rb_tree_const_iterator {
    pub _M_node: std__Rb_tree_const_iterator__Base_ptr,
}
pub type std__Rb_tree_const_iterator_value_type<_Tp> = _Tp;
pub type std__Rb_tree_const_iterator_reference<_Tp> = *mut _Tp;
pub type std__Rb_tree_const_iterator_pointer<_Tp> = *mut _Tp;
pub type std__Rb_tree_const_iterator_iterator = std__Rb_tree_iterator;
pub type std__Rb_tree_const_iterator_iterator_category =
    std_bidirectional_iterator_tag;
pub type std__Rb_tree_const_iterator_difference_type = isize;
pub type std__Rb_tree_const_iterator__Self = std__Rb_tree_const_iterator;
pub type std__Rb_tree_const_iterator__Base_ptr =
    std__Rb_tree_node_base__Const_Base_ptr;
pub type std__Rb_tree_const_iterator__Link_type = *const std__Rb_tree_node;
extern "C" {
    #[link_name =
          "?_Rb_tree_insert_and_rebalance@std@@YAX_NPEAU_Rb_tree_node_base@1@1AEAU21@@Z"]
    pub fn std__Rb_tree_insert_and_rebalance(__insert_left: bool,
                                             __x: *mut std__Rb_tree_node_base,
                                             __p: *mut std__Rb_tree_node_base,
                                             __header:
                                                 *mut std__Rb_tree_node_base);
}
extern "C" {
    #[link_name =
          "?_Rb_tree_rebalance_for_erase@std@@YAPEAU_Rb_tree_node_base@1@QEAU21@AEAU21@@Z"]
    pub fn std__Rb_tree_rebalance_for_erase(__z:
                                                *const std__Rb_tree_node_base,
                                            __header:
                                                *mut std__Rb_tree_node_base)
     -> *mut std__Rb_tree_node_base;
}
#[repr(C)]
pub struct std__Rb_tree<_Compare> {
    pub _M_impl: u8,
}
pub type std__Rb_tree__Node_allocator = __gnu_cxx___alloc_traits;
pub type std__Rb_tree__Alloc_traits = __gnu_cxx___alloc_traits;
pub type std__Rb_tree__Base_ptr = *mut std__Rb_tree_node_base;
pub type std__Rb_tree__Const_Base_ptr = *const std__Rb_tree_node_base;
pub type std__Rb_tree_key_type<_Key> = _Key;
pub type std__Rb_tree_value_type<_Val> = _Val;
pub type std__Rb_tree_pointer<_Val> = *mut std__Rb_tree_value_type<_Val>;
pub type std__Rb_tree_const_pointer<_Val> =
    *const std__Rb_tree_value_type<_Val>;
pub type std__Rb_tree_reference<_Val> = *mut std__Rb_tree_value_type<_Val>;
pub type std__Rb_tree_const_reference<_Val> =
    *const std__Rb_tree_value_type<_Val>;
pub type std__Rb_tree__Link_type = *mut std__Rb_tree_node;
pub type std__Rb_tree__Const_Link_type = *const std__Rb_tree_node;
pub type std__Rb_tree_size_type = usize;
pub type std__Rb_tree_difference_type = isize;
pub type std__Rb_tree_allocator_type<_Alloc> = _Alloc;
pub type std__Rb_tree_reverse_iterator =
    std_reverse_iterator<std__Rb_tree_iterator>;
pub type std__Rb_tree_const_reverse_iterator =
    std_reverse_iterator<std__Rb_tree_const_iterator>;
extern "C" {
    #[link_name =
          "?_Rb_tree_black_count@std@@YAIPEBU_Rb_tree_node_base@1@0@Z"]
    pub fn std__Rb_tree_black_count(__node: *const std__Rb_tree_node_base,
                                    __root: *const std__Rb_tree_node_base)
     -> ::std::os::raw::c_uint;
}
#[repr(C)]
pub struct std_map {
    pub _M_t: std_map__Rep_type,
}
pub type std_map_key_type<_Key> = _Key;
pub type std_map_mapped_type<_Tp> = _Tp;
pub type std_map_value_type<_Key, _Tp> = std_pair<_Key, _Tp>;
pub type std_map_key_compare<_Compare> = _Compare;
pub type std_map_allocator_type<_Alloc> = _Alloc;
pub type std_map__Alloc_value_type = [u8; 0usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_map_value_compare<_Compare> {
    pub comp: _Compare,
}
pub type std_map__Pair_alloc_type = __gnu_cxx___alloc_traits;
pub type std_map__Rep_type = std__Rb_tree<std_map_key_compare<_Compare>>;
pub type std_map__Alloc_traits = __gnu_cxx___alloc_traits;
pub type std_map_pointer = std_map__Alloc_traits;
pub type std_map_const_pointer = std_map__Alloc_traits;
pub type std_map_reference = std_map__Alloc_traits;
pub type std_map_const_reference = std_map__Alloc_traits;
pub type std_map_iterator = std_map__Rep_type;
pub type std_map_const_iterator = std_map__Rep_type;
pub type std_map_size_type = std_map__Rep_type;
pub type std_map_difference_type = std_map__Rep_type;
pub type std_map_reverse_iterator = std_map__Rep_type;
pub type std_map_const_reverse_iterator = std_map__Rep_type;
#[repr(C)]
pub struct std_multimap {
    pub _M_t: std_multimap__Rep_type,
}
pub type std_multimap_key_type<_Key> = _Key;
pub type std_multimap_mapped_type<_Tp> = _Tp;
pub type std_multimap_value_type<_Key, _Tp> = std_pair<_Key, _Tp>;
pub type std_multimap_key_compare<_Compare> = _Compare;
pub type std_multimap_allocator_type<_Alloc> = _Alloc;
pub type std_multimap__Alloc_value_type = [u8; 0usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_multimap_value_compare<_Compare> {
    pub comp: _Compare,
}
pub type std_multimap__Pair_alloc_type = __gnu_cxx___alloc_traits;
pub type std_multimap__Rep_type =
    std__Rb_tree<std_multimap_key_compare<_Compare>>;
pub type std_multimap__Alloc_traits = __gnu_cxx___alloc_traits;
pub type std_multimap_pointer = std_multimap__Alloc_traits;
pub type std_multimap_const_pointer = std_multimap__Alloc_traits;
pub type std_multimap_reference = std_multimap__Alloc_traits;
pub type std_multimap_const_reference = std_multimap__Alloc_traits;
pub type std_multimap_iterator = std_multimap__Rep_type;
pub type std_multimap_const_iterator = std_multimap__Rep_type;
pub type std_multimap_size_type = std_multimap__Rep_type;
pub type std_multimap_difference_type = std_multimap__Rep_type;
pub type std_multimap_reverse_iterator = std_multimap__Rep_type;
pub type std_multimap_const_reverse_iterator = std_multimap__Rep_type;
#[repr(C)]
pub struct std_set {
    pub _M_t: std_set__Rep_type,
}
pub type std_set__Alloc_value_type = [u8; 0usize];
pub type std_set_key_type<_Key> = _Key;
pub type std_set_value_type<_Key> = _Key;
pub type std_set_key_compare<_Compare> = _Compare;
pub type std_set_value_compare<_Compare> = _Compare;
pub type std_set_allocator_type<_Alloc> = _Alloc;
pub type std_set__Key_alloc_type = __gnu_cxx___alloc_traits;
pub type std_set__Rep_type = std__Rb_tree<std_set_key_compare<_Compare>>;
pub type std_set__Alloc_traits = __gnu_cxx___alloc_traits;
pub type std_set_pointer = std_set__Alloc_traits;
pub type std_set_const_pointer = std_set__Alloc_traits;
pub type std_set_reference = std_set__Alloc_traits;
pub type std_set_const_reference = std_set__Alloc_traits;
pub type std_set_iterator = std_set__Rep_type;
pub type std_set_const_iterator = std_set__Rep_type;
pub type std_set_reverse_iterator = std_set__Rep_type;
pub type std_set_const_reverse_iterator = std_set__Rep_type;
pub type std_set_size_type = std_set__Rep_type;
pub type std_set_difference_type = std_set__Rep_type;
#[repr(C)]
pub struct std_multiset {
    pub _M_t: std_multiset__Rep_type,
}
pub type std_multiset__Alloc_value_type = [u8; 0usize];
pub type std_multiset_key_type<_Key> = _Key;
pub type std_multiset_value_type<_Key> = _Key;
pub type std_multiset_key_compare<_Compare> = _Compare;
pub type std_multiset_value_compare<_Compare> = _Compare;
pub type std_multiset_allocator_type<_Alloc> = _Alloc;
pub type std_multiset__Key_alloc_type = __gnu_cxx___alloc_traits;
pub type std_multiset__Rep_type =
    std__Rb_tree<std_multiset_key_compare<_Compare>>;
pub type std_multiset__Alloc_traits = __gnu_cxx___alloc_traits;
pub type std_multiset_pointer = std_multiset__Alloc_traits;
pub type std_multiset_const_pointer = std_multiset__Alloc_traits;
pub type std_multiset_reference = std_multiset__Alloc_traits;
pub type std_multiset_const_reference = std_multiset__Alloc_traits;
pub type std_multiset_iterator = std_multiset__Rep_type;
pub type std_multiset_const_iterator = std_multiset__Rep_type;
pub type std_multiset_reverse_iterator = std_multiset__Rep_type;
pub type std_multiset_const_reverse_iterator = std_multiset__Rep_type;
pub type std_multiset_size_type = std_multiset__Rep_type;
pub type std_multiset_difference_type = std_multiset__Rep_type;
pub type __gnuc_va_list = __builtin_va_list;
pub type va_list = __gnuc_va_list;
extern "C" {
    pub fn __mingw_get_crt_info() -> *const ::std::os::raw::c_char;
}
pub type rsize_t = usize;
pub type wint_t = ::std::os::raw::c_ushort;
pub type wctype_t = ::std::os::raw::c_ushort;
pub type errno_t = ::std::os::raw::c_int;
pub type __time32_t = ::std::os::raw::c_long;
pub type __time64_t = ::std::os::raw::c_longlong;
pub type time_t = __time64_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct threadlocaleinfostruct {
    pub refcount: ::std::os::raw::c_int,
    pub lc_codepage: ::std::os::raw::c_uint,
    pub lc_collate_cp: ::std::os::raw::c_uint,
    pub lc_handle: [::std::os::raw::c_ulong; 6usize],
    pub lc_id: [LC_ID; 6usize],
    pub lc_category: [threadlocaleinfostruct__bindgen_ty_1; 6usize],
    pub lc_clike: ::std::os::raw::c_int,
    pub mb_cur_max: ::std::os::raw::c_int,
    pub lconv_intl_refcount: *mut ::std::os::raw::c_int,
    pub lconv_num_refcount: *mut ::std::os::raw::c_int,
    pub lconv_mon_refcount: *mut ::std::os::raw::c_int,
    pub lconv: *mut lconv,
    pub ctype1_refcount: *mut ::std::os::raw::c_int,
    pub ctype1: *mut ::std::os::raw::c_ushort,
    pub pctype: *const ::std::os::raw::c_ushort,
    pub pclmap: *const ::std::os::raw::c_uchar,
    pub pcumap: *const ::std::os::raw::c_uchar,
    pub lc_time_curr: *mut __lc_time_data,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct threadlocaleinfostruct__bindgen_ty_1 {
    pub locale: *mut ::std::os::raw::c_char,
    pub wlocale: *mut u16,
    pub refcount: *mut ::std::os::raw::c_int,
    pub wrefcount: *mut ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_threadlocaleinfostruct__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<threadlocaleinfostruct__bindgen_ty_1>() ,
               32usize , concat ! (
               "Size of: " , stringify ! (
               threadlocaleinfostruct__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<threadlocaleinfostruct__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                threadlocaleinfostruct__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const threadlocaleinfostruct__bindgen_ty_1 ) )
                . locale as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                threadlocaleinfostruct__bindgen_ty_1 ) , "::" , stringify ! (
                locale ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const threadlocaleinfostruct__bindgen_ty_1 ) )
                . wlocale as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                threadlocaleinfostruct__bindgen_ty_1 ) , "::" , stringify ! (
                wlocale ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const threadlocaleinfostruct__bindgen_ty_1 ) )
                . refcount as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                threadlocaleinfostruct__bindgen_ty_1 ) , "::" , stringify ! (
                refcount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const threadlocaleinfostruct__bindgen_ty_1 ) )
                . wrefcount as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                threadlocaleinfostruct__bindgen_ty_1 ) , "::" , stringify ! (
                wrefcount ) ));
}
impl Clone for threadlocaleinfostruct__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_threadlocaleinfostruct() {
    assert_eq!(::std::mem::size_of::<threadlocaleinfostruct>() , 352usize ,
               concat ! ( "Size of: " , stringify ! ( threadlocaleinfostruct )
               ));
    assert_eq! (::std::mem::align_of::<threadlocaleinfostruct>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( threadlocaleinfostruct ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const threadlocaleinfostruct ) ) . refcount as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( threadlocaleinfostruct
                ) , "::" , stringify ! ( refcount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const threadlocaleinfostruct ) ) . lc_codepage
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( threadlocaleinfostruct
                ) , "::" , stringify ! ( lc_codepage ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const threadlocaleinfostruct ) ) .
                lc_collate_cp as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( threadlocaleinfostruct
                ) , "::" , stringify ! ( lc_collate_cp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const threadlocaleinfostruct ) ) . lc_handle as
                * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( threadlocaleinfostruct
                ) , "::" , stringify ! ( lc_handle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const threadlocaleinfostruct ) ) . lc_id as *
                const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( threadlocaleinfostruct
                ) , "::" , stringify ! ( lc_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const threadlocaleinfostruct ) ) . lc_category
                as * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( threadlocaleinfostruct
                ) , "::" , stringify ! ( lc_category ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const threadlocaleinfostruct ) ) . lc_clike as
                * const _ as usize } , 264usize , concat ! (
                "Alignment of field: " , stringify ! ( threadlocaleinfostruct
                ) , "::" , stringify ! ( lc_clike ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const threadlocaleinfostruct ) ) . mb_cur_max
                as * const _ as usize } , 268usize , concat ! (
                "Alignment of field: " , stringify ! ( threadlocaleinfostruct
                ) , "::" , stringify ! ( mb_cur_max ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const threadlocaleinfostruct ) ) .
                lconv_intl_refcount as * const _ as usize } , 272usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( threadlocaleinfostruct
                ) , "::" , stringify ! ( lconv_intl_refcount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const threadlocaleinfostruct ) ) .
                lconv_num_refcount as * const _ as usize } , 280usize , concat
                ! (
                "Alignment of field: " , stringify ! ( threadlocaleinfostruct
                ) , "::" , stringify ! ( lconv_num_refcount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const threadlocaleinfostruct ) ) .
                lconv_mon_refcount as * const _ as usize } , 288usize , concat
                ! (
                "Alignment of field: " , stringify ! ( threadlocaleinfostruct
                ) , "::" , stringify ! ( lconv_mon_refcount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const threadlocaleinfostruct ) ) . lconv as *
                const _ as usize } , 296usize , concat ! (
                "Alignment of field: " , stringify ! ( threadlocaleinfostruct
                ) , "::" , stringify ! ( lconv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const threadlocaleinfostruct ) ) .
                ctype1_refcount as * const _ as usize } , 304usize , concat !
                (
                "Alignment of field: " , stringify ! ( threadlocaleinfostruct
                ) , "::" , stringify ! ( ctype1_refcount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const threadlocaleinfostruct ) ) . ctype1 as *
                const _ as usize } , 312usize , concat ! (
                "Alignment of field: " , stringify ! ( threadlocaleinfostruct
                ) , "::" , stringify ! ( ctype1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const threadlocaleinfostruct ) ) . pctype as *
                const _ as usize } , 320usize , concat ! (
                "Alignment of field: " , stringify ! ( threadlocaleinfostruct
                ) , "::" , stringify ! ( pctype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const threadlocaleinfostruct ) ) . pclmap as *
                const _ as usize } , 328usize , concat ! (
                "Alignment of field: " , stringify ! ( threadlocaleinfostruct
                ) , "::" , stringify ! ( pclmap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const threadlocaleinfostruct ) ) . pcumap as *
                const _ as usize } , 336usize , concat ! (
                "Alignment of field: " , stringify ! ( threadlocaleinfostruct
                ) , "::" , stringify ! ( pcumap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const threadlocaleinfostruct ) ) . lc_time_curr
                as * const _ as usize } , 344usize , concat ! (
                "Alignment of field: " , stringify ! ( threadlocaleinfostruct
                ) , "::" , stringify ! ( lc_time_curr ) ));
}
impl Clone for threadlocaleinfostruct {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct threadmbcinfostruct([u8; 0]);
pub type pthreadlocinfo = *mut threadlocaleinfostruct;
pub type pthreadmbcinfo = *mut threadmbcinfostruct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __lc_time_data([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy)]
pub struct localeinfo_struct {
    pub locinfo: pthreadlocinfo,
    pub mbcinfo: pthreadmbcinfo,
}
#[test]
fn bindgen_test_layout_localeinfo_struct() {
    assert_eq!(::std::mem::size_of::<localeinfo_struct>() , 16usize , concat !
               ( "Size of: " , stringify ! ( localeinfo_struct ) ));
    assert_eq! (::std::mem::align_of::<localeinfo_struct>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( localeinfo_struct ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const localeinfo_struct ) ) . locinfo as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( localeinfo_struct ) ,
                "::" , stringify ! ( locinfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const localeinfo_struct ) ) . mbcinfo as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( localeinfo_struct ) ,
                "::" , stringify ! ( mbcinfo ) ));
}
impl Clone for localeinfo_struct {
    fn clone(&self) -> Self { *self }
}
pub type _locale_tstruct = localeinfo_struct;
pub type _locale_t = *mut localeinfo_struct;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tagLC_ID {
    pub wLanguage: ::std::os::raw::c_ushort,
    pub wCountry: ::std::os::raw::c_ushort,
    pub wCodePage: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_tagLC_ID() {
    assert_eq!(::std::mem::size_of::<tagLC_ID>() , 6usize , concat ! (
               "Size of: " , stringify ! ( tagLC_ID ) ));
    assert_eq! (::std::mem::align_of::<tagLC_ID>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( tagLC_ID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tagLC_ID ) ) . wLanguage as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tagLC_ID ) , "::" ,
                stringify ! ( wLanguage ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tagLC_ID ) ) . wCountry as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( tagLC_ID ) , "::" ,
                stringify ! ( wCountry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tagLC_ID ) ) . wCodePage as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( tagLC_ID ) , "::" ,
                stringify ! ( wCodePage ) ));
}
impl Clone for tagLC_ID {
    fn clone(&self) -> Self { *self }
}
pub type LC_ID = tagLC_ID;
pub type LPLC_ID = *mut tagLC_ID;
pub type threadlocinfo = threadlocaleinfostruct;
extern "C" {
    pub fn _errno() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn _set_errno(_Value: ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn _get_errno(_Value: *mut ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn __threadid() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __threadhandle() -> usize;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct max_align_t {
    pub __max_align_ll: ::std::os::raw::c_longlong,
    pub __max_align_ld: f64,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(::std::mem::size_of::<max_align_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( max_align_t ) ));
    assert_eq! (::std::mem::align_of::<max_align_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( max_align_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const max_align_t ) ) . __max_align_ll as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( max_align_t ) , "::" ,
                stringify ! ( __max_align_ll ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const max_align_t ) ) . __max_align_ld as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( max_align_t ) , "::" ,
                stringify ! ( __max_align_ld ) ));
}
impl Clone for max_align_t {
    fn clone(&self) -> Self { *self }
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type int_least32_t = ::std::os::raw::c_int;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type int_least64_t = ::std::os::raw::c_longlong;
pub type uint_least64_t = ::std::os::raw::c_ulonglong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type int_fast16_t = ::std::os::raw::c_short;
pub type uint_fast16_t = ::std::os::raw::c_ushort;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type int_fast64_t = ::std::os::raw::c_longlong;
pub type uint_fast64_t = ::std::os::raw::c_ulonglong;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
pub type octave_idx_type = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _SETJMP_FLOAT128 {
    pub Part: [::std::os::raw::c_ulonglong; 2usize],
}
#[test]
fn bindgen_test_layout__SETJMP_FLOAT128() {
    assert_eq!(::std::mem::size_of::<_SETJMP_FLOAT128>() , 16usize , concat !
               ( "Size of: " , stringify ! ( _SETJMP_FLOAT128 ) ));
    assert_eq! (::std::mem::align_of::<_SETJMP_FLOAT128>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( _SETJMP_FLOAT128 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _SETJMP_FLOAT128 ) ) . Part as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _SETJMP_FLOAT128 ) ,
                "::" , stringify ! ( Part ) ));
}
impl Clone for _SETJMP_FLOAT128 {
    fn clone(&self) -> Self { *self }
}
pub type SETJMP_FLOAT128 = _SETJMP_FLOAT128;
pub type _JBTYPE = SETJMP_FLOAT128;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _JUMP_BUFFER {
    pub Frame: ::std::os::raw::c_ulonglong,
    pub Rbx: ::std::os::raw::c_ulonglong,
    pub Rsp: ::std::os::raw::c_ulonglong,
    pub Rbp: ::std::os::raw::c_ulonglong,
    pub Rsi: ::std::os::raw::c_ulonglong,
    pub Rdi: ::std::os::raw::c_ulonglong,
    pub R12: ::std::os::raw::c_ulonglong,
    pub R13: ::std::os::raw::c_ulonglong,
    pub R14: ::std::os::raw::c_ulonglong,
    pub R15: ::std::os::raw::c_ulonglong,
    pub Rip: ::std::os::raw::c_ulonglong,
    pub Spare: ::std::os::raw::c_ulonglong,
    pub Xmm6: SETJMP_FLOAT128,
    pub Xmm7: SETJMP_FLOAT128,
    pub Xmm8: SETJMP_FLOAT128,
    pub Xmm9: SETJMP_FLOAT128,
    pub Xmm10: SETJMP_FLOAT128,
    pub Xmm11: SETJMP_FLOAT128,
    pub Xmm12: SETJMP_FLOAT128,
    pub Xmm13: SETJMP_FLOAT128,
    pub Xmm14: SETJMP_FLOAT128,
    pub Xmm15: SETJMP_FLOAT128,
}
#[test]
fn bindgen_test_layout__JUMP_BUFFER() {
    assert_eq!(::std::mem::size_of::<_JUMP_BUFFER>() , 256usize , concat ! (
               "Size of: " , stringify ! ( _JUMP_BUFFER ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _JUMP_BUFFER ) ) . Frame as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _JUMP_BUFFER ) , "::" ,
                stringify ! ( Frame ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _JUMP_BUFFER ) ) . Rbx as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _JUMP_BUFFER ) , "::" ,
                stringify ! ( Rbx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _JUMP_BUFFER ) ) . Rsp as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _JUMP_BUFFER ) , "::" ,
                stringify ! ( Rsp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _JUMP_BUFFER ) ) . Rbp as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _JUMP_BUFFER ) , "::" ,
                stringify ! ( Rbp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _JUMP_BUFFER ) ) . Rsi as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _JUMP_BUFFER ) , "::" ,
                stringify ! ( Rsi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _JUMP_BUFFER ) ) . Rdi as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _JUMP_BUFFER ) , "::" ,
                stringify ! ( Rdi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _JUMP_BUFFER ) ) . R12 as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _JUMP_BUFFER ) , "::" ,
                stringify ! ( R12 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _JUMP_BUFFER ) ) . R13 as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( _JUMP_BUFFER ) , "::" ,
                stringify ! ( R13 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _JUMP_BUFFER ) ) . R14 as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( _JUMP_BUFFER ) , "::" ,
                stringify ! ( R14 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _JUMP_BUFFER ) ) . R15 as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( _JUMP_BUFFER ) , "::" ,
                stringify ! ( R15 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _JUMP_BUFFER ) ) . Rip as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( _JUMP_BUFFER ) , "::" ,
                stringify ! ( Rip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _JUMP_BUFFER ) ) . Spare as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( _JUMP_BUFFER ) , "::" ,
                stringify ! ( Spare ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _JUMP_BUFFER ) ) . Xmm6 as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( _JUMP_BUFFER ) , "::" ,
                stringify ! ( Xmm6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _JUMP_BUFFER ) ) . Xmm7 as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( _JUMP_BUFFER ) , "::" ,
                stringify ! ( Xmm7 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _JUMP_BUFFER ) ) . Xmm8 as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( _JUMP_BUFFER ) , "::" ,
                stringify ! ( Xmm8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _JUMP_BUFFER ) ) . Xmm9 as * const _ as
                usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( _JUMP_BUFFER ) , "::" ,
                stringify ! ( Xmm9 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _JUMP_BUFFER ) ) . Xmm10 as * const _ as
                usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( _JUMP_BUFFER ) , "::" ,
                stringify ! ( Xmm10 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _JUMP_BUFFER ) ) . Xmm11 as * const _ as
                usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( _JUMP_BUFFER ) , "::" ,
                stringify ! ( Xmm11 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _JUMP_BUFFER ) ) . Xmm12 as * const _ as
                usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( _JUMP_BUFFER ) , "::" ,
                stringify ! ( Xmm12 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _JUMP_BUFFER ) ) . Xmm13 as * const _ as
                usize } , 208usize , concat ! (
                "Alignment of field: " , stringify ! ( _JUMP_BUFFER ) , "::" ,
                stringify ! ( Xmm13 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _JUMP_BUFFER ) ) . Xmm14 as * const _ as
                usize } , 224usize , concat ! (
                "Alignment of field: " , stringify ! ( _JUMP_BUFFER ) , "::" ,
                stringify ! ( Xmm14 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _JUMP_BUFFER ) ) . Xmm15 as * const _ as
                usize } , 240usize , concat ! (
                "Alignment of field: " , stringify ! ( _JUMP_BUFFER ) , "::" ,
                stringify ! ( Xmm15 ) ));
}
impl Clone for _JUMP_BUFFER {
    fn clone(&self) -> Self { *self }
}
pub type jmp_buf = [_JBTYPE; 16usize];
extern "C" {
    pub fn mingw_getsp() -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _setjmp(_Buf: *mut _JBTYPE, _Ctx: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _setjmp3(_Buf: *mut _JBTYPE, _Ctx: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ms_longjmp(_Buf: *mut _JBTYPE, _Value: ::std::os::raw::c_int);
}
extern "C" {
    pub fn longjmp(_Buf: *mut _JBTYPE, _Value: ::std::os::raw::c_int);
}
pub type sig_atomic_t = ::std::os::raw::c_int;
pub type __p_sig_fn_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
extern "C" {
    pub fn __pxcptinfoptrs() -> *mut *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn signal(_SigNum: ::std::os::raw::c_int, _Func: __p_sig_fn_t)
     -> __p_sig_fn_t;
}
extern "C" {
    pub fn raise(_SigNum: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___normal_iterator<_Iterator> {
    pub _M_current: _Iterator,
}
pub type __gnu_cxx___normal_iterator___traits_type = std_iterator_traits;
pub type __gnu_cxx___normal_iterator_iterator_type<_Iterator> = _Iterator;
pub type __gnu_cxx___normal_iterator_iterator_category =
    __gnu_cxx___normal_iterator___traits_type;
pub type __gnu_cxx___normal_iterator_value_type =
    __gnu_cxx___normal_iterator___traits_type;
pub type __gnu_cxx___normal_iterator_difference_type =
    __gnu_cxx___normal_iterator___traits_type;
pub type __gnu_cxx___normal_iterator_reference =
    __gnu_cxx___normal_iterator___traits_type;
pub type __gnu_cxx___normal_iterator_pointer =
    __gnu_cxx___normal_iterator___traits_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___add_unsigned {
    pub _address: u8,
}
pub type __gnu_cxx___add_unsigned___if_type = u8;
pub type __gnu_cxx___add_unsigned___type = __gnu_cxx___add_unsigned___if_type;
#[test]
fn __bindgen_test_layout___gnu_cxx___add_unsigned_instantiation_870() {
    assert_eq!(::std::mem::size_of::<__gnu_cxx___add_unsigned>() , 1usize ,
               concat ! (
               "Size of template specialization: " , stringify ! (
               __gnu_cxx___add_unsigned ) ));
    assert_eq!(::std::mem::align_of::<__gnu_cxx___add_unsigned>() , 1usize ,
               concat ! (
               "Alignment of template specialization: " , stringify ! (
               __gnu_cxx___add_unsigned ) ));
}
#[test]
fn __bindgen_test_layout___gnu_cxx___add_unsigned_instantiation_874() {
    assert_eq!(::std::mem::size_of::<__gnu_cxx___add_unsigned>() , 1usize ,
               concat ! (
               "Size of template specialization: " , stringify ! (
               __gnu_cxx___add_unsigned ) ));
    assert_eq!(::std::mem::align_of::<__gnu_cxx___add_unsigned>() , 1usize ,
               concat ! (
               "Alignment of template specialization: " , stringify ! (
               __gnu_cxx___add_unsigned ) ));
}
#[test]
fn __bindgen_test_layout___gnu_cxx___add_unsigned_instantiation_878() {
    assert_eq!(::std::mem::size_of::<__gnu_cxx___add_unsigned>() , 1usize ,
               concat ! (
               "Size of template specialization: " , stringify ! (
               __gnu_cxx___add_unsigned ) ));
    assert_eq!(::std::mem::align_of::<__gnu_cxx___add_unsigned>() , 1usize ,
               concat ! (
               "Alignment of template specialization: " , stringify ! (
               __gnu_cxx___add_unsigned ) ));
}
#[test]
fn __bindgen_test_layout___gnu_cxx___add_unsigned_instantiation_882() {
    assert_eq!(::std::mem::size_of::<__gnu_cxx___add_unsigned>() , 1usize ,
               concat ! (
               "Size of template specialization: " , stringify ! (
               __gnu_cxx___add_unsigned ) ));
    assert_eq!(::std::mem::align_of::<__gnu_cxx___add_unsigned>() , 1usize ,
               concat ! (
               "Alignment of template specialization: " , stringify ! (
               __gnu_cxx___add_unsigned ) ));
}
#[test]
fn __bindgen_test_layout___gnu_cxx___add_unsigned_instantiation_886() {
    assert_eq!(::std::mem::size_of::<__gnu_cxx___add_unsigned>() , 1usize ,
               concat ! (
               "Size of template specialization: " , stringify ! (
               __gnu_cxx___add_unsigned ) ));
    assert_eq!(::std::mem::align_of::<__gnu_cxx___add_unsigned>() , 1usize ,
               concat ! (
               "Alignment of template specialization: " , stringify ! (
               __gnu_cxx___add_unsigned ) ));
}
#[test]
fn __bindgen_test_layout___gnu_cxx___add_unsigned_instantiation_890() {
    assert_eq!(::std::mem::size_of::<__gnu_cxx___add_unsigned>() , 1usize ,
               concat ! (
               "Size of template specialization: " , stringify ! (
               __gnu_cxx___add_unsigned ) ));
    assert_eq!(::std::mem::align_of::<__gnu_cxx___add_unsigned>() , 1usize ,
               concat ! (
               "Alignment of template specialization: " , stringify ! (
               __gnu_cxx___add_unsigned ) ));
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___remove_unsigned {
    pub _address: u8,
}
pub type __gnu_cxx___remove_unsigned___if_type = u8;
pub type __gnu_cxx___remove_unsigned___type =
    __gnu_cxx___remove_unsigned___if_type;
#[test]
fn __bindgen_test_layout___gnu_cxx___remove_unsigned_instantiation_910() {
    assert_eq!(::std::mem::size_of::<__gnu_cxx___remove_unsigned>() , 1usize ,
               concat ! (
               "Size of template specialization: " , stringify ! (
               __gnu_cxx___remove_unsigned ) ));
    assert_eq!(::std::mem::align_of::<__gnu_cxx___remove_unsigned>() , 1usize
               , concat ! (
               "Alignment of template specialization: " , stringify ! (
               __gnu_cxx___remove_unsigned ) ));
}
#[test]
fn __bindgen_test_layout___gnu_cxx___remove_unsigned_instantiation_914() {
    assert_eq!(::std::mem::size_of::<__gnu_cxx___remove_unsigned>() , 1usize ,
               concat ! (
               "Size of template specialization: " , stringify ! (
               __gnu_cxx___remove_unsigned ) ));
    assert_eq!(::std::mem::align_of::<__gnu_cxx___remove_unsigned>() , 1usize
               , concat ! (
               "Alignment of template specialization: " , stringify ! (
               __gnu_cxx___remove_unsigned ) ));
}
#[test]
fn __bindgen_test_layout___gnu_cxx___remove_unsigned_instantiation_918() {
    assert_eq!(::std::mem::size_of::<__gnu_cxx___remove_unsigned>() , 1usize ,
               concat ! (
               "Size of template specialization: " , stringify ! (
               __gnu_cxx___remove_unsigned ) ));
    assert_eq!(::std::mem::align_of::<__gnu_cxx___remove_unsigned>() , 1usize
               , concat ! (
               "Alignment of template specialization: " , stringify ! (
               __gnu_cxx___remove_unsigned ) ));
}
#[test]
fn __bindgen_test_layout___gnu_cxx___remove_unsigned_instantiation_922() {
    assert_eq!(::std::mem::size_of::<__gnu_cxx___remove_unsigned>() , 1usize ,
               concat ! (
               "Size of template specialization: " , stringify ! (
               __gnu_cxx___remove_unsigned ) ));
    assert_eq!(::std::mem::align_of::<__gnu_cxx___remove_unsigned>() , 1usize
               , concat ! (
               "Alignment of template specialization: " , stringify ! (
               __gnu_cxx___remove_unsigned ) ));
}
#[test]
fn __bindgen_test_layout___gnu_cxx___remove_unsigned_instantiation_926() {
    assert_eq!(::std::mem::size_of::<__gnu_cxx___remove_unsigned>() , 1usize ,
               concat ! (
               "Size of template specialization: " , stringify ! (
               __gnu_cxx___remove_unsigned ) ));
    assert_eq!(::std::mem::align_of::<__gnu_cxx___remove_unsigned>() , 1usize
               , concat ! (
               "Alignment of template specialization: " , stringify ! (
               __gnu_cxx___remove_unsigned ) ));
}
#[test]
fn __bindgen_test_layout___gnu_cxx___remove_unsigned_instantiation_930() {
    assert_eq!(::std::mem::size_of::<__gnu_cxx___remove_unsigned>() , 1usize ,
               concat ! (
               "Size of template specialization: " , stringify ! (
               __gnu_cxx___remove_unsigned ) ));
    assert_eq!(::std::mem::align_of::<__gnu_cxx___remove_unsigned>() , 1usize
               , concat ! (
               "Alignment of template specialization: " , stringify ! (
               __gnu_cxx___remove_unsigned ) ));
}
#[test]
fn __bindgen_test_layout___gnu_cxx___promote_instantiation_954() {
    assert_eq!(::std::mem::size_of::<u8>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! ( u8 ) ));
    assert_eq!(::std::mem::align_of::<u8>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! ( u8 )
               ));
}
#[test]
fn __bindgen_test_layout___gnu_cxx___promote_instantiation_958() {
    assert_eq!(::std::mem::size_of::<u8>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! ( u8 ) ));
    assert_eq!(::std::mem::align_of::<u8>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! ( u8 )
               ));
}
#[test]
fn __bindgen_test_layout___gnu_cxx___promote_instantiation_962() {
    assert_eq!(::std::mem::size_of::<u8>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! ( u8 ) ));
    assert_eq!(::std::mem::align_of::<u8>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! ( u8 )
               ));
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___promote_2 {
    pub _address: u8,
}
pub type __gnu_cxx___promote_2___type<_Tp2> = _Tp2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___promote_3 {
    pub _address: u8,
}
pub type __gnu_cxx___promote_3___type<_Tp2> = _Tp2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___promote_4 {
    pub _address: u8,
}
pub type __gnu_cxx___promote_4___type<_Tp2> = _Tp2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___numeric_traits_integer {
    pub _address: u8,
}
extern "C" {
    #[link_name = "__min"]
    pub static __gnu_cxx___min: _Value;
}
extern "C" {
    #[link_name = "__max"]
    pub static __gnu_cxx___max: _Value;
}
extern "C" {
    #[link_name = "__is_signed"]
    pub static __gnu_cxx___is_signed: bool;
}
extern "C" {
    #[link_name = "__digits"]
    pub static __gnu_cxx___digits: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___numeric_traits_floating {
    pub _address: u8,
}
extern "C" {
    #[link_name = "__max_digits10"]
    pub static __gnu_cxx___max_digits10: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__digits10"]
    pub static __gnu_cxx___digits10: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__max_exponent10"]
    pub static __gnu_cxx___max_exponent10: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___numeric_traits {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __gnu_cxx___ops__Iter_less_iter {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout___gnu_cxx___ops__Iter_less_iter() {
    assert_eq!(::std::mem::size_of::<__gnu_cxx___ops__Iter_less_iter>() ,
               1usize , concat ! (
               "Size of: " , stringify ! ( __gnu_cxx___ops__Iter_less_iter )
               ));
    assert_eq! (::std::mem::align_of::<__gnu_cxx___ops__Iter_less_iter>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! (
                __gnu_cxx___ops__Iter_less_iter ) ));
}
impl Clone for __gnu_cxx___ops__Iter_less_iter {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __gnu_cxx___ops__Iter_less_val {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout___gnu_cxx___ops__Iter_less_val() {
    assert_eq!(::std::mem::size_of::<__gnu_cxx___ops__Iter_less_val>() ,
               1usize , concat ! (
               "Size of: " , stringify ! ( __gnu_cxx___ops__Iter_less_val )
               ));
    assert_eq! (::std::mem::align_of::<__gnu_cxx___ops__Iter_less_val>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! ( __gnu_cxx___ops__Iter_less_val
                ) ));
}
impl Clone for __gnu_cxx___ops__Iter_less_val {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __gnu_cxx___ops__Val_less_iter {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout___gnu_cxx___ops__Val_less_iter() {
    assert_eq!(::std::mem::size_of::<__gnu_cxx___ops__Val_less_iter>() ,
               1usize , concat ! (
               "Size of: " , stringify ! ( __gnu_cxx___ops__Val_less_iter )
               ));
    assert_eq! (::std::mem::align_of::<__gnu_cxx___ops__Val_less_iter>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! ( __gnu_cxx___ops__Val_less_iter
                ) ));
}
impl Clone for __gnu_cxx___ops__Val_less_iter {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __gnu_cxx___ops__Iter_equal_to_iter {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout___gnu_cxx___ops__Iter_equal_to_iter() {
    assert_eq!(::std::mem::size_of::<__gnu_cxx___ops__Iter_equal_to_iter>() ,
               1usize , concat ! (
               "Size of: " , stringify ! ( __gnu_cxx___ops__Iter_equal_to_iter
               ) ));
    assert_eq! (::std::mem::align_of::<__gnu_cxx___ops__Iter_equal_to_iter>()
                , 1usize , concat ! (
                "Alignment of " , stringify ! (
                __gnu_cxx___ops__Iter_equal_to_iter ) ));
}
impl Clone for __gnu_cxx___ops__Iter_equal_to_iter {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __gnu_cxx___ops__Iter_equal_to_val {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout___gnu_cxx___ops__Iter_equal_to_val() {
    assert_eq!(::std::mem::size_of::<__gnu_cxx___ops__Iter_equal_to_val>() ,
               1usize , concat ! (
               "Size of: " , stringify ! ( __gnu_cxx___ops__Iter_equal_to_val
               ) ));
    assert_eq! (::std::mem::align_of::<__gnu_cxx___ops__Iter_equal_to_val>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! (
                __gnu_cxx___ops__Iter_equal_to_val ) ));
}
impl Clone for __gnu_cxx___ops__Iter_equal_to_val {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___ops__Iter_comp_iter<_Compare> {
    pub _M_comp: _Compare,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___ops__Iter_comp_val<_Compare> {
    pub _M_comp: _Compare,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___ops__Val_comp_iter<_Compare> {
    pub _M_comp: _Compare,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___ops__Iter_equals_val<_Value> {
    pub _M_value: *mut _Value,
}
#[repr(C)]
pub struct __gnu_cxx___ops__Iter_equals_iter {
    pub _M_ref: std_iterator_traits,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___ops__Iter_pred<_Predicate> {
    pub _M_pred: _Predicate,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___ops__Iter_comp_to_val<_Compare, _Value> {
    pub _M_comp: _Compare,
    pub _M_value: *mut _Value,
}
#[repr(C)]
pub struct __gnu_cxx___ops__Iter_comp_to_iter<_Compare> {
    pub _M_comp: _Compare,
    pub _M_ref: std_iterator_traits,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___ops__Iter_negate<_Predicate> {
    pub _M_pred: _Predicate,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx__Char_types {
    pub _address: u8,
}
pub type __gnu_cxx__Char_types_int_type = ::std::os::raw::c_ulong;
pub type __gnu_cxx__Char_types_pos_type = std_streampos;
pub type __gnu_cxx__Char_types_off_type = std_streamoff;
pub type __gnu_cxx__Char_types_state_type = mbstate_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx_char_traits {
    pub _address: u8,
}
pub type __gnu_cxx_char_traits_char_type<_CharT> = _CharT;
pub type __gnu_cxx_char_traits_int_type = __gnu_cxx__Char_types;
pub type __gnu_cxx_char_traits_pos_type = __gnu_cxx__Char_types;
pub type __gnu_cxx_char_traits_off_type = __gnu_cxx__Char_types;
pub type __gnu_cxx_char_traits_state_type = __gnu_cxx__Char_types;
extern "C" {
    #[link_name = "?__verbose_terminate_handler@__gnu_cxx@@YAXXZ"]
    pub fn __gnu_cxx___verbose_terminate_handler();
}
#[repr(C)]
#[derive(Debug)]
pub struct __gnu_cxx_new_allocator {
    pub _address: u8,
}
pub type __gnu_cxx_new_allocator_size_type = usize;
pub type __gnu_cxx_new_allocator_difference_type = isize;
pub type __gnu_cxx_new_allocator_pointer<_Tp> = *mut _Tp;
pub type __gnu_cxx_new_allocator_const_pointer<_Tp> = *mut _Tp;
pub type __gnu_cxx_new_allocator_reference<_Tp> = *mut _Tp;
pub type __gnu_cxx_new_allocator_const_reference<_Tp> = *mut _Tp;
pub type __gnu_cxx_new_allocator_value_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx_new_allocator_rebind {
    pub _address: u8,
}
pub type __gnu_cxx_new_allocator_rebind_other = __gnu_cxx_new_allocator;
pub type __gnu_cxx_new_allocator_propagate_on_container_move_assignment =
    std_true_type;
#[repr(C)]
pub struct __gnu_cxx___allocator_always_compares_equal {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx_array_allocator {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx_bitmap_allocator {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx_malloc_allocator {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx_mt_allocator {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx_pool_allocator {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___alloc_traits {
    pub _address: u8,
}
pub type __gnu_cxx___alloc_traits_allocator_type<_Alloc> = _Alloc;
pub type __gnu_cxx___alloc_traits__Base_type = std_allocator_traits;
pub type __gnu_cxx___alloc_traits_value_type =
    __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_pointer =
    __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_const_pointer =
    __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_size_type =
    __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_difference_type =
    __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_reference =
    *mut __gnu_cxx___alloc_traits_value_type;
pub type __gnu_cxx___alloc_traits_const_reference =
    *const __gnu_cxx___alloc_traits_value_type;
pub type __gnu_cxx___alloc_traits___is_custom_pointer = std___and_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___alloc_traits_rebind {
    pub _address: u8,
}
pub type __gnu_cxx___alloc_traits_rebind_other =
    __gnu_cxx___alloc_traits__Base_type;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum __gnu_cxx__Lock_policy {
    _S_single = 0,
    _S_mutex = 1,
    _S_atomic = 2,
}
extern "C" {
    #[link_name = "?__default_lock_policy@__gnu_cxx@@3W4_Lock_policy@1@B"]
    pub static __gnu_cxx___default_lock_policy: __gnu_cxx__Lock_policy;
}
#[repr(C)]
#[derive(Debug)]
pub struct __gnu_cxx___concurrence_lock_error {
    pub _base: std_exception,
}
#[test]
fn bindgen_test_layout___gnu_cxx___concurrence_lock_error() {
    assert_eq!(::std::mem::size_of::<__gnu_cxx___concurrence_lock_error>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( __gnu_cxx___concurrence_lock_error
               ) ));
    assert_eq! (::std::mem::align_of::<__gnu_cxx___concurrence_lock_error>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                __gnu_cxx___concurrence_lock_error ) ));
}
#[repr(C)]
#[derive(Debug)]
pub struct __gnu_cxx___concurrence_unlock_error {
    pub _base: std_exception,
}
#[test]
fn bindgen_test_layout___gnu_cxx___concurrence_unlock_error() {
    assert_eq!(::std::mem::size_of::<__gnu_cxx___concurrence_unlock_error>() ,
               8usize , concat ! (
               "Size of: " , stringify ! (
               __gnu_cxx___concurrence_unlock_error ) ));
    assert_eq! (::std::mem::align_of::<__gnu_cxx___concurrence_unlock_error>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                __gnu_cxx___concurrence_unlock_error ) ));
}
#[repr(C)]
#[derive(Debug)]
pub struct __gnu_cxx___concurrence_broadcast_error {
    pub _base: std_exception,
}
#[test]
fn bindgen_test_layout___gnu_cxx___concurrence_broadcast_error() {
    assert_eq!(::std::mem::size_of::<__gnu_cxx___concurrence_broadcast_error>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               __gnu_cxx___concurrence_broadcast_error ) ));
    assert_eq! (::std::mem::align_of::<__gnu_cxx___concurrence_broadcast_error>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                __gnu_cxx___concurrence_broadcast_error ) ));
}
#[repr(C)]
#[derive(Debug)]
pub struct __gnu_cxx___concurrence_wait_error {
    pub _base: std_exception,
}
#[test]
fn bindgen_test_layout___gnu_cxx___concurrence_wait_error() {
    assert_eq!(::std::mem::size_of::<__gnu_cxx___concurrence_wait_error>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( __gnu_cxx___concurrence_wait_error
               ) ));
    assert_eq! (::std::mem::align_of::<__gnu_cxx___concurrence_wait_error>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                __gnu_cxx___concurrence_wait_error ) ));
}
#[repr(C)]
#[derive(Debug)]
pub struct __gnu_cxx___mutex {
    pub _M_mutex: __gthread_mutex_t,
}
#[test]
fn bindgen_test_layout___gnu_cxx___mutex() {
    assert_eq!(::std::mem::size_of::<__gnu_cxx___mutex>() , 16usize , concat !
               ( "Size of: " , stringify ! ( __gnu_cxx___mutex ) ));
    assert_eq! (::std::mem::align_of::<__gnu_cxx___mutex>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( __gnu_cxx___mutex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __gnu_cxx___mutex ) ) . _M_mutex as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __gnu_cxx___mutex ) ,
                "::" , stringify ! ( _M_mutex ) ));
}
#[repr(C)]
#[derive(Debug)]
pub struct __gnu_cxx___recursive_mutex {
    pub _M_mutex: __gthread_recursive_mutex_t,
}
#[test]
fn bindgen_test_layout___gnu_cxx___recursive_mutex() {
    assert_eq!(::std::mem::size_of::<__gnu_cxx___recursive_mutex>() , 24usize
               , concat ! (
               "Size of: " , stringify ! ( __gnu_cxx___recursive_mutex ) ));
    assert_eq! (::std::mem::align_of::<__gnu_cxx___recursive_mutex>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( __gnu_cxx___recursive_mutex )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __gnu_cxx___recursive_mutex ) ) .
                _M_mutex as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __gnu_cxx___recursive_mutex ) , "::" , stringify ! ( _M_mutex
                ) ));
}
#[repr(C)]
#[derive(Debug)]
pub struct __gnu_cxx___scoped_lock {
    pub _M_device: *mut __gnu_cxx___scoped_lock___mutex_type,
}
pub type __gnu_cxx___scoped_lock___mutex_type = __gnu_cxx___mutex;
#[test]
fn bindgen_test_layout___gnu_cxx___scoped_lock() {
    assert_eq!(::std::mem::size_of::<__gnu_cxx___scoped_lock>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( __gnu_cxx___scoped_lock ) ));
    assert_eq! (::std::mem::align_of::<__gnu_cxx___scoped_lock>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( __gnu_cxx___scoped_lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __gnu_cxx___scoped_lock ) ) . _M_device
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __gnu_cxx___scoped_lock
                ) , "::" , stringify ! ( _M_device ) ));
}
#[repr(C)]
pub struct __gnu_cxx___aligned_buffer {
    pub _M_storage: u8,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _iobuf {
    pub _ptr: *mut ::std::os::raw::c_char,
    pub _cnt: ::std::os::raw::c_int,
    pub _base: *mut ::std::os::raw::c_char,
    pub _flag: ::std::os::raw::c_int,
    pub _file: ::std::os::raw::c_int,
    pub _charbuf: ::std::os::raw::c_int,
    pub _bufsiz: ::std::os::raw::c_int,
    pub _tmpfname: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__iobuf() {
    assert_eq!(::std::mem::size_of::<_iobuf>() , 48usize , concat ! (
               "Size of: " , stringify ! ( _iobuf ) ));
    assert_eq! (::std::mem::align_of::<_iobuf>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _iobuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _iobuf ) ) . _ptr as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _iobuf ) , "::" ,
                stringify ! ( _ptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _iobuf ) ) . _cnt as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _iobuf ) , "::" ,
                stringify ! ( _cnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _iobuf ) ) . _base as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _iobuf ) , "::" ,
                stringify ! ( _base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _iobuf ) ) . _flag as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _iobuf ) , "::" ,
                stringify ! ( _flag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _iobuf ) ) . _file as * const _ as usize
                } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( _iobuf ) , "::" ,
                stringify ! ( _file ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _iobuf ) ) . _charbuf as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _iobuf ) , "::" ,
                stringify ! ( _charbuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _iobuf ) ) . _bufsiz as * const _ as
                usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( _iobuf ) , "::" ,
                stringify ! ( _bufsiz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _iobuf ) ) . _tmpfname as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _iobuf ) , "::" ,
                stringify ! ( _tmpfname ) ));
}
impl Clone for _iobuf {
    fn clone(&self) -> Self { *self }
}
pub type FILE = _iobuf;
extern "C" {
    pub fn __iob_func() -> *mut FILE;
}
pub type _fsize_t = ::std::os::raw::c_ulong;
#[repr(C)]
pub struct _wfinddata32_t {
    pub attrib: ::std::os::raw::c_uint,
    pub time_create: __time32_t,
    pub time_access: __time32_t,
    pub time_write: __time32_t,
    pub size: _fsize_t,
    pub name: [u16; 260usize],
}
#[test]
fn bindgen_test_layout__wfinddata32_t() {
    assert_eq!(::std::mem::size_of::<_wfinddata32_t>() , 540usize , concat ! (
               "Size of: " , stringify ! ( _wfinddata32_t ) ));
    assert_eq! (::std::mem::align_of::<_wfinddata32_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( _wfinddata32_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _wfinddata32_t ) ) . attrib as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _wfinddata32_t ) , "::"
                , stringify ! ( attrib ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _wfinddata32_t ) ) . time_create as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _wfinddata32_t ) , "::"
                , stringify ! ( time_create ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _wfinddata32_t ) ) . time_access as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _wfinddata32_t ) , "::"
                , stringify ! ( time_access ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _wfinddata32_t ) ) . time_write as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( _wfinddata32_t ) , "::"
                , stringify ! ( time_write ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _wfinddata32_t ) ) . size as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _wfinddata32_t ) , "::"
                , stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _wfinddata32_t ) ) . name as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( _wfinddata32_t ) , "::"
                , stringify ! ( name ) ));
}
#[repr(C)]
pub struct _wfinddata32i64_t {
    pub attrib: ::std::os::raw::c_uint,
    pub time_create: __time32_t,
    pub time_access: __time32_t,
    pub time_write: __time32_t,
    pub size: ::std::os::raw::c_longlong,
    pub name: [u16; 260usize],
}
#[test]
fn bindgen_test_layout__wfinddata32i64_t() {
    assert_eq!(::std::mem::size_of::<_wfinddata32i64_t>() , 544usize , concat
               ! ( "Size of: " , stringify ! ( _wfinddata32i64_t ) ));
    assert_eq! (::std::mem::align_of::<_wfinddata32i64_t>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( _wfinddata32i64_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _wfinddata32i64_t ) ) . attrib as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _wfinddata32i64_t ) ,
                "::" , stringify ! ( attrib ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _wfinddata32i64_t ) ) . time_create as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _wfinddata32i64_t ) ,
                "::" , stringify ! ( time_create ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _wfinddata32i64_t ) ) . time_access as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _wfinddata32i64_t ) ,
                "::" , stringify ! ( time_access ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _wfinddata32i64_t ) ) . time_write as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( _wfinddata32i64_t ) ,
                "::" , stringify ! ( time_write ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _wfinddata32i64_t ) ) . size as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _wfinddata32i64_t ) ,
                "::" , stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _wfinddata32i64_t ) ) . name as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _wfinddata32i64_t ) ,
                "::" , stringify ! ( name ) ));
}
#[repr(C)]
pub struct _wfinddata64i32_t {
    pub attrib: ::std::os::raw::c_uint,
    pub time_create: __time64_t,
    pub time_access: __time64_t,
    pub time_write: __time64_t,
    pub size: _fsize_t,
    pub name: [u16; 260usize],
}
#[test]
fn bindgen_test_layout__wfinddata64i32_t() {
    assert_eq!(::std::mem::size_of::<_wfinddata64i32_t>() , 560usize , concat
               ! ( "Size of: " , stringify ! ( _wfinddata64i32_t ) ));
    assert_eq! (::std::mem::align_of::<_wfinddata64i32_t>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( _wfinddata64i32_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _wfinddata64i32_t ) ) . attrib as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _wfinddata64i32_t ) ,
                "::" , stringify ! ( attrib ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _wfinddata64i32_t ) ) . time_create as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _wfinddata64i32_t ) ,
                "::" , stringify ! ( time_create ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _wfinddata64i32_t ) ) . time_access as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _wfinddata64i32_t ) ,
                "::" , stringify ! ( time_access ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _wfinddata64i32_t ) ) . time_write as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _wfinddata64i32_t ) ,
                "::" , stringify ! ( time_write ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _wfinddata64i32_t ) ) . size as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _wfinddata64i32_t ) ,
                "::" , stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _wfinddata64i32_t ) ) . name as * const _
                as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( _wfinddata64i32_t ) ,
                "::" , stringify ! ( name ) ));
}
#[repr(C)]
pub struct _wfinddata64_t {
    pub attrib: ::std::os::raw::c_uint,
    pub time_create: __time64_t,
    pub time_access: __time64_t,
    pub time_write: __time64_t,
    pub size: ::std::os::raw::c_longlong,
    pub name: [u16; 260usize],
}
#[test]
fn bindgen_test_layout__wfinddata64_t() {
    assert_eq!(::std::mem::size_of::<_wfinddata64_t>() , 560usize , concat ! (
               "Size of: " , stringify ! ( _wfinddata64_t ) ));
    assert_eq! (::std::mem::align_of::<_wfinddata64_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _wfinddata64_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _wfinddata64_t ) ) . attrib as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _wfinddata64_t ) , "::"
                , stringify ! ( attrib ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _wfinddata64_t ) ) . time_create as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _wfinddata64_t ) , "::"
                , stringify ! ( time_create ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _wfinddata64_t ) ) . time_access as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _wfinddata64_t ) , "::"
                , stringify ! ( time_access ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _wfinddata64_t ) ) . time_write as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _wfinddata64_t ) , "::"
                , stringify ! ( time_write ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _wfinddata64_t ) ) . size as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _wfinddata64_t ) , "::"
                , stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _wfinddata64_t ) ) . name as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _wfinddata64_t ) , "::"
                , stringify ! ( name ) ));
}
extern "C" {
    #[link_name = "__imp__pctype"]
    pub static mut __imp__pctype: *mut *mut ::std::os::raw::c_ushort;
}
extern "C" {
    #[link_name = "__imp__wctype"]
    pub static mut __imp__wctype: *mut *mut ::std::os::raw::c_ushort;
}
extern "C" {
    #[link_name = "__imp__pwctype"]
    pub static mut __imp__pwctype: *mut *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn iswalpha(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswalpha_l(_C: wint_t, _Locale: _locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswupper(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswupper_l(_C: wint_t, _Locale: _locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswlower(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswlower_l(_C: wint_t, _Locale: _locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswdigit(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswdigit_l(_C: wint_t, _Locale: _locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswxdigit(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswxdigit_l(_C: wint_t, _Locale: _locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswspace(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswspace_l(_C: wint_t, _Locale: _locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswpunct(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswpunct_l(_C: wint_t, _Locale: _locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswalnum(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswalnum_l(_C: wint_t, _Locale: _locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswprint(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswprint_l(_C: wint_t, _Locale: _locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswgraph(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswgraph_l(_C: wint_t, _Locale: _locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswcntrl(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswcntrl_l(_C: wint_t, _Locale: _locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswascii(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isleadbyte(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _isleadbyte_l(_C: ::std::os::raw::c_int, _Locale: _locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn towupper(_C: wint_t) -> wint_t;
}
extern "C" {
    pub fn _towupper_l(_C: wint_t, _Locale: _locale_t) -> wint_t;
}
extern "C" {
    pub fn towlower(_C: wint_t) -> wint_t;
}
extern "C" {
    pub fn _towlower_l(_C: wint_t, _Locale: _locale_t) -> wint_t;
}
extern "C" {
    pub fn iswctype(_C: wint_t, _Type: wctype_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswctype_l(_C: wint_t, _Type: wctype_t, _Locale: _locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iswcsymf(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswcsymf_l(_C: wint_t, _Locale: _locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iswcsym(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswcsym_l(_C: wint_t, _Locale: _locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn is_wctype(_C: wint_t, _Type: wctype_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswblank(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wgetcwd(_DstBuf: *mut u16, _SizeInWords: ::std::os::raw::c_int)
     -> *mut u16;
}
extern "C" {
    pub fn _wgetdcwd(_Drive: ::std::os::raw::c_int, _DstBuf: *mut u16,
                     _SizeInWords: ::std::os::raw::c_int) -> *mut u16;
}
extern "C" {
    pub fn _wgetdcwd_nolock(_Drive: ::std::os::raw::c_int, _DstBuf: *mut u16,
                            _SizeInWords: ::std::os::raw::c_int) -> *mut u16;
}
extern "C" {
    pub fn _wchdir(_Path: *const u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wmkdir(_Path: *const u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wrmdir(_Path: *const u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _waccess(_Filename: *const u16, _AccessMode: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wchmod(_Filename: *const u16, _Mode: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcreat(_Filename: *const u16,
                   _PermissionMode: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wfindfirst32(_Filename: *const u16,
                         _FindData: *mut _wfinddata32_t) -> isize;
}
extern "C" {
    pub fn _wfindnext32(_FindHandle: isize, _FindData: *mut _wfinddata32_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wunlink(_Filename: *const u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wrename(_OldFilename: *const u16, _NewFilename: *const u16)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wmktemp(_TemplateName: *mut u16) -> *mut u16;
}
extern "C" {
    pub fn _wfindfirst32i64(_Filename: *const u16,
                            _FindData: *mut _wfinddata32i64_t) -> isize;
}
extern "C" {
    pub fn _wfindfirst64i32(_Filename: *const u16,
                            _FindData: *mut _wfinddata64i32_t) -> isize;
}
extern "C" {
    pub fn _wfindfirst64(_Filename: *const u16,
                         _FindData: *mut _wfinddata64_t) -> isize;
}
extern "C" {
    pub fn _wfindnext32i64(_FindHandle: isize,
                           _FindData: *mut _wfinddata32i64_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wfindnext64i32(_FindHandle: isize,
                           _FindData: *mut _wfinddata64i32_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wfindnext64(_FindHandle: isize, _FindData: *mut _wfinddata64_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wsopen_s(_FileHandle: *mut ::std::os::raw::c_int,
                     _Filename: *const u16, _OpenFlag: ::std::os::raw::c_int,
                     _ShareFlag: ::std::os::raw::c_int,
                     _PermissionFlag: ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn _wopen(_Filename: *const u16,
                  _OpenFlag: ::std::os::raw::c_int, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wsopen(_Filename: *const u16, _OpenFlag: ::std::os::raw::c_int,
                   _ShareFlag: ::std::os::raw::c_int, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wsetlocale(_Category: ::std::os::raw::c_int, _Locale: *const u16)
     -> *mut u16;
}
extern "C" {
    pub fn _wexecl(_Filename: *const u16, _ArgList: *const u16, ...) -> isize;
}
extern "C" {
    pub fn _wexecle(_Filename: *const u16, _ArgList: *const u16, ...)
     -> isize;
}
extern "C" {
    pub fn _wexeclp(_Filename: *const u16, _ArgList: *const u16, ...)
     -> isize;
}
extern "C" {
    pub fn _wexeclpe(_Filename: *const u16, _ArgList: *const u16, ...)
     -> isize;
}
extern "C" {
    pub fn _wexecv(_Filename: *const u16, _ArgList: *const *const u16)
     -> isize;
}
extern "C" {
    pub fn _wexecve(_Filename: *const u16, _ArgList: *const *const u16,
                    _Env: *const *const u16) -> isize;
}
extern "C" {
    pub fn _wexecvp(_Filename: *const u16, _ArgList: *const *const u16)
     -> isize;
}
extern "C" {
    pub fn _wexecvpe(_Filename: *const u16, _ArgList: *const *const u16,
                     _Env: *const *const u16) -> isize;
}
extern "C" {
    pub fn _wspawnl(_Mode: ::std::os::raw::c_int, _Filename: *const u16,
                    _ArgList: *const u16, ...) -> isize;
}
extern "C" {
    pub fn _wspawnle(_Mode: ::std::os::raw::c_int, _Filename: *const u16,
                     _ArgList: *const u16, ...) -> isize;
}
extern "C" {
    pub fn _wspawnlp(_Mode: ::std::os::raw::c_int, _Filename: *const u16,
                     _ArgList: *const u16, ...) -> isize;
}
extern "C" {
    pub fn _wspawnlpe(_Mode: ::std::os::raw::c_int, _Filename: *const u16,
                      _ArgList: *const u16, ...) -> isize;
}
extern "C" {
    pub fn _wspawnv(_Mode: ::std::os::raw::c_int, _Filename: *const u16,
                    _ArgList: *const *const u16) -> isize;
}
extern "C" {
    pub fn _wspawnve(_Mode: ::std::os::raw::c_int, _Filename: *const u16,
                     _ArgList: *const *const u16, _Env: *const *const u16)
     -> isize;
}
extern "C" {
    pub fn _wspawnvp(_Mode: ::std::os::raw::c_int, _Filename: *const u16,
                     _ArgList: *const *const u16) -> isize;
}
extern "C" {
    pub fn _wspawnvpe(_Mode: ::std::os::raw::c_int, _Filename: *const u16,
                      _ArgList: *const *const u16, _Env: *const *const u16)
     -> isize;
}
extern "C" {
    pub fn _wsystem(_Command: *const u16) -> ::std::os::raw::c_int;
}
pub type _ino_t = ::std::os::raw::c_ushort;
pub type ino_t = ::std::os::raw::c_ushort;
pub type _dev_t = ::std::os::raw::c_uint;
pub type dev_t = ::std::os::raw::c_uint;
pub type _off_t = ::std::os::raw::c_long;
pub type off32_t = ::std::os::raw::c_long;
pub type _off64_t = ::std::os::raw::c_longlong;
pub type off64_t = ::std::os::raw::c_longlong;
pub type off_t = off32_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _stat32 {
    pub st_dev: _dev_t,
    pub st_ino: _ino_t,
    pub st_mode: ::std::os::raw::c_ushort,
    pub st_nlink: ::std::os::raw::c_short,
    pub st_uid: ::std::os::raw::c_short,
    pub st_gid: ::std::os::raw::c_short,
    pub st_rdev: _dev_t,
    pub st_size: _off_t,
    pub st_atime: __time32_t,
    pub st_mtime: __time32_t,
    pub st_ctime: __time32_t,
}
#[test]
fn bindgen_test_layout__stat32() {
    assert_eq!(::std::mem::size_of::<_stat32>() , 36usize , concat ! (
               "Size of: " , stringify ! ( _stat32 ) ));
    assert_eq! (::std::mem::align_of::<_stat32>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( _stat32 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _stat32 ) ) . st_dev as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _stat32 ) , "::" ,
                stringify ! ( st_dev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _stat32 ) ) . st_ino as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _stat32 ) , "::" ,
                stringify ! ( st_ino ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _stat32 ) ) . st_mode as * const _ as
                usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( _stat32 ) , "::" ,
                stringify ! ( st_mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _stat32 ) ) . st_nlink as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _stat32 ) , "::" ,
                stringify ! ( st_nlink ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _stat32 ) ) . st_uid as * const _ as
                usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( _stat32 ) , "::" ,
                stringify ! ( st_uid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _stat32 ) ) . st_gid as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( _stat32 ) , "::" ,
                stringify ! ( st_gid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _stat32 ) ) . st_rdev as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _stat32 ) , "::" ,
                stringify ! ( st_rdev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _stat32 ) ) . st_size as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( _stat32 ) , "::" ,
                stringify ! ( st_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _stat32 ) ) . st_atime as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _stat32 ) , "::" ,
                stringify ! ( st_atime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _stat32 ) ) . st_mtime as * const _ as
                usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( _stat32 ) , "::" ,
                stringify ! ( st_mtime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _stat32 ) ) . st_ctime as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _stat32 ) , "::" ,
                stringify ! ( st_ctime ) ));
}
impl Clone for _stat32 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct stat {
    pub st_dev: _dev_t,
    pub st_ino: _ino_t,
    pub st_mode: ::std::os::raw::c_ushort,
    pub st_nlink: ::std::os::raw::c_short,
    pub st_uid: ::std::os::raw::c_short,
    pub st_gid: ::std::os::raw::c_short,
    pub st_rdev: _dev_t,
    pub st_size: _off_t,
    pub st_atime: time_t,
    pub st_mtime: time_t,
    pub st_ctime: time_t,
}
#[test]
fn bindgen_test_layout_stat() {
    assert_eq!(::std::mem::size_of::<stat>() , 48usize , concat ! (
               "Size of: " , stringify ! ( stat ) ));
    assert_eq! (::std::mem::align_of::<stat>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( stat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat ) ) . st_dev as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( stat ) , "::" ,
                stringify ! ( st_dev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat ) ) . st_ino as * const _ as usize }
                , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( stat ) , "::" ,
                stringify ! ( st_ino ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat ) ) . st_mode as * const _ as usize
                } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( stat ) , "::" ,
                stringify ! ( st_mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat ) ) . st_nlink as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( stat ) , "::" ,
                stringify ! ( st_nlink ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat ) ) . st_uid as * const _ as usize }
                , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( stat ) , "::" ,
                stringify ! ( st_uid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat ) ) . st_gid as * const _ as usize }
                , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( stat ) , "::" ,
                stringify ! ( st_gid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat ) ) . st_rdev as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( stat ) , "::" ,
                stringify ! ( st_rdev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat ) ) . st_size as * const _ as usize
                } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( stat ) , "::" ,
                stringify ! ( st_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat ) ) . st_atime as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( stat ) , "::" ,
                stringify ! ( st_atime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat ) ) . st_mtime as * const _ as usize
                } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( stat ) , "::" ,
                stringify ! ( st_mtime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat ) ) . st_ctime as * const _ as usize
                } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( stat ) , "::" ,
                stringify ! ( st_ctime ) ));
}
impl Clone for stat {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _stat32i64 {
    pub st_dev: _dev_t,
    pub st_ino: _ino_t,
    pub st_mode: ::std::os::raw::c_ushort,
    pub st_nlink: ::std::os::raw::c_short,
    pub st_uid: ::std::os::raw::c_short,
    pub st_gid: ::std::os::raw::c_short,
    pub st_rdev: _dev_t,
    pub st_size: ::std::os::raw::c_longlong,
    pub st_atime: __time32_t,
    pub st_mtime: __time32_t,
    pub st_ctime: __time32_t,
}
#[test]
fn bindgen_test_layout__stat32i64() {
    assert_eq!(::std::mem::size_of::<_stat32i64>() , 48usize , concat ! (
               "Size of: " , stringify ! ( _stat32i64 ) ));
    assert_eq! (::std::mem::align_of::<_stat32i64>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _stat32i64 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _stat32i64 ) ) . st_dev as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _stat32i64 ) , "::" ,
                stringify ! ( st_dev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _stat32i64 ) ) . st_ino as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _stat32i64 ) , "::" ,
                stringify ! ( st_ino ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _stat32i64 ) ) . st_mode as * const _ as
                usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( _stat32i64 ) , "::" ,
                stringify ! ( st_mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _stat32i64 ) ) . st_nlink as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _stat32i64 ) , "::" ,
                stringify ! ( st_nlink ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _stat32i64 ) ) . st_uid as * const _ as
                usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( _stat32i64 ) , "::" ,
                stringify ! ( st_uid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _stat32i64 ) ) . st_gid as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( _stat32i64 ) , "::" ,
                stringify ! ( st_gid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _stat32i64 ) ) . st_rdev as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _stat32i64 ) , "::" ,
                stringify ! ( st_rdev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _stat32i64 ) ) . st_size as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _stat32i64 ) , "::" ,
                stringify ! ( st_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _stat32i64 ) ) . st_atime as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _stat32i64 ) , "::" ,
                stringify ! ( st_atime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _stat32i64 ) ) . st_mtime as * const _ as
                usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( _stat32i64 ) , "::" ,
                stringify ! ( st_mtime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _stat32i64 ) ) . st_ctime as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _stat32i64 ) , "::" ,
                stringify ! ( st_ctime ) ));
}
impl Clone for _stat32i64 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _stat64i32 {
    pub st_dev: _dev_t,
    pub st_ino: _ino_t,
    pub st_mode: ::std::os::raw::c_ushort,
    pub st_nlink: ::std::os::raw::c_short,
    pub st_uid: ::std::os::raw::c_short,
    pub st_gid: ::std::os::raw::c_short,
    pub st_rdev: _dev_t,
    pub st_size: _off_t,
    pub st_atime: __time64_t,
    pub st_mtime: __time64_t,
    pub st_ctime: __time64_t,
}
#[test]
fn bindgen_test_layout__stat64i32() {
    assert_eq!(::std::mem::size_of::<_stat64i32>() , 48usize , concat ! (
               "Size of: " , stringify ! ( _stat64i32 ) ));
    assert_eq! (::std::mem::align_of::<_stat64i32>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _stat64i32 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _stat64i32 ) ) . st_dev as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _stat64i32 ) , "::" ,
                stringify ! ( st_dev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _stat64i32 ) ) . st_ino as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _stat64i32 ) , "::" ,
                stringify ! ( st_ino ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _stat64i32 ) ) . st_mode as * const _ as
                usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( _stat64i32 ) , "::" ,
                stringify ! ( st_mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _stat64i32 ) ) . st_nlink as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _stat64i32 ) , "::" ,
                stringify ! ( st_nlink ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _stat64i32 ) ) . st_uid as * const _ as
                usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( _stat64i32 ) , "::" ,
                stringify ! ( st_uid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _stat64i32 ) ) . st_gid as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( _stat64i32 ) , "::" ,
                stringify ! ( st_gid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _stat64i32 ) ) . st_rdev as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _stat64i32 ) , "::" ,
                stringify ! ( st_rdev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _stat64i32 ) ) . st_size as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( _stat64i32 ) , "::" ,
                stringify ! ( st_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _stat64i32 ) ) . st_atime as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _stat64i32 ) , "::" ,
                stringify ! ( st_atime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _stat64i32 ) ) . st_mtime as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _stat64i32 ) , "::" ,
                stringify ! ( st_mtime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _stat64i32 ) ) . st_ctime as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _stat64i32 ) , "::" ,
                stringify ! ( st_ctime ) ));
}
impl Clone for _stat64i32 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _stat64 {
    pub st_dev: _dev_t,
    pub st_ino: _ino_t,
    pub st_mode: ::std::os::raw::c_ushort,
    pub st_nlink: ::std::os::raw::c_short,
    pub st_uid: ::std::os::raw::c_short,
    pub st_gid: ::std::os::raw::c_short,
    pub st_rdev: _dev_t,
    pub st_size: ::std::os::raw::c_longlong,
    pub st_atime: __time64_t,
    pub st_mtime: __time64_t,
    pub st_ctime: __time64_t,
}
#[test]
fn bindgen_test_layout__stat64() {
    assert_eq!(::std::mem::size_of::<_stat64>() , 56usize , concat ! (
               "Size of: " , stringify ! ( _stat64 ) ));
    assert_eq! (::std::mem::align_of::<_stat64>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _stat64 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _stat64 ) ) . st_dev as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _stat64 ) , "::" ,
                stringify ! ( st_dev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _stat64 ) ) . st_ino as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _stat64 ) , "::" ,
                stringify ! ( st_ino ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _stat64 ) ) . st_mode as * const _ as
                usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( _stat64 ) , "::" ,
                stringify ! ( st_mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _stat64 ) ) . st_nlink as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _stat64 ) , "::" ,
                stringify ! ( st_nlink ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _stat64 ) ) . st_uid as * const _ as
                usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( _stat64 ) , "::" ,
                stringify ! ( st_uid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _stat64 ) ) . st_gid as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( _stat64 ) , "::" ,
                stringify ! ( st_gid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _stat64 ) ) . st_rdev as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _stat64 ) , "::" ,
                stringify ! ( st_rdev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _stat64 ) ) . st_size as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _stat64 ) , "::" ,
                stringify ! ( st_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _stat64 ) ) . st_atime as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _stat64 ) , "::" ,
                stringify ! ( st_atime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _stat64 ) ) . st_mtime as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _stat64 ) , "::" ,
                stringify ! ( st_mtime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _stat64 ) ) . st_ctime as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _stat64 ) , "::" ,
                stringify ! ( st_ctime ) ));
}
impl Clone for _stat64 {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn _wstat32(_Name: *const u16, _Stat: *mut _stat32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wstat32i64(_Name: *const u16, _Stat: *mut _stat32i64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wstat64i32(_Name: *const u16, _Stat: *mut _stat64i32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wstat64(_Name: *const u16, _Stat: *mut _stat64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _cgetws(_Buffer: *mut u16) -> *mut u16;
}
extern "C" {
    pub fn _getwch() -> wint_t;
}
extern "C" {
    pub fn _getwche() -> wint_t;
}
extern "C" {
    pub fn _putwch(_WCh: u16) -> wint_t;
}
extern "C" {
    pub fn _ungetwch(_WCh: wint_t) -> wint_t;
}
extern "C" {
    pub fn _cputws(_String: *const u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _cwprintf(_Format: *const u16, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _cwscanf(_Format: *const u16, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _cwscanf_l(_Format: *const u16, _Locale: _locale_t, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vcwprintf(_Format: *const u16, _ArgList: va_list)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _cwprintf_p(_Format: *const u16, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vcwprintf_p(_Format: *const u16, _ArgList: va_list)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _cwprintf_l(_Format: *const u16, _Locale: _locale_t, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vcwprintf_l(_Format: *const u16, _Locale: _locale_t,
                        _ArgList: va_list) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _cwprintf_p_l(_Format: *const u16, _Locale: _locale_t, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vcwprintf_p_l(_Format: *const u16, _Locale: _locale_t,
                          _ArgList: va_list) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _putwch_nolock(_WCh: u16) -> wint_t;
}
extern "C" {
    pub fn _getwch_nolock() -> wint_t;
}
extern "C" {
    pub fn _getwche_nolock() -> wint_t;
}
extern "C" {
    pub fn _ungetwch_nolock(_WCh: wint_t) -> wint_t;
}
extern "C" {
    pub fn __mingw_swscanf(_Src: *const u16, _Format: *const u16, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __mingw_vswscanf(_Str: *const u16, Format: *const u16,
                            argp: va_list) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __mingw_wscanf(_Format: *const u16, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __mingw_vwscanf(Format: *const u16, argp: va_list)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __mingw_fwscanf(_File: *mut FILE, _Format: *const u16, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __mingw_vfwscanf(fp: *mut FILE, Format: *const u16, argp: va_list)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __mingw_fwprintf(_File: *mut FILE, _Format: *const u16, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __mingw_wprintf(_Format: *const u16, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __mingw_vfwprintf(_File: *mut FILE, _Format: *const u16,
                             _ArgList: va_list) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __mingw_vwprintf(_Format: *const u16, _ArgList: va_list)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __mingw_snwprintf(s: *mut u16, n: usize, format: *const u16, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __mingw_vsnwprintf(arg1: *mut u16, arg2: usize, arg3: *const u16,
                              arg4: va_list) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __mingw_swprintf(arg1: *mut u16, arg2: *const u16, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __mingw_vswprintf(arg1: *mut u16, arg2: *const u16, arg3: va_list)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wfsopen(_Filename: *const u16, _Mode: *const u16,
                    _ShFlag: ::std::os::raw::c_int) -> *mut FILE;
}
extern "C" {
    pub fn fgetwc(_File: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _fgetwchar() -> wint_t;
}
extern "C" {
    pub fn fputwc(_Ch: u16, _File: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _fputwchar(_Ch: u16) -> wint_t;
}
extern "C" {
    pub fn getwc(_File: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn getwchar() -> wint_t;
}
extern "C" {
    pub fn putwc(_Ch: u16, _File: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn putwchar(_Ch: u16) -> wint_t;
}
extern "C" {
    pub fn ungetwc(_Ch: wint_t, _File: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn fgetws(_Dst: *mut u16, _SizeInWords: ::std::os::raw::c_int,
                  _File: *mut FILE) -> *mut u16;
}
extern "C" {
    pub fn fputws(_Str: *const u16, _File: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _getws(_String: *mut u16) -> *mut u16;
}
extern "C" {
    pub fn _putws(_Str: *const u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _scwprintf(_Format: *const u16, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _swprintf_l(arg1: *mut u16, _SizeInWords: usize,
                       _Format: *const u16, _Locale: _locale_t, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _swprintf_c(_DstBuf: *mut u16, _SizeInWords: usize,
                       _Format: *const u16, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vswprintf_c(_DstBuf: *mut u16, _SizeInWords: usize,
                        _Format: *const u16, _ArgList: va_list)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _snwprintf(_Dest: *mut u16, _Count: usize,
                      _Format: *const u16, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vsnwprintf(_Dest: *mut u16, _Count: usize, _Format: *const u16,
                       _Args: va_list) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fwprintf_p(_File: *mut FILE, _Format: *const u16, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wprintf_p(_Format: *const u16, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vfwprintf_p(_File: *mut FILE, _Format: *const u16,
                        _ArgList: va_list) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vwprintf_p(_Format: *const u16, _ArgList: va_list)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _swprintf_p(_DstBuf: *mut u16, _MaxCount: usize,
                       _Format: *const u16, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vswprintf_p(_DstBuf: *mut u16, _MaxCount: usize,
                        _Format: *const u16, _ArgList: va_list)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _scwprintf_p(_Format: *const u16, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vscwprintf_p(_Format: *const u16, _ArgList: va_list)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wprintf_l(_Format: *const u16, _Locale: _locale_t, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wprintf_p_l(_Format: *const u16, _Locale: _locale_t, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vwprintf_l(_Format: *const u16, _Locale: _locale_t,
                       _ArgList: va_list) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vwprintf_p_l(_Format: *const u16, _Locale: _locale_t,
                         _ArgList: va_list) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fwprintf_l(_File: *mut FILE, _Format: *const u16,
                       _Locale: _locale_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fwprintf_p_l(_File: *mut FILE, _Format: *const u16,
                         _Locale: _locale_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vfwprintf_l(_File: *mut FILE, _Format: *const u16,
                        _Locale: _locale_t, _ArgList: va_list)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vfwprintf_p_l(_File: *mut FILE, _Format: *const u16,
                          _Locale: _locale_t, _ArgList: va_list)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _swprintf_c_l(_DstBuf: *mut u16, _MaxCount: usize,
                         _Format: *const u16, _Locale: _locale_t, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _swprintf_p_l(_DstBuf: *mut u16, _MaxCount: usize,
                         _Format: *const u16, _Locale: _locale_t, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vswprintf_c_l(_DstBuf: *mut u16, _MaxCount: usize,
                          _Format: *const u16, _Locale: _locale_t,
                          _ArgList: va_list) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vswprintf_p_l(_DstBuf: *mut u16, _MaxCount: usize,
                          _Format: *const u16, _Locale: _locale_t,
                          _ArgList: va_list) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _scwprintf_l(_Format: *const u16, _Locale: _locale_t, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _scwprintf_p_l(_Format: *const u16, _Locale: _locale_t, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vscwprintf_p_l(_Format: *const u16, _Locale: _locale_t,
                           _ArgList: va_list) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _snwprintf_l(_DstBuf: *mut u16, _MaxCount: usize,
                        _Format: *const u16, _Locale: _locale_t, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vsnwprintf_l(_DstBuf: *mut u16, _MaxCount: usize,
                         _Format: *const u16, _Locale: _locale_t,
                         _ArgList: va_list) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _swprintf(_Dest: *mut u16, _Format: *const u16, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vswprintf(_Dest: *mut u16, _Format: *const u16, _Args: va_list)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __swprintf_l(_Dest: *mut u16, _Format: *const u16,
                        _Plocinfo: _locale_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vswprintf_l(_Dest: *mut u16, _MaxCount: usize,
                        _Format: *const u16, _Locale: _locale_t,
                        _ArgList: va_list) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __vswprintf_l(_Dest: *mut u16, _Format: *const u16,
                         _Plocinfo: _locale_t, _Args: va_list)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wtempnam(_Directory: *const u16, _FilePrefix: *const u16)
     -> *mut u16;
}
extern "C" {
    pub fn _vscwprintf(_Format: *const u16, _ArgList: va_list)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vscwprintf_l(_Format: *const u16, _Locale: _locale_t,
                         _ArgList: va_list) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fwscanf_l(_File: *mut FILE, _Format: *const u16,
                      _Locale: _locale_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _swscanf_l(_Src: *const u16, _Format: *const u16,
                      _Locale: _locale_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _snwscanf(_Src: *const u16, _MaxCount: usize,
                     _Format: *const u16, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _snwscanf_l(_Src: *const u16, _MaxCount: usize,
                       _Format: *const u16, _Locale: _locale_t, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wscanf_l(_Format: *const u16, _Locale: _locale_t, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wfdopen(_FileHandle: ::std::os::raw::c_int, _Mode: *const u16)
     -> *mut FILE;
}
extern "C" {
    pub fn _wfopen(_Filename: *const u16, _Mode: *const u16) -> *mut FILE;
}
extern "C" {
    pub fn _wfreopen(_Filename: *const u16, _Mode: *const u16,
                     _OldFile: *mut FILE) -> *mut FILE;
}
extern "C" {
    pub fn _wperror(_ErrMsg: *const u16);
}
extern "C" {
    pub fn _wpopen(_Command: *const u16, _Mode: *const u16) -> *mut FILE;
}
extern "C" {
    pub fn _wremove(_Filename: *const u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wtmpnam(_Buffer: *mut u16) -> *mut u16;
}
extern "C" {
    pub fn _fgetwc_nolock(_File: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _fputwc_nolock(_Ch: u16, _File: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _ungetwc_nolock(_Ch: wint_t, _File: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _itow(_Value: ::std::os::raw::c_int, _Dest: *mut u16,
                 _Radix: ::std::os::raw::c_int) -> *mut u16;
}
extern "C" {
    pub fn _ltow(_Value: ::std::os::raw::c_long, _Dest: *mut u16,
                 _Radix: ::std::os::raw::c_int) -> *mut u16;
}
extern "C" {
    pub fn _ultow(_Value: ::std::os::raw::c_ulong, _Dest: *mut u16,
                  _Radix: ::std::os::raw::c_int) -> *mut u16;
}
extern "C" {
    pub fn _wcstod_l(_Str: *const u16, _EndPtr: *mut *mut u16,
                     _Locale: _locale_t) -> f64;
}
extern "C" {
    pub fn __mingw_wcstod(_Str: *const u16, _EndPtr: *mut *mut u16) -> f64;
}
extern "C" {
    pub fn __mingw_wcstof(nptr: *const u16, endptr: *mut *mut u16) -> f32;
}
extern "C" {
    pub fn __mingw_wcstold(arg1: *const u16, arg2: *mut *mut u16) -> f64;
}
extern "C" {
    pub fn wcstold(arg1: *const u16, arg2: *mut *mut u16) -> f64;
}
extern "C" {
    pub fn wcstol(_Str: *const u16, _EndPtr: *mut *mut u16,
                  _Radix: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _wcstol_l(_Str: *const u16, _EndPtr: *mut *mut u16,
                     _Radix: ::std::os::raw::c_int, _Locale: _locale_t)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn wcstoul(_Str: *const u16, _EndPtr: *mut *mut u16,
                   _Radix: ::std::os::raw::c_int) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _wcstoul_l(_Str: *const u16, _EndPtr: *mut *mut u16,
                      _Radix: ::std::os::raw::c_int, _Locale: _locale_t)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _wgetenv(_VarName: *const u16) -> *mut u16;
}
extern "C" {
    pub fn _wtof(_Str: *const u16) -> f64;
}
extern "C" {
    pub fn _wtof_l(_Str: *const u16, _Locale: _locale_t) -> f64;
}
extern "C" {
    pub fn _wtoi(_Str: *const u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wtoi_l(_Str: *const u16, _Locale: _locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wtol(_Str: *const u16) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _wtol_l(_Str: *const u16, _Locale: _locale_t)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _i64tow(_Val: ::std::os::raw::c_longlong, _DstBuf: *mut u16,
                   _Radix: ::std::os::raw::c_int) -> *mut u16;
}
extern "C" {
    pub fn _ui64tow(_Val: ::std::os::raw::c_ulonglong, _DstBuf: *mut u16,
                    _Radix: ::std::os::raw::c_int) -> *mut u16;
}
extern "C" {
    pub fn _wtoi64(_Str: *const u16) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wtoi64_l(_Str: *const u16, _Locale: _locale_t)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoi64(_Str: *const u16, _EndPtr: *mut *mut u16,
                     _Radix: ::std::os::raw::c_int)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoi64_l(_Str: *const u16, _EndPtr: *mut *mut u16,
                       _Radix: ::std::os::raw::c_int, _Locale: _locale_t)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoui64(_Str: *const u16, _EndPtr: *mut *mut u16,
                      _Radix: ::std::os::raw::c_int)
     -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _wcstoui64_l(_Str: *const u16, _EndPtr: *mut *mut u16,
                        _Radix: ::std::os::raw::c_int, _Locale: _locale_t)
     -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _wfullpath(_FullPath: *mut u16, _Path: *const u16,
                      _SizeInWords: usize) -> *mut u16;
}
extern "C" {
    pub fn _wmakepath(_ResultPath: *mut u16, _Drive: *const u16,
                      _Dir: *const u16, _Filename: *const u16,
                      _Ext: *const u16);
}
extern "C" {
    pub fn _wputenv(_EnvString: *const u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wsearchenv(_Filename: *const u16, _EnvVar: *const u16,
                       _ResultPath: *mut u16);
}
extern "C" {
    pub fn _wsplitpath(_FullPath: *const u16, _Drive: *mut u16,
                       _Dir: *mut u16, _Filename: *mut u16, _Ext: *mut u16);
}
extern "C" {
    pub fn _wcsdup(_Str: *const u16) -> *mut u16;
}
extern "C" {
    pub fn wcscat(_Dest: *mut u16, _Source: *const u16) -> *mut u16;
}
extern "C" {
    pub fn wcschr(_Str: *const u16, _Ch: u16) -> *mut u16;
}
extern "C" {
    pub fn wcscmp(_Str1: *const u16, _Str2: *const u16)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcscpy(_Dest: *mut u16, _Source: *const u16) -> *mut u16;
}
extern "C" {
    pub fn wcscspn(_Str: *const u16, _Control: *const u16) -> usize;
}
extern "C" {
    pub fn wcslen(_Str: *const u16) -> usize;
}
extern "C" {
    pub fn wcsnlen(_Src: *const u16, _MaxCount: usize) -> usize;
}
extern "C" {
    pub fn wcsncat(_Dest: *mut u16, _Source: *const u16, _Count: usize)
     -> *mut u16;
}
extern "C" {
    pub fn wcsncmp(_Str1: *const u16, _Str2: *const u16, _MaxCount: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsncpy(_Dest: *mut u16, _Source: *const u16, _Count: usize)
     -> *mut u16;
}
extern "C" {
    pub fn _wcsncpy_l(_Dest: *mut u16, _Source: *const u16, _Count: usize,
                      _Locale: _locale_t) -> *mut u16;
}
extern "C" {
    pub fn wcspbrk(_Str: *const u16, _Control: *const u16) -> *mut u16;
}
extern "C" {
    pub fn wcsrchr(_Str: *const u16, _Ch: u16) -> *mut u16;
}
extern "C" {
    pub fn wcsspn(_Str: *const u16, _Control: *const u16) -> usize;
}
extern "C" {
    pub fn wcsstr(_Str: *const u16, _SubStr: *const u16) -> *mut u16;
}
extern "C" {
    pub fn wcstok(_Str: *mut u16, _Delim: *const u16) -> *mut u16;
}
extern "C" {
    pub fn _wcserror(_ErrNum: ::std::os::raw::c_int) -> *mut u16;
}
extern "C" {
    pub fn __wcserror(_Str: *const u16) -> *mut u16;
}
extern "C" {
    pub fn _wcsicmp(_Str1: *const u16, _Str2: *const u16)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsicmp_l(_Str1: *const u16, _Str2: *const u16,
                      _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnicmp(_Str1: *const u16, _Str2: *const u16, _MaxCount: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnicmp_l(_Str1: *const u16, _Str2: *const u16, _MaxCount: usize,
                       _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnset(_Str: *mut u16, _Val: u16, _MaxCount: usize) -> *mut u16;
}
extern "C" {
    pub fn _wcsrev(_Str: *mut u16) -> *mut u16;
}
extern "C" {
    pub fn _wcsset(_Str: *mut u16, _Val: u16) -> *mut u16;
}
extern "C" {
    pub fn _wcslwr(_String: *mut u16) -> *mut u16;
}
extern "C" {
    pub fn _wcslwr_l(_String: *mut u16, _Locale: _locale_t) -> *mut u16;
}
extern "C" {
    pub fn _wcsupr(_String: *mut u16) -> *mut u16;
}
extern "C" {
    pub fn _wcsupr_l(_String: *mut u16, _Locale: _locale_t) -> *mut u16;
}
extern "C" {
    pub fn wcsxfrm(_Dst: *mut u16, _Src: *const u16, _MaxCount: usize)
     -> usize;
}
extern "C" {
    pub fn _wcsxfrm_l(_Dst: *mut u16, _Src: *const u16, _MaxCount: usize,
                      _Locale: _locale_t) -> usize;
}
extern "C" {
    pub fn wcscoll(_Str1: *const u16, _Str2: *const u16)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcscoll_l(_Str1: *const u16, _Str2: *const u16,
                      _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsicoll(_Str1: *const u16, _Str2: *const u16)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsicoll_l(_Str1: *const u16, _Str2: *const u16,
                       _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsncoll(_Str1: *const u16, _Str2: *const u16, _MaxCount: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsncoll_l(_Str1: *const u16, _Str2: *const u16, _MaxCount: usize,
                       _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnicoll(_Str1: *const u16, _Str2: *const u16, _MaxCount: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnicoll_l(_Str1: *const u16, _Str2: *const u16,
                        _MaxCount: usize, _Locale: _locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsdup(_Str: *const u16) -> *mut u16;
}
extern "C" {
    pub fn wcsicmp(_Str1: *const u16, _Str2: *const u16)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsnicmp(_Str1: *const u16, _Str2: *const u16, _MaxCount: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsnset(_Str: *mut u16, _Val: u16, _MaxCount: usize) -> *mut u16;
}
extern "C" {
    pub fn wcsrev(_Str: *mut u16) -> *mut u16;
}
extern "C" {
    pub fn wcsset(_Str: *mut u16, _Val: u16) -> *mut u16;
}
extern "C" {
    pub fn wcslwr(_Str: *mut u16) -> *mut u16;
}
extern "C" {
    pub fn wcsupr(_Str: *mut u16) -> *mut u16;
}
extern "C" {
    pub fn wcsicoll(_Str1: *const u16, _Str2: *const u16)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(::std::mem::size_of::<tm>() , 36usize , concat ! (
               "Size of: " , stringify ! ( tm ) ));
    assert_eq! (::std::mem::align_of::<tm>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( tm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_sec as * const _ as usize } ,
                0usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_min as * const _ as usize } ,
                4usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_min ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_hour as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_hour ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_mday as * const _ as usize }
                , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_mday ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_mon as * const _ as usize } ,
                16usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_mon ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_year as * const _ as usize }
                , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_year ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_wday as * const _ as usize }
                , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_wday ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_yday as * const _ as usize }
                , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_yday ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_isdst as * const _ as usize }
                , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_isdst ) ));
}
impl Clone for tm {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn _wasctime(_Tm: *const tm) -> *mut u16;
}
extern "C" {
    pub fn _wctime32(_Time: *const __time32_t) -> *mut u16;
}
extern "C" {
    pub fn wcsftime(_Buf: *mut u16, _SizeInWords: usize, _Format: *const u16,
                    _Tm: *const tm) -> usize;
}
extern "C" {
    pub fn _wcsftime_l(_Buf: *mut u16, _SizeInWords: usize,
                       _Format: *const u16, _Tm: *const tm,
                       _Locale: _locale_t) -> usize;
}
extern "C" {
    pub fn _wstrdate(_Buffer: *mut u16) -> *mut u16;
}
extern "C" {
    pub fn _wstrtime(_Buffer: *mut u16) -> *mut u16;
}
extern "C" {
    pub fn _wctime64(_Time: *const __time64_t) -> *mut u16;
}
extern "C" {
    pub fn _wctime(_Time: *const time_t) -> *mut u16;
}
pub type mbstate_t = ::std::os::raw::c_int;
pub type _Wint_t = u16;
extern "C" {
    pub fn btowc(arg1: ::std::os::raw::c_int) -> wint_t;
}
extern "C" {
    pub fn mbrlen(_Ch: *const ::std::os::raw::c_char, _SizeInBytes: usize,
                  _State: *mut mbstate_t) -> usize;
}
extern "C" {
    pub fn mbrtowc(_DstCh: *mut u16, _SrcCh: *const ::std::os::raw::c_char,
                   _SizeInBytes: usize, _State: *mut mbstate_t) -> usize;
}
extern "C" {
    pub fn mbsrtowcs(_Dest: *mut u16,
                     _PSrc: *mut *const ::std::os::raw::c_char, _Count: usize,
                     _State: *mut mbstate_t) -> usize;
}
extern "C" {
    pub fn wcrtomb(_Dest: *mut ::std::os::raw::c_char, _Source: u16,
                   _State: *mut mbstate_t) -> usize;
}
extern "C" {
    pub fn wcsrtombs(_Dest: *mut ::std::os::raw::c_char,
                     _PSource: *mut *const u16, _Count: usize,
                     _State: *mut mbstate_t) -> usize;
}
extern "C" {
    pub fn wctob(_WCh: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wmemset(s: *mut u16, c: u16, n: usize) -> *mut u16;
}
extern "C" {
    pub fn wmemchr(s: *const u16, c: u16, n: usize) -> *mut u16;
}
extern "C" {
    pub fn wmemcmp(s1: *const u16, s2: *const u16, n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wmemcpy(s1: *mut u16, s2: *const u16, n: usize) -> *mut u16;
}
extern "C" {
    pub fn wmempcpy(_Dst: *mut u16, _Src: *const u16, _Size: usize)
     -> *mut u16;
}
extern "C" {
    pub fn wmemmove(s1: *mut u16, s2: *const u16, n: usize) -> *mut u16;
}
extern "C" {
    pub fn fwide(stream: *mut FILE, mode: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbsinit(ps: *const mbstate_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcstoll(nptr: *const u16, endptr: *mut *mut u16,
                   base: ::std::os::raw::c_int) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn wcstoull(nptr: *const u16, endptr: *mut *mut u16,
                    base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn memmove(_Dst: *mut ::std::os::raw::c_void,
                   _Src: *const ::std::os::raw::c_void, _MaxCount: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcpy(_Dst: *mut ::std::os::raw::c_void,
                  _Src: *const ::std::os::raw::c_void, _MaxCount: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __mingw_str_wide_utf8(wptr: *const u16,
                                 mbptr: *mut *mut ::std::os::raw::c_char,
                                 buflen: *mut usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __mingw_str_utf8_wide(mbptr: *const ::std::os::raw::c_char,
                                 wptr: *mut *mut u16, buflen: *mut usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __mingw_str_free(ptr: *mut ::std::os::raw::c_void);
}
pub type fpos_t = ::std::os::raw::c_longlong;
extern "C" {
    pub fn __mingw_sscanf(_Src: *const ::std::os::raw::c_char,
                          _Format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __mingw_vsscanf(_Str: *const ::std::os::raw::c_char,
                           Format: *const ::std::os::raw::c_char,
                           argp: va_list) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __mingw_scanf(_Format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __mingw_vscanf(Format: *const ::std::os::raw::c_char,
                          argp: va_list) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __mingw_fscanf(_File: *mut FILE,
                          _Format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __mingw_vfscanf(fp: *mut FILE,
                           Format: *const ::std::os::raw::c_char,
                           argp: va_list) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __mingw_vsnprintf(_DstBuf: *mut ::std::os::raw::c_char,
                             _MaxCount: usize,
                             _Format: *const ::std::os::raw::c_char,
                             _ArgList: va_list) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __mingw_snprintf(s: *mut ::std::os::raw::c_char, n: usize,
                            format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __mingw_printf(arg1: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __mingw_vprintf(arg1: *const ::std::os::raw::c_char, arg2: va_list)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __mingw_fprintf(arg1: *mut FILE,
                           arg2: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __mingw_vfprintf(arg1: *mut FILE,
                            arg2: *const ::std::os::raw::c_char,
                            arg3: va_list) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __mingw_sprintf(arg1: *mut ::std::os::raw::c_char,
                           arg2: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __mingw_vsprintf(arg1: *mut ::std::os::raw::c_char,
                            arg2: *const ::std::os::raw::c_char,
                            arg3: va_list) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __mingw_asprintf(arg1: *mut *mut ::std::os::raw::c_char,
                            arg2: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __mingw_vasprintf(arg1: *mut *mut ::std::os::raw::c_char,
                             arg2: *const ::std::os::raw::c_char,
                             arg3: va_list) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _filbuf(_File: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _flsbuf(_Ch: ::std::os::raw::c_int, _File: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fsopen(_Filename: *const ::std::os::raw::c_char,
                   _Mode: *const ::std::os::raw::c_char,
                   _ShFlag: ::std::os::raw::c_int) -> *mut FILE;
}
extern "C" {
    pub fn clearerr(_File: *mut FILE);
}
extern "C" {
    pub fn fclose(_File: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fcloseall() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fdopen(_FileHandle: ::std::os::raw::c_int,
                   _Mode: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn feof(_File: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(_File: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(_File: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(_File: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fgetchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetpos(_File: *mut FILE, _Pos: *mut fpos_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetpos64(_File: *mut FILE, _Pos: *mut fpos_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(_Buf: *mut ::std::os::raw::c_char,
                 _MaxCount: ::std::os::raw::c_int, _File: *mut FILE)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _fileno(_File: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _tempnam(_DirName: *const ::std::os::raw::c_char,
                    _FilePrefix: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _flushall() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(_Filename: *const ::std::os::raw::c_char,
                 _Mode: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fopen64(filename: *const ::std::os::raw::c_char,
                   mode: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fputc(_Ch: ::std::os::raw::c_int, _File: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fputchar(_Ch: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputs(_Str: *const ::std::os::raw::c_char, _File: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(_DstBuf: *mut ::std::os::raw::c_void, _ElementSize: usize,
                 _Count: usize, _File: *mut FILE) -> usize;
}
extern "C" {
    pub fn freopen(_Filename: *const ::std::os::raw::c_char,
                   _Mode: *const ::std::os::raw::c_char, _File: *mut FILE)
     -> *mut FILE;
}
extern "C" {
    pub fn fsetpos(_File: *mut FILE, _Pos: *const fpos_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos64(_File: *mut FILE, _Pos: *const fpos_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseek(_File: *mut FILE, _Offset: ::std::os::raw::c_long,
                 _Origin: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseeko64(stream: *mut FILE, offset: _off64_t,
                    whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseeko(stream: *mut FILE, offset: _off_t,
                  whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(_File: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn ftello(stream: *mut FILE) -> _off_t;
}
extern "C" {
    pub fn ftello64(stream: *mut FILE) -> _off64_t;
}
extern "C" {
    pub fn _fseeki64(_File: *mut FILE, _Offset: ::std::os::raw::c_longlong,
                     _Origin: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _ftelli64(_File: *mut FILE) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fwrite(_Str: *const ::std::os::raw::c_void, _Size: usize,
                  _Count: usize, _File: *mut FILE) -> usize;
}
extern "C" {
    pub fn getc(_File: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _getmaxstdio() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gets(_Buffer: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _getw(_File: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(_ErrMsg: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn _pclose(_File: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _popen(_Command: *const ::std::os::raw::c_char,
                  _Mode: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn putc(_Ch: ::std::os::raw::c_int, _File: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(_Ch: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(_Str: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _putw(_Word: ::std::os::raw::c_int, _File: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn remove(_Filename: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(_OldFilename: *const ::std::os::raw::c_char,
                  _NewFilename: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _unlink(_Filename: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unlink(_Filename: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rewind(_File: *mut FILE);
}
extern "C" {
    pub fn _rmtmp() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuf(_File: *mut FILE, _Buffer: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn _setmaxstdio(_Max: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _set_output_format(_Format: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _get_output_format() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn setvbuf(_File: *mut FILE, _Buf: *mut ::std::os::raw::c_char,
                   _Mode: ::std::os::raw::c_int, _Size: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _scprintf(_Format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _snscanf(_Src: *const ::std::os::raw::c_char, _MaxCount: usize,
                    _Format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(_Buffer: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ungetc(_Ch: ::std::os::raw::c_int, _File: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _snprintf(_Dest: *mut ::std::os::raw::c_char, _Count: usize,
                     _Format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vsnprintf(_Dest: *mut ::std::os::raw::c_char, _Count: usize,
                      _Format: *const ::std::os::raw::c_char, _Args: va_list)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vscprintf(_Format: *const ::std::os::raw::c_char,
                      _ArgList: va_list) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _set_printf_count_output(_Value: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _get_printf_count_output() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _lock_file(_File: *mut FILE);
}
extern "C" {
    pub fn _unlock_file(_File: *mut FILE);
}
extern "C" {
    pub fn _fclose_nolock(_File: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fflush_nolock(_File: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fread_nolock(_DstBuf: *mut ::std::os::raw::c_void,
                         _ElementSize: usize, _Count: usize, _File: *mut FILE)
     -> usize;
}
extern "C" {
    pub fn _fseek_nolock(_File: *mut FILE, _Offset: ::std::os::raw::c_long,
                         _Origin: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _ftell_nolock(_File: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _fseeki64_nolock(_File: *mut FILE,
                            _Offset: ::std::os::raw::c_longlong,
                            _Origin: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _ftelli64_nolock(_File: *mut FILE) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _fwrite_nolock(_DstBuf: *const ::std::os::raw::c_void,
                          _Size: usize, _Count: usize, _File: *mut FILE)
     -> usize;
}
extern "C" {
    pub fn _ungetc_nolock(_Ch: ::std::os::raw::c_int, _File: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tempnam(_Directory: *const ::std::os::raw::c_char,
                   _FilePrefix: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcloseall() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fdopen(_FileHandle: ::std::os::raw::c_int,
                  _Format: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fgetchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno(_File: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flushall() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputchar(_Ch: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(_File: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(_Ch: ::std::os::raw::c_int, _File: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rmtmp() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _spawnv(_Mode: ::std::os::raw::c_int,
                   _Filename: *const ::std::os::raw::c_char,
                   _ArgList: *const *const ::std::os::raw::c_char) -> isize;
}
extern "C" {
    pub fn _spawnve(_Mode: ::std::os::raw::c_int,
                    _Filename: *const ::std::os::raw::c_char,
                    _ArgList: *const *const ::std::os::raw::c_char,
                    _Env: *const *const ::std::os::raw::c_char) -> isize;
}
extern "C" {
    pub fn _spawnvp(_Mode: ::std::os::raw::c_int,
                    _Filename: *const ::std::os::raw::c_char,
                    _ArgList: *const *const ::std::os::raw::c_char) -> isize;
}
extern "C" {
    pub fn _spawnvpe(_Mode: ::std::os::raw::c_int,
                     _Filename: *const ::std::os::raw::c_char,
                     _ArgList: *const *const ::std::os::raw::c_char,
                     _Env: *const *const ::std::os::raw::c_char) -> isize;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lconv {
    pub decimal_point: *mut ::std::os::raw::c_char,
    pub thousands_sep: *mut ::std::os::raw::c_char,
    pub grouping: *mut ::std::os::raw::c_char,
    pub int_curr_symbol: *mut ::std::os::raw::c_char,
    pub currency_symbol: *mut ::std::os::raw::c_char,
    pub mon_decimal_point: *mut ::std::os::raw::c_char,
    pub mon_thousands_sep: *mut ::std::os::raw::c_char,
    pub mon_grouping: *mut ::std::os::raw::c_char,
    pub positive_sign: *mut ::std::os::raw::c_char,
    pub negative_sign: *mut ::std::os::raw::c_char,
    pub int_frac_digits: ::std::os::raw::c_char,
    pub frac_digits: ::std::os::raw::c_char,
    pub p_cs_precedes: ::std::os::raw::c_char,
    pub p_sep_by_space: ::std::os::raw::c_char,
    pub n_cs_precedes: ::std::os::raw::c_char,
    pub n_sep_by_space: ::std::os::raw::c_char,
    pub p_sign_posn: ::std::os::raw::c_char,
    pub n_sign_posn: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_lconv() {
    assert_eq!(::std::mem::size_of::<lconv>() , 88usize , concat ! (
               "Size of: " , stringify ! ( lconv ) ));
    assert_eq! (::std::mem::align_of::<lconv>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lconv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lconv ) ) . decimal_point as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lconv ) , "::" ,
                stringify ! ( decimal_point ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lconv ) ) . thousands_sep as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lconv ) , "::" ,
                stringify ! ( thousands_sep ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lconv ) ) . grouping as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lconv ) , "::" ,
                stringify ! ( grouping ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lconv ) ) . int_curr_symbol as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( lconv ) , "::" ,
                stringify ! ( int_curr_symbol ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lconv ) ) . currency_symbol as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( lconv ) , "::" ,
                stringify ! ( currency_symbol ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lconv ) ) . mon_decimal_point as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( lconv ) , "::" ,
                stringify ! ( mon_decimal_point ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lconv ) ) . mon_thousands_sep as * const
                _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( lconv ) , "::" ,
                stringify ! ( mon_thousands_sep ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lconv ) ) . mon_grouping as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( lconv ) , "::" ,
                stringify ! ( mon_grouping ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lconv ) ) . positive_sign as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( lconv ) , "::" ,
                stringify ! ( positive_sign ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lconv ) ) . negative_sign as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( lconv ) , "::" ,
                stringify ! ( negative_sign ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lconv ) ) . int_frac_digits as * const _
                as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( lconv ) , "::" ,
                stringify ! ( int_frac_digits ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lconv ) ) . frac_digits as * const _ as
                usize } , 81usize , concat ! (
                "Alignment of field: " , stringify ! ( lconv ) , "::" ,
                stringify ! ( frac_digits ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lconv ) ) . p_cs_precedes as * const _ as
                usize } , 82usize , concat ! (
                "Alignment of field: " , stringify ! ( lconv ) , "::" ,
                stringify ! ( p_cs_precedes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lconv ) ) . p_sep_by_space as * const _
                as usize } , 83usize , concat ! (
                "Alignment of field: " , stringify ! ( lconv ) , "::" ,
                stringify ! ( p_sep_by_space ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lconv ) ) . n_cs_precedes as * const _ as
                usize } , 84usize , concat ! (
                "Alignment of field: " , stringify ! ( lconv ) , "::" ,
                stringify ! ( n_cs_precedes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lconv ) ) . n_sep_by_space as * const _
                as usize } , 85usize , concat ! (
                "Alignment of field: " , stringify ! ( lconv ) , "::" ,
                stringify ! ( n_sep_by_space ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lconv ) ) . p_sign_posn as * const _ as
                usize } , 86usize , concat ! (
                "Alignment of field: " , stringify ! ( lconv ) , "::" ,
                stringify ! ( p_sign_posn ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lconv ) ) . n_sign_posn as * const _ as
                usize } , 87usize , concat ! (
                "Alignment of field: " , stringify ! ( lconv ) , "::" ,
                stringify ! ( n_sign_posn ) ));
}
impl Clone for lconv {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn _configthreadlocale(_Flag: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setlocale(_Category: ::std::os::raw::c_int,
                     _Locale: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn localeconv() -> *mut lconv;
}
extern "C" {
    pub fn _get_current_locale() -> _locale_t;
}
extern "C" {
    pub fn _create_locale(_Category: ::std::os::raw::c_int,
                          _Locale: *const ::std::os::raw::c_char)
     -> _locale_t;
}
extern "C" {
    pub fn _free_locale(_Locale: _locale_t);
}
extern "C" {
    pub fn __get_current_locale() -> _locale_t;
}
extern "C" {
    pub fn __create_locale(_Category: ::std::os::raw::c_int,
                           _Locale: *const ::std::os::raw::c_char)
     -> _locale_t;
}
extern "C" {
    pub fn __free_locale(_Locale: _locale_t);
}
extern "C" {
    #[link_name = "__newclmap"]
    pub static mut __newclmap: [::std::os::raw::c_uchar; 0usize];
}
extern "C" {
    #[link_name = "__newcumap"]
    pub static mut __newcumap: [::std::os::raw::c_uchar; 0usize];
}
extern "C" {
    #[link_name = "__ptlocinfo"]
    pub static mut __ptlocinfo: pthreadlocinfo;
}
extern "C" {
    #[link_name = "__ptmbcinfo"]
    pub static mut __ptmbcinfo: pthreadmbcinfo;
}
extern "C" {
    #[link_name = "__globallocalestatus"]
    pub static mut __globallocalestatus: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__locale_changed"]
    pub static mut __locale_changed: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__initiallocinfo"]
    pub static mut __initiallocinfo: threadlocaleinfostruct;
}
extern "C" {
    #[link_name = "__initiallocalestructinfo"]
    pub static mut __initiallocalestructinfo: _locale_tstruct;
}
extern "C" {
    pub fn __updatetlocinfo() -> pthreadlocinfo;
}
extern "C" {
    pub fn __updatetmbcinfo() -> pthreadmbcinfo;
}
extern "C" {
    pub fn _isctype(_C: ::std::os::raw::c_int, _Type: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _isctype_l(_C: ::std::os::raw::c_int, _Type: ::std::os::raw::c_int,
                      _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isalpha(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _isalpha_l(_C: ::std::os::raw::c_int, _Locale: _locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isupper(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _isupper_l(_C: ::std::os::raw::c_int, _Locale: _locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn islower(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _islower_l(_C: ::std::os::raw::c_int, _Locale: _locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isdigit(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _isdigit_l(_C: ::std::os::raw::c_int, _Locale: _locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isxdigit(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _isxdigit_l(_C: ::std::os::raw::c_int, _Locale: _locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isspace(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _isspace_l(_C: ::std::os::raw::c_int, _Locale: _locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ispunct(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _ispunct_l(_C: ::std::os::raw::c_int, _Locale: _locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isalnum(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _isalnum_l(_C: ::std::os::raw::c_int, _Locale: _locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isprint(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _isprint_l(_C: ::std::os::raw::c_int, _Locale: _locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isgraph(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _isgraph_l(_C: ::std::os::raw::c_int, _Locale: _locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iscntrl(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iscntrl_l(_C: ::std::os::raw::c_int, _Locale: _locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn toupper(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tolower(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _tolower(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _tolower_l(_C: ::std::os::raw::c_int, _Locale: _locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _toupper(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _toupper_l(_C: ::std::os::raw::c_int, _Locale: _locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isascii(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __toascii(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iscsymf(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iscsym(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isblank(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__imp___mb_cur_max"]
    pub static mut __imp___mb_cur_max: *mut ::std::os::raw::c_int;
}
#[repr(C)]
pub struct __cxxabiv1___forced_unwind__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct __cxxabiv1___forced_unwind {
    pub vtable_: *const __cxxabiv1___forced_unwind__bindgen_vtable,
}
#[test]
fn bindgen_test_layout___cxxabiv1___forced_unwind() {
    assert_eq!(::std::mem::size_of::<__cxxabiv1___forced_unwind>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( __cxxabiv1___forced_unwind ) ));
    assert_eq! (::std::mem::align_of::<__cxxabiv1___forced_unwind>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( __cxxabiv1___forced_unwind )
                ));
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __cxxabiv1___class_type_info([u8; 0]);
pub type __gthread_key_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __gthread_once_t {
    pub done: ::std::os::raw::c_int,
    pub started: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout___gthread_once_t() {
    assert_eq!(::std::mem::size_of::<__gthread_once_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( __gthread_once_t ) ));
    assert_eq! (::std::mem::align_of::<__gthread_once_t>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( __gthread_once_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __gthread_once_t ) ) . done as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __gthread_once_t ) ,
                "::" , stringify ! ( done ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __gthread_once_t ) ) . started as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __gthread_once_t ) ,
                "::" , stringify ! ( started ) ));
}
impl Clone for __gthread_once_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __gthread_mutex_t {
    pub counter: ::std::os::raw::c_long,
    pub sema: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___gthread_mutex_t() {
    assert_eq!(::std::mem::size_of::<__gthread_mutex_t>() , 16usize , concat !
               ( "Size of: " , stringify ! ( __gthread_mutex_t ) ));
    assert_eq! (::std::mem::align_of::<__gthread_mutex_t>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( __gthread_mutex_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __gthread_mutex_t ) ) . counter as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __gthread_mutex_t ) ,
                "::" , stringify ! ( counter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __gthread_mutex_t ) ) . sema as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __gthread_mutex_t ) ,
                "::" , stringify ! ( sema ) ));
}
impl Clone for __gthread_mutex_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __gthread_recursive_mutex_t {
    pub counter: ::std::os::raw::c_long,
    pub depth: ::std::os::raw::c_long,
    pub owner: ::std::os::raw::c_ulong,
    pub sema: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___gthread_recursive_mutex_t() {
    assert_eq!(::std::mem::size_of::<__gthread_recursive_mutex_t>() , 24usize
               , concat ! (
               "Size of: " , stringify ! ( __gthread_recursive_mutex_t ) ));
    assert_eq! (::std::mem::align_of::<__gthread_recursive_mutex_t>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( __gthread_recursive_mutex_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __gthread_recursive_mutex_t ) ) . counter
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __gthread_recursive_mutex_t ) , "::" , stringify ! ( counter )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __gthread_recursive_mutex_t ) ) . depth
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                __gthread_recursive_mutex_t ) , "::" , stringify ! ( depth )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __gthread_recursive_mutex_t ) ) . owner
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                __gthread_recursive_mutex_t ) , "::" , stringify ! ( owner )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __gthread_recursive_mutex_t ) ) . sema as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                __gthread_recursive_mutex_t ) , "::" , stringify ! ( sema )
                ));
}
impl Clone for __gthread_recursive_mutex_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "_CRT_MT"]
    pub static mut _CRT_MT: ::std::os::raw::c_int;
}
extern "C" {
    pub fn __mingwthr_key_dtor(arg1: ::std::os::raw::c_ulong,
                               arg2:
                                   ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                  *mut ::std::os::raw::c_void)>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gthr_win32_once(arg1: *mut std___gthread_once_t,
                             arg2:
                                 ::std::option::Option<unsafe extern "C" fn()>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gthr_win32_key_create(arg1: *mut __gthread_key_t,
                                   arg2:
                                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                      *mut ::std::os::raw::c_void)>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gthr_win32_key_delete(arg1: __gthread_key_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gthr_win32_getspecific(arg1: __gthread_key_t)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __gthr_win32_setspecific(arg1: __gthread_key_t,
                                    arg2: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gthr_win32_mutex_init_function(arg1: *mut __gthread_mutex_t);
}
extern "C" {
    pub fn __gthr_win32_mutex_lock(arg1: *mut __gthread_mutex_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gthr_win32_mutex_trylock(arg1: *mut __gthread_mutex_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gthr_win32_mutex_unlock(arg1: *mut __gthread_mutex_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gthr_win32_recursive_mutex_init_function(arg1:
                                                          *mut __gthread_recursive_mutex_t);
}
extern "C" {
    pub fn __gthr_win32_recursive_mutex_lock(arg1:
                                                 *mut __gthread_recursive_mutex_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gthr_win32_recursive_mutex_trylock(arg1:
                                                    *mut __gthread_recursive_mutex_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gthr_win32_recursive_mutex_unlock(arg1:
                                                   *mut __gthread_recursive_mutex_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gthr_win32_mutex_destroy(arg1: *mut __gthread_mutex_t);
}
extern "C" {
    pub fn __gthr_win32_recursive_mutex_destroy(arg1:
                                                    *mut __gthread_recursive_mutex_t)
     -> ::std::os::raw::c_int;
}
pub type _onexit_t =
    ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__div_t() {
    assert_eq!(::std::mem::size_of::<_div_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( _div_t ) ));
    assert_eq! (::std::mem::align_of::<_div_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( _div_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _div_t ) ) . quot as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _div_t ) , "::" ,
                stringify ! ( quot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _div_t ) ) . rem as * const _ as usize }
                , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _div_t ) , "::" ,
                stringify ! ( rem ) ));
}
impl Clone for _div_t {
    fn clone(&self) -> Self { *self }
}
pub type div_t = _div_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout__ldiv_t() {
    assert_eq!(::std::mem::size_of::<_ldiv_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( _ldiv_t ) ));
    assert_eq! (::std::mem::align_of::<_ldiv_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( _ldiv_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _ldiv_t ) ) . quot as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _ldiv_t ) , "::" ,
                stringify ! ( quot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _ldiv_t ) ) . rem as * const _ as usize }
                , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _ldiv_t ) , "::" ,
                stringify ! ( rem ) ));
}
impl Clone for _ldiv_t {
    fn clone(&self) -> Self { *self }
}
pub type ldiv_t = _ldiv_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _LDOUBLE {
    pub ld: [::std::os::raw::c_uchar; 10usize],
}
#[test]
fn bindgen_test_layout__LDOUBLE() {
    assert_eq!(::std::mem::size_of::<_LDOUBLE>() , 10usize , concat ! (
               "Size of: " , stringify ! ( _LDOUBLE ) ));
    assert_eq! (::std::mem::align_of::<_LDOUBLE>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( _LDOUBLE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _LDOUBLE ) ) . ld as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _LDOUBLE ) , "::" ,
                stringify ! ( ld ) ));
}
impl Clone for _LDOUBLE {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CRT_DOUBLE {
    pub x: f64,
}
#[test]
fn bindgen_test_layout__CRT_DOUBLE() {
    assert_eq!(::std::mem::size_of::<_CRT_DOUBLE>() , 8usize , concat ! (
               "Size of: " , stringify ! ( _CRT_DOUBLE ) ));
    assert_eq! (::std::mem::align_of::<_CRT_DOUBLE>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _CRT_DOUBLE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _CRT_DOUBLE ) ) . x as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _CRT_DOUBLE ) , "::" ,
                stringify ! ( x ) ));
}
impl Clone for _CRT_DOUBLE {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _CRT_FLOAT {
    pub f: f32,
}
#[test]
fn bindgen_test_layout__CRT_FLOAT() {
    assert_eq!(::std::mem::size_of::<_CRT_FLOAT>() , 4usize , concat ! (
               "Size of: " , stringify ! ( _CRT_FLOAT ) ));
    assert_eq! (::std::mem::align_of::<_CRT_FLOAT>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( _CRT_FLOAT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _CRT_FLOAT ) ) . f as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _CRT_FLOAT ) , "::" ,
                stringify ! ( f ) ));
}
impl Clone for _CRT_FLOAT {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _LONGDOUBLE {
    pub x: f64,
}
#[test]
fn bindgen_test_layout__LONGDOUBLE() {
    assert_eq!(::std::mem::size_of::<_LONGDOUBLE>() , 8usize , concat ! (
               "Size of: " , stringify ! ( _LONGDOUBLE ) ));
    assert_eq! (::std::mem::align_of::<_LONGDOUBLE>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _LONGDOUBLE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _LONGDOUBLE ) ) . x as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _LONGDOUBLE ) , "::" ,
                stringify ! ( x ) ));
}
impl Clone for _LONGDOUBLE {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _LDBL12 {
    pub ld12: [::std::os::raw::c_uchar; 12usize],
}
#[test]
fn bindgen_test_layout__LDBL12() {
    assert_eq!(::std::mem::size_of::<_LDBL12>() , 12usize , concat ! (
               "Size of: " , stringify ! ( _LDBL12 ) ));
    assert_eq! (::std::mem::align_of::<_LDBL12>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( _LDBL12 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _LDBL12 ) ) . ld12 as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _LDBL12 ) , "::" ,
                stringify ! ( ld12 ) ));
}
impl Clone for _LDBL12 {
    fn clone(&self) -> Self { *self }
}
pub type _purecall_handler = ::std::option::Option<unsafe extern "C" fn()>;
extern "C" {
    pub fn _set_purecall_handler(_Handler: _purecall_handler)
     -> _purecall_handler;
}
extern "C" {
    pub fn _get_purecall_handler() -> _purecall_handler;
}
pub type _invalid_parameter_handler =
    ::std::option::Option<unsafe extern "C" fn(arg1: *const u16,
                                               arg2: *const u16,
                                               arg3: *const u16,
                                               arg4: ::std::os::raw::c_uint,
                                               arg5: usize)>;
extern "C" {
    pub fn _set_invalid_parameter_handler(_Handler:
                                              _invalid_parameter_handler)
     -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _get_invalid_parameter_handler() -> _invalid_parameter_handler;
}
extern "C" {
    pub fn __doserrno() -> *mut ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _set_doserrno(_Value: ::std::os::raw::c_ulong) -> errno_t;
}
extern "C" {
    pub fn _get_doserrno(_Value: *mut ::std::os::raw::c_ulong) -> errno_t;
}
extern "C" {
    #[link_name = "_sys_errlist"]
    pub static mut _sys_errlist: [*mut ::std::os::raw::c_char; 1usize];
}
extern "C" {
    #[link_name = "_sys_nerr"]
    pub static mut _sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__imp___argc"]
    pub static mut __imp___argc: *mut ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__imp___argv"]
    pub static mut __imp___argv: *mut *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "__imp___wargv"]
    pub static mut __imp___wargv: *mut *mut *mut u16;
}
extern "C" {
    #[link_name = "__imp__environ"]
    pub static mut __imp__environ: *mut *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "__imp__wenviron"]
    pub static mut __imp__wenviron: *mut *mut *mut u16;
}
extern "C" {
    #[link_name = "__imp__pgmptr"]
    pub static mut __imp__pgmptr: *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "__imp__wpgmptr"]
    pub static mut __imp__wpgmptr: *mut *mut u16;
}
extern "C" {
    pub fn _get_pgmptr(_Value: *mut *mut ::std::os::raw::c_char) -> errno_t;
}
extern "C" {
    pub fn _get_wpgmptr(_Value: *mut *mut u16) -> errno_t;
}
extern "C" {
    #[link_name = "__imp__fmode"]
    pub static mut __imp__fmode: *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn _set_fmode(_Mode: ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn _get_fmode(_PMode: *mut ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    #[link_name = "__imp__osplatform"]
    pub static mut __imp__osplatform: *mut ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "__imp__osver"]
    pub static mut __imp__osver: *mut ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "__imp__winver"]
    pub static mut __imp__winver: *mut ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "__imp__winmajor"]
    pub static mut __imp__winmajor: *mut ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "__imp__winminor"]
    pub static mut __imp__winminor: *mut ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _get_osplatform(_Value: *mut ::std::os::raw::c_uint) -> errno_t;
}
extern "C" {
    pub fn _get_osver(_Value: *mut ::std::os::raw::c_uint) -> errno_t;
}
extern "C" {
    pub fn _get_winver(_Value: *mut ::std::os::raw::c_uint) -> errno_t;
}
extern "C" {
    pub fn _get_winmajor(_Value: *mut ::std::os::raw::c_uint) -> errno_t;
}
extern "C" {
    pub fn _get_winminor(_Value: *mut ::std::os::raw::c_uint) -> errno_t;
}
extern "C" {
    pub fn exit(_Code: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _exit(_Code: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _Exit(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn _set_abort_behavior(_Flags: ::std::os::raw::c_uint,
                               _Mask: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn abs(_X: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(_X: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _abs64(arg1: ::std::os::raw::c_longlong)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn atexit(arg1: ::std::option::Option<unsafe extern "C" fn()>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atof(_String: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn _atof_l(_String: *const ::std::os::raw::c_char, _Locale: _locale_t)
     -> f64;
}
extern "C" {
    pub fn atoi(_Str: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atoi_l(_Str: *const ::std::os::raw::c_char, _Locale: _locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(_Str: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _atol_l(_Str: *const ::std::os::raw::c_char, _Locale: _locale_t)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn bsearch(_Key: *const ::std::os::raw::c_void,
                   _Base: *const ::std::os::raw::c_void,
                   _NumOfElements: usize, _SizeOfElements: usize,
                   _PtFuncCompare:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *const ::std::os::raw::c_void,
                                                                  arg2:
                                                                      *const ::std::os::raw::c_void)
                                                 -> ::std::os::raw::c_int>)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(_Base: *mut ::std::os::raw::c_void, _NumOfElements: usize,
                 _SizeOfElements: usize,
                 _PtFuncCompare:
                     ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                    *const ::std::os::raw::c_void,
                                                                arg2:
                                                                    *const ::std::os::raw::c_void)
                                               -> ::std::os::raw::c_int>);
}
extern "C" {
    pub fn _byteswap_ushort(_Short: ::std::os::raw::c_ushort)
     -> ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn _byteswap_ulong(_Long: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _byteswap_uint64(_Int64: ::std::os::raw::c_ulonglong)
     -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn div(_Numerator: ::std::os::raw::c_int,
               _Denominator: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn getenv(_VarName: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _itoa(_Value: ::std::os::raw::c_int,
                 _Dest: *mut ::std::os::raw::c_char,
                 _Radix: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _i64toa(_Val: ::std::os::raw::c_longlong,
                   _DstBuf: *mut ::std::os::raw::c_char,
                   _Radix: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ui64toa(_Val: ::std::os::raw::c_ulonglong,
                    _DstBuf: *mut ::std::os::raw::c_char,
                    _Radix: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _atoi64(_String: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _atoi64_l(_String: *const ::std::os::raw::c_char,
                     _Locale: _locale_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _strtoi64(_String: *const ::std::os::raw::c_char,
                     _EndPtr: *mut *mut ::std::os::raw::c_char,
                     _Radix: ::std::os::raw::c_int)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _strtoi64_l(_String: *const ::std::os::raw::c_char,
                       _EndPtr: *mut *mut ::std::os::raw::c_char,
                       _Radix: ::std::os::raw::c_int, _Locale: _locale_t)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _strtoui64(_String: *const ::std::os::raw::c_char,
                      _EndPtr: *mut *mut ::std::os::raw::c_char,
                      _Radix: ::std::os::raw::c_int)
     -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strtoui64_l(_String: *const ::std::os::raw::c_char,
                        _EndPtr: *mut *mut ::std::os::raw::c_char,
                        _Radix: ::std::os::raw::c_int, _Locale: _locale_t)
     -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn ldiv(_Numerator: ::std::os::raw::c_long,
                _Denominator: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn _ltoa(_Value: ::std::os::raw::c_long,
                 _Dest: *mut ::std::os::raw::c_char,
                 _Radix: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mblen(_Ch: *const ::std::os::raw::c_char, _MaxCount: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mblen_l(_Ch: *const ::std::os::raw::c_char, _MaxCount: usize,
                    _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mbstrlen(_Str: *const ::std::os::raw::c_char) -> usize;
}
extern "C" {
    pub fn _mbstrlen_l(_Str: *const ::std::os::raw::c_char,
                       _Locale: _locale_t) -> usize;
}
extern "C" {
    pub fn _mbstrnlen(_Str: *const ::std::os::raw::c_char, _MaxCount: usize)
     -> usize;
}
extern "C" {
    pub fn _mbstrnlen_l(_Str: *const ::std::os::raw::c_char, _MaxCount: usize,
                        _Locale: _locale_t) -> usize;
}
extern "C" {
    pub fn mbtowc(_DstCh: *mut u16, _SrcCh: *const ::std::os::raw::c_char,
                  _SrcSizeInBytes: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mbtowc_l(_DstCh: *mut u16, _SrcCh: *const ::std::os::raw::c_char,
                     _SrcSizeInBytes: usize, _Locale: _locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(_Dest: *mut u16, _Source: *const ::std::os::raw::c_char,
                    _MaxCount: usize) -> usize;
}
extern "C" {
    pub fn _mbstowcs_l(_Dest: *mut u16,
                       _Source: *const ::std::os::raw::c_char,
                       _MaxCount: usize, _Locale: _locale_t) -> usize;
}
extern "C" {
    pub fn mkstemp(template_name: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _set_error_mode(_Mode: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(_Seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn strtold(arg1: *const ::std::os::raw::c_char,
                   arg2: *mut *mut ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn __strtod(arg1: *const ::std::os::raw::c_char,
                    arg2: *mut *mut ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn __mingw_strtof(arg1: *const ::std::os::raw::c_char,
                          arg2: *mut *mut ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn __mingw_strtod(arg1: *const ::std::os::raw::c_char,
                          arg2: *mut *mut ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn __mingw_strtold(arg1: *const ::std::os::raw::c_char,
                           arg2: *mut *mut ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn _strtod_l(_Str: *const ::std::os::raw::c_char,
                     _EndPtr: *mut *mut ::std::os::raw::c_char,
                     _Locale: _locale_t) -> f64;
}
extern "C" {
    pub fn strtol(_Str: *const ::std::os::raw::c_char,
                  _EndPtr: *mut *mut ::std::os::raw::c_char,
                  _Radix: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _strtol_l(_Str: *const ::std::os::raw::c_char,
                     _EndPtr: *mut *mut ::std::os::raw::c_char,
                     _Radix: ::std::os::raw::c_int, _Locale: _locale_t)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(_Str: *const ::std::os::raw::c_char,
                   _EndPtr: *mut *mut ::std::os::raw::c_char,
                   _Radix: ::std::os::raw::c_int) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _strtoul_l(_Str: *const ::std::os::raw::c_char,
                      _EndPtr: *mut *mut ::std::os::raw::c_char,
                      _Radix: ::std::os::raw::c_int, _Locale: _locale_t)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn system(_Command: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _ultoa(_Value: ::std::os::raw::c_ulong,
                  _Dest: *mut ::std::os::raw::c_char,
                  _Radix: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn wctomb(_MbCh: *mut ::std::os::raw::c_char, _WCh: u16)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wctomb_l(_MbCh: *mut ::std::os::raw::c_char, _WCh: u16,
                     _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcstombs(_Dest: *mut ::std::os::raw::c_char, _Source: *const u16,
                    _MaxCount: usize) -> usize;
}
extern "C" {
    pub fn _wcstombs_l(_Dest: *mut ::std::os::raw::c_char,
                       _Source: *const u16, _MaxCount: usize,
                       _Locale: _locale_t) -> usize;
}
extern "C" {
    pub fn calloc(_NumOfElements: usize, _SizeOfElements: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(_Memory: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn malloc(_Size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(_Memory: *mut ::std::os::raw::c_void, _NewSize: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _recalloc(_Memory: *mut ::std::os::raw::c_void, _Count: usize,
                     _Size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_free(_Memory: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _aligned_malloc(_Size: usize, _Alignment: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_offset_malloc(_Size: usize, _Alignment: usize,
                                  _Offset: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_realloc(_Memory: *mut ::std::os::raw::c_void,
                            _Size: usize, _Alignment: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_recalloc(_Memory: *mut ::std::os::raw::c_void,
                             _Count: usize, _Size: usize, _Alignment: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_offset_realloc(_Memory: *mut ::std::os::raw::c_void,
                                   _Size: usize, _Alignment: usize,
                                   _Offset: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_offset_recalloc(_Memory: *mut ::std::os::raw::c_void,
                                    _Count: usize, _Size: usize,
                                    _Alignment: usize, _Offset: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _putenv(_EnvString: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fullpath(_FullPath: *mut ::std::os::raw::c_char,
                     _Path: *const ::std::os::raw::c_char,
                     _SizeInBytes: usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ecvt(_Val: f64, _NumOfDigits: ::std::os::raw::c_int,
                 _PtDec: *mut ::std::os::raw::c_int,
                 _PtSign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _fcvt(_Val: f64, _NumOfDec: ::std::os::raw::c_int,
                 _PtDec: *mut ::std::os::raw::c_int,
                 _PtSign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _gcvt(_Val: f64, _NumOfDigits: ::std::os::raw::c_int,
                 _DstBuf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _atodbl(_Result: *mut _CRT_DOUBLE,
                   _Str: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atoldbl(_Result: *mut _LDOUBLE, _Str: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atoflt(_Result: *mut _CRT_FLOAT,
                   _Str: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atodbl_l(_Result: *mut _CRT_DOUBLE,
                     _Str: *mut ::std::os::raw::c_char, _Locale: _locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atoldbl_l(_Result: *mut _LDOUBLE,
                      _Str: *mut ::std::os::raw::c_char, _Locale: _locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atoflt_l(_Result: *mut _CRT_FLOAT,
                     _Str: *mut ::std::os::raw::c_char, _Locale: _locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _makepath(_Path: *mut ::std::os::raw::c_char,
                     _Drive: *const ::std::os::raw::c_char,
                     _Dir: *const ::std::os::raw::c_char,
                     _Filename: *const ::std::os::raw::c_char,
                     _Ext: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn _onexit(_Func: _onexit_t) -> _onexit_t;
}
extern "C" {
    pub fn _rotl64(_Val: ::std::os::raw::c_ulonglong,
                   _Shift: ::std::os::raw::c_int)
     -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _rotr64(Value: ::std::os::raw::c_ulonglong,
                   Shift: ::std::os::raw::c_int)
     -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _rotr(_Val: ::std::os::raw::c_uint, _Shift: ::std::os::raw::c_int)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _rotl(_Val: ::std::os::raw::c_uint, _Shift: ::std::os::raw::c_int)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _searchenv(_Filename: *const ::std::os::raw::c_char,
                      _EnvVar: *const ::std::os::raw::c_char,
                      _ResultPath: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn _splitpath(_FullPath: *const ::std::os::raw::c_char,
                      _Drive: *mut ::std::os::raw::c_char,
                      _Dir: *mut ::std::os::raw::c_char,
                      _Filename: *mut ::std::os::raw::c_char,
                      _Ext: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn _swab(_Buf1: *mut ::std::os::raw::c_char,
                 _Buf2: *mut ::std::os::raw::c_char,
                 _SizeInBytes: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _beep(_Frequency: ::std::os::raw::c_uint,
                 _Duration: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn _seterrormode(_Mode: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _sleep(_Duration: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn ecvt(_Val: f64, _NumOfDigits: ::std::os::raw::c_int,
                _PtDec: *mut ::std::os::raw::c_int,
                _PtSign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(_Val: f64, _NumOfDec: ::std::os::raw::c_int,
                _PtDec: *mut ::std::os::raw::c_int,
                _PtSign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(_Val: f64, _NumOfDigits: ::std::os::raw::c_int,
                _DstBuf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn itoa(_Val: ::std::os::raw::c_int,
                _DstBuf: *mut ::std::os::raw::c_char,
                _Radix: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ltoa(_Val: ::std::os::raw::c_long,
                _DstBuf: *mut ::std::os::raw::c_char,
                _Radix: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(_EnvString: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn swab(_Buf1: *mut ::std::os::raw::c_char,
                _Buf2: *mut ::std::os::raw::c_char,
                _SizeInBytes: ::std::os::raw::c_int);
}
extern "C" {
    pub fn ultoa(_Val: ::std::os::raw::c_ulong,
                 _Dstbuf: *mut ::std::os::raw::c_char,
                 _Radix: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn onexit(_Func: _onexit_t) -> _onexit_t;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(::std::mem::size_of::<lldiv_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( lldiv_t ) ));
    assert_eq! (::std::mem::align_of::<lldiv_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lldiv_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lldiv_t ) ) . quot as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lldiv_t ) , "::" ,
                stringify ! ( quot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lldiv_t ) ) . rem as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lldiv_t ) , "::" ,
                stringify ! ( rem ) ));
}
impl Clone for lldiv_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn lldiv(arg1: ::std::os::raw::c_longlong,
                 arg2: ::std::os::raw::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn llabs(arg1: ::std::os::raw::c_longlong)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoll(arg1: *const ::std::os::raw::c_char,
                   arg2: *mut *mut ::std::os::raw::c_char,
                   arg3: ::std::os::raw::c_int) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(arg1: *const ::std::os::raw::c_char,
                    arg2: *mut *mut ::std::os::raw::c_char,
                    arg3: ::std::os::raw::c_int)
     -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn atoll(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_longlong;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _heapinfo {
    pub _pentry: *mut ::std::os::raw::c_int,
    pub _size: usize,
    pub _useflag: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__heapinfo() {
    assert_eq!(::std::mem::size_of::<_heapinfo>() , 24usize , concat ! (
               "Size of: " , stringify ! ( _heapinfo ) ));
    assert_eq! (::std::mem::align_of::<_heapinfo>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _heapinfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _heapinfo ) ) . _pentry as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _heapinfo ) , "::" ,
                stringify ! ( _pentry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _heapinfo ) ) . _size as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _heapinfo ) , "::" ,
                stringify ! ( _size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _heapinfo ) ) . _useflag as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _heapinfo ) , "::" ,
                stringify ! ( _useflag ) ));
}
impl Clone for _heapinfo {
    fn clone(&self) -> Self { *self }
}
pub type _HEAPINFO = _heapinfo;
extern "C" {
    #[link_name = "_amblksiz"]
    pub static mut _amblksiz: ::std::os::raw::c_uint;
}
extern "C" {
    pub fn __mingw_aligned_malloc(_Size: usize, _Alignment: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __mingw_aligned_free(_Memory: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn __mingw_aligned_offset_realloc(_Memory:
                                              *mut ::std::os::raw::c_void,
                                          _Size: usize, _Alignment: usize,
                                          _Offset: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __mingw_aligned_realloc(_Memory: *mut ::std::os::raw::c_void,
                                   _Size: usize, _Offset: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _resetstkoflw() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _set_malloc_crt_max_wait(_NewValue: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _expand(_Memory: *mut ::std::os::raw::c_void, _NewSize: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _msize(_Memory: *mut ::std::os::raw::c_void) -> usize;
}
extern "C" {
    pub fn _get_sbh_threshold() -> usize;
}
extern "C" {
    pub fn _set_sbh_threshold(_NewValue: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _set_amblksiz(_Value: usize) -> errno_t;
}
extern "C" {
    pub fn _get_amblksiz(_Value: *mut usize) -> errno_t;
}
extern "C" {
    pub fn _heapadd(_Memory: *mut ::std::os::raw::c_void, _Size: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _heapchk() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _heapmin() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _heapset(_Fill: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _heapwalk(_EntryInfo: *mut _HEAPINFO) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _heapused(_Used: *mut usize, _Commit: *mut usize) -> usize;
}
extern "C" {
    pub fn _get_heap_handle() -> isize;
}
pub type octave_jmp_buf = jmp_buf;
extern "C" {
    #[link_name = "current_context"]
    pub static mut current_context: octave_jmp_buf;
}
extern "C" {
    pub fn octave_save_current_context(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn octave_restore_current_context(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn octave_jump_to_enclosing_context();
}
#[repr(C)]
pub struct octave_execution_exception__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct octave_execution_exception {
    pub vtable_: *const octave_execution_exception__bindgen_vtable,
    pub m_stack_trace: std_string,
}
#[test]
fn bindgen_test_layout_octave_execution_exception() {
    assert_eq!(::std::mem::size_of::<octave_execution_exception>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( octave_execution_exception ) ));
    assert_eq! (::std::mem::align_of::<octave_execution_exception>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( octave_execution_exception )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_execution_exception ) ) .
                m_stack_trace as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                octave_execution_exception ) , "::" , stringify ! (
                m_stack_trace ) ));
}
#[repr(C)]
#[derive(Debug)]
pub struct octave_exit_exception {
    pub m_exit_status: ::std::os::raw::c_int,
    pub m_safe_to_return: bool,
}
#[test]
fn bindgen_test_layout_octave_exit_exception() {
    assert_eq!(::std::mem::size_of::<octave_exit_exception>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( octave_exit_exception )
               ));
    assert_eq! (::std::mem::align_of::<octave_exit_exception>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( octave_exit_exception ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_exit_exception ) ) . m_exit_status
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_exit_exception )
                , "::" , stringify ! ( m_exit_status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_exit_exception ) ) .
                m_safe_to_return as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_exit_exception )
                , "::" , stringify ! ( m_safe_to_return ) ));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct octave_interrupt_exception {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_octave_interrupt_exception() {
    assert_eq!(::std::mem::size_of::<octave_interrupt_exception>() , 1usize ,
               concat ! (
               "Size of: " , stringify ! ( octave_interrupt_exception ) ));
    assert_eq! (::std::mem::align_of::<octave_interrupt_exception>() , 1usize
                , concat ! (
                "Alignment of " , stringify ! ( octave_interrupt_exception )
                ));
}
impl Clone for octave_interrupt_exception {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct octave_numeric_limits {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_octave_numeric_limits_instantiation_20399() {
    assert_eq!(::std::mem::size_of::<octave_numeric_limits>() , 1usize ,
               concat ! (
               "Size of template specialization: " , stringify ! (
               octave_numeric_limits ) ));
    assert_eq!(::std::mem::align_of::<octave_numeric_limits>() , 1usize ,
               concat ! (
               "Alignment of template specialization: " , stringify ! (
               octave_numeric_limits ) ));
}
#[test]
fn __bindgen_test_layout_octave_numeric_limits_instantiation_20403() {
    assert_eq!(::std::mem::size_of::<octave_numeric_limits>() , 1usize ,
               concat ! (
               "Size of template specialization: " , stringify ! (
               octave_numeric_limits ) ));
    assert_eq!(::std::mem::align_of::<octave_numeric_limits>() , 1usize ,
               concat ! (
               "Alignment of template specialization: " , stringify ! (
               octave_numeric_limits ) ));
}
extern "C" {
    #[link_name = "?is_NA@math@octave@@YA_NN@Z"]
    pub fn octave_math_is_NA(x: f64) -> bool;
}
extern "C" {
    #[link_name = "?is_NA@math@octave@@YA_NM@Z"]
    pub fn octave_math_is_NA1(x: f32) -> bool;
}
extern "C" {
    #[link_name = "?is_NA@math@octave@@YA_NAEBU?$complex@N@std@@@Z"]
    pub fn octave_math_is_NA2(x: *const Complex) -> bool;
}
extern "C" {
    #[link_name = "?is_NA@math@octave@@YA_NAEBU?$complex@M@std@@@Z"]
    pub fn octave_math_is_NA3(x: *const FloatComplex) -> bool;
}
extern "C" {
    #[link_name = "?is_NaN_or_NA@math@octave@@YA_NAEBU?$complex@N@std@@@Z"]
    pub fn octave_math_is_NaN_or_NA(x: *const Complex) -> bool;
}
extern "C" {
    #[link_name = "?is_NaN_or_NA@math@octave@@YA_NAEBU?$complex@M@std@@@Z"]
    pub fn octave_math_is_NaN_or_NA1(x: *const FloatComplex) -> bool;
}
extern "C" {
    #[link_name = "?copysign@math@octave@@YANNN@Z"]
    pub fn octave_math_copysign(x: f64, y: f64) -> f64;
}
extern "C" {
    #[link_name = "?copysign@math@octave@@YAMMM@Z"]
    pub fn octave_math_copysign1(x: f32, y: f32) -> f32;
}
extern "C" {
    #[link_name = "?signbit@math@octave@@YANN@Z"]
    pub fn octave_math_signbit(x: f64) -> f64;
}
extern "C" {
    #[link_name = "?signbit@math@octave@@YAMM@Z"]
    pub fn octave_math_signbit1(x: f32) -> f32;
}
extern "C" {
    #[link_name = "?negative_sign@math@octave@@YA_NN@Z"]
    pub fn octave_math_negative_sign(x: f64) -> bool;
}
extern "C" {
    #[link_name = "?negative_sign@math@octave@@YA_NM@Z"]
    pub fn octave_math_negative_sign1(x: f32) -> bool;
}
extern "C" {
    #[link_name = "?acos@math@octave@@YA?AU?$complex@N@std@@AEBU34@@Z"]
    pub fn octave_math_acos(x: *const Complex) -> Complex;
}
extern "C" {
    #[link_name = "?acos@math@octave@@YA?AU?$complex@M@std@@AEBU34@@Z"]
    pub fn octave_math_acos1(x: *const FloatComplex) -> FloatComplex;
}
extern "C" {
    #[link_name = "?asin@math@octave@@YA?AU?$complex@N@std@@AEBU34@@Z"]
    pub fn octave_math_asin(x: *const Complex) -> Complex;
}
extern "C" {
    #[link_name = "?asin@math@octave@@YA?AU?$complex@M@std@@AEBU34@@Z"]
    pub fn octave_math_asin1(x: *const FloatComplex) -> FloatComplex;
}
extern "C" {
    #[link_name = "?atan@math@octave@@YA?AU?$complex@N@std@@AEBU34@@Z"]
    pub fn octave_math_atan(x: *const Complex) -> Complex;
}
extern "C" {
    #[link_name = "?atan@math@octave@@YA?AU?$complex@M@std@@AEBU34@@Z"]
    pub fn octave_math_atan1(x: *const FloatComplex) -> FloatComplex;
}
extern "C" {
    #[link_name = "?log2@math@octave@@YANN@Z"]
    pub fn octave_math_log2(x: f64) -> f64;
}
extern "C" {
    #[link_name = "?log2@math@octave@@YAMM@Z"]
    pub fn octave_math_log21(x: f32) -> f32;
}
extern "C" {
    #[link_name = "?log2@math@octave@@YA?AU?$complex@N@std@@AEBU34@@Z"]
    pub fn octave_math_log22(x: *const Complex) -> Complex;
}
extern "C" {
    #[link_name = "?log2@math@octave@@YA?AU?$complex@M@std@@AEBU34@@Z"]
    pub fn octave_math_log23(x: *const FloatComplex) -> FloatComplex;
}
extern "C" {
    #[link_name = "?log2@math@octave@@YANNAEAH@Z"]
    pub fn octave_math_log24(x: f64, exp: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    #[link_name = "?log2@math@octave@@YAMMAEAH@Z"]
    pub fn octave_math_log25(x: f32, exp: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    #[link_name = "?log2@math@octave@@YA?AU?$complex@N@std@@AEBU34@AEAH@Z"]
    pub fn octave_math_log26(x: *const Complex,
                             exp: *mut ::std::os::raw::c_int) -> Complex;
}
extern "C" {
    #[link_name = "?log2@math@octave@@YA?AU?$complex@M@std@@AEBU34@AEAH@Z"]
    pub fn octave_math_log27(x: *const FloatComplex,
                             exp: *mut ::std::os::raw::c_int) -> FloatComplex;
}
extern "C" {
    #[link_name = "?exp2@math@octave@@YANN@Z"]
    pub fn octave_math_exp2(x: f64) -> f64;
}
extern "C" {
    #[link_name = "?exp2@math@octave@@YAMM@Z"]
    pub fn octave_math_exp21(x: f32) -> f32;
}
extern "C" {
    #[link_name = "?trunc@math@octave@@YANN@Z"]
    pub fn octave_math_trunc(x: f64) -> f64;
}
extern "C" {
    #[link_name = "?trunc@math@octave@@YAMM@Z"]
    pub fn octave_math_trunc1(x: f32) -> f32;
}
extern "C" {
    #[link_name = "?floor@math@octave@@YANN@Z"]
    pub fn octave_math_floor(x: f64) -> f64;
}
extern "C" {
    #[link_name = "?floor@math@octave@@YAMM@Z"]
    pub fn octave_math_floor1(x: f32) -> f32;
}
extern "C" {
    #[link_name = "?round@math@octave@@YANN@Z"]
    pub fn octave_math_round(x: f64) -> f64;
}
extern "C" {
    #[link_name = "?round@math@octave@@YAMM@Z"]
    pub fn octave_math_round1(x: f32) -> f32;
}
extern "C" {
    #[link_name = "?frexp@math@octave@@YANNPEAH@Z"]
    pub fn octave_math_frexp(x: f64, expptr: *mut ::std::os::raw::c_int)
     -> f64;
}
extern "C" {
    #[link_name = "?frexp@math@octave@@YAMMPEAH@Z"]
    pub fn octave_math_frexp1(x: f32, expptr: *mut ::std::os::raw::c_int)
     -> f32;
}
extern "C" {
    #[link_name = "?isnan@math@octave@@YA_NN@Z"]
    pub fn octave_math_isnan(x: f64) -> bool;
}
extern "C" {
    #[link_name = "?isnan@math@octave@@YA_NM@Z"]
    pub fn octave_math_isnan1(x: f32) -> bool;
}
extern "C" {
    #[link_name = "?finite@math@octave@@YA_NN@Z"]
    pub fn octave_math_finite(x: f64) -> bool;
}
extern "C" {
    #[link_name = "?finite@math@octave@@YA_NM@Z"]
    pub fn octave_math_finite1(x: f32) -> bool;
}
extern "C" {
    #[link_name = "?isinf@math@octave@@YA_NN@Z"]
    pub fn octave_math_isinf(x: f64) -> bool;
}
extern "C" {
    #[link_name = "?isinf@math@octave@@YA_NM@Z"]
    pub fn octave_math_isinf1(x: f32) -> bool;
}
extern "C" {
    #[link_name = "?nint_big@math@octave@@YAHN@Z"]
    pub fn octave_math_nint_big(x: f64) -> octave_idx_type;
}
extern "C" {
    #[link_name = "?nint_big@math@octave@@YAHM@Z"]
    pub fn octave_math_nint_big1(x: f32) -> octave_idx_type;
}
extern "C" {
    #[link_name = "?nint@math@octave@@YAHN@Z"]
    pub fn octave_math_nint(x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "?nint@math@octave@@YAHM@Z"]
    pub fn octave_math_nint1(x: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "?rc_acos@math@octave@@YA?AU?$complex@N@std@@N@Z"]
    pub fn octave_math_rc_acos(arg1: f64) -> Complex;
}
extern "C" {
    #[link_name = "?rc_acos@math@octave@@YA?AU?$complex@M@std@@M@Z"]
    pub fn octave_math_rc_acos1(arg1: f32) -> FloatComplex;
}
extern "C" {
    #[link_name = "?rc_acosh@math@octave@@YA?AU?$complex@N@std@@N@Z"]
    pub fn octave_math_rc_acosh(arg1: f64) -> Complex;
}
extern "C" {
    #[link_name = "?rc_acosh@math@octave@@YA?AU?$complex@M@std@@M@Z"]
    pub fn octave_math_rc_acosh1(arg1: f32) -> FloatComplex;
}
extern "C" {
    #[link_name = "?rc_asin@math@octave@@YA?AU?$complex@N@std@@N@Z"]
    pub fn octave_math_rc_asin(arg1: f64) -> Complex;
}
extern "C" {
    #[link_name = "?rc_asin@math@octave@@YA?AU?$complex@M@std@@M@Z"]
    pub fn octave_math_rc_asin1(arg1: f32) -> FloatComplex;
}
extern "C" {
    #[link_name = "?rc_atanh@math@octave@@YA?AU?$complex@N@std@@N@Z"]
    pub fn octave_math_rc_atanh(arg1: f64) -> Complex;
}
extern "C" {
    #[link_name = "?rc_atanh@math@octave@@YA?AU?$complex@M@std@@M@Z"]
    pub fn octave_math_rc_atanh1(arg1: f32) -> FloatComplex;
}
extern "C" {
    #[link_name = "?rc_log@math@octave@@YA?AU?$complex@N@std@@N@Z"]
    pub fn octave_math_rc_log(arg1: f64) -> Complex;
}
extern "C" {
    #[link_name = "?rc_log@math@octave@@YA?AU?$complex@M@std@@M@Z"]
    pub fn octave_math_rc_log1(arg1: f32) -> FloatComplex;
}
extern "C" {
    #[link_name = "?rc_log2@math@octave@@YA?AU?$complex@N@std@@N@Z"]
    pub fn octave_math_rc_log2(arg1: f64) -> Complex;
}
extern "C" {
    #[link_name = "?rc_log2@math@octave@@YA?AU?$complex@M@std@@M@Z"]
    pub fn octave_math_rc_log21(arg1: f32) -> FloatComplex;
}
extern "C" {
    #[link_name = "?rc_log10@math@octave@@YA?AU?$complex@N@std@@N@Z"]
    pub fn octave_math_rc_log10(arg1: f64) -> Complex;
}
extern "C" {
    #[link_name = "?rc_log10@math@octave@@YA?AU?$complex@M@std@@M@Z"]
    pub fn octave_math_rc_log101(arg1: f32) -> FloatComplex;
}
extern "C" {
    #[link_name = "?rc_sqrt@math@octave@@YA?AU?$complex@N@std@@N@Z"]
    pub fn octave_math_rc_sqrt(arg1: f64) -> Complex;
}
extern "C" {
    #[link_name = "?rc_sqrt@math@octave@@YA?AU?$complex@M@std@@M@Z"]
    pub fn octave_math_rc_sqrt1(arg1: f32) -> FloatComplex;
}
#[repr(C)]
pub struct octave_math_aepbalance__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
pub struct octave_math_aepbalance<MT> {
    pub vtable_: *const octave_math_aepbalance__bindgen_vtable,
    pub balanced_mat: MT,
    pub scale: octave_math_aepbalance_VT,
    pub ilo: octave_idx_type,
    pub ihi: octave_idx_type,
    pub job: ::std::os::raw::c_char,
}
pub type octave_math_aepbalance_VT = [u8; 0usize];
#[repr(C)]
pub struct octave_math_gepbalance<T> {
    pub balanced_mat: T,
    pub balanced_mat2: T,
    pub balancing_mat: octave_math_gepbalance_RT,
    pub balancing_mat2: octave_math_gepbalance_RT,
}
pub type octave_math_gepbalance_RT = [u8; 0usize];
#[repr(C)]
pub struct octave_math_chol<T> {
    pub chol_mat: T,
    pub xrcond: octave_math_chol_COND_T,
    pub is_upper: bool,
}
pub type octave_math_chol_VT = [u8; 0usize];
pub type octave_math_chol_COND_T = [u8; 0usize];
#[repr(C)]
#[derive(Debug)]
pub struct octave_math_hess<T> {
    pub hess_mat: T,
    pub unitary_hess_mat: T,
}
#[repr(C)]
#[derive(Debug)]
pub struct octave_math_schur<T> {
    pub schur_mat: T,
    pub unitary_mat: T,
}
#[repr(C)]
pub struct octave_math_svd<T> {
    pub m_type: octave_math_svd_Type,
    pub m_driver: octave_math_svd_Driver,
    pub left_sm: T,
    pub sigma: octave_math_svd_DM_T,
    pub right_sm: T,
}
pub type octave_math_svd_DM_T = [u8; 0usize];
pub const octave_math_svd_Type_economy: octave_math_svd_Type =
    octave_math_svd_Type::std;
pub const octave_math_svd_Type_sigma_only: octave_math_svd_Type =
    octave_math_svd_Type::std;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum octave_math_svd_Type { std = 0, }
pub const octave_math_svd_Driver_GESDD: octave_math_svd_Driver =
    octave_math_svd_Driver::GESVD;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum octave_math_svd_Driver { GESVD = 0, }
pub type octave_math_svd_P = [u8; 0usize];
pub type octave_math_svd_DM_P = [u8; 0usize];
#[repr(C)]
pub struct octave_math_lu__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct octave_math_lu<T> {
    pub vtable_: *const octave_math_lu__bindgen_vtable,
    pub a_fact: T,
    pub l_fact: T,
    pub ipvt: Array<::std::os::raw::c_int>,
}
pub type octave_math_lu_VT = [u8; 0usize];
pub type octave_math_lu_ELT_T = [u8; 0usize];
#[repr(C)]
pub struct octave_math_qr__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct octave_math_qr<T> {
    pub vtable_: *const octave_math_qr__bindgen_vtable,
    pub q: T,
    pub r: T,
}
pub type octave_math_qr_ELT_T = [u8; 0usize];
pub type octave_math_qr_RV_T = [u8; 0usize];
pub type octave_math_qr_CV_T = [u8; 0usize];
pub const octave_math_qr_type_raw: octave_math_qr_type =
    octave_math_qr_type::std;
pub const octave_math_qr_type_economy: octave_math_qr_type =
    octave_math_qr_type::std;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum octave_math_qr_type { std = 0, }
extern "C" {
    #[link_name = "?warn_qrupdate_once@math@octave@@YAXXZ"]
    pub fn octave_math_warn_qrupdate_once();
}
#[repr(C)]
#[derive(Debug)]
pub struct octave_index_exception {
    pub _base: octave_execution_exception,
    pub index: std_string,
    pub nd: octave_idx_type,
    pub dim: octave_idx_type,
    pub var: std_string,
}
#[test]
fn bindgen_test_layout_octave_index_exception() {
    assert_eq!(::std::mem::size_of::<octave_index_exception>() , 40usize ,
               concat ! ( "Size of: " , stringify ! ( octave_index_exception )
               ));
    assert_eq! (::std::mem::align_of::<octave_index_exception>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( octave_index_exception ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_index_exception ) ) . index as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_index_exception
                ) , "::" , stringify ! ( index ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_index_exception ) ) . nd as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_index_exception
                ) , "::" , stringify ! ( nd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_index_exception ) ) . dim as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_index_exception
                ) , "::" , stringify ! ( dim ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_index_exception ) ) . var as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_index_exception
                ) , "::" , stringify ! ( var ) ));
}
extern "C" {
    #[link_name =
          "?expression@index_exception@octave@@IEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ"]
    pub fn octave_index_exception_expression(this:
                                                 *const octave_index_exception)
     -> std_string;
}
impl octave_index_exception {
    #[inline]
    pub unsafe fn expression(&self) -> std_string {
        octave_index_exception_expression(self)
    }
}
extern "C" {
    #[link_name = "?err_nan_to_logical_conversion@octave@@YAXXZ"]
    pub fn octave_err_nan_to_logical_conversion();
}
extern "C" {
    #[link_name = "?err_nan_to_character_conversion@octave@@YAXXZ"]
    pub fn octave_err_nan_to_character_conversion();
}
extern "C" {
    #[link_name = "?err_nonconformant@octave@@YAXPEBDHH@Z"]
    pub fn octave_err_nonconformant(op: *const ::std::os::raw::c_char,
                                    op1_len: octave_idx_type,
                                    op2_len: octave_idx_type);
}
extern "C" {
    #[link_name = "?err_nonconformant@octave@@YAXPEBDHHHH@Z"]
    pub fn octave_err_nonconformant1(op: *const ::std::os::raw::c_char,
                                     op1_nr: octave_idx_type,
                                     op1_nc: octave_idx_type,
                                     op2_nr: octave_idx_type,
                                     op2_nc: octave_idx_type);
}
extern "C" {
    #[link_name = "?err_nonconformant@octave@@YAXPEBDAEBVdim_vector@@1@Z"]
    pub fn octave_err_nonconformant2(op: *const ::std::os::raw::c_char,
                                     op1_dims: *const dim_vector,
                                     op2_dims: *const dim_vector);
}
extern "C" {
    #[link_name = "?err_index_out_of_range@octave@@YAXHHHHAEBVdim_vector@@@Z"]
    pub fn octave_err_index_out_of_range(nd: ::std::os::raw::c_int,
                                         dim: ::std::os::raw::c_int,
                                         iext: octave_idx_type,
                                         ext: octave_idx_type,
                                         d: *const dim_vector);
}
extern "C" {
    #[link_name = "?err_index_out_of_range@octave@@YAXHHHH@Z"]
    pub fn octave_err_index_out_of_range1(nd: ::std::os::raw::c_int,
                                          dim: ::std::os::raw::c_int,
                                          iext: octave_idx_type,
                                          ext: octave_idx_type);
}
extern "C" {
    #[link_name = "?err_del_index_out_of_range@octave@@YAX_NHH@Z"]
    pub fn octave_err_del_index_out_of_range(is1d: bool,
                                             iext: octave_idx_type,
                                             ext: octave_idx_type);
}
extern "C" {
    #[link_name =
          "?err_invalid_index@octave@@YAXNHHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn octave_err_invalid_index(n: f64, nd: octave_idx_type,
                                    dim: octave_idx_type,
                                    var: *const std_string);
}
extern "C" {
    #[link_name =
          "?err_invalid_index@octave@@YAXHHHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn octave_err_invalid_index1(n: octave_idx_type, nd: octave_idx_type,
                                     dim: octave_idx_type,
                                     var: *const std_string);
}
extern "C" {
    #[link_name =
          "?err_invalid_index@octave@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HH0@Z"]
    pub fn octave_err_invalid_index2(idx: *const std_string,
                                     nd: octave_idx_type,
                                     dim: octave_idx_type,
                                     var: *const std_string);
}
extern "C" {
    #[link_name = "?err_invalid_resize@octave@@YAXXZ"]
    pub fn octave_err_invalid_resize();
}
extern "C" {
    #[link_name = "?warn_singular_matrix@octave@@YAXN@Z"]
    pub fn octave_warn_singular_matrix(rcond: f64);
}
#[repr(C)]
pub struct octave_sys_base_tm__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct octave_sys_base_tm {
    pub vtable_: *const octave_sys_base_tm__bindgen_vtable,
    pub m_usec: ::std::os::raw::c_int,
    pub m_sec: ::std::os::raw::c_int,
    pub m_min: ::std::os::raw::c_int,
    pub m_hour: ::std::os::raw::c_int,
    pub m_mday: ::std::os::raw::c_int,
    pub m_mon: ::std::os::raw::c_int,
    pub m_year: ::std::os::raw::c_int,
    pub m_wday: ::std::os::raw::c_int,
    pub m_yday: ::std::os::raw::c_int,
    pub m_isdst: ::std::os::raw::c_int,
    pub m_gmtoff: ::std::os::raw::c_long,
    pub m_zone: std_string,
}
#[test]
fn bindgen_test_layout_octave_sys_base_tm() {
    assert_eq!(::std::mem::size_of::<octave_sys_base_tm>() , 64usize , concat
               ! ( "Size of: " , stringify ! ( octave_sys_base_tm ) ));
    assert_eq! (::std::mem::align_of::<octave_sys_base_tm>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( octave_sys_base_tm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_sys_base_tm ) ) . m_usec as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_sys_base_tm ) ,
                "::" , stringify ! ( m_usec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_sys_base_tm ) ) . m_sec as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_sys_base_tm ) ,
                "::" , stringify ! ( m_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_sys_base_tm ) ) . m_min as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_sys_base_tm ) ,
                "::" , stringify ! ( m_min ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_sys_base_tm ) ) . m_hour as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_sys_base_tm ) ,
                "::" , stringify ! ( m_hour ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_sys_base_tm ) ) . m_mday as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_sys_base_tm ) ,
                "::" , stringify ! ( m_mday ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_sys_base_tm ) ) . m_mon as * const
                _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_sys_base_tm ) ,
                "::" , stringify ! ( m_mon ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_sys_base_tm ) ) . m_year as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_sys_base_tm ) ,
                "::" , stringify ! ( m_year ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_sys_base_tm ) ) . m_wday as *
                const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_sys_base_tm ) ,
                "::" , stringify ! ( m_wday ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_sys_base_tm ) ) . m_yday as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_sys_base_tm ) ,
                "::" , stringify ! ( m_yday ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_sys_base_tm ) ) . m_isdst as *
                const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_sys_base_tm ) ,
                "::" , stringify ! ( m_isdst ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_sys_base_tm ) ) . m_gmtoff as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_sys_base_tm ) ,
                "::" , stringify ! ( m_gmtoff ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_sys_base_tm ) ) . m_zone as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_sys_base_tm ) ,
                "::" , stringify ! ( m_zone ) ));
}
extern "C" {
    #[link_name = "?usec@base_tm@sys@octave@@QEAAAEAV123@H@Z"]
    pub fn octave_sys_base_tm_usec(this: *mut octave_sys_base_tm,
                                   v: ::std::os::raw::c_int)
     -> *mut octave_sys_base_tm;
}
extern "C" {
    #[link_name = "?sec@base_tm@sys@octave@@QEAAAEAV123@H@Z"]
    pub fn octave_sys_base_tm_sec(this: *mut octave_sys_base_tm,
                                  v: ::std::os::raw::c_int)
     -> *mut octave_sys_base_tm;
}
extern "C" {
    #[link_name = "?min@base_tm@sys@octave@@QEAAAEAV123@H@Z"]
    pub fn octave_sys_base_tm_min(this: *mut octave_sys_base_tm,
                                  v: ::std::os::raw::c_int)
     -> *mut octave_sys_base_tm;
}
extern "C" {
    #[link_name = "?hour@base_tm@sys@octave@@QEAAAEAV123@H@Z"]
    pub fn octave_sys_base_tm_hour(this: *mut octave_sys_base_tm,
                                   v: ::std::os::raw::c_int)
     -> *mut octave_sys_base_tm;
}
extern "C" {
    #[link_name = "?mday@base_tm@sys@octave@@QEAAAEAV123@H@Z"]
    pub fn octave_sys_base_tm_mday(this: *mut octave_sys_base_tm,
                                   v: ::std::os::raw::c_int)
     -> *mut octave_sys_base_tm;
}
extern "C" {
    #[link_name = "?mon@base_tm@sys@octave@@QEAAAEAV123@H@Z"]
    pub fn octave_sys_base_tm_mon(this: *mut octave_sys_base_tm,
                                  v: ::std::os::raw::c_int)
     -> *mut octave_sys_base_tm;
}
extern "C" {
    #[link_name = "?year@base_tm@sys@octave@@QEAAAEAV123@H@Z"]
    pub fn octave_sys_base_tm_year(this: *mut octave_sys_base_tm,
                                   v: ::std::os::raw::c_int)
     -> *mut octave_sys_base_tm;
}
extern "C" {
    #[link_name = "?wday@base_tm@sys@octave@@QEAAAEAV123@H@Z"]
    pub fn octave_sys_base_tm_wday(this: *mut octave_sys_base_tm,
                                   v: ::std::os::raw::c_int)
     -> *mut octave_sys_base_tm;
}
extern "C" {
    #[link_name = "?yday@base_tm@sys@octave@@QEAAAEAV123@H@Z"]
    pub fn octave_sys_base_tm_yday(this: *mut octave_sys_base_tm,
                                   v: ::std::os::raw::c_int)
     -> *mut octave_sys_base_tm;
}
extern "C" {
    #[link_name = "?isdst@base_tm@sys@octave@@QEAAAEAV123@H@Z"]
    pub fn octave_sys_base_tm_isdst(this: *mut octave_sys_base_tm,
                                    v: ::std::os::raw::c_int)
     -> *mut octave_sys_base_tm;
}
extern "C" {
    #[link_name = "?gmtoff@base_tm@sys@octave@@QEAAAEAV123@J@Z"]
    pub fn octave_sys_base_tm_gmtoff(this: *mut octave_sys_base_tm,
                                     v: ::std::os::raw::c_long)
     -> *mut octave_sys_base_tm;
}
extern "C" {
    #[link_name =
          "?zone@base_tm@sys@octave@@QEAAAEAV123@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn octave_sys_base_tm_zone(this: *mut octave_sys_base_tm,
                                   s: *const std_string)
     -> *mut octave_sys_base_tm;
}
extern "C" {
    #[link_name =
          "?strftime@base_tm@sys@octave@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV45@@Z"]
    pub fn octave_sys_base_tm_strftime(this: *const octave_sys_base_tm,
                                       fmt: *const std_string) -> std_string;
}
extern "C" {
    #[link_name = "?init@base_tm@sys@octave@@IEAAXPEAX@Z"]
    pub fn octave_sys_base_tm_init(this: *mut octave_sys_base_tm,
                                   p: *mut ::std::os::raw::c_void);
}
impl octave_sys_base_tm {
    #[inline]
    pub unsafe fn usec(&mut self, v: ::std::os::raw::c_int)
     -> *mut octave_sys_base_tm {
        octave_sys_base_tm_usec(self, v)
    }
    #[inline]
    pub unsafe fn sec(&mut self, v: ::std::os::raw::c_int)
     -> *mut octave_sys_base_tm {
        octave_sys_base_tm_sec(self, v)
    }
    #[inline]
    pub unsafe fn min(&mut self, v: ::std::os::raw::c_int)
     -> *mut octave_sys_base_tm {
        octave_sys_base_tm_min(self, v)
    }
    #[inline]
    pub unsafe fn hour(&mut self, v: ::std::os::raw::c_int)
     -> *mut octave_sys_base_tm {
        octave_sys_base_tm_hour(self, v)
    }
    #[inline]
    pub unsafe fn mday(&mut self, v: ::std::os::raw::c_int)
     -> *mut octave_sys_base_tm {
        octave_sys_base_tm_mday(self, v)
    }
    #[inline]
    pub unsafe fn mon(&mut self, v: ::std::os::raw::c_int)
     -> *mut octave_sys_base_tm {
        octave_sys_base_tm_mon(self, v)
    }
    #[inline]
    pub unsafe fn year(&mut self, v: ::std::os::raw::c_int)
     -> *mut octave_sys_base_tm {
        octave_sys_base_tm_year(self, v)
    }
    #[inline]
    pub unsafe fn wday(&mut self, v: ::std::os::raw::c_int)
     -> *mut octave_sys_base_tm {
        octave_sys_base_tm_wday(self, v)
    }
    #[inline]
    pub unsafe fn yday(&mut self, v: ::std::os::raw::c_int)
     -> *mut octave_sys_base_tm {
        octave_sys_base_tm_yday(self, v)
    }
    #[inline]
    pub unsafe fn isdst(&mut self, v: ::std::os::raw::c_int)
     -> *mut octave_sys_base_tm {
        octave_sys_base_tm_isdst(self, v)
    }
    #[inline]
    pub unsafe fn gmtoff(&mut self, v: ::std::os::raw::c_long)
     -> *mut octave_sys_base_tm {
        octave_sys_base_tm_gmtoff(self, v)
    }
    #[inline]
    pub unsafe fn zone(&mut self, s: *const std_string)
     -> *mut octave_sys_base_tm {
        octave_sys_base_tm_zone(self, s)
    }
    #[inline]
    pub unsafe fn strftime(&self, fmt: *const std_string) -> std_string {
        octave_sys_base_tm_strftime(self, fmt)
    }
    #[inline]
    pub unsafe fn init(&mut self, p: *mut ::std::os::raw::c_void) {
        octave_sys_base_tm_init(self, p)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct octave_sys_time {
    pub ot_unix_time: time_t,
    pub ot_usec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_octave_sys_time() {
    assert_eq!(::std::mem::size_of::<octave_sys_time>() , 16usize , concat ! (
               "Size of: " , stringify ! ( octave_sys_time ) ));
    assert_eq! (::std::mem::align_of::<octave_sys_time>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( octave_sys_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_sys_time ) ) . ot_unix_time as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_sys_time ) ,
                "::" , stringify ! ( ot_unix_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_sys_time ) ) . ot_usec as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_sys_time ) ,
                "::" , stringify ! ( ot_usec ) ));
}
extern "C" {
    #[link_name = "?stamp@time@sys@octave@@QEAAXXZ"]
    pub fn octave_sys_time_stamp(this: *mut octave_sys_time);
}
extern "C" {
    #[link_name =
          "?ctime@time@sys@octave@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ"]
    pub fn octave_sys_time_ctime(this: *const octave_sys_time) -> std_string;
}
extern "C" {
    #[link_name = "??0time@sys@octave@@QEAA@N@Z"]
    pub fn octave_sys_time_time(this: *mut octave_sys_time, d: f64);
}
extern "C" {
    #[link_name = "??0time@sys@octave@@QEAA@AEBVbase_tm@12@@Z"]
    pub fn octave_sys_time_time1(this: *mut octave_sys_time,
                                 tm: *const octave_sys_base_tm);
}
impl octave_sys_time {
    #[inline]
    pub unsafe fn stamp(&mut self) { octave_sys_time_stamp(self) }
    #[inline]
    pub unsafe fn ctime(&self) -> std_string { octave_sys_time_ctime(self) }
    #[inline]
    pub unsafe fn new(d: f64) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_sys_time_time(&mut __bindgen_tmp, d);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(tm: *const octave_sys_base_tm) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_sys_time_time1(&mut __bindgen_tmp, tm);
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct octave_sys_localtime {
    pub _base: octave_sys_base_tm,
}
#[test]
fn bindgen_test_layout_octave_sys_localtime() {
    assert_eq!(::std::mem::size_of::<octave_sys_localtime>() , 64usize ,
               concat ! ( "Size of: " , stringify ! ( octave_sys_localtime )
               ));
    assert_eq! (::std::mem::align_of::<octave_sys_localtime>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( octave_sys_localtime ) ));
}
#[repr(C)]
#[derive(Debug)]
pub struct octave_sys_gmtime {
    pub _base: octave_sys_base_tm,
}
#[test]
fn bindgen_test_layout_octave_sys_gmtime() {
    assert_eq!(::std::mem::size_of::<octave_sys_gmtime>() , 64usize , concat !
               ( "Size of: " , stringify ! ( octave_sys_gmtime ) ));
    assert_eq! (::std::mem::align_of::<octave_sys_gmtime>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( octave_sys_gmtime ) ));
}
#[repr(C)]
#[derive(Debug)]
pub struct octave_sys_strptime {
    pub _base: octave_sys_base_tm,
    pub nchars: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_octave_sys_strptime() {
    assert_eq!(::std::mem::size_of::<octave_sys_strptime>() , 72usize , concat
               ! ( "Size of: " , stringify ! ( octave_sys_strptime ) ));
    assert_eq! (::std::mem::align_of::<octave_sys_strptime>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( octave_sys_strptime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_sys_strptime ) ) . nchars as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_sys_strptime ) ,
                "::" , stringify ! ( nchars ) ));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct octave_sys_cpu_time {
    pub m_usr_sec: time_t,
    pub m_sys_sec: time_t,
    pub m_usr_usec: ::std::os::raw::c_long,
    pub m_sys_usec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_octave_sys_cpu_time() {
    assert_eq!(::std::mem::size_of::<octave_sys_cpu_time>() , 24usize , concat
               ! ( "Size of: " , stringify ! ( octave_sys_cpu_time ) ));
    assert_eq! (::std::mem::align_of::<octave_sys_cpu_time>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( octave_sys_cpu_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_sys_cpu_time ) ) . m_usr_sec as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_sys_cpu_time ) ,
                "::" , stringify ! ( m_usr_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_sys_cpu_time ) ) . m_sys_sec as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_sys_cpu_time ) ,
                "::" , stringify ! ( m_sys_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_sys_cpu_time ) ) . m_usr_usec as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_sys_cpu_time ) ,
                "::" , stringify ! ( m_usr_usec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_sys_cpu_time ) ) . m_sys_usec as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_sys_cpu_time ) ,
                "::" , stringify ! ( m_sys_usec ) ));
}
extern "C" {
    #[link_name = "?stamp@cpu_time@sys@octave@@QEAAXXZ"]
    pub fn octave_sys_cpu_time_stamp(this: *mut octave_sys_cpu_time);
}
impl Clone for octave_sys_cpu_time {
    fn clone(&self) -> Self { *self }
}
impl octave_sys_cpu_time {
    #[inline]
    pub unsafe fn stamp(&mut self) { octave_sys_cpu_time_stamp(self) }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct octave_sys_resource_usage {
    pub m_cpu: octave_sys_cpu_time,
    pub m_maxrss: ::std::os::raw::c_long,
    pub m_ixrss: ::std::os::raw::c_long,
    pub m_idrss: ::std::os::raw::c_long,
    pub m_isrss: ::std::os::raw::c_long,
    pub m_minflt: ::std::os::raw::c_long,
    pub m_majflt: ::std::os::raw::c_long,
    pub m_nswap: ::std::os::raw::c_long,
    pub m_inblock: ::std::os::raw::c_long,
    pub m_oublock: ::std::os::raw::c_long,
    pub m_msgsnd: ::std::os::raw::c_long,
    pub m_msgrcv: ::std::os::raw::c_long,
    pub m_nsignals: ::std::os::raw::c_long,
    pub m_nvcsw: ::std::os::raw::c_long,
    pub m_nivcsw: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_octave_sys_resource_usage() {
    assert_eq!(::std::mem::size_of::<octave_sys_resource_usage>() , 80usize ,
               concat ! (
               "Size of: " , stringify ! ( octave_sys_resource_usage ) ));
    assert_eq! (::std::mem::align_of::<octave_sys_resource_usage>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( octave_sys_resource_usage )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_sys_resource_usage ) ) . m_cpu as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                octave_sys_resource_usage ) , "::" , stringify ! ( m_cpu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_sys_resource_usage ) ) . m_maxrss
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                octave_sys_resource_usage ) , "::" , stringify ! ( m_maxrss )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_sys_resource_usage ) ) . m_ixrss
                as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                octave_sys_resource_usage ) , "::" , stringify ! ( m_ixrss )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_sys_resource_usage ) ) . m_idrss
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                octave_sys_resource_usage ) , "::" , stringify ! ( m_idrss )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_sys_resource_usage ) ) . m_isrss
                as * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! (
                octave_sys_resource_usage ) , "::" , stringify ! ( m_isrss )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_sys_resource_usage ) ) . m_minflt
                as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                octave_sys_resource_usage ) , "::" , stringify ! ( m_minflt )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_sys_resource_usage ) ) . m_majflt
                as * const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! (
                octave_sys_resource_usage ) , "::" , stringify ! ( m_majflt )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_sys_resource_usage ) ) . m_nswap
                as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                octave_sys_resource_usage ) , "::" , stringify ! ( m_nswap )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_sys_resource_usage ) ) . m_inblock
                as * const _ as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! (
                octave_sys_resource_usage ) , "::" , stringify ! ( m_inblock )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_sys_resource_usage ) ) . m_oublock
                as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! (
                octave_sys_resource_usage ) , "::" , stringify ! ( m_oublock )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_sys_resource_usage ) ) . m_msgsnd
                as * const _ as usize } , 60usize , concat ! (
                "Alignment of field: " , stringify ! (
                octave_sys_resource_usage ) , "::" , stringify ! ( m_msgsnd )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_sys_resource_usage ) ) . m_msgrcv
                as * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! (
                octave_sys_resource_usage ) , "::" , stringify ! ( m_msgrcv )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_sys_resource_usage ) ) .
                m_nsignals as * const _ as usize } , 68usize , concat ! (
                "Alignment of field: " , stringify ! (
                octave_sys_resource_usage ) , "::" , stringify ! ( m_nsignals
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_sys_resource_usage ) ) . m_nvcsw
                as * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! (
                octave_sys_resource_usage ) , "::" , stringify ! ( m_nvcsw )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_sys_resource_usage ) ) . m_nivcsw
                as * const _ as usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! (
                octave_sys_resource_usage ) , "::" , stringify ! ( m_nivcsw )
                ));
}
extern "C" {
    #[link_name = "?stamp@resource_usage@sys@octave@@QEAAXXZ"]
    pub fn octave_sys_resource_usage_stamp(this:
                                               *mut octave_sys_resource_usage);
}
impl Clone for octave_sys_resource_usage {
    fn clone(&self) -> Self { *self }
}
impl octave_sys_resource_usage {
    #[inline]
    pub unsafe fn stamp(&mut self) { octave_sys_resource_usage_stamp(self) }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct octave_mach_info {
    pub native_float_fmt: octave_mach_info_float_format,
    pub big_chief: bool,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum octave_mach_info_float_format {
    flt_fmt_unknown = 0,
    flt_fmt_ieee_little_endian = 1,
    flt_fmt_ieee_big_endian = 2,
}
extern "C" {
    #[link_name = "?instance@mach_info@octave@@0PEAV12@EA"]
    pub static mut octave_mach_info_instance: *mut octave_mach_info;
}
#[test]
fn bindgen_test_layout_octave_mach_info() {
    assert_eq!(::std::mem::size_of::<octave_mach_info>() , 8usize , concat ! (
               "Size of: " , stringify ! ( octave_mach_info ) ));
    assert_eq! (::std::mem::align_of::<octave_mach_info>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( octave_mach_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_mach_info ) ) . native_float_fmt
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_mach_info ) ,
                "::" , stringify ! ( native_float_fmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_mach_info ) ) . big_chief as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_mach_info ) ,
                "::" , stringify ! ( big_chief ) ));
}
extern "C" {
    #[link_name = "?instance_ok@mach_info@octave@@SA_NXZ"]
    pub fn octave_mach_info_instance_ok() -> bool;
}
extern "C" {
    #[link_name =
          "?native_float_format@mach_info@octave@@SA?AW4float_format@12@XZ"]
    pub fn octave_mach_info_native_float_format()
     -> octave_mach_info_float_format;
}
extern "C" {
    #[link_name = "?words_big_endian@mach_info@octave@@SA_NXZ"]
    pub fn octave_mach_info_words_big_endian() -> bool;
}
extern "C" {
    #[link_name = "?words_little_endian@mach_info@octave@@SA_NXZ"]
    pub fn octave_mach_info_words_little_endian() -> bool;
}
extern "C" {
    #[link_name =
          "?string_to_float_format@mach_info@octave@@SA?AW4float_format@12@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn octave_mach_info_string_to_float_format(arg1: *const std_string)
     -> octave_mach_info_float_format;
}
extern "C" {
    #[link_name =
          "?float_format_as_string@mach_info@octave@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4float_format@12@@Z"]
    pub fn octave_mach_info_float_format_as_string(arg1:
                                                       octave_mach_info_float_format)
     -> std_string;
}
extern "C" {
    #[link_name = "??0mach_info@octave@@IEAA@XZ"]
    pub fn octave_mach_info_mach_info(this: *mut octave_mach_info);
}
impl Clone for octave_mach_info {
    fn clone(&self) -> Self { *self }
}
impl octave_mach_info {
    #[inline]
    pub unsafe fn instance_ok() -> bool { octave_mach_info_instance_ok() }
    #[inline]
    pub unsafe fn native_float_format() -> octave_mach_info_float_format {
        octave_mach_info_native_float_format()
    }
    #[inline]
    pub unsafe fn words_big_endian() -> bool {
        octave_mach_info_words_big_endian()
    }
    #[inline]
    pub unsafe fn words_little_endian() -> bool {
        octave_mach_info_words_little_endian()
    }
    #[inline]
    pub unsafe fn string_to_float_format(arg1: *const std_string)
     -> octave_mach_info_float_format {
        octave_mach_info_string_to_float_format(arg1)
    }
    #[inline]
    pub unsafe fn float_format_as_string(arg1: octave_mach_info_float_format)
     -> std_string {
        octave_mach_info_float_format_as_string(arg1)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_mach_info_mach_info(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
#[repr(C)]
pub struct octave_unwind_protect {
    pub _base: action_container,
    pub lifo: std_stack<std_deque<*mut action_container_elem>>,
}
#[test]
fn bindgen_test_layout_octave_unwind_protect() {
    assert_eq!(::std::mem::size_of::<octave_unwind_protect>() , 88usize ,
               concat ! ( "Size of: " , stringify ! ( octave_unwind_protect )
               ));
    assert_eq! (::std::mem::align_of::<octave_unwind_protect>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( octave_unwind_protect ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_unwind_protect ) ) . lifo as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_unwind_protect )
                , "::" , stringify ! ( lifo ) ));
}
#[repr(C)]
pub struct octave_unwind_protect_safe {
    pub _base: octave_unwind_protect,
}
#[test]
fn bindgen_test_layout_octave_unwind_protect_safe() {
    assert_eq!(::std::mem::size_of::<octave_unwind_protect_safe>() , 88usize ,
               concat ! (
               "Size of: " , stringify ! ( octave_unwind_protect_safe ) ));
    assert_eq! (::std::mem::align_of::<octave_unwind_protect_safe>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( octave_unwind_protect_safe )
                ));
}
#[repr(C)]
pub struct octave_base_list__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
pub struct octave_base_list {
    pub vtable_: *const octave_base_list__bindgen_vtable,
    pub lst: std_list,
}
pub type octave_base_list_iterator = std_list;
pub type octave_base_list_const_iterator = std_list;
pub type octave_base_list_reverse_iterator = std_list;
pub type octave_base_list_const_reverse_iterator = std_list;
#[repr(C)]
#[derive(Debug)]
pub struct octave_regexp {
    pub pattern: std_string,
    pub options: octave_regexp_opts,
    pub data: *mut ::std::os::raw::c_void,
    pub m: std_string,
    pub named_pats: string_vector,
    pub nnames: ::std::os::raw::c_int,
    pub named_idx: Array<::std::os::raw::c_int>,
    pub who: std_string,
}
#[repr(C)]
#[derive(Debug)]
pub struct octave_regexp_opts {
    pub x_case_insensitive: bool,
    pub x_dotexceptnewline: bool,
    pub x_emptymatch: bool,
    pub x_freespacing: bool,
    pub x_lineanchors: bool,
    pub x_once: bool,
}
#[test]
fn bindgen_test_layout_octave_regexp_opts() {
    assert_eq!(::std::mem::size_of::<octave_regexp_opts>() , 6usize , concat !
               ( "Size of: " , stringify ! ( octave_regexp_opts ) ));
    assert_eq! (::std::mem::align_of::<octave_regexp_opts>() , 1usize , concat
                ! ( "Alignment of " , stringify ! ( octave_regexp_opts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_regexp_opts ) ) .
                x_case_insensitive as * const _ as usize } , 0usize , concat !
                (
                "Alignment of field: " , stringify ! ( octave_regexp_opts ) ,
                "::" , stringify ! ( x_case_insensitive ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_regexp_opts ) ) .
                x_dotexceptnewline as * const _ as usize } , 1usize , concat !
                (
                "Alignment of field: " , stringify ! ( octave_regexp_opts ) ,
                "::" , stringify ! ( x_dotexceptnewline ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_regexp_opts ) ) . x_emptymatch as
                * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_regexp_opts ) ,
                "::" , stringify ! ( x_emptymatch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_regexp_opts ) ) . x_freespacing as
                * const _ as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_regexp_opts ) ,
                "::" , stringify ! ( x_freespacing ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_regexp_opts ) ) . x_lineanchors as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_regexp_opts ) ,
                "::" , stringify ! ( x_lineanchors ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_regexp_opts ) ) . x_once as *
                const _ as usize } , 5usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_regexp_opts ) ,
                "::" , stringify ! ( x_once ) ));
}
#[repr(C)]
pub struct octave_regexp_match_data {
    pub _base: octave_base_list,
    pub named_pats: string_vector,
}
#[test]
fn bindgen_test_layout_octave_regexp_match_data() {
    assert_eq!(::std::mem::size_of::<octave_regexp_match_data>() , 64usize ,
               concat ! (
               "Size of: " , stringify ! ( octave_regexp_match_data ) ));
    assert_eq! (::std::mem::align_of::<octave_regexp_match_data>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( octave_regexp_match_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_regexp_match_data ) ) . named_pats
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                octave_regexp_match_data ) , "::" , stringify ! ( named_pats )
                ));
}
#[repr(C)]
#[derive(Debug)]
pub struct octave_regexp_match_element {
    pub x_match_string: std_string,
    pub x_named_tokens: string_vector,
    pub x_tokens: string_vector,
    pub x_token_extents: Matrix,
    pub x_start: f64,
    pub x_end: f64,
}
#[test]
fn bindgen_test_layout_octave_regexp_match_element() {
    assert_eq!(::std::mem::size_of::<octave_regexp_match_element>() , 144usize
               , concat ! (
               "Size of: " , stringify ! ( octave_regexp_match_element ) ));
    assert_eq! (::std::mem::align_of::<octave_regexp_match_element>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( octave_regexp_match_element )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_regexp_match_element ) ) .
                x_match_string as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                octave_regexp_match_element ) , "::" , stringify ! (
                x_match_string ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_regexp_match_element ) ) .
                x_named_tokens as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                octave_regexp_match_element ) , "::" , stringify ! (
                x_named_tokens ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_regexp_match_element ) ) .
                x_tokens as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                octave_regexp_match_element ) , "::" , stringify ! ( x_tokens
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_regexp_match_element ) ) .
                x_token_extents as * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! (
                octave_regexp_match_element ) , "::" , stringify ! (
                x_token_extents ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_regexp_match_element ) ) . x_start
                as * const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! (
                octave_regexp_match_element ) , "::" , stringify ! ( x_start )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_regexp_match_element ) ) . x_end
                as * const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! (
                octave_regexp_match_element ) , "::" , stringify ! ( x_end )
                ));
}
#[test]
fn bindgen_test_layout_octave_regexp() {
    assert_eq!(::std::mem::size_of::<octave_regexp>() , 128usize , concat ! (
               "Size of: " , stringify ! ( octave_regexp ) ));
    assert_eq! (::std::mem::align_of::<octave_regexp>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( octave_regexp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_regexp ) ) . pattern as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_regexp ) , "::"
                , stringify ! ( pattern ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_regexp ) ) . options as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_regexp ) , "::"
                , stringify ! ( options ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_regexp ) ) . data as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_regexp ) , "::"
                , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_regexp ) ) . m as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_regexp ) , "::"
                , stringify ! ( m ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_regexp ) ) . named_pats as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_regexp ) , "::"
                , stringify ! ( named_pats ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_regexp ) ) . nnames as * const _
                as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_regexp ) , "::"
                , stringify ! ( nnames ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_regexp ) ) . named_idx as * const
                _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_regexp ) , "::"
                , stringify ! ( named_idx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_regexp ) ) . who as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_regexp ) , "::"
                , stringify ! ( who ) ));
}
extern "C" {
    #[link_name =
          "?match@regexp@octave@@QEAA?AVmatch_data@12@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn octave_regexp_match(this: *mut octave_regexp,
                               buffer: *const std_string)
     -> octave_regexp_match_data;
}
extern "C" {
    #[link_name =
          "?is_match@regexp@octave@@QEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn octave_regexp_is_match(this: *mut octave_regexp,
                                  buffer: *const std_string) -> bool;
}
extern "C" {
    #[link_name =
          "?is_match@regexp@octave@@QEAA?AV?$Array@_N@@AEBVstring_vector@@@Z"]
    pub fn octave_regexp_is_match1(this: *mut octave_regexp,
                                   buffer: *const string_vector)
     -> Array<bool>;
}
extern "C" {
    #[link_name =
          "?replace@regexp@octave@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z"]
    pub fn octave_regexp_replace(this: *mut octave_regexp,
                                 buffer: *const std_string,
                                 replacement: *const std_string)
     -> std_string;
}
impl octave_regexp {
    #[inline]
    pub unsafe fn match_(&mut self, buffer: *const std_string)
     -> octave_regexp_match_data {
        octave_regexp_match(self, buffer)
    }
    #[inline]
    pub unsafe fn is_match(&mut self, buffer: *const std_string) -> bool {
        octave_regexp_is_match(self, buffer)
    }
    #[inline]
    pub unsafe fn is_match1(&mut self, buffer: *const string_vector)
     -> Array<bool> {
        octave_regexp_is_match1(self, buffer)
    }
    #[inline]
    pub unsafe fn replace(&mut self, buffer: *const std_string,
                          replacement: *const std_string) -> std_string {
        octave_regexp_replace(self, buffer, replacement)
    }
}
#[test]
fn __bindgen_test_layout_std_map_instantiation_68821() {
    assert_eq!(::std::mem::size_of::<std_map>() , 48usize , concat ! (
               "Size of template specialization: " , stringify ! ( std_map )
               ));
    assert_eq!(::std::mem::align_of::<std_map>() , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_map ) ));
}
#[repr(C)]
#[derive(Debug)]
pub struct octave_dynamic_library {
    pub rep: *mut octave_dynamic_library_dynlib_rep,
}
pub type octave_dynamic_library_name_mangler =
    ::std::option::Option<unsafe extern "C" fn(arg1: *const std_string)
                              -> std_string>;
pub type octave_dynamic_library_close_hook =
    ::std::option::Option<unsafe extern "C" fn(arg1: *const std_string)>;
#[repr(C)]
pub struct octave_dynamic_library_dynlib_rep__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
pub struct octave_dynamic_library_dynlib_rep {
    pub vtable_: *const octave_dynamic_library_dynlib_rep__bindgen_vtable,
    pub count: octave_refcount<::std::os::raw::c_int>,
    pub file: std_string,
    pub tm_loaded: octave_sys_time,
    pub fcn_names: std_map,
}
pub type octave_dynamic_library_dynlib_rep_fcn_names_iterator = u8;
pub type octave_dynamic_library_dynlib_rep_fcn_names_const_iterator = u8;
extern "C" {
    #[link_name =
          "?instances@dynlib_rep@dynamic_library@octave@@1V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAVdynlib_rep@dynamic_library@octave@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAVdynlib_rep@dynamic_library@octave@@@std@@@2@@std@@A"]
    pub static mut octave_dynamic_library_dynlib_rep_instances: std_map;
}
#[test]
fn bindgen_test_layout_octave_dynamic_library_dynlib_rep() {
    assert_eq!(::std::mem::size_of::<octave_dynamic_library_dynlib_rep>() ,
               88usize , concat ! (
               "Size of: " , stringify ! ( octave_dynamic_library_dynlib_rep )
               ));
    assert_eq! (::std::mem::align_of::<octave_dynamic_library_dynlib_rep>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                octave_dynamic_library_dynlib_rep ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_dynamic_library_dynlib_rep ) ) .
                count as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                octave_dynamic_library_dynlib_rep ) , "::" , stringify ! (
                count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_dynamic_library_dynlib_rep ) ) .
                file as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                octave_dynamic_library_dynlib_rep ) , "::" , stringify ! (
                file ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_dynamic_library_dynlib_rep ) ) .
                tm_loaded as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                octave_dynamic_library_dynlib_rep ) , "::" , stringify ! (
                tm_loaded ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_dynamic_library_dynlib_rep ) ) .
                fcn_names as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                octave_dynamic_library_dynlib_rep ) , "::" , stringify ! (
                fcn_names ) ));
}
extern "C" {
    #[link_name =
          "?is_out_of_date@dynlib_rep@dynamic_library@octave@@QEBA_NXZ"]
    pub fn octave_dynamic_library_dynlib_rep_is_out_of_date(this:
                                                                *const octave_dynamic_library_dynlib_rep)
     -> bool;
}
extern "C" {
    #[link_name =
          "?new_instance@dynlib_rep@dynamic_library@octave@@SAPEAV123@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn octave_dynamic_library_dynlib_rep_new_instance(f:
                                                              *const std_string)
     -> *mut octave_dynamic_library_dynlib_rep;
}
extern "C" {
    #[link_name =
          "?get_instance@dynlib_rep@dynamic_library@octave@@SAPEAV123@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z"]
    pub fn octave_dynamic_library_dynlib_rep_get_instance(f:
                                                              *const std_string,
                                                          fake: bool)
     -> *mut octave_dynamic_library_dynlib_rep;
}
extern "C" {
    #[link_name =
          "?add_fcn_name@dynlib_rep@dynamic_library@octave@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn octave_dynamic_library_dynlib_rep_add_fcn_name(this:
                                                              *mut octave_dynamic_library_dynlib_rep,
                                                          arg1:
                                                              *const std_string);
}
extern "C" {
    #[link_name =
          "?remove_fcn_name@dynlib_rep@dynamic_library@octave@@QEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn octave_dynamic_library_dynlib_rep_remove_fcn_name(this:
                                                                 *mut octave_dynamic_library_dynlib_rep,
                                                             arg1:
                                                                 *const std_string)
     -> bool;
}
extern "C" {
    #[link_name =
          "?do_close_hook@dynlib_rep@dynamic_library@octave@@QEAAXP6AXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@Z"]
    pub fn octave_dynamic_library_dynlib_rep_do_close_hook(this:
                                                               *mut octave_dynamic_library_dynlib_rep,
                                                           cl_hook:
                                                               octave_dynamic_library_close_hook);
}
extern "C" {
    #[link_name = "?fake_reload@dynlib_rep@dynamic_library@octave@@IEAAXXZ"]
    pub fn octave_dynamic_library_dynlib_rep_fake_reload(this:
                                                             *mut octave_dynamic_library_dynlib_rep);
}
extern "C" {
    #[link_name =
          "??0dynlib_rep@dynamic_library@octave@@IEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn octave_dynamic_library_dynlib_rep_dynlib_rep(this:
                                                            *mut octave_dynamic_library_dynlib_rep,
                                                        f: *const std_string);
}
impl octave_dynamic_library_dynlib_rep {
    #[inline]
    pub unsafe fn is_out_of_date(&self) -> bool {
        octave_dynamic_library_dynlib_rep_is_out_of_date(self)
    }
    #[inline]
    pub unsafe fn new_instance(f: *const std_string)
     -> *mut octave_dynamic_library_dynlib_rep {
        octave_dynamic_library_dynlib_rep_new_instance(f)
    }
    #[inline]
    pub unsafe fn get_instance(f: *const std_string, fake: bool)
     -> *mut octave_dynamic_library_dynlib_rep {
        octave_dynamic_library_dynlib_rep_get_instance(f, fake)
    }
    #[inline]
    pub unsafe fn add_fcn_name(&mut self, arg1: *const std_string) {
        octave_dynamic_library_dynlib_rep_add_fcn_name(self, arg1)
    }
    #[inline]
    pub unsafe fn remove_fcn_name(&mut self, arg1: *const std_string)
     -> bool {
        octave_dynamic_library_dynlib_rep_remove_fcn_name(self, arg1)
    }
    #[inline]
    pub unsafe fn do_close_hook(&mut self,
                                cl_hook: octave_dynamic_library_close_hook) {
        octave_dynamic_library_dynlib_rep_do_close_hook(self, cl_hook)
    }
    #[inline]
    pub unsafe fn fake_reload(&mut self) {
        octave_dynamic_library_dynlib_rep_fake_reload(self)
    }
    #[inline]
    pub unsafe fn new(f: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_dynamic_library_dynlib_rep_dynlib_rep(&mut __bindgen_tmp, f);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "?nil_rep@dynamic_library@octave@@0Vdynlib_rep@12@A"]
    pub static mut octave_dynamic_library_nil_rep:
               octave_dynamic_library_dynlib_rep;
}
#[test]
fn bindgen_test_layout_octave_dynamic_library() {
    assert_eq!(::std::mem::size_of::<octave_dynamic_library>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( octave_dynamic_library )
               ));
    assert_eq! (::std::mem::align_of::<octave_dynamic_library>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( octave_dynamic_library ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_dynamic_library ) ) . rep as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_dynamic_library
                ) , "::" , stringify ! ( rep ) ));
}
pub type octave_execution_exception = octave_exit_exception;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum octave_exception {
    octave_no_exception = 0,
    octave_exec_exception = 1,
    octave_alloc_exception = 3,
    octave_quit_exception = 4,
}
extern "C" {
    #[link_name = "octave_interrupt_immediately"]
    pub static mut octave_interrupt_immediately: sig_atomic_t;
}
extern "C" {
    #[link_name = "octave_interrupt_state"]
    pub static mut octave_interrupt_state: sig_atomic_t;
}
extern "C" {
    #[link_name = "octave_exception_state"]
    pub static mut octave_exception_state: sig_atomic_t;
}
extern "C" {
    #[link_name = "octave_exit_exception_status"]
    pub static mut octave_exit_exception_status: sig_atomic_t;
}
extern "C" {
    #[link_name = "octave_exit_exception_safe_to_return"]
    pub static mut octave_exit_exception_safe_to_return: sig_atomic_t;
}
extern "C" {
    #[link_name = "octave_signal_caught"]
    pub static mut octave_signal_caught: sig_atomic_t;
}
extern "C" {
    pub fn octave_handle_signal();
}
extern "C" {
    pub fn octave_throw_interrupt_exception();
}
extern "C" {
    pub fn octave_throw_execution_exception();
}
extern "C" {
    pub fn octave_throw_bad_alloc();
}
extern "C" {
    pub fn octave_rethrow_exception();
}
extern "C" {
    pub fn clean_up_and_exit(exit_status: ::std::os::raw::c_int,
                             safe_to_return: bool);
}
extern "C" {
    #[link_name = "?octave_signal_hook@@3P6AXXZEA"]
    pub static mut octave_signal_hook:
               ::std::option::Option<unsafe extern "C" fn()>;
}
extern "C" {
    #[link_name = "?octave_interrupt_hook@@3P6AXXZEA"]
    pub static mut octave_interrupt_hook:
               ::std::option::Option<unsafe extern "C" fn()>;
}
extern "C" {
    #[link_name = "?octave_bad_alloc_hook@@3P6AXXZEA"]
    pub static mut octave_bad_alloc_hook:
               ::std::option::Option<unsafe extern "C" fn()>;
}
extern "C" {
    pub fn liboctave_fatal(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn liboctave_fatal_with_id(id: *const ::std::os::raw::c_char,
                                   fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn liboctave_warning(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn liboctave_warning_with_id(id: *const ::std::os::raw::c_char,
                                     fmt: *const ::std::os::raw::c_char, ...);
}
pub type liboctave_error_handler =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *const ::std::os::raw::c_char, ...)>;
pub type liboctave_error_with_id_handler =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *const ::std::os::raw::c_char,
                                               arg2:
                                                   *const ::std::os::raw::c_char, ...)>;
pub type liboctave_warning_handler =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *const ::std::os::raw::c_char, ...)>;
pub type liboctave_warning_with_id_handler =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *const ::std::os::raw::c_char,
                                               arg2:
                                                   *const ::std::os::raw::c_char, ...)>;
extern "C" {
    #[link_name = "current_liboctave_error_handler"]
    pub static mut current_liboctave_error_handler:
               ::std::option::Option<unsafe extern "C" fn()>;
}
extern "C" {
    #[link_name = "current_liboctave_error_with_id_handler"]
    pub static mut current_liboctave_error_with_id_handler:
               ::std::option::Option<unsafe extern "C" fn()>;
}
extern "C" {
    #[link_name = "current_liboctave_warning_handler"]
    pub static mut current_liboctave_warning_handler:
               liboctave_warning_handler;
}
extern "C" {
    #[link_name = "current_liboctave_warning_with_id_handler"]
    pub static mut current_liboctave_warning_with_id_handler:
               liboctave_warning_with_id_handler;
}
extern "C" {
    pub fn set_liboctave_error_handler(f:
                                           ::std::option::Option<unsafe extern "C" fn()>);
}
extern "C" {
    pub fn set_liboctave_error_with_id_handler(f:
                                                   ::std::option::Option<unsafe extern "C" fn()>);
}
extern "C" {
    pub fn set_liboctave_warning_handler(f: liboctave_warning_handler);
}
extern "C" {
    pub fn set_liboctave_warning_with_id_handler(f:
                                                     liboctave_warning_with_id_handler);
}
extern "C" {
    pub fn _wassert(_Message: *const u16, _File: *const u16,
                    _Line: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn _assert(_Message: *const ::std::os::raw::c_char,
                   _File: *const ::std::os::raw::c_char,
                   _Line: ::std::os::raw::c_uint);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _exception {
    pub type_: ::std::os::raw::c_int,
    pub name: *const ::std::os::raw::c_char,
    pub arg1: f64,
    pub arg2: f64,
    pub retval: f64,
}
#[test]
fn bindgen_test_layout__exception() {
    assert_eq!(::std::mem::size_of::<_exception>() , 40usize , concat ! (
               "Size of: " , stringify ! ( _exception ) ));
    assert_eq! (::std::mem::align_of::<_exception>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _exception ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _exception ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _exception ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _exception ) ) . name as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _exception ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _exception ) ) . arg1 as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _exception ) , "::" ,
                stringify ! ( arg1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _exception ) ) . arg2 as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _exception ) , "::" ,
                stringify ! ( arg2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _exception ) ) . retval as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _exception ) , "::" ,
                stringify ! ( retval ) ));
}
impl Clone for _exception {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __mingw_types_compatible_p {
    pub _address: u8,
}
#[repr(C)]
#[derive(Copy)]
pub union __mingw_dbl_type_t {
    pub x: f64,
    pub val: ::std::os::raw::c_ulonglong,
    pub lh: __mingw_dbl_type_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __mingw_dbl_type_t__bindgen_ty_1 {
    pub low: ::std::os::raw::c_uint,
    pub high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___mingw_dbl_type_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<__mingw_dbl_type_t__bindgen_ty_1>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( __mingw_dbl_type_t__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<__mingw_dbl_type_t__bindgen_ty_1>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                __mingw_dbl_type_t__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mingw_dbl_type_t__bindgen_ty_1 ) ) .
                low as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __mingw_dbl_type_t__bindgen_ty_1 ) , "::" , stringify ! ( low
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mingw_dbl_type_t__bindgen_ty_1 ) ) .
                high as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                __mingw_dbl_type_t__bindgen_ty_1 ) , "::" , stringify ! ( high
                ) ));
}
impl Clone for __mingw_dbl_type_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout___mingw_dbl_type_t() {
    assert_eq!(::std::mem::size_of::<__mingw_dbl_type_t>() , 8usize , concat !
               ( "Size of: " , stringify ! ( __mingw_dbl_type_t ) ));
    assert_eq! (::std::mem::align_of::<__mingw_dbl_type_t>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( __mingw_dbl_type_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mingw_dbl_type_t ) ) . x as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mingw_dbl_type_t ) ,
                "::" , stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mingw_dbl_type_t ) ) . val as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mingw_dbl_type_t ) ,
                "::" , stringify ! ( val ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mingw_dbl_type_t ) ) . lh as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mingw_dbl_type_t ) ,
                "::" , stringify ! ( lh ) ));
}
impl Clone for __mingw_dbl_type_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union __mingw_flt_type_t {
    pub x: f32,
    pub val: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___mingw_flt_type_t() {
    assert_eq!(::std::mem::size_of::<__mingw_flt_type_t>() , 4usize , concat !
               ( "Size of: " , stringify ! ( __mingw_flt_type_t ) ));
    assert_eq! (::std::mem::align_of::<__mingw_flt_type_t>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( __mingw_flt_type_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mingw_flt_type_t ) ) . x as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mingw_flt_type_t ) ,
                "::" , stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mingw_flt_type_t ) ) . val as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mingw_flt_type_t ) ,
                "::" , stringify ! ( val ) ));
}
impl Clone for __mingw_flt_type_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union __mingw_ldbl_type_t {
    pub x: f64,
    pub lh: __mingw_ldbl_type_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __mingw_ldbl_type_t__bindgen_ty_1 {
    pub low: ::std::os::raw::c_uint,
    pub high: ::std::os::raw::c_uint,
    pub _bitfield_1: [u16; 2usize],
    pub _bitfield_2: u32,
}
#[test]
fn bindgen_test_layout___mingw_ldbl_type_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<__mingw_ldbl_type_t__bindgen_ty_1>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( __mingw_ldbl_type_t__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<__mingw_ldbl_type_t__bindgen_ty_1>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                __mingw_ldbl_type_t__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mingw_ldbl_type_t__bindgen_ty_1 ) ) .
                low as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __mingw_ldbl_type_t__bindgen_ty_1 ) , "::" , stringify ! ( low
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mingw_ldbl_type_t__bindgen_ty_1 ) ) .
                high as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                __mingw_ldbl_type_t__bindgen_ty_1 ) , "::" , stringify ! (
                high ) ));
}
impl Clone for __mingw_ldbl_type_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl __mingw_ldbl_type_t__bindgen_ty_1 {
    #[inline]
    pub fn sign_exponent(&self) -> ::std::os::raw::c_int {
        let mask = 65535usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_sign_exponent(&mut self, val: ::std::os::raw::c_int) {
        let mask = 65535usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 0usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn res1(&self) -> ::std::os::raw::c_int {
        let mask = 4294901760usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 16usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_res1(&mut self, val: ::std::os::raw::c_int) {
        let mask = 4294901760usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 16usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn res0(&self) -> ::std::os::raw::c_int {
        let mask = 4294967295usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_2) };
        let val = (field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_res0(&mut self, val: ::std::os::raw::c_int) {
        let mask = 4294967295usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_2) };
        field_val &= !mask;
        field_val |= (val << 0usize) & mask;
        self._bitfield_2 = unsafe { ::std::mem::transmute(field_val) };
    }
}
#[test]
fn bindgen_test_layout___mingw_ldbl_type_t() {
    assert_eq!(::std::mem::size_of::<__mingw_ldbl_type_t>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( __mingw_ldbl_type_t ) ));
    assert_eq! (::std::mem::align_of::<__mingw_ldbl_type_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( __mingw_ldbl_type_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mingw_ldbl_type_t ) ) . x as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mingw_ldbl_type_t ) ,
                "::" , stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mingw_ldbl_type_t ) ) . lh as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mingw_ldbl_type_t ) ,
                "::" , stringify ! ( lh ) ));
}
impl Clone for __mingw_ldbl_type_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union __mingw_fp_types_t {
    pub ld: *mut f64,
    pub d: *mut f64,
    pub f: *mut f32,
    pub ldt: *mut __mingw_ldbl_type_t,
    pub dt: *mut __mingw_dbl_type_t,
    pub ft: *mut __mingw_flt_type_t,
}
#[test]
fn bindgen_test_layout___mingw_fp_types_t() {
    assert_eq!(::std::mem::size_of::<__mingw_fp_types_t>() , 8usize , concat !
               ( "Size of: " , stringify ! ( __mingw_fp_types_t ) ));
    assert_eq! (::std::mem::align_of::<__mingw_fp_types_t>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( __mingw_fp_types_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mingw_fp_types_t ) ) . ld as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mingw_fp_types_t ) ,
                "::" , stringify ! ( ld ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mingw_fp_types_t ) ) . d as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mingw_fp_types_t ) ,
                "::" , stringify ! ( d ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mingw_fp_types_t ) ) . f as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mingw_fp_types_t ) ,
                "::" , stringify ! ( f ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mingw_fp_types_t ) ) . ldt as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mingw_fp_types_t ) ,
                "::" , stringify ! ( ldt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mingw_fp_types_t ) ) . dt as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mingw_fp_types_t ) ,
                "::" , stringify ! ( dt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mingw_fp_types_t ) ) . ft as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mingw_fp_types_t ) ,
                "::" , stringify ! ( ft ) ));
}
impl Clone for __mingw_fp_types_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "__imp__HUGE"]
    pub static mut __imp__HUGE: *mut f64;
}
extern "C" {
    pub fn __mingw_raise_matherr(typ: ::std::os::raw::c_int,
                                 name: *const ::std::os::raw::c_char, a1: f64,
                                 a2: f64, rslt: f64);
}
extern "C" {
    pub fn __mingw_setusermatherr(arg1:
                                      ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                     *mut _exception)
                                                                ->
                                                                    ::std::os::raw::c_int>);
}
extern "C" {
    pub fn __setusermatherr(arg1:
                                ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                               *mut _exception)
                                                          ->
                                                              ::std::os::raw::c_int>);
}
extern "C" {
    pub fn sin(_X: f64) -> f64;
}
extern "C" {
    pub fn cos(_X: f64) -> f64;
}
extern "C" {
    pub fn tan(_X: f64) -> f64;
}
extern "C" {
    pub fn sinh(_X: f64) -> f64;
}
extern "C" {
    pub fn cosh(_X: f64) -> f64;
}
extern "C" {
    pub fn tanh(_X: f64) -> f64;
}
extern "C" {
    pub fn asin(_X: f64) -> f64;
}
extern "C" {
    pub fn acos(_X: f64) -> f64;
}
extern "C" {
    pub fn atan(_X: f64) -> f64;
}
extern "C" {
    pub fn atan2(_Y: f64, _X: f64) -> f64;
}
extern "C" {
    pub fn exp(_X: f64) -> f64;
}
extern "C" {
    pub fn log(_X: f64) -> f64;
}
extern "C" {
    pub fn log10(_X: f64) -> f64;
}
extern "C" {
    pub fn pow(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn sqrt(_X: f64) -> f64;
}
extern "C" {
    pub fn ceil(_X: f64) -> f64;
}
extern "C" {
    pub fn floor(_X: f64) -> f64;
}
extern "C" {
    pub fn fabsf(x: f32) -> f32;
}
extern "C" {
    pub fn fabsl(arg1: f64) -> f64;
}
extern "C" {
    pub fn fabs(_X: f64) -> f64;
}
extern "C" {
    pub fn ldexp(_X: f64, _Y: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn frexp(_X: f64, _Y: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn modf(_X: f64, _Y: *mut f64) -> f64;
}
extern "C" {
    pub fn fmod(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn sincos(__x: f64, p_sin: *mut f64, p_cos: *mut f64);
}
extern "C" {
    pub fn sincosl(__x: f64, p_sin: *mut f64, p_cos: *mut f64);
}
extern "C" {
    pub fn sincosf(__x: f32, p_sin: *mut f32, p_cos: *mut f32);
}
pub type float_t = f32;
pub type double_t = f64;
extern "C" {
    pub fn __fpclassifyl(arg1: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __fpclassifyf(arg1: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __fpclassify(arg1: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isnan(arg1: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isnanf(arg1: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isnanl(arg1: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbit(arg1: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbitf(arg1: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbitl(arg1: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sinf(_X: f32) -> f32;
}
extern "C" {
    pub fn sinl(arg1: f64) -> f64;
}
extern "C" {
    pub fn cosf(_X: f32) -> f32;
}
extern "C" {
    pub fn cosl(arg1: f64) -> f64;
}
extern "C" {
    pub fn tanf(_X: f32) -> f32;
}
extern "C" {
    pub fn tanl(arg1: f64) -> f64;
}
extern "C" {
    pub fn asinf(_X: f32) -> f32;
}
extern "C" {
    pub fn asinl(arg1: f64) -> f64;
}
extern "C" {
    pub fn acosf(arg1: f32) -> f32;
}
extern "C" {
    pub fn acosl(arg1: f64) -> f64;
}
extern "C" {
    pub fn atanf(arg1: f32) -> f32;
}
extern "C" {
    pub fn atanl(arg1: f64) -> f64;
}
extern "C" {
    pub fn atan2f(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn atan2l(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn sinhf(_X: f32) -> f32;
}
extern "C" {
    pub fn sinhl(arg1: f64) -> f64;
}
extern "C" {
    pub fn coshf(_X: f32) -> f32;
}
extern "C" {
    pub fn coshl(arg1: f64) -> f64;
}
extern "C" {
    pub fn tanhf(_X: f32) -> f32;
}
extern "C" {
    pub fn tanhl(arg1: f64) -> f64;
}
extern "C" {
    pub fn acosh(arg1: f64) -> f64;
}
extern "C" {
    pub fn acoshf(arg1: f32) -> f32;
}
extern "C" {
    pub fn acoshl(arg1: f64) -> f64;
}
extern "C" {
    pub fn asinh(arg1: f64) -> f64;
}
extern "C" {
    pub fn asinhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn asinhl(arg1: f64) -> f64;
}
extern "C" {
    pub fn atanh(arg1: f64) -> f64;
}
extern "C" {
    pub fn atanhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn atanhl(arg1: f64) -> f64;
}
extern "C" {
    pub fn expf(_X: f32) -> f32;
}
extern "C" {
    pub fn expl(arg1: f64) -> f64;
}
extern "C" {
    pub fn exp2(arg1: f64) -> f64;
}
extern "C" {
    pub fn exp2f(arg1: f32) -> f32;
}
extern "C" {
    pub fn exp2l(arg1: f64) -> f64;
}
extern "C" {
    pub fn expm1(arg1: f64) -> f64;
}
extern "C" {
    pub fn expm1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn expm1l(arg1: f64) -> f64;
}
extern "C" {
    pub fn frexpf(_X: f32, _Y: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn frexpl(arg1: f64, arg2: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ilogb(arg1: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ilogbf(arg1: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ilogbl(arg1: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ldexpf(_X: f32, _Y: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn ldexpl(arg1: f64, arg2: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn logf(arg1: f32) -> f32;
}
extern "C" {
    pub fn logl(arg1: f64) -> f64;
}
extern "C" {
    pub fn log10f(arg1: f32) -> f32;
}
extern "C" {
    pub fn log10l(arg1: f64) -> f64;
}
extern "C" {
    pub fn log1p(arg1: f64) -> f64;
}
extern "C" {
    pub fn log1pf(arg1: f32) -> f32;
}
extern "C" {
    pub fn log1pl(arg1: f64) -> f64;
}
extern "C" {
    pub fn log2(arg1: f64) -> f64;
}
extern "C" {
    pub fn log2f(arg1: f32) -> f32;
}
extern "C" {
    pub fn log2l(arg1: f64) -> f64;
}
extern "C" {
    pub fn logb(arg1: f64) -> f64;
}
extern "C" {
    pub fn logbf(arg1: f32) -> f32;
}
extern "C" {
    pub fn logbl(arg1: f64) -> f64;
}
extern "C" {
    pub fn modff(arg1: f32, arg2: *mut f32) -> f32;
}
extern "C" {
    pub fn modfl(arg1: f64, arg2: *mut f64) -> f64;
}
extern "C" {
    pub fn scalbn(arg1: f64, arg2: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn scalbnf(arg1: f32, arg2: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn scalbnl(arg1: f64, arg2: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn scalbln(arg1: f64, arg2: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn scalblnf(arg1: f32, arg2: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn scalblnl(arg1: f64, arg2: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn cbrt(arg1: f64) -> f64;
}
extern "C" {
    pub fn cbrtf(arg1: f32) -> f32;
}
extern "C" {
    pub fn cbrtl(arg1: f64) -> f64;
}
extern "C" {
    pub fn hypot(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn hypotf(x: f32, y: f32) -> f32;
}
extern "C" {
    pub fn hypotl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn powf(_X: f32, _Y: f32) -> f32;
}
extern "C" {
    pub fn powl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn sqrtf(arg1: f32) -> f32;
}
extern "C" {
    pub fn sqrtl(arg1: f64) -> f64;
}
extern "C" {
    pub fn erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn erfl(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn erfcl(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammal(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "signgam"]
    pub static mut signgam: ::std::os::raw::c_int;
}
extern "C" {
    pub fn tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn ceilf(arg1: f32) -> f32;
}
extern "C" {
    pub fn ceill(arg1: f64) -> f64;
}
extern "C" {
    pub fn floorf(arg1: f32) -> f32;
}
extern "C" {
    pub fn floorl(arg1: f64) -> f64;
}
extern "C" {
    pub fn nearbyint(arg1: f64) -> f64;
}
extern "C" {
    pub fn nearbyintf(arg1: f32) -> f32;
}
extern "C" {
    pub fn nearbyintl(arg1: f64) -> f64;
}
extern "C" {
    pub fn rint(arg1: f64) -> f64;
}
extern "C" {
    pub fn rintf(arg1: f32) -> f32;
}
extern "C" {
    pub fn rintl(arg1: f64) -> f64;
}
extern "C" {
    pub fn lrint(arg1: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lrintf(arg1: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lrintl(arg1: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrint(arg1: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llrintf(arg1: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llrintl(arg1: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn round(arg1: f64) -> f64;
}
extern "C" {
    pub fn roundf(arg1: f32) -> f32;
}
extern "C" {
    pub fn roundl(arg1: f64) -> f64;
}
extern "C" {
    pub fn lround(arg1: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lroundf(arg1: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lroundl(arg1: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llround(arg1: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llroundf(arg1: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llroundl(arg1: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn trunc(arg1: f64) -> f64;
}
extern "C" {
    pub fn truncf(arg1: f32) -> f32;
}
extern "C" {
    pub fn truncl(arg1: f64) -> f64;
}
extern "C" {
    pub fn fmodf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fmodl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn remainder(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn remainderf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn remainderl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn remquo(arg1: f64, arg2: f64, arg3: *mut ::std::os::raw::c_int)
     -> f64;
}
extern "C" {
    pub fn remquof(arg1: f32, arg2: f32, arg3: *mut ::std::os::raw::c_int)
     -> f32;
}
extern "C" {
    pub fn remquol(arg1: f64, arg2: f64, arg3: *mut ::std::os::raw::c_int)
     -> f64;
}
extern "C" {
    pub fn copysign(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn copysignf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn copysignl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn nan(tagp: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn nanf(tagp: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn nanl(tagp: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn nextafter(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn nextafterf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn nextafterl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn nexttoward(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn nexttowardf(arg1: f32, arg2: f64) -> f32;
}
extern "C" {
    pub fn nexttowardl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fdim(x: f64, y: f64) -> f64;
}
extern "C" {
    pub fn fdimf(x: f32, y: f32) -> f32;
}
extern "C" {
    pub fn fdiml(x: f64, y: f64) -> f64;
}
extern "C" {
    pub fn fmax(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fmaxf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fmaxl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fmin(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fminf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fminl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fma(arg1: f64, arg2: f64, arg3: f64) -> f64;
}
extern "C" {
    pub fn fmaf(arg1: f32, arg2: f32, arg3: f32) -> f32;
}
extern "C" {
    pub fn fmal(arg1: f64, arg2: f64, arg3: f64) -> f64;
}
extern "C" {
    pub fn _copysignf(_Number: f32, _Sign: f32) -> f32;
}
extern "C" {
    pub fn _chgsignf(_X: f32) -> f32;
}
extern "C" {
    pub fn _logbf(_X: f32) -> f32;
}
extern "C" {
    pub fn _nextafterf(_X: f32, _Y: f32) -> f32;
}
extern "C" {
    pub fn _finitef(_X: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _isnanf(_X: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fpclassf(_X: f32) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct octave_refcount<T> {
    pub count: octave_refcount_count_type<T>,
}
pub type octave_refcount_count_type<T> = T;
#[repr(C)]
#[derive(Debug)]
pub struct dim_vector {
    pub rep: *mut octave_idx_type,
}
#[test]
fn bindgen_test_layout_dim_vector() {
    assert_eq!(::std::mem::size_of::<dim_vector>() , 8usize , concat ! (
               "Size of: " , stringify ! ( dim_vector ) ));
    assert_eq! (::std::mem::align_of::<dim_vector>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( dim_vector ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dim_vector ) ) . rep as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( dim_vector ) , "::" ,
                stringify ! ( rep ) ));
}
extern "C" {
    #[link_name = "?chop_all_singletons@dim_vector@@QEAAXXZ"]
    pub fn dim_vector_chop_all_singletons(this: *mut dim_vector);
}
extern "C" {
    #[link_name = "?dim_max@dim_vector@@SAHXZ"]
    pub fn dim_vector_dim_max() -> octave_idx_type;
}
extern "C" {
    #[link_name =
          "?str@dim_vector@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@D@Z"]
    pub fn dim_vector_str(this: *const dim_vector,
                          sep: ::std::os::raw::c_char) -> std_string;
}
extern "C" {
    #[link_name = "?num_ones@dim_vector@@QEBAHXZ"]
    pub fn dim_vector_num_ones(this: *const dim_vector)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "?safe_numel@dim_vector@@QEBAHXZ"]
    pub fn dim_vector_safe_numel(this: *const dim_vector) -> octave_idx_type;
}
extern "C" {
    #[link_name = "?squeeze@dim_vector@@QEBA?AV1@XZ"]
    pub fn dim_vector_squeeze(this: *const dim_vector) -> dim_vector;
}
extern "C" {
    #[link_name = "?concat@dim_vector@@QEAA_NAEBV1@H@Z"]
    pub fn dim_vector_concat(this: *mut dim_vector, dvb: *const dim_vector,
                             dim: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    #[link_name = "?hvcat@dim_vector@@QEAA_NAEBV1@H@Z"]
    pub fn dim_vector_hvcat(this: *mut dim_vector, dvb: *const dim_vector,
                            dim: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    #[link_name = "?redim@dim_vector@@QEBA?AV1@H@Z"]
    pub fn dim_vector_redim(this: *const dim_vector, n: ::std::os::raw::c_int)
     -> dim_vector;
}
impl dim_vector {
    #[inline]
    pub unsafe fn chop_all_singletons(&mut self) {
        dim_vector_chop_all_singletons(self)
    }
    #[inline]
    pub unsafe fn dim_max() -> octave_idx_type { dim_vector_dim_max() }
    #[inline]
    pub unsafe fn str(&self, sep: ::std::os::raw::c_char) -> std_string {
        dim_vector_str(self, sep)
    }
    #[inline]
    pub unsafe fn num_ones(&self) -> ::std::os::raw::c_int {
        dim_vector_num_ones(self)
    }
    #[inline]
    pub unsafe fn safe_numel(&self) -> octave_idx_type {
        dim_vector_safe_numel(self)
    }
    #[inline]
    pub unsafe fn squeeze(&self) -> dim_vector { dim_vector_squeeze(self) }
    #[inline]
    pub unsafe fn concat(&mut self, dvb: *const dim_vector,
                         dim: ::std::os::raw::c_int) -> bool {
        dim_vector_concat(self, dvb, dim)
    }
    #[inline]
    pub unsafe fn hvcat(&mut self, dvb: *const dim_vector,
                        dim: ::std::os::raw::c_int) -> bool {
        dim_vector_hvcat(self, dvb, dim)
    }
    #[inline]
    pub unsafe fn redim(&self, n: ::std::os::raw::c_int) -> dim_vector {
        dim_vector_redim(self, n)
    }
}
extern "C" {
    pub fn _memccpy(_Dst: *mut ::std::os::raw::c_void,
                    _Src: *const ::std::os::raw::c_void,
                    _Val: ::std::os::raw::c_int, _MaxCount: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memchr(_Buf: *const ::std::os::raw::c_void,
                  _Val: ::std::os::raw::c_int, _MaxCount: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _memicmp(_Buf1: *const ::std::os::raw::c_void,
                    _Buf2: *const ::std::os::raw::c_void, _Size: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _memicmp_l(_Buf1: *const ::std::os::raw::c_void,
                      _Buf2: *const ::std::os::raw::c_void, _Size: usize,
                      _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memcmp(_Buf1: *const ::std::os::raw::c_void,
                  _Buf2: *const ::std::os::raw::c_void, _Size: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mempcpy(_Dst: *mut ::std::os::raw::c_void,
                   _Src: *const ::std::os::raw::c_void, _Size: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(_Dst: *mut ::std::os::raw::c_void,
                  _Val: ::std::os::raw::c_int, _Size: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memccpy(_Dst: *mut ::std::os::raw::c_void,
                   _Src: *const ::std::os::raw::c_void,
                   _Val: ::std::os::raw::c_int, _Size: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memicmp(_Buf1: *const ::std::os::raw::c_void,
                   _Buf2: *const ::std::os::raw::c_void, _Size: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strset(_Str: *mut ::std::os::raw::c_char,
                   _Val: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strset_l(_Str: *mut ::std::os::raw::c_char,
                     _Val: ::std::os::raw::c_int, _Locale: _locale_t)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcpy(_Dest: *mut ::std::os::raw::c_char,
                  _Source: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(_Dest: *mut ::std::os::raw::c_char,
                  _Source: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(_Str1: *const ::std::os::raw::c_char,
                  _Str2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strlen(_Str: *const ::std::os::raw::c_char) -> usize;
}
extern "C" {
    pub fn strnlen(_Str: *const ::std::os::raw::c_char, _MaxCount: usize)
     -> usize;
}
extern "C" {
    pub fn _strdup(_Src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(_Str: *const ::std::os::raw::c_char,
                  _Val: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _stricmp(_Str1: *const ::std::os::raw::c_char,
                    _Str2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strcmpi(_Str1: *const ::std::os::raw::c_char,
                    _Str2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _stricmp_l(_Str1: *const ::std::os::raw::c_char,
                      _Str2: *const ::std::os::raw::c_char,
                      _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(_Str1: *const ::std::os::raw::c_char,
                   _Str2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strcoll_l(_Str1: *const ::std::os::raw::c_char,
                      _Str2: *const ::std::os::raw::c_char,
                      _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _stricoll(_Str1: *const ::std::os::raw::c_char,
                     _Str2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _stricoll_l(_Str1: *const ::std::os::raw::c_char,
                       _Str2: *const ::std::os::raw::c_char,
                       _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strncoll(_Str1: *const ::std::os::raw::c_char,
                     _Str2: *const ::std::os::raw::c_char, _MaxCount: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strncoll_l(_Str1: *const ::std::os::raw::c_char,
                       _Str2: *const ::std::os::raw::c_char, _MaxCount: usize,
                       _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strnicoll(_Str1: *const ::std::os::raw::c_char,
                      _Str2: *const ::std::os::raw::c_char, _MaxCount: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strnicoll_l(_Str1: *const ::std::os::raw::c_char,
                        _Str2: *const ::std::os::raw::c_char,
                        _MaxCount: usize, _Locale: _locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcspn(_Str: *const ::std::os::raw::c_char,
                   _Control: *const ::std::os::raw::c_char) -> usize;
}
extern "C" {
    pub fn _strerror(_ErrMsg: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strerror(arg1: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strlwr(_String: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlwr_l(_String: *mut ::std::os::raw::c_char, _Locale: _locale_t)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(_Dest: *mut ::std::os::raw::c_char,
                   _Source: *const ::std::os::raw::c_char, _Count: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncmp(_Str1: *const ::std::os::raw::c_char,
                   _Str2: *const ::std::os::raw::c_char, _MaxCount: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strnicmp(_Str1: *const ::std::os::raw::c_char,
                     _Str2: *const ::std::os::raw::c_char, _MaxCount: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strnicmp_l(_Str1: *const ::std::os::raw::c_char,
                       _Str2: *const ::std::os::raw::c_char, _MaxCount: usize,
                       _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncpy(_Dest: *mut ::std::os::raw::c_char,
                   _Source: *const ::std::os::raw::c_char, _Count: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strnset(_Str: *mut ::std::os::raw::c_char,
                    _Val: ::std::os::raw::c_int, _MaxCount: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strnset_l(str: *mut ::std::os::raw::c_char,
                      c: ::std::os::raw::c_int, count: usize,
                      _Locale: _locale_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strpbrk(_Str: *const ::std::os::raw::c_char,
                   _Control: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(_Str: *const ::std::os::raw::c_char,
                   _Ch: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strrev(_Str: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strspn(_Str: *const ::std::os::raw::c_char,
                  _Control: *const ::std::os::raw::c_char) -> usize;
}
extern "C" {
    pub fn strstr(_Str: *const ::std::os::raw::c_char,
                  _SubStr: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(_Str: *mut ::std::os::raw::c_char,
                  _Delim: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok_r(_Str: *mut ::std::os::raw::c_char,
                    _Delim: *const ::std::os::raw::c_char,
                    __last: *mut *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strupr(_String: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strupr_l(_String: *mut ::std::os::raw::c_char, _Locale: _locale_t)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strxfrm(_Dst: *mut ::std::os::raw::c_char,
                   _Src: *const ::std::os::raw::c_char, _MaxCount: usize)
     -> usize;
}
extern "C" {
    pub fn _strxfrm_l(_Dst: *mut ::std::os::raw::c_char,
                      _Src: *const ::std::os::raw::c_char, _MaxCount: usize,
                      _Locale: _locale_t) -> usize;
}
extern "C" {
    pub fn strdup(_Src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmpi(_Str1: *const ::std::os::raw::c_char,
                   _Str2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn stricmp(_Str1: *const ::std::os::raw::c_char,
                   _Str2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strlwr(_Str: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnicmp(_Str1: *const ::std::os::raw::c_char,
                    _Str: *const ::std::os::raw::c_char, _MaxCount: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(arg1: *const ::std::os::raw::c_char,
                       arg2: *const ::std::os::raw::c_char, arg3: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(arg1: *const ::std::os::raw::c_char,
                      arg2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strnset(_Str: *mut ::std::os::raw::c_char,
                   _Val: ::std::os::raw::c_int, _MaxCount: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrev(_Str: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strset(_Str: *mut ::std::os::raw::c_char,
                  _Val: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strupr(_Str: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct octave_int<T> {
    pub ival: T,
}
pub type octave_int_val_type<T> = T;
pub type octave_int8 = octave_int<::std::os::raw::c_schar>;
pub type octave_int16 = octave_int<::std::os::raw::c_short>;
pub type octave_int32 = octave_int<::std::os::raw::c_int>;
pub type octave_int64 = octave_int<::std::os::raw::c_longlong>;
pub type octave_uint8 = octave_int<::std::os::raw::c_uchar>;
pub type octave_uint16 = octave_int<::std::os::raw::c_ushort>;
pub type octave_uint32 = octave_int<::std::os::raw::c_uint>;
pub type octave_uint64 = octave_int<::std::os::raw::c_ulonglong>;
#[repr(C)]
pub struct Array__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct Array<T> {
    pub vtable_: *const Array__bindgen_vtable,
    pub dimensions: dim_vector,
    pub rep: *mut Array_ArrayRep<T>,
    pub slice_data: *mut T,
    pub slice_len: octave_idx_type,
}
#[repr(C)]
#[derive(Debug)]
pub struct Array_ArrayRep<T> {
    pub data: *mut T,
    pub len: octave_idx_type,
    pub count: octave_refcount<::std::os::raw::c_int>,
}
pub type Array_element_type<T> = T;
pub type Array_value_type<T> = T;
pub type Array_size_type = octave_idx_type;
pub type Array_crefT = ref_param;
pub type Array_compare_fcn_type =
    ::std::option::Option<unsafe extern "C" fn(arg1: ref_param,
                                               arg2: ref_param) -> bool>;
#[repr(C)]
pub struct Sparse__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct Sparse<T> {
    pub vtable_: *const Sparse__bindgen_vtable,
    pub rep: *mut Sparse_SparseRep<T>,
    pub dimensions: dim_vector,
}
pub type Sparse_element_type<T> = T;
#[repr(C)]
#[derive(Debug)]
pub struct Sparse_SparseRep<T> {
    pub d: *mut T,
    pub r: *mut octave_idx_type,
    pub c: *mut octave_idx_type,
    pub nzmx: octave_idx_type,
    pub nrows: octave_idx_type,
    pub ncols: octave_idx_type,
    pub count: octave_refcount<::std::os::raw::c_int>,
}
#[repr(C)]
#[derive(Debug)]
pub struct Range {
    pub rng_base: f64,
    pub rng_limit: f64,
    pub rng_inc: f64,
    pub rng_numel: octave_idx_type,
    pub cache: Matrix,
}
#[test]
fn bindgen_test_layout_Range() {
    assert_eq!(::std::mem::size_of::<Range>() , 72usize , concat ! (
               "Size of: " , stringify ! ( Range ) ));
    assert_eq! (::std::mem::align_of::<Range>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( Range ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Range ) ) . rng_base as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Range ) , "::" ,
                stringify ! ( rng_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Range ) ) . rng_limit as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( Range ) , "::" ,
                stringify ! ( rng_limit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Range ) ) . rng_inc as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( Range ) , "::" ,
                stringify ! ( rng_inc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Range ) ) . rng_numel as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( Range ) , "::" ,
                stringify ! ( rng_numel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Range ) ) . cache as * const _ as usize }
                , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( Range ) , "::" ,
                stringify ! ( cache ) ));
}
extern "C" {
    #[link_name = "?all_elements_are_ints@Range@@QEBA_NXZ"]
    pub fn Range_all_elements_are_ints(this: *const Range) -> bool;
}
extern "C" {
    #[link_name = "?matrix_value@Range@@QEBA?AVMatrix@@XZ"]
    pub fn Range_matrix_value(this: *const Range) -> Matrix;
}
extern "C" {
    #[link_name = "?min@Range@@QEBANXZ"]
    pub fn Range_min(this: *const Range) -> f64;
}
extern "C" {
    #[link_name = "?max@Range@@QEBANXZ"]
    pub fn Range_max(this: *const Range) -> f64;
}
extern "C" {
    #[link_name = "?sort_internal@Range@@QEAAX_N@Z"]
    pub fn Range_sort_internal(this: *mut Range, ascending: bool);
}
extern "C" {
    #[link_name = "?sort_internal@Range@@QEAAXAEAV?$Array@H@@_N@Z"]
    pub fn Range_sort_internal1(this: *mut Range,
                                sidx: *mut Array<::std::os::raw::c_int>,
                                ascending: bool);
}
extern "C" {
    #[link_name = "?diag@Range@@QEBA?AVMatrix@@H@Z"]
    pub fn Range_diag(this: *const Range, k: octave_idx_type) -> Matrix;
}
extern "C" {
    #[link_name = "?sort@Range@@QEBA?AV1@HW4sortmode@@@Z"]
    pub fn Range_sort(this: *const Range, dim: octave_idx_type,
                      mode: sortmode) -> Range;
}
extern "C" {
    #[link_name = "?sort@Range@@QEBA?AV1@AEAV?$Array@H@@HW4sortmode@@@Z"]
    pub fn Range_sort1(this: *const Range,
                       sidx: *mut Array<::std::os::raw::c_int>,
                       dim: octave_idx_type, mode: sortmode) -> Range;
}
extern "C" {
    #[link_name = "?is_sorted@Range@@QEBA?AW4sortmode@@W42@@Z"]
    pub fn Range_is_sorted(this: *const Range, mode: sortmode) -> sortmode;
}
extern "C" {
    #[link_name = "?checkelem@Range@@QEBANH@Z"]
    pub fn Range_checkelem(this: *const Range, i: octave_idx_type) -> f64;
}
extern "C" {
    #[link_name = "?elem@Range@@QEBANH@Z"]
    pub fn Range_elem(this: *const Range, i: octave_idx_type) -> f64;
}
extern "C" {
    #[link_name = "?index@Range@@QEBA?AV?$Array@N@@AEBVidx_vector@@@Z"]
    pub fn Range_index(this: *const Range, i: *const idx_vector)
     -> Array<f64>;
}
extern "C" {
    #[link_name = "?set_base@Range@@QEAAXN@Z"]
    pub fn Range_set_base(this: *mut Range, b: f64);
}
extern "C" {
    #[link_name = "?set_limit@Range@@QEAAXN@Z"]
    pub fn Range_set_limit(this: *mut Range, l: f64);
}
extern "C" {
    #[link_name = "?set_inc@Range@@QEAAXN@Z"]
    pub fn Range_set_inc(this: *mut Range, i: f64);
}
impl Range {
    #[inline]
    pub unsafe fn all_elements_are_ints(&self) -> bool {
        Range_all_elements_are_ints(self)
    }
    #[inline]
    pub unsafe fn matrix_value(&self) -> Matrix { Range_matrix_value(self) }
    #[inline]
    pub unsafe fn min(&self) -> f64 { Range_min(self) }
    #[inline]
    pub unsafe fn max(&self) -> f64 { Range_max(self) }
    #[inline]
    pub unsafe fn sort_internal(&mut self, ascending: bool) {
        Range_sort_internal(self, ascending)
    }
    #[inline]
    pub unsafe fn sort_internal1(&mut self,
                                 sidx: *mut Array<::std::os::raw::c_int>,
                                 ascending: bool) {
        Range_sort_internal1(self, sidx, ascending)
    }
    #[inline]
    pub unsafe fn diag(&self, k: octave_idx_type) -> Matrix {
        Range_diag(self, k)
    }
    #[inline]
    pub unsafe fn sort(&self, dim: octave_idx_type, mode: sortmode) -> Range {
        Range_sort(self, dim, mode)
    }
    #[inline]
    pub unsafe fn sort1(&self, sidx: *mut Array<::std::os::raw::c_int>,
                        dim: octave_idx_type, mode: sortmode) -> Range {
        Range_sort1(self, sidx, dim, mode)
    }
    #[inline]
    pub unsafe fn is_sorted(&self, mode: sortmode) -> sortmode {
        Range_is_sorted(self, mode)
    }
    #[inline]
    pub unsafe fn checkelem(&self, i: octave_idx_type) -> f64 {
        Range_checkelem(self, i)
    }
    #[inline]
    pub unsafe fn elem(&self, i: octave_idx_type) -> f64 {
        Range_elem(self, i)
    }
    #[inline]
    pub unsafe fn index(&self, i: *const idx_vector) -> Array<f64> {
        Range_index(self, i)
    }
    #[inline]
    pub unsafe fn set_base(&mut self, b: f64) { Range_set_base(self, b) }
    #[inline]
    pub unsafe fn set_limit(&mut self, l: f64) { Range_set_limit(self, l) }
    #[inline]
    pub unsafe fn set_inc(&mut self, i: f64) { Range_set_inc(self, i) }
}
#[repr(C)]
#[derive(Debug)]
pub struct idx_vector {
    pub rep: *mut idx_vector_idx_base_rep,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum idx_vector_idx_class_type {
    class_invalid = -1,
    class_colon = 0,
    class_range = 1,
    class_scalar = 2,
    class_vector = 3,
    class_mask = 4,
}
#[repr(C)]
pub struct idx_vector_idx_base_rep__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct idx_vector_idx_base_rep {
    pub vtable_: *const idx_vector_idx_base_rep__bindgen_vtable,
    pub count: octave_refcount<::std::os::raw::c_int>,
    pub err: bool,
}
#[test]
fn bindgen_test_layout_idx_vector_idx_base_rep() {
    assert_eq!(::std::mem::size_of::<idx_vector_idx_base_rep>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( idx_vector_idx_base_rep ) ));
    assert_eq! (::std::mem::align_of::<idx_vector_idx_base_rep>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( idx_vector_idx_base_rep ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const idx_vector_idx_base_rep ) ) . count as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( idx_vector_idx_base_rep
                ) , "::" , stringify ! ( count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const idx_vector_idx_base_rep ) ) . err as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( idx_vector_idx_base_rep
                ) , "::" , stringify ! ( err ) ));
}
#[repr(C)]
#[derive(Debug)]
pub struct idx_vector_idx_colon_rep {
    pub _base: idx_vector_idx_base_rep,
}
#[test]
fn bindgen_test_layout_idx_vector_idx_colon_rep() {
    assert_eq!(::std::mem::size_of::<idx_vector_idx_colon_rep>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( idx_vector_idx_colon_rep ) ));
    assert_eq! (::std::mem::align_of::<idx_vector_idx_colon_rep>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( idx_vector_idx_colon_rep ) ));
}
extern "C" {
    #[link_name = "??0idx_colon_rep@idx_vector@@QEAA@D@Z"]
    pub fn idx_vector_idx_colon_rep_idx_colon_rep(this:
                                                      *mut idx_vector_idx_colon_rep,
                                                  c: ::std::os::raw::c_char);
}
impl idx_vector_idx_colon_rep {
    #[inline]
    pub unsafe fn new(c: ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        idx_vector_idx_colon_rep_idx_colon_rep(&mut __bindgen_tmp, c);
        __bindgen_tmp
    }
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum idx_vector_direct { DIRECT = 0, }
#[repr(C)]
#[derive(Debug)]
pub struct idx_vector_idx_range_rep {
    pub _base: idx_vector_idx_base_rep,
    pub start: octave_idx_type,
    pub len: octave_idx_type,
    pub step: octave_idx_type,
}
#[test]
fn bindgen_test_layout_idx_vector_idx_range_rep() {
    assert_eq!(::std::mem::size_of::<idx_vector_idx_range_rep>() , 32usize ,
               concat ! (
               "Size of: " , stringify ! ( idx_vector_idx_range_rep ) ));
    assert_eq! (::std::mem::align_of::<idx_vector_idx_range_rep>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( idx_vector_idx_range_rep ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const idx_vector_idx_range_rep ) ) . start as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                idx_vector_idx_range_rep ) , "::" , stringify ! ( start ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const idx_vector_idx_range_rep ) ) . len as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                idx_vector_idx_range_rep ) , "::" , stringify ! ( len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const idx_vector_idx_range_rep ) ) . step as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                idx_vector_idx_range_rep ) , "::" , stringify ! ( step ) ));
}
extern "C" {
    #[link_name = "?unconvert@idx_range_rep@idx_vector@@QEBA?AVRange@@XZ"]
    pub fn idx_vector_idx_range_rep_unconvert(this:
                                                  *const idx_vector_idx_range_rep)
     -> Range;
}
extern "C" {
    #[link_name = "??0idx_range_rep@idx_vector@@QEAA@HHH@Z"]
    pub fn idx_vector_idx_range_rep_idx_range_rep(this:
                                                      *mut idx_vector_idx_range_rep,
                                                  _start: octave_idx_type,
                                                  _limit: octave_idx_type,
                                                  _step: octave_idx_type);
}
extern "C" {
    #[link_name = "??0idx_range_rep@idx_vector@@QEAA@AEBVRange@@@Z"]
    pub fn idx_vector_idx_range_rep_idx_range_rep1(this:
                                                       *mut idx_vector_idx_range_rep,
                                                   arg1: *const Range);
}
impl idx_vector_idx_range_rep {
    #[inline]
    pub unsafe fn unconvert(&self) -> Range {
        idx_vector_idx_range_rep_unconvert(self)
    }
    #[inline]
    pub unsafe fn new(_start: octave_idx_type, _limit: octave_idx_type,
                      _step: octave_idx_type) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        idx_vector_idx_range_rep_idx_range_rep(&mut __bindgen_tmp, _start,
                                               _limit, _step);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(arg1: *const Range) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        idx_vector_idx_range_rep_idx_range_rep1(&mut __bindgen_tmp, arg1);
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct idx_vector_idx_scalar_rep {
    pub _base: idx_vector_idx_base_rep,
    pub data: octave_idx_type,
}
#[test]
fn bindgen_test_layout_idx_vector_idx_scalar_rep() {
    assert_eq!(::std::mem::size_of::<idx_vector_idx_scalar_rep>() , 24usize ,
               concat ! (
               "Size of: " , stringify ! ( idx_vector_idx_scalar_rep ) ));
    assert_eq! (::std::mem::align_of::<idx_vector_idx_scalar_rep>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( idx_vector_idx_scalar_rep )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const idx_vector_idx_scalar_rep ) ) . data as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                idx_vector_idx_scalar_rep ) , "::" , stringify ! ( data ) ));
}
extern "C" {
    #[link_name = "?unconvert@idx_scalar_rep@idx_vector@@QEBANXZ"]
    pub fn idx_vector_idx_scalar_rep_unconvert(this:
                                                   *const idx_vector_idx_scalar_rep)
     -> f64;
}
extern "C" {
    #[link_name = "??0idx_scalar_rep@idx_vector@@QEAA@H@Z"]
    pub fn idx_vector_idx_scalar_rep_idx_scalar_rep(this:
                                                        *mut idx_vector_idx_scalar_rep,
                                                    i: octave_idx_type);
}
impl idx_vector_idx_scalar_rep {
    #[inline]
    pub unsafe fn unconvert(&self) -> f64 {
        idx_vector_idx_scalar_rep_unconvert(self)
    }
    #[inline]
    pub unsafe fn new(i: octave_idx_type) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        idx_vector_idx_scalar_rep_idx_scalar_rep(&mut __bindgen_tmp, i);
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct idx_vector_idx_vector_rep {
    pub _base: idx_vector_idx_base_rep,
    pub data: *const octave_idx_type,
    pub len: octave_idx_type,
    pub ext: octave_idx_type,
    pub aowner: *mut Array<::std::os::raw::c_int>,
    pub orig_dims: dim_vector,
}
#[test]
fn bindgen_test_layout_idx_vector_idx_vector_rep() {
    assert_eq!(::std::mem::size_of::<idx_vector_idx_vector_rep>() , 48usize ,
               concat ! (
               "Size of: " , stringify ! ( idx_vector_idx_vector_rep ) ));
    assert_eq! (::std::mem::align_of::<idx_vector_idx_vector_rep>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( idx_vector_idx_vector_rep )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const idx_vector_idx_vector_rep ) ) . data as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                idx_vector_idx_vector_rep ) , "::" , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const idx_vector_idx_vector_rep ) ) . len as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                idx_vector_idx_vector_rep ) , "::" , stringify ! ( len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const idx_vector_idx_vector_rep ) ) . ext as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                idx_vector_idx_vector_rep ) , "::" , stringify ! ( ext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const idx_vector_idx_vector_rep ) ) . aowner as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                idx_vector_idx_vector_rep ) , "::" , stringify ! ( aowner )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const idx_vector_idx_vector_rep ) ) . orig_dims
                as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                idx_vector_idx_vector_rep ) , "::" , stringify ! ( orig_dims )
                ));
}
extern "C" {
    #[link_name =
          "?unconvert@idx_vector_rep@idx_vector@@QEBA?AV?$Array@N@@XZ"]
    pub fn idx_vector_idx_vector_rep_unconvert(this:
                                                   *const idx_vector_idx_vector_rep)
     -> Array<f64>;
}
extern "C" {
    #[link_name = "??0idx_vector_rep@idx_vector@@QEAA@AEBV?$Array@H@@@Z"]
    pub fn idx_vector_idx_vector_rep_idx_vector_rep(this:
                                                        *mut idx_vector_idx_vector_rep,
                                                    inda:
                                                        *const Array<::std::os::raw::c_int>);
}
extern "C" {
    #[link_name =
          "??0idx_vector_rep@idx_vector@@QEAA@AEBV?$Array@H@@HW4direct@1@@Z"]
    pub fn idx_vector_idx_vector_rep_idx_vector_rep1(this:
                                                         *mut idx_vector_idx_vector_rep,
                                                     inda:
                                                         *const Array<::std::os::raw::c_int>,
                                                     _ext: octave_idx_type,
                                                     arg1: idx_vector_direct);
}
extern "C" {
    #[link_name = "??0idx_vector_rep@idx_vector@@QEAA@_N@Z"]
    pub fn idx_vector_idx_vector_rep_idx_vector_rep2(this:
                                                         *mut idx_vector_idx_vector_rep,
                                                     arg1: bool);
}
extern "C" {
    #[link_name = "??0idx_vector_rep@idx_vector@@QEAA@AEBV?$Array@_N@@H@Z"]
    pub fn idx_vector_idx_vector_rep_idx_vector_rep3(this:
                                                         *mut idx_vector_idx_vector_rep,
                                                     arg1: *const Array<bool>,
                                                     arg2: octave_idx_type);
}
extern "C" {
    #[link_name = "??0idx_vector_rep@idx_vector@@QEAA@AEBV?$Sparse@_N@@@Z"]
    pub fn idx_vector_idx_vector_rep_idx_vector_rep4(this:
                                                         *mut idx_vector_idx_vector_rep,
                                                     arg1:
                                                         *const Sparse<bool>);
}
impl idx_vector_idx_vector_rep {
    #[inline]
    pub unsafe fn unconvert(&self) -> Array<f64> {
        idx_vector_idx_vector_rep_unconvert(self)
    }
    #[inline]
    pub unsafe fn new(inda: *const Array<::std::os::raw::c_int>) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        idx_vector_idx_vector_rep_idx_vector_rep(&mut __bindgen_tmp, inda);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(inda: *const Array<::std::os::raw::c_int>,
                       _ext: octave_idx_type, arg1: idx_vector_direct)
     -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        idx_vector_idx_vector_rep_idx_vector_rep1(&mut __bindgen_tmp, inda,
                                                  _ext, arg1);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new2(arg1: bool) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        idx_vector_idx_vector_rep_idx_vector_rep2(&mut __bindgen_tmp, arg1);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new3(arg1: *const Array<bool>, arg2: octave_idx_type)
     -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        idx_vector_idx_vector_rep_idx_vector_rep3(&mut __bindgen_tmp, arg1,
                                                  arg2);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new4(arg1: *const Sparse<bool>) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        idx_vector_idx_vector_rep_idx_vector_rep4(&mut __bindgen_tmp, arg1);
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct idx_vector_idx_mask_rep {
    pub _base: idx_vector_idx_base_rep,
    pub data: *const bool,
    pub len: octave_idx_type,
    pub ext: octave_idx_type,
    pub lsti: octave_idx_type,
    pub lste: octave_idx_type,
    pub aowner: *mut Array<bool>,
    pub orig_dims: dim_vector,
}
#[test]
fn bindgen_test_layout_idx_vector_idx_mask_rep() {
    assert_eq!(::std::mem::size_of::<idx_vector_idx_mask_rep>() , 56usize ,
               concat ! (
               "Size of: " , stringify ! ( idx_vector_idx_mask_rep ) ));
    assert_eq! (::std::mem::align_of::<idx_vector_idx_mask_rep>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( idx_vector_idx_mask_rep ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const idx_vector_idx_mask_rep ) ) . data as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( idx_vector_idx_mask_rep
                ) , "::" , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const idx_vector_idx_mask_rep ) ) . len as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( idx_vector_idx_mask_rep
                ) , "::" , stringify ! ( len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const idx_vector_idx_mask_rep ) ) . ext as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( idx_vector_idx_mask_rep
                ) , "::" , stringify ! ( ext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const idx_vector_idx_mask_rep ) ) . lsti as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( idx_vector_idx_mask_rep
                ) , "::" , stringify ! ( lsti ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const idx_vector_idx_mask_rep ) ) . lste as *
                const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( idx_vector_idx_mask_rep
                ) , "::" , stringify ! ( lste ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const idx_vector_idx_mask_rep ) ) . aowner as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( idx_vector_idx_mask_rep
                ) , "::" , stringify ! ( aowner ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const idx_vector_idx_mask_rep ) ) . orig_dims
                as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( idx_vector_idx_mask_rep
                ) , "::" , stringify ! ( orig_dims ) ));
}
extern "C" {
    #[link_name = "?unconvert@idx_mask_rep@idx_vector@@QEBA?AV?$Array@_N@@XZ"]
    pub fn idx_vector_idx_mask_rep_unconvert(this:
                                                 *const idx_vector_idx_mask_rep)
     -> Array<bool>;
}
extern "C" {
    #[link_name = "??0idx_mask_rep@idx_vector@@QEAA@_N@Z"]
    pub fn idx_vector_idx_mask_rep_idx_mask_rep(this:
                                                    *mut idx_vector_idx_mask_rep,
                                                arg1: bool);
}
extern "C" {
    #[link_name = "??0idx_mask_rep@idx_vector@@QEAA@AEBV?$Array@_N@@H@Z"]
    pub fn idx_vector_idx_mask_rep_idx_mask_rep1(this:
                                                     *mut idx_vector_idx_mask_rep,
                                                 arg1: *const Array<bool>,
                                                 arg2: octave_idx_type);
}
impl idx_vector_idx_mask_rep {
    #[inline]
    pub unsafe fn unconvert(&self) -> Array<bool> {
        idx_vector_idx_mask_rep_unconvert(self)
    }
    #[inline]
    pub unsafe fn new(arg1: bool) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        idx_vector_idx_mask_rep_idx_mask_rep(&mut __bindgen_tmp, arg1);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(arg1: *const Array<bool>, arg2: octave_idx_type)
     -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        idx_vector_idx_mask_rep_idx_mask_rep1(&mut __bindgen_tmp, arg1, arg2);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "?colon@idx_vector@@2V1@B"]
    pub static idx_vector_colon: idx_vector;
}
#[test]
fn bindgen_test_layout_idx_vector() {
    assert_eq!(::std::mem::size_of::<idx_vector>() , 8usize , concat ! (
               "Size of: " , stringify ! ( idx_vector ) ));
    assert_eq! (::std::mem::align_of::<idx_vector>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( idx_vector ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const idx_vector ) ) . rep as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( idx_vector ) , "::" ,
                stringify ! ( rep ) ));
}
extern "C" {
    #[link_name = "?maybe_reduce@idx_vector@@QEAA_NHAEBV1@H@Z"]
    pub fn idx_vector_maybe_reduce(this: *mut idx_vector, n: octave_idx_type,
                                   j: *const idx_vector, nj: octave_idx_type)
     -> bool;
}
extern "C" {
    #[link_name = "?is_cont_range@idx_vector@@QEBA_NHAEAH0@Z"]
    pub fn idx_vector_is_cont_range(this: *const idx_vector,
                                    n: octave_idx_type,
                                    l: *mut octave_idx_type,
                                    u: *mut octave_idx_type) -> bool;
}
extern "C" {
    #[link_name = "?increment@idx_vector@@QEBAHXZ"]
    pub fn idx_vector_increment(this: *const idx_vector) -> octave_idx_type;
}
extern "C" {
    #[link_name = "?complement@idx_vector@@QEBA?AV1@H@Z"]
    pub fn idx_vector_complement(this: *const idx_vector, n: octave_idx_type)
     -> idx_vector;
}
extern "C" {
    #[link_name = "?is_permutation@idx_vector@@QEBA_NH@Z"]
    pub fn idx_vector_is_permutation(this: *const idx_vector,
                                     n: octave_idx_type) -> bool;
}
extern "C" {
    #[link_name = "?inverse_permutation@idx_vector@@QEBA?AV1@H@Z"]
    pub fn idx_vector_inverse_permutation(this: *const idx_vector,
                                          n: octave_idx_type) -> idx_vector;
}
extern "C" {
    #[link_name = "?copy_data@idx_vector@@QEBAXPEAH@Z"]
    pub fn idx_vector_copy_data(this: *const idx_vector,
                                data: *mut octave_idx_type);
}
extern "C" {
    #[link_name = "?unmask@idx_vector@@QEBA?AV1@XZ"]
    pub fn idx_vector_unmask(this: *const idx_vector) -> idx_vector;
}
extern "C" {
    #[link_name =
          "?unconvert@idx_vector@@QEBAXAEAW4idx_class_type@1@AEANAEAVRange@@AEAV?$Array@N@@AEAV?$Array@_N@@@Z"]
    pub fn idx_vector_unconvert(this: *const idx_vector,
                                iclass: *mut idx_vector_idx_class_type,
                                scalar: *mut f64, range: *mut Range,
                                array: *mut Array<f64>,
                                mask: *mut Array<bool>);
}
extern "C" {
    #[link_name = "?as_array@idx_vector@@QEBA?AV?$Array@H@@XZ"]
    pub fn idx_vector_as_array(this: *const idx_vector)
     -> Array<::std::os::raw::c_int>;
}
extern "C" {
    #[link_name = "?raw@idx_vector@@QEAAPEBHXZ"]
    pub fn idx_vector_raw(this: *mut idx_vector) -> *const octave_idx_type;
}
extern "C" {
    #[link_name = "?is_vector@idx_vector@@QEBA_NXZ"]
    pub fn idx_vector_is_vector(this: *const idx_vector) -> bool;
}
extern "C" {
    #[link_name = "?freeze@idx_vector@@QEAAHHPEBD_N@Z"]
    pub fn idx_vector_freeze(this: *mut idx_vector, z_len: octave_idx_type,
                             tag: *const ::std::os::raw::c_char,
                             resize_ok: bool) -> octave_idx_type;
}
extern "C" {
    #[link_name = "?ones_count@idx_vector@@QEBAHXZ"]
    pub fn idx_vector_ones_count(this: *const idx_vector) -> octave_idx_type;
}
extern "C" {
    #[link_name = "??0idx_vector@@QEAA@AEBV?$Array@_N@@@Z"]
    pub fn idx_vector_idx_vector(this: *mut idx_vector,
                                 nda: *const Array<bool>);
}
impl idx_vector {
    #[inline]
    pub unsafe fn maybe_reduce(&mut self, n: octave_idx_type,
                               j: *const idx_vector, nj: octave_idx_type)
     -> bool {
        idx_vector_maybe_reduce(self, n, j, nj)
    }
    #[inline]
    pub unsafe fn is_cont_range(&self, n: octave_idx_type,
                                l: *mut octave_idx_type,
                                u: *mut octave_idx_type) -> bool {
        idx_vector_is_cont_range(self, n, l, u)
    }
    #[inline]
    pub unsafe fn increment(&self) -> octave_idx_type {
        idx_vector_increment(self)
    }
    #[inline]
    pub unsafe fn complement(&self, n: octave_idx_type) -> idx_vector {
        idx_vector_complement(self, n)
    }
    #[inline]
    pub unsafe fn is_permutation(&self, n: octave_idx_type) -> bool {
        idx_vector_is_permutation(self, n)
    }
    #[inline]
    pub unsafe fn inverse_permutation(&self, n: octave_idx_type)
     -> idx_vector {
        idx_vector_inverse_permutation(self, n)
    }
    #[inline]
    pub unsafe fn copy_data(&self, data: *mut octave_idx_type) {
        idx_vector_copy_data(self, data)
    }
    #[inline]
    pub unsafe fn unmask(&self) -> idx_vector { idx_vector_unmask(self) }
    #[inline]
    pub unsafe fn unconvert(&self, iclass: *mut idx_vector_idx_class_type,
                            scalar: *mut f64, range: *mut Range,
                            array: *mut Array<f64>, mask: *mut Array<bool>) {
        idx_vector_unconvert(self, iclass, scalar, range, array, mask)
    }
    #[inline]
    pub unsafe fn as_array(&self) -> Array<::std::os::raw::c_int> {
        idx_vector_as_array(self)
    }
    #[inline]
    pub unsafe fn raw(&mut self) -> *const octave_idx_type {
        idx_vector_raw(self)
    }
    #[inline]
    pub unsafe fn is_vector(&self) -> bool { idx_vector_is_vector(self) }
    #[inline]
    pub unsafe fn freeze(&mut self, z_len: octave_idx_type,
                         tag: *const ::std::os::raw::c_char, resize_ok: bool)
     -> octave_idx_type {
        idx_vector_freeze(self, z_len, tag, resize_ok)
    }
    #[inline]
    pub unsafe fn ones_count(&self) -> octave_idx_type {
        idx_vector_ones_count(self)
    }
    #[inline]
    pub unsafe fn new(nda: *const Array<bool>) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        idx_vector_idx_vector(&mut __bindgen_tmp, nda);
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct equal_types {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct is_instance {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct is_class_type {
    pub __bindgen_anon_1: is_class_type_two,
}
pub type is_class_type_one = ::std::os::raw::c_char;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct is_class_type_two {
    pub c: [::std::os::raw::c_char; 2usize],
}
pub const is_class_type_yes: is_class_type__bindgen_ty_1 =
    is_class_type__bindgen_ty_1::yes;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum is_class_type__bindgen_ty_1 { yes = 0, }
pub const is_class_type_no: is_class_type__bindgen_ty_2 =
    is_class_type__bindgen_ty_2::no;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum is_class_type__bindgen_ty_2 { no = 0, }
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ref_param {
    pub _address: u8,
}
pub type ref_param_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct strip_template_param {
    pub _address: u8,
}
pub type strip_template_param_type<T> = T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct subst_template_param {
    pub _address: u8,
}
pub type subst_template_param_type<S> = S;
pub type wctrans_t = u16;
extern "C" {
    pub fn towctrans(arg1: wint_t, arg2: wctrans_t) -> wint_t;
}
extern "C" {
    pub fn wctrans(arg1: *const ::std::os::raw::c_char) -> wctrans_t;
}
extern "C" {
    pub fn wctype(arg1: *const ::std::os::raw::c_char) -> wctype_t;
}
pub type _pid_t = ::std::os::raw::c_longlong;
pub type pid_t = _pid_t;
pub type _mode_t = ::std::os::raw::c_ushort;
pub type mode_t = _mode_t;
pub type useconds_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(::std::mem::size_of::<timespec>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timespec ) ));
    assert_eq! (::std::mem::align_of::<timespec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timespec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec ) ) . tv_sec as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec ) ) . tv_nsec as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec ) , "::" ,
                stringify ! ( tv_nsec ) ));
}
impl Clone for timespec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(::std::mem::size_of::<itimerspec>() , 32usize , concat ! (
               "Size of: " , stringify ! ( itimerspec ) ));
    assert_eq! (::std::mem::align_of::<itimerspec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( itimerspec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const itimerspec ) ) . it_interval as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( itimerspec ) , "::" ,
                stringify ! ( it_interval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const itimerspec ) ) . it_value as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( itimerspec ) , "::" ,
                stringify ! ( it_value ) ));
}
impl Clone for itimerspec {
    fn clone(&self) -> Self { *self }
}
pub type _sigset_t = ::std::os::raw::c_ulonglong;
extern "C" {
    pub fn octave_qsort(base: *mut ::std::os::raw::c_void, n: usize,
                        size: usize,
                        cmp:
                            ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                           *const ::std::os::raw::c_void,
                                                                       arg2:
                                                                           *const ::std::os::raw::c_void)
                                                      ->
                                                          ::std::os::raw::c_int>);
}
extern "C" {
    pub fn octave_strcasecmp(s1: *const ::std::os::raw::c_char,
                             s2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn octave_strncasecmp(s1: *const ::std::os::raw::c_char,
                              s2: *const ::std::os::raw::c_char, n: usize)
     -> ::std::os::raw::c_int;
}
pub type Complex = std_complex<f64>;
pub type FloatComplex = std_complex<f32>;
extern "C" {
    #[link_name = "?xis_int_or_inf_or_nan@@YA_NN@Z"]
    pub fn xis_int_or_inf_or_nan(x: f64) -> bool;
}
extern "C" {
    #[link_name = "?xis_one_or_zero@@YA_NN@Z"]
    pub fn xis_one_or_zero(x: f64) -> bool;
}
extern "C" {
    #[link_name = "?xis_zero@@YA_NN@Z"]
    pub fn xis_zero(x: f64) -> bool;
}
extern "C" {
    #[link_name = "?xtoo_large_for_float@@YA_NN@Z"]
    pub fn xtoo_large_for_float(x: f64) -> bool;
}
extern "C" {
    #[link_name = "?xtoo_large_for_float@@YA_NAEBU?$complex@N@std@@@Z"]
    pub fn xtoo_large_for_float1(x: *const Complex) -> bool;
}
extern "C" {
    #[link_name = "?xis_int_or_inf_or_nan@@YA_NM@Z"]
    pub fn xis_int_or_inf_or_nan1(x: f32) -> bool;
}
extern "C" {
    #[link_name = "?xis_one_or_zero@@YA_NM@Z"]
    pub fn xis_one_or_zero1(x: f32) -> bool;
}
extern "C" {
    #[link_name = "?xis_zero@@YA_NM@Z"]
    pub fn xis_zero1(x: f32) -> bool;
}
extern "C" {
    #[link_name = "?xtoo_large_for_float@@YA_NM@Z"]
    pub fn xtoo_large_for_float2(x: f32) -> bool;
}
extern "C" {
    #[link_name = "?strsave@@YAPEADPEBD@Z"]
    pub fn strsave(arg1: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name =
          "?octave_putenv@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z"]
    pub fn octave_putenv(arg1: *const std_string, arg2: *const std_string);
}
extern "C" {
    #[link_name =
          "?octave_fgets@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAU_iobuf@@@Z"]
    pub fn octave_fgets(arg1: *mut FILE) -> std_string;
}
extern "C" {
    #[link_name =
          "?octave_fgetl@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAU_iobuf@@@Z"]
    pub fn octave_fgetl(arg1: *mut FILE) -> std_string;
}
extern "C" {
    #[link_name =
          "?octave_fgets@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAU_iobuf@@AEA_N@Z"]
    pub fn octave_fgets1(arg1: *mut FILE, eof: *mut bool) -> std_string;
}
extern "C" {
    #[link_name =
          "?octave_fgetl@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAU_iobuf@@AEA_N@Z"]
    pub fn octave_fgetl1(arg1: *mut FILE, eof: *mut bool) -> std_string;
}
extern "C" {
    #[link_name =
          "??$octave_read_value@N@@YANAEAV?$basic_istream@DU?$char_traits@D@std@@@std@@@Z"]
    pub fn octave_read_value(is: *mut std_istream) -> f64;
}
extern "C" {
    #[link_name =
          "??$octave_read_value@U?$complex@N@std@@@@YA?AU?$complex@N@std@@AEAV?$basic_istream@DU?$char_traits@D@std@@@1@@Z"]
    pub fn octave_read_value1(is: *mut std_istream) -> Complex;
}
extern "C" {
    #[link_name =
          "??$octave_read_value@M@@YAMAEAV?$basic_istream@DU?$char_traits@D@std@@@std@@@Z"]
    pub fn octave_read_value2(is: *mut std_istream) -> f32;
}
extern "C" {
    #[link_name =
          "??$octave_read_value@U?$complex@M@std@@@@YA?AU?$complex@M@std@@AEAV?$basic_istream@DU?$char_traits@D@std@@@1@@Z"]
    pub fn octave_read_value3(is: *mut std_istream) -> FloatComplex;
}
extern "C" {
    #[link_name =
          "?octave_write_double@@YAXAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@N@Z"]
    pub fn octave_write_double(os: *mut std_ostream, dval: f64);
}
extern "C" {
    #[link_name =
          "?octave_write_complex@@YAXAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEBU?$complex@N@2@@Z"]
    pub fn octave_write_complex(os: *mut std_ostream, cval: *const Complex);
}
extern "C" {
    #[link_name =
          "?octave_write_float@@YAXAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@M@Z"]
    pub fn octave_write_float(os: *mut std_ostream, dval: f32);
}
extern "C" {
    #[link_name =
          "?octave_write_float_complex@@YAXAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEBU?$complex@M@2@@Z"]
    pub fn octave_write_float_complex(os: *mut std_ostream,
                                      cval: *const FloatComplex);
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sortmode { UNSORTED = 0, ASCENDING = 1, DESCENDING = 2, }
#[repr(C)]
#[derive(Debug)]
pub struct octave_sort<T> {
    pub compare: octave_sort_compare_fcn_type,
    pub ms: *mut octave_sort_MergeState<T>,
}
pub type octave_sort_compare_fcn_type =
    ::std::option::Option<unsafe extern "C" fn(arg1: ref_param,
                                               arg2: ref_param) -> bool>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct octave_sort_s_slice {
    pub base: octave_idx_type,
    pub len: octave_idx_type,
}
#[repr(C)]
pub struct octave_sort_MergeState<T> {
    pub min_gallop: octave_idx_type,
    pub a: *mut T,
    pub ia: *mut octave_idx_type,
    pub alloced: octave_idx_type,
    pub n: octave_idx_type,
    pub pending: [octave_sort_s_slice; 85usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vec_index<T> {
    pub vec: T,
    pub indx: octave_idx_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NoAlias<ArrayClass> {
    pub _base: ArrayClass,
}
pub type NoAlias_T = [u8; 0usize];
#[repr(C)]
#[derive(Debug)]
pub struct PermMatrix {
    pub _base: Array<::std::os::raw::c_int>,
}
#[test]
fn bindgen_test_layout_PermMatrix() {
    assert_eq!(::std::mem::size_of::<PermMatrix>() , 40usize , concat ! (
               "Size of: " , stringify ! ( PermMatrix ) ));
    assert_eq! (::std::mem::align_of::<PermMatrix>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( PermMatrix ) ));
}
extern "C" {
    #[link_name = "?checkelem@PermMatrix@@QEBAHHH@Z"]
    pub fn PermMatrix_checkelem(this: *const PermMatrix, i: octave_idx_type,
                                j: octave_idx_type) -> octave_idx_type;
}
extern "C" {
    #[link_name = "?transpose@PermMatrix@@QEBA?AV1@XZ"]
    pub fn PermMatrix_transpose(this: *const PermMatrix) -> PermMatrix;
}
extern "C" {
    #[link_name = "?inverse@PermMatrix@@QEBA?AV1@XZ"]
    pub fn PermMatrix_inverse(this: *const PermMatrix) -> PermMatrix;
}
extern "C" {
    #[link_name = "?determinant@PermMatrix@@QEBAHXZ"]
    pub fn PermMatrix_determinant(this: *const PermMatrix) -> octave_idx_type;
}
extern "C" {
    #[link_name = "?power@PermMatrix@@QEBA?AV1@H@Z"]
    pub fn PermMatrix_power(this: *const PermMatrix, n: octave_idx_type)
     -> PermMatrix;
}
extern "C" {
    #[link_name = "?eye@PermMatrix@@SA?AV1@H@Z"]
    pub fn PermMatrix_eye(n: octave_idx_type) -> PermMatrix;
}
extern "C" {
    #[link_name = "??0PermMatrix@@QEAA@H@Z"]
    pub fn PermMatrix_PermMatrix(this: *mut PermMatrix, n: octave_idx_type);
}
extern "C" {
    #[link_name = "??0PermMatrix@@QEAA@AEBV?$Array@H@@@Z"]
    pub fn PermMatrix_PermMatrix1(this: *mut PermMatrix,
                                  p: *const Array<::std::os::raw::c_int>);
}
extern "C" {
    #[link_name = "??0PermMatrix@@QEAA@AEBV?$Array@H@@_N1@Z"]
    pub fn PermMatrix_PermMatrix2(this: *mut PermMatrix,
                                  p: *const Array<::std::os::raw::c_int>,
                                  colp: bool, check: bool);
}
extern "C" {
    #[link_name = "??0PermMatrix@@QEAA@AEBVidx_vector@@@Z"]
    pub fn PermMatrix_PermMatrix3(this: *mut PermMatrix,
                                  idx: *const idx_vector);
}
extern "C" {
    #[link_name = "??0PermMatrix@@QEAA@AEBVidx_vector@@_NH@Z"]
    pub fn PermMatrix_PermMatrix4(this: *mut PermMatrix,
                                  idx: *const idx_vector, colp: bool,
                                  n: octave_idx_type);
}
impl PermMatrix {
    #[inline]
    pub unsafe fn checkelem(&self, i: octave_idx_type, j: octave_idx_type)
     -> octave_idx_type {
        PermMatrix_checkelem(self, i, j)
    }
    #[inline]
    pub unsafe fn transpose(&self) -> PermMatrix {
        PermMatrix_transpose(self)
    }
    #[inline]
    pub unsafe fn inverse(&self) -> PermMatrix { PermMatrix_inverse(self) }
    #[inline]
    pub unsafe fn determinant(&self) -> octave_idx_type {
        PermMatrix_determinant(self)
    }
    #[inline]
    pub unsafe fn power(&self, n: octave_idx_type) -> PermMatrix {
        PermMatrix_power(self, n)
    }
    #[inline]
    pub unsafe fn eye(n: octave_idx_type) -> PermMatrix { PermMatrix_eye(n) }
    #[inline]
    pub unsafe fn new(n: octave_idx_type) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        PermMatrix_PermMatrix(&mut __bindgen_tmp, n);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(p: *const Array<::std::os::raw::c_int>) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        PermMatrix_PermMatrix1(&mut __bindgen_tmp, p);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new2(p: *const Array<::std::os::raw::c_int>, colp: bool,
                       check: bool) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        PermMatrix_PermMatrix2(&mut __bindgen_tmp, p, colp, check);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new3(idx: *const idx_vector) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        PermMatrix_PermMatrix3(&mut __bindgen_tmp, idx);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new4(idx: *const idx_vector, colp: bool, n: octave_idx_type)
     -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        PermMatrix_PermMatrix4(&mut __bindgen_tmp, idx, colp, n);
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct octave_local_buffer<T> {
    pub data: *mut T,
}
#[repr(C)]
pub struct octave_chunk_buffer__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct octave_chunk_buffer {
    pub vtable_: *const octave_chunk_buffer__bindgen_vtable,
    pub cnk: *mut ::std::os::raw::c_char,
    pub dat: *mut ::std::os::raw::c_char,
}
extern "C" {
    #[link_name = "?chunk_size@octave_chunk_buffer@@0_KB"]
    pub static octave_chunk_buffer_chunk_size: usize;
}
extern "C" {
    #[link_name = "?top@octave_chunk_buffer@@0PEADEA"]
    pub static mut octave_chunk_buffer_top: *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "?chunk@octave_chunk_buffer@@0PEADEA"]
    pub static mut octave_chunk_buffer_chunk: *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "?left@octave_chunk_buffer@@0_KA"]
    pub static mut octave_chunk_buffer_left: usize;
}
extern "C" {
    #[link_name = "?active@octave_chunk_buffer@@0_KA"]
    pub static mut octave_chunk_buffer_active: usize;
}
#[test]
fn bindgen_test_layout_octave_chunk_buffer() {
    assert_eq!(::std::mem::size_of::<octave_chunk_buffer>() , 24usize , concat
               ! ( "Size of: " , stringify ! ( octave_chunk_buffer ) ));
    assert_eq! (::std::mem::align_of::<octave_chunk_buffer>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( octave_chunk_buffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_chunk_buffer ) ) . cnk as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_chunk_buffer ) ,
                "::" , stringify ! ( cnk ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_chunk_buffer ) ) . dat as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_chunk_buffer ) ,
                "::" , stringify ! ( dat ) ));
}
extern "C" {
    #[link_name = "?clear@octave_chunk_buffer@@SAXXZ"]
    pub fn octave_chunk_buffer_clear();
}
extern "C" {
    #[link_name = "??0octave_chunk_buffer@@QEAA@_K@Z"]
    pub fn octave_chunk_buffer_octave_chunk_buffer(this:
                                                       *mut octave_chunk_buffer,
                                                   size: usize);
}
impl octave_chunk_buffer {
    #[inline]
    pub unsafe fn clear() { octave_chunk_buffer_clear() }
    #[inline]
    pub unsafe fn new(size: usize) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_chunk_buffer_octave_chunk_buffer(&mut __bindgen_tmp, size);
        __bindgen_tmp
    }
}
#[test]
fn __bindgen_test_layout_octave_local_buffer_instantiation_20235() {
    assert_eq!(::std::mem::size_of::<octave_local_buffer<bool>>() , 24usize ,
               concat ! (
               "Size of template specialization: " , stringify ! (
               octave_local_buffer<bool> ) ));
    assert_eq!(::std::mem::align_of::<octave_local_buffer<bool>>() , 8usize ,
               concat ! (
               "Alignment of template specialization: " , stringify ! (
               octave_local_buffer<bool> ) ));
}
#[test]
fn __bindgen_test_layout_octave_local_buffer_instantiation_20239() {
    assert_eq!(::std::mem::size_of::<octave_local_buffer<::std::os::raw::c_char>>()
               , 24usize , concat ! (
               "Size of template specialization: " , stringify ! (
               octave_local_buffer<::std::os::raw::c_char> ) ));
    assert_eq!(::std::mem::align_of::<octave_local_buffer<::std::os::raw::c_char>>()
               , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               octave_local_buffer<::std::os::raw::c_char> ) ));
}
#[test]
fn __bindgen_test_layout_octave_local_buffer_instantiation_20243() {
    assert_eq!(::std::mem::size_of::<octave_local_buffer<::std::os::raw::c_ushort>>()
               , 24usize , concat ! (
               "Size of template specialization: " , stringify ! (
               octave_local_buffer<::std::os::raw::c_ushort> ) ));
    assert_eq!(::std::mem::align_of::<octave_local_buffer<::std::os::raw::c_ushort>>()
               , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               octave_local_buffer<::std::os::raw::c_ushort> ) ));
}
#[test]
fn __bindgen_test_layout_octave_local_buffer_instantiation_20247() {
    assert_eq!(::std::mem::size_of::<octave_local_buffer<::std::os::raw::c_short>>()
               , 24usize , concat ! (
               "Size of template specialization: " , stringify ! (
               octave_local_buffer<::std::os::raw::c_short> ) ));
    assert_eq!(::std::mem::align_of::<octave_local_buffer<::std::os::raw::c_short>>()
               , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               octave_local_buffer<::std::os::raw::c_short> ) ));
}
#[test]
fn __bindgen_test_layout_octave_local_buffer_instantiation_20251() {
    assert_eq!(::std::mem::size_of::<octave_local_buffer<::std::os::raw::c_int>>()
               , 24usize , concat ! (
               "Size of template specialization: " , stringify ! (
               octave_local_buffer<::std::os::raw::c_int> ) ));
    assert_eq!(::std::mem::align_of::<octave_local_buffer<::std::os::raw::c_int>>()
               , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               octave_local_buffer<::std::os::raw::c_int> ) ));
}
#[test]
fn __bindgen_test_layout_octave_local_buffer_instantiation_20255() {
    assert_eq!(::std::mem::size_of::<octave_local_buffer<::std::os::raw::c_uint>>()
               , 24usize , concat ! (
               "Size of template specialization: " , stringify ! (
               octave_local_buffer<::std::os::raw::c_uint> ) ));
    assert_eq!(::std::mem::align_of::<octave_local_buffer<::std::os::raw::c_uint>>()
               , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               octave_local_buffer<::std::os::raw::c_uint> ) ));
}
#[test]
fn __bindgen_test_layout_octave_local_buffer_instantiation_20259() {
    assert_eq!(::std::mem::size_of::<octave_local_buffer<::std::os::raw::c_long>>()
               , 24usize , concat ! (
               "Size of template specialization: " , stringify ! (
               octave_local_buffer<::std::os::raw::c_long> ) ));
    assert_eq!(::std::mem::align_of::<octave_local_buffer<::std::os::raw::c_long>>()
               , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               octave_local_buffer<::std::os::raw::c_long> ) ));
}
#[test]
fn __bindgen_test_layout_octave_local_buffer_instantiation_20263() {
    assert_eq!(::std::mem::size_of::<octave_local_buffer<::std::os::raw::c_ulong>>()
               , 24usize , concat ! (
               "Size of template specialization: " , stringify ! (
               octave_local_buffer<::std::os::raw::c_ulong> ) ));
    assert_eq!(::std::mem::align_of::<octave_local_buffer<::std::os::raw::c_ulong>>()
               , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               octave_local_buffer<::std::os::raw::c_ulong> ) ));
}
#[test]
fn __bindgen_test_layout_octave_local_buffer_instantiation_20267() {
    assert_eq!(::std::mem::size_of::<octave_local_buffer<f32>>() , 24usize ,
               concat ! (
               "Size of template specialization: " , stringify ! (
               octave_local_buffer<f32> ) ));
    assert_eq!(::std::mem::align_of::<octave_local_buffer<f32>>() , 8usize ,
               concat ! (
               "Alignment of template specialization: " , stringify ! (
               octave_local_buffer<f32> ) ));
}
#[test]
fn __bindgen_test_layout_octave_local_buffer_instantiation_20271() {
    assert_eq!(::std::mem::size_of::<octave_local_buffer<f64>>() , 24usize ,
               concat ! (
               "Size of template specialization: " , stringify ! (
               octave_local_buffer<f64> ) ));
    assert_eq!(::std::mem::align_of::<octave_local_buffer<f64>>() , 8usize ,
               concat ! (
               "Alignment of template specialization: " , stringify ! (
               octave_local_buffer<f64> ) ));
}
#[test]
fn __bindgen_test_layout_octave_local_buffer_instantiation_20275() {
    assert_eq!(::std::mem::size_of::<octave_local_buffer<std_complex<f64>>>()
               , 24usize , concat ! (
               "Size of template specialization: " , stringify ! (
               octave_local_buffer<std_complex<f64>> ) ));
    assert_eq!(::std::mem::align_of::<octave_local_buffer<std_complex<f64>>>()
               , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               octave_local_buffer<std_complex<f64>> ) ));
}
#[test]
fn __bindgen_test_layout_octave_local_buffer_instantiation_20278() {
    assert_eq!(::std::mem::size_of::<octave_local_buffer<std_complex<f32>>>()
               , 24usize , concat ! (
               "Size of template specialization: " , stringify ! (
               octave_local_buffer<std_complex<f32>> ) ));
    assert_eq!(::std::mem::align_of::<octave_local_buffer<std_complex<f32>>>()
               , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               octave_local_buffer<std_complex<f32>> ) ));
}
#[repr(C)]
#[derive(Copy)]
pub union lo_ieee_double {
    pub value: f64,
    pub word: [::std::os::raw::c_uint; 2usize],
}
#[test]
fn bindgen_test_layout_lo_ieee_double() {
    assert_eq!(::std::mem::size_of::<lo_ieee_double>() , 8usize , concat ! (
               "Size of: " , stringify ! ( lo_ieee_double ) ));
    assert_eq! (::std::mem::align_of::<lo_ieee_double>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lo_ieee_double ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lo_ieee_double ) ) . value as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lo_ieee_double ) , "::"
                , stringify ! ( value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lo_ieee_double ) ) . word as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lo_ieee_double ) , "::"
                , stringify ! ( word ) ));
}
impl Clone for lo_ieee_double {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union lo_ieee_float {
    pub value: f32,
    pub word: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_lo_ieee_float() {
    assert_eq!(::std::mem::size_of::<lo_ieee_float>() , 4usize , concat ! (
               "Size of: " , stringify ! ( lo_ieee_float ) ));
    assert_eq! (::std::mem::align_of::<lo_ieee_float>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( lo_ieee_float ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lo_ieee_float ) ) . value as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lo_ieee_float ) , "::"
                , stringify ! ( value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lo_ieee_float ) ) . word as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lo_ieee_float ) , "::"
                , stringify ! ( word ) ));
}
impl Clone for lo_ieee_float {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn octave_ieee_init();
}
extern "C" {
    pub fn __lo_ieee_isnan(x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __lo_ieee_finite(x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __lo_ieee_isinf(x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __lo_ieee_is_NA(arg1: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __lo_ieee_is_old_NA(arg1: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __lo_ieee_replace_old_NA(arg1: f64) -> f64;
}
extern "C" {
    pub fn lo_ieee_inf_value() -> f64;
}
extern "C" {
    pub fn lo_ieee_na_value() -> f64;
}
extern "C" {
    pub fn lo_ieee_nan_value() -> f64;
}
extern "C" {
    pub fn __lo_ieee_signbit(arg1: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __lo_ieee_float_isnan(x: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __lo_ieee_float_finite(x: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __lo_ieee_float_isinf(x: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __lo_ieee_float_is_NA(arg1: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lo_ieee_float_inf_value() -> f32;
}
extern "C" {
    pub fn lo_ieee_float_na_value() -> f32;
}
extern "C" {
    pub fn lo_ieee_float_nan_value() -> f32;
}
extern "C" {
    pub fn __lo_ieee_float_signbit(arg1: f32) -> ::std::os::raw::c_int;
}
#[test]
fn __bindgen_test_layout_query_integer_type_instantiation_21409() {
    assert_eq!(::std::mem::size_of::<u8>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! ( u8 ) ));
    assert_eq!(::std::mem::align_of::<u8>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! ( u8 )
               ));
}
#[test]
fn __bindgen_test_layout_query_integer_type_instantiation_21411() {
    assert_eq!(::std::mem::size_of::<u8>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! ( u8 ) ));
    assert_eq!(::std::mem::align_of::<u8>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! ( u8 )
               ));
}
#[test]
fn __bindgen_test_layout_query_integer_type_instantiation_21413() {
    assert_eq!(::std::mem::size_of::<u8>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! ( u8 ) ));
    assert_eq!(::std::mem::align_of::<u8>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! ( u8 )
               ));
}
#[test]
fn __bindgen_test_layout_query_integer_type_instantiation_21415() {
    assert_eq!(::std::mem::size_of::<u8>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! ( u8 ) ));
    assert_eq!(::std::mem::align_of::<u8>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! ( u8 )
               ));
}
#[test]
fn __bindgen_test_layout_query_integer_type_instantiation_21417() {
    assert_eq!(::std::mem::size_of::<u8>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! ( u8 ) ));
    assert_eq!(::std::mem::align_of::<u8>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! ( u8 )
               ));
}
#[test]
fn __bindgen_test_layout_query_integer_type_instantiation_21419() {
    assert_eq!(::std::mem::size_of::<u8>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! ( u8 ) ));
    assert_eq!(::std::mem::align_of::<u8>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! ( u8 )
               ));
}
#[test]
fn __bindgen_test_layout_query_integer_type_instantiation_21421() {
    assert_eq!(::std::mem::size_of::<u8>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! ( u8 ) ));
    assert_eq!(::std::mem::align_of::<u8>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! ( u8 )
               ));
}
#[test]
fn __bindgen_test_layout_query_integer_type_instantiation_21423() {
    assert_eq!(::std::mem::size_of::<u8>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! ( u8 ) ));
    assert_eq!(::std::mem::align_of::<u8>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! ( u8 )
               ));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct octave_int_cmp_op {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct octave_int_cmp_op_prom {
    pub _address: u8,
}
pub type octave_int_cmp_op_prom_type = u8;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct octave_int_cmp_op_lt {
    pub _address: u8,
}
pub const octave_int_cmp_op_lt_ltval: bool = true;
pub const octave_int_cmp_op_lt_gtval: bool = false;
#[test]
fn bindgen_test_layout_octave_int_cmp_op_lt() {
    assert_eq!(::std::mem::size_of::<octave_int_cmp_op_lt>() , 1usize , concat
               ! ( "Size of: " , stringify ! ( octave_int_cmp_op_lt ) ));
    assert_eq! (::std::mem::align_of::<octave_int_cmp_op_lt>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( octave_int_cmp_op_lt ) ));
}
impl Clone for octave_int_cmp_op_lt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct octave_int_cmp_op_le {
    pub _address: u8,
}
pub const octave_int_cmp_op_le_ltval: bool = true;
pub const octave_int_cmp_op_le_gtval: bool = false;
#[test]
fn bindgen_test_layout_octave_int_cmp_op_le() {
    assert_eq!(::std::mem::size_of::<octave_int_cmp_op_le>() , 1usize , concat
               ! ( "Size of: " , stringify ! ( octave_int_cmp_op_le ) ));
    assert_eq! (::std::mem::align_of::<octave_int_cmp_op_le>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( octave_int_cmp_op_le ) ));
}
impl Clone for octave_int_cmp_op_le {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct octave_int_cmp_op_gt {
    pub _address: u8,
}
pub const octave_int_cmp_op_gt_ltval: bool = false;
pub const octave_int_cmp_op_gt_gtval: bool = true;
#[test]
fn bindgen_test_layout_octave_int_cmp_op_gt() {
    assert_eq!(::std::mem::size_of::<octave_int_cmp_op_gt>() , 1usize , concat
               ! ( "Size of: " , stringify ! ( octave_int_cmp_op_gt ) ));
    assert_eq! (::std::mem::align_of::<octave_int_cmp_op_gt>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( octave_int_cmp_op_gt ) ));
}
impl Clone for octave_int_cmp_op_gt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct octave_int_cmp_op_ge {
    pub _address: u8,
}
pub const octave_int_cmp_op_ge_ltval: bool = false;
pub const octave_int_cmp_op_ge_gtval: bool = true;
#[test]
fn bindgen_test_layout_octave_int_cmp_op_ge() {
    assert_eq!(::std::mem::size_of::<octave_int_cmp_op_ge>() , 1usize , concat
               ! ( "Size of: " , stringify ! ( octave_int_cmp_op_ge ) ));
    assert_eq! (::std::mem::align_of::<octave_int_cmp_op_ge>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( octave_int_cmp_op_ge ) ));
}
impl Clone for octave_int_cmp_op_ge {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct octave_int_cmp_op_eq {
    pub _address: u8,
}
pub const octave_int_cmp_op_eq_ltval: bool = false;
pub const octave_int_cmp_op_eq_gtval: bool = false;
#[test]
fn bindgen_test_layout_octave_int_cmp_op_eq() {
    assert_eq!(::std::mem::size_of::<octave_int_cmp_op_eq>() , 1usize , concat
               ! ( "Size of: " , stringify ! ( octave_int_cmp_op_eq ) ));
    assert_eq! (::std::mem::align_of::<octave_int_cmp_op_eq>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( octave_int_cmp_op_eq ) ));
}
impl Clone for octave_int_cmp_op_eq {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct octave_int_cmp_op_ne {
    pub _address: u8,
}
pub const octave_int_cmp_op_ne_ltval: bool = true;
pub const octave_int_cmp_op_ne_gtval: bool = true;
#[test]
fn bindgen_test_layout_octave_int_cmp_op_ne() {
    assert_eq!(::std::mem::size_of::<octave_int_cmp_op_ne>() , 1usize , concat
               ! ( "Size of: " , stringify ! ( octave_int_cmp_op_ne ) ));
    assert_eq! (::std::mem::align_of::<octave_int_cmp_op_ne>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( octave_int_cmp_op_ne ) ));
}
impl Clone for octave_int_cmp_op_ne {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct octave_int_cmp_op_ct {
    pub _address: u8,
}
pub const octave_int_cmp_op_ct_ltval: bool = true;
pub const octave_int_cmp_op_ct_gtval: bool = true;
#[test]
fn bindgen_test_layout_octave_int_cmp_op_ct() {
    assert_eq!(::std::mem::size_of::<octave_int_cmp_op_ct>() , 1usize , concat
               ! ( "Size of: " , stringify ! ( octave_int_cmp_op_ct ) ));
    assert_eq! (::std::mem::align_of::<octave_int_cmp_op_ct>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( octave_int_cmp_op_ct ) ));
}
impl Clone for octave_int_cmp_op_ct {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct octave_int_cmp_op_cf {
    pub _address: u8,
}
pub const octave_int_cmp_op_cf_ltval: bool = false;
pub const octave_int_cmp_op_cf_gtval: bool = false;
#[test]
fn bindgen_test_layout_octave_int_cmp_op_cf() {
    assert_eq!(::std::mem::size_of::<octave_int_cmp_op_cf>() , 1usize , concat
               ! ( "Size of: " , stringify ! ( octave_int_cmp_op_cf ) ));
    assert_eq! (::std::mem::align_of::<octave_int_cmp_op_cf>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( octave_int_cmp_op_cf ) ));
}
impl Clone for octave_int_cmp_op_cf {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_octave_int_cmp_op() {
    assert_eq!(::std::mem::size_of::<octave_int_cmp_op>() , 1usize , concat !
               ( "Size of: " , stringify ! ( octave_int_cmp_op ) ));
    assert_eq! (::std::mem::align_of::<octave_int_cmp_op>() , 1usize , concat
                ! ( "Alignment of " , stringify ! ( octave_int_cmp_op ) ));
}
impl Clone for octave_int_cmp_op {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct octave_int_base {
    pub _address: u8,
}
#[repr(C)]
pub struct octave_int_arith {
    pub _address: u8,
}
extern "C" {
    #[link_name = "?index_in_bounds@@YA_NAEBV?$Array@H@@AEBVdim_vector@@@Z"]
    pub fn index_in_bounds(ra_idx: *const Array<::std::os::raw::c_int>,
                           dimensions: *const dim_vector) -> bool;
}
extern "C" {
    #[link_name = "?increment_index@@YAXAEAV?$Array@H@@AEBVdim_vector@@H@Z"]
    pub fn increment_index(ra_idx: *mut Array<::std::os::raw::c_int>,
                           dimensions: *const dim_vector,
                           start_dimension: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "?get_scalar_idx@@YAHAEAV?$Array@H@@AEAVdim_vector@@@Z"]
    pub fn get_scalar_idx(idx: *mut Array<::std::os::raw::c_int>,
                          dims: *mut dim_vector) -> octave_idx_type;
}
extern "C" {
    #[link_name = "?num_ones@@YAHAEBV?$Array@H@@@Z"]
    pub fn num_ones(ra_idx: *const Array<::std::os::raw::c_int>)
     -> octave_idx_type;
}
extern "C" {
    #[link_name = "?is_scalar@@YA_NAEBVdim_vector@@@Z"]
    pub fn is_scalar(dim: *const dim_vector) -> bool;
}
extern "C" {
    #[link_name = "?is_vector@@YA_NAEBVdim_vector@@@Z"]
    pub fn is_vector(dim: *const dim_vector) -> bool;
}
extern "C" {
    #[link_name = "?any_ones@@YA_NAEBV?$Array@H@@@Z"]
    pub fn any_ones(arr: *const Array<::std::os::raw::c_int>) -> bool;
}
extern "C" {
    #[link_name = "?compute_index@@YAHHAEBVdim_vector@@@Z"]
    pub fn compute_index(n: octave_idx_type, dims: *const dim_vector)
     -> octave_idx_type;
}
extern "C" {
    #[link_name = "?compute_index@@YAHHHAEBVdim_vector@@@Z"]
    pub fn compute_index1(i: octave_idx_type, j: octave_idx_type,
                          dims: *const dim_vector) -> octave_idx_type;
}
extern "C" {
    #[link_name = "?compute_index@@YAHHHHAEBVdim_vector@@@Z"]
    pub fn compute_index2(i: octave_idx_type, j: octave_idx_type,
                          k: octave_idx_type, dims: *const dim_vector)
     -> octave_idx_type;
}
extern "C" {
    #[link_name = "?compute_index@@YAHAEBV?$Array@H@@AEBVdim_vector@@@Z"]
    pub fn compute_index3(ra_idx: *const Array<::std::os::raw::c_int>,
                          dims: *const dim_vector) -> octave_idx_type;
}
extern "C" {
    #[link_name =
          "?conv_to_int_array@@YA?AV?$Array@H@@AEBV?$Array@Vidx_vector@@@@@Z"]
    pub fn conv_to_int_array(a: *const Array<idx_vector>)
     -> Array<::std::os::raw::c_int>;
}
extern "C" {
    #[link_name =
          "?conv_to_array@@YA?AV?$Array@Vidx_vector@@@@PEBVidx_vector@@H@Z"]
    pub fn conv_to_array(tmp: *const idx_vector, len: octave_idx_type)
     -> Array<idx_vector>;
}
extern "C" {
    #[link_name =
          "?freeze@@YA?AVdim_vector@@AEAV?$Array@Vidx_vector@@@@AEBV1@H@Z"]
    pub fn freeze(ra_idx: *mut Array<idx_vector>,
                  dimensions: *const dim_vector,
                  resize_ok: ::std::os::raw::c_int) -> dim_vector;
}
extern "C" {
    #[link_name = "?vector_equivalent@@YA_NAEBVdim_vector@@@Z"]
    pub fn vector_equivalent(dv: *const dim_vector) -> bool;
}
extern "C" {
    #[link_name = "?all_ok@@YA_NAEBV?$Array@Vidx_vector@@@@@Z"]
    pub fn all_ok(ra_idx: *const Array<idx_vector>) -> bool;
}
extern "C" {
    #[link_name = "?any_orig_empty@@YA_NAEBV?$Array@Vidx_vector@@@@@Z"]
    pub fn any_orig_empty(ra_idx: *const Array<idx_vector>) -> bool;
}
extern "C" {
    #[link_name =
          "?all_colon_equiv@@YA_NAEBV?$Array@Vidx_vector@@@@AEBVdim_vector@@@Z"]
    pub fn all_colon_equiv(ra_idx: *const Array<idx_vector>,
                           frozen_lengths: *const dim_vector) -> bool;
}
extern "C" {
    #[link_name = "?all_ones@@YA_NAEBV?$Array@H@@@Z"]
    pub fn all_ones(arr: *const Array<::std::os::raw::c_int>) -> bool;
}
extern "C" {
    #[link_name =
          "?get_elt_idx@@YA?AV?$Array@H@@AEBV?$Array@Vidx_vector@@@@AEBV1@@Z"]
    pub fn get_elt_idx(ra_idx: *const Array<idx_vector>,
                       result_idx: *const Array<::std::os::raw::c_int>)
     -> Array<::std::os::raw::c_int>;
}
extern "C" {
    #[link_name = "?get_ra_idx@@YA?AV?$Array@H@@HAEBVdim_vector@@@Z"]
    pub fn get_ra_idx(idx: octave_idx_type, dims: *const dim_vector)
     -> Array<::std::os::raw::c_int>;
}
extern "C" {
    #[link_name =
          "?zero_dims_inquire@@YA?AVdim_vector@@AEBV?$Array@Vidx_vector@@@@AEBV1@@Z"]
    pub fn zero_dims_inquire(ia: *const Array<idx_vector>,
                             rhdv: *const dim_vector) -> dim_vector;
}
extern "C" {
    #[link_name =
          "?zero_dims_inquire@@YA?AVdim_vector@@AEBVidx_vector@@0AEBV1@@Z"]
    pub fn zero_dims_inquire1(i: *const idx_vector, j: *const idx_vector,
                              rhdv: *const dim_vector) -> dim_vector;
}
extern "C" {
    #[link_name =
          "?sub2ind@@YA?AVidx_vector@@AEBVdim_vector@@AEBV?$Array@Vidx_vector@@@@@Z"]
    pub fn sub2ind(dv: *const dim_vector, idxa: *const Array<idx_vector>)
     -> idx_vector;
}
extern "C" {
    #[link_name =
          "?ind2sub@@YA?AV?$Array@Vidx_vector@@@@AEBVdim_vector@@AEBVidx_vector@@@Z"]
    pub fn ind2sub(dv: *const dim_vector, idx: *const idx_vector)
     -> Array<idx_vector>;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct permute_vector {
    pub pidx: octave_idx_type,
    pub iidx: octave_idx_type,
}
#[test]
fn bindgen_test_layout_permute_vector() {
    assert_eq!(::std::mem::size_of::<permute_vector>() , 8usize , concat ! (
               "Size of: " , stringify ! ( permute_vector ) ));
    assert_eq! (::std::mem::align_of::<permute_vector>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( permute_vector ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const permute_vector ) ) . pidx as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( permute_vector ) , "::"
                , stringify ! ( pidx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const permute_vector ) ) . iidx as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( permute_vector ) , "::"
                , stringify ! ( iidx ) ));
}
impl Clone for permute_vector {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "?permute_vector_compare@@YAHPEBX0@Z"]
    pub fn permute_vector_compare(a: *const ::std::os::raw::c_void,
                                  b: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug)]
pub struct MArray<T> {
    pub _base: Array<T>,
}
#[repr(C)]
#[derive(Debug)]
pub struct MSparse<T> {
    pub _base: Sparse<T>,
}
#[repr(C)]
#[derive(Debug)]
pub struct Matrix {
    pub _base: NDArray,
}
pub type Matrix_column_vector_type = ColumnVector;
pub type Matrix_row_vector_type = RowVector;
pub type Matrix_real_column_vector_type = ColumnVector;
pub type Matrix_real_row_vector_type = RowVector;
pub type Matrix_real_matrix_type = Matrix;
pub type Matrix_complex_matrix_type = ComplexMatrix;
pub type Matrix_real_diag_matrix_type = DiagMatrix;
pub type Matrix_complex_diag_matrix_type = ComplexDiagMatrix;
pub type Matrix_real_elt_type = f64;
pub type Matrix_complex_elt_type = Complex;
pub type Matrix_solve_singularity_handler =
    ::std::option::Option<unsafe extern "C" fn(rcon: f64)>;
#[test]
fn bindgen_test_layout_Matrix() {
    assert_eq!(::std::mem::size_of::<Matrix>() , 40usize , concat ! (
               "Size of: " , stringify ! ( Matrix ) ));
    assert_eq! (::std::mem::align_of::<Matrix>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( Matrix ) ));
}
extern "C" {
    #[link_name = "?is_symmetric@Matrix@@QEBA_NXZ"]
    pub fn Matrix_is_symmetric(this: *const Matrix) -> bool;
}
extern "C" {
    #[link_name = "?insert@Matrix@@QEAAAEAV1@AEBV1@HH@Z"]
    pub fn Matrix_insert(this: *mut Matrix, a: *const Matrix,
                         r: octave_idx_type, c: octave_idx_type)
     -> *mut Matrix;
}
extern "C" {
    #[link_name = "?insert@Matrix@@QEAAAEAV1@AEBVRowVector@@HH@Z"]
    pub fn Matrix_insert1(this: *mut Matrix, a: *const RowVector,
                          r: octave_idx_type, c: octave_idx_type)
     -> *mut Matrix;
}
extern "C" {
    #[link_name = "?insert@Matrix@@QEAAAEAV1@AEBVColumnVector@@HH@Z"]
    pub fn Matrix_insert2(this: *mut Matrix, a: *const ColumnVector,
                          r: octave_idx_type, c: octave_idx_type)
     -> *mut Matrix;
}
extern "C" {
    #[link_name = "?insert@Matrix@@QEAAAEAV1@AEBVDiagMatrix@@HH@Z"]
    pub fn Matrix_insert3(this: *mut Matrix, a: *const DiagMatrix,
                          r: octave_idx_type, c: octave_idx_type)
     -> *mut Matrix;
}
extern "C" {
    #[link_name = "?fill@Matrix@@QEAAAEAV1@N@Z"]
    pub fn Matrix_fill(this: *mut Matrix, val: f64) -> *mut Matrix;
}
extern "C" {
    #[link_name = "?fill@Matrix@@QEAAAEAV1@NHHHH@Z"]
    pub fn Matrix_fill1(this: *mut Matrix, val: f64, r1: octave_idx_type,
                        c1: octave_idx_type, r2: octave_idx_type,
                        c2: octave_idx_type) -> *mut Matrix;
}
extern "C" {
    #[link_name = "?append@Matrix@@QEBA?AV1@AEBV1@@Z"]
    pub fn Matrix_append(this: *const Matrix, a: *const Matrix) -> Matrix;
}
extern "C" {
    #[link_name = "?append@Matrix@@QEBA?AV1@AEBVRowVector@@@Z"]
    pub fn Matrix_append1(this: *const Matrix, a: *const RowVector) -> Matrix;
}
extern "C" {
    #[link_name = "?append@Matrix@@QEBA?AV1@AEBVColumnVector@@@Z"]
    pub fn Matrix_append2(this: *const Matrix, a: *const ColumnVector)
     -> Matrix;
}
extern "C" {
    #[link_name = "?append@Matrix@@QEBA?AV1@AEBVDiagMatrix@@@Z"]
    pub fn Matrix_append3(this: *const Matrix, a: *const DiagMatrix)
     -> Matrix;
}
extern "C" {
    #[link_name = "?stack@Matrix@@QEBA?AV1@AEBV1@@Z"]
    pub fn Matrix_stack(this: *const Matrix, a: *const Matrix) -> Matrix;
}
extern "C" {
    #[link_name = "?stack@Matrix@@QEBA?AV1@AEBVRowVector@@@Z"]
    pub fn Matrix_stack1(this: *const Matrix, a: *const RowVector) -> Matrix;
}
extern "C" {
    #[link_name = "?stack@Matrix@@QEBA?AV1@AEBVColumnVector@@@Z"]
    pub fn Matrix_stack2(this: *const Matrix, a: *const ColumnVector)
     -> Matrix;
}
extern "C" {
    #[link_name = "?stack@Matrix@@QEBA?AV1@AEBVDiagMatrix@@@Z"]
    pub fn Matrix_stack3(this: *const Matrix, a: *const DiagMatrix) -> Matrix;
}
extern "C" {
    #[link_name = "?extract@Matrix@@QEBA?AV1@HHHH@Z"]
    pub fn Matrix_extract(this: *const Matrix, r1: octave_idx_type,
                          c1: octave_idx_type, r2: octave_idx_type,
                          c2: octave_idx_type) -> Matrix;
}
extern "C" {
    #[link_name = "?extract_n@Matrix@@QEBA?AV1@HHHH@Z"]
    pub fn Matrix_extract_n(this: *const Matrix, r1: octave_idx_type,
                            c1: octave_idx_type, nr: octave_idx_type,
                            nc: octave_idx_type) -> Matrix;
}
extern "C" {
    #[link_name = "?row@Matrix@@QEBA?AVRowVector@@H@Z"]
    pub fn Matrix_row(this: *const Matrix, i: octave_idx_type) -> RowVector;
}
extern "C" {
    #[link_name = "?column@Matrix@@QEBA?AVColumnVector@@H@Z"]
    pub fn Matrix_column(this: *const Matrix, i: octave_idx_type)
     -> ColumnVector;
}
extern "C" {
    #[link_name = "?inverse@Matrix@@QEBA?AV1@XZ"]
    pub fn Matrix_inverse(this: *const Matrix) -> Matrix;
}
extern "C" {
    #[link_name = "?inverse@Matrix@@QEBA?AV1@AEAH@Z"]
    pub fn Matrix_inverse1(this: *const Matrix, info: *mut octave_idx_type)
     -> Matrix;
}
extern "C" {
    #[link_name = "?inverse@Matrix@@QEBA?AV1@AEAHAEAN_N2@Z"]
    pub fn Matrix_inverse2(this: *const Matrix, info: *mut octave_idx_type,
                           rcon: *mut f64, force: bool, calc_cond: bool)
     -> Matrix;
}
extern "C" {
    #[link_name = "?inverse@Matrix@@QEBA?AV1@AEAVMatrixType@@@Z"]
    pub fn Matrix_inverse3(this: *const Matrix, mattype: *mut MatrixType)
     -> Matrix;
}
extern "C" {
    #[link_name = "?inverse@Matrix@@QEBA?AV1@AEAVMatrixType@@AEAH@Z"]
    pub fn Matrix_inverse4(this: *const Matrix, mattype: *mut MatrixType,
                           info: *mut octave_idx_type) -> Matrix;
}
extern "C" {
    #[link_name = "?inverse@Matrix@@QEBA?AV1@AEAVMatrixType@@AEAHAEAN_N3@Z"]
    pub fn Matrix_inverse5(this: *const Matrix, mattype: *mut MatrixType,
                           info: *mut octave_idx_type, rcon: *mut f64,
                           force: bool, calc_cond: bool) -> Matrix;
}
extern "C" {
    #[link_name = "?pseudo_inverse@Matrix@@QEBA?AV1@N@Z"]
    pub fn Matrix_pseudo_inverse(this: *const Matrix, tol: f64) -> Matrix;
}
extern "C" {
    #[link_name = "?fourier@Matrix@@QEBA?AVComplexMatrix@@XZ"]
    pub fn Matrix_fourier(this: *const Matrix) -> ComplexMatrix;
}
extern "C" {
    #[link_name = "?ifourier@Matrix@@QEBA?AVComplexMatrix@@XZ"]
    pub fn Matrix_ifourier(this: *const Matrix) -> ComplexMatrix;
}
extern "C" {
    #[link_name = "?fourier2d@Matrix@@QEBA?AVComplexMatrix@@XZ"]
    pub fn Matrix_fourier2d(this: *const Matrix) -> ComplexMatrix;
}
extern "C" {
    #[link_name = "?ifourier2d@Matrix@@QEBA?AVComplexMatrix@@XZ"]
    pub fn Matrix_ifourier2d(this: *const Matrix) -> ComplexMatrix;
}
extern "C" {
    #[link_name = "?determinant@Matrix@@QEBA?AV?$base_det@N@@XZ"]
    pub fn Matrix_determinant(this: *const Matrix) -> DET;
}
extern "C" {
    #[link_name = "?determinant@Matrix@@QEBA?AV?$base_det@N@@AEAH@Z"]
    pub fn Matrix_determinant1(this: *const Matrix,
                               info: *mut octave_idx_type) -> DET;
}
extern "C" {
    #[link_name = "?determinant@Matrix@@QEBA?AV?$base_det@N@@AEAHAEAN_N@Z"]
    pub fn Matrix_determinant2(this: *const Matrix,
                               info: *mut octave_idx_type, rcon: *mut f64,
                               calc_cond: bool) -> DET;
}
extern "C" {
    #[link_name =
          "?determinant@Matrix@@QEBA?AV?$base_det@N@@AEAVMatrixType@@AEAHAEAN_N@Z"]
    pub fn Matrix_determinant3(this: *const Matrix, mattype: *mut MatrixType,
                               info: *mut octave_idx_type, rcon: *mut f64,
                               calc_cond: bool) -> DET;
}
extern "C" {
    #[link_name = "?rcond@Matrix@@QEBANXZ"]
    pub fn Matrix_rcond(this: *const Matrix) -> f64;
}
extern "C" {
    #[link_name = "?rcond@Matrix@@QEBANAEAVMatrixType@@@Z"]
    pub fn Matrix_rcond1(this: *const Matrix, mattype: *mut MatrixType)
     -> f64;
}
extern "C" {
    #[link_name = "?solve@Matrix@@QEBA?AV1@AEAVMatrixType@@AEBV1@@Z"]
    pub fn Matrix_solve(this: *const Matrix, typ: *mut MatrixType,
                        b: *const Matrix) -> Matrix;
}
extern "C" {
    #[link_name = "?solve@Matrix@@QEBA?AV1@AEAVMatrixType@@AEBV1@AEAH@Z"]
    pub fn Matrix_solve1(this: *const Matrix, typ: *mut MatrixType,
                         b: *const Matrix, info: *mut octave_idx_type)
     -> Matrix;
}
extern "C" {
    #[link_name = "?solve@Matrix@@QEBA?AV1@AEAVMatrixType@@AEBV1@AEAHAEAN@Z"]
    pub fn Matrix_solve2(this: *const Matrix, typ: *mut MatrixType,
                         b: *const Matrix, info: *mut octave_idx_type,
                         rcon: *mut f64) -> Matrix;
}
extern "C" {
    #[link_name =
          "?solve@Matrix@@QEBA?AV1@AEAVMatrixType@@AEBV1@AEAHAEANP6AXN@Z_NW4blas_trans_type@@@Z"]
    pub fn Matrix_solve3(this: *const Matrix, typ: *mut MatrixType,
                         b: *const Matrix, info: *mut octave_idx_type,
                         rcon: *mut f64,
                         sing_handler: Matrix_solve_singularity_handler,
                         singular_fallback: bool, transt: blas_trans_type)
     -> Matrix;
}
extern "C" {
    #[link_name =
          "?solve@Matrix@@QEBA?AVComplexMatrix@@AEAVMatrixType@@AEBV2@@Z"]
    pub fn Matrix_solve4(this: *const Matrix, typ: *mut MatrixType,
                         b: *const ComplexMatrix) -> ComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@Matrix@@QEBA?AVComplexMatrix@@AEAVMatrixType@@AEBV2@AEAH@Z"]
    pub fn Matrix_solve5(this: *const Matrix, typ: *mut MatrixType,
                         b: *const ComplexMatrix, info: *mut octave_idx_type)
     -> ComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@Matrix@@QEBA?AVComplexMatrix@@AEAVMatrixType@@AEBV2@AEAHAEAN@Z"]
    pub fn Matrix_solve6(this: *const Matrix, typ: *mut MatrixType,
                         b: *const ComplexMatrix, info: *mut octave_idx_type,
                         rcon: *mut f64) -> ComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@Matrix@@QEBA?AVComplexMatrix@@AEAVMatrixType@@AEBV2@AEAHAEANP6AXN@Z_NW4blas_trans_type@@@Z"]
    pub fn Matrix_solve7(this: *const Matrix, typ: *mut MatrixType,
                         b: *const ComplexMatrix, info: *mut octave_idx_type,
                         rcon: *mut f64,
                         sing_handler: Matrix_solve_singularity_handler,
                         singular_fallback: bool, transt: blas_trans_type)
     -> ComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@Matrix@@QEBA?AVColumnVector@@AEAVMatrixType@@AEBV2@@Z"]
    pub fn Matrix_solve8(this: *const Matrix, typ: *mut MatrixType,
                         b: *const ColumnVector) -> ColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@Matrix@@QEBA?AVColumnVector@@AEAVMatrixType@@AEBV2@AEAH@Z"]
    pub fn Matrix_solve9(this: *const Matrix, typ: *mut MatrixType,
                         b: *const ColumnVector, info: *mut octave_idx_type)
     -> ColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@Matrix@@QEBA?AVColumnVector@@AEAVMatrixType@@AEBV2@AEAHAEAN@Z"]
    pub fn Matrix_solve10(this: *const Matrix, typ: *mut MatrixType,
                          b: *const ColumnVector, info: *mut octave_idx_type,
                          rcon: *mut f64) -> ColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@Matrix@@QEBA?AVColumnVector@@AEAVMatrixType@@AEBV2@AEAHAEANP6AXN@ZW4blas_trans_type@@@Z"]
    pub fn Matrix_solve11(this: *const Matrix, typ: *mut MatrixType,
                          b: *const ColumnVector, info: *mut octave_idx_type,
                          rcon: *mut f64,
                          sing_handler: Matrix_solve_singularity_handler,
                          transt: blas_trans_type) -> ColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@Matrix@@QEBA?AVComplexColumnVector@@AEAVMatrixType@@AEBV2@@Z"]
    pub fn Matrix_solve12(this: *const Matrix, typ: *mut MatrixType,
                          b: *const ComplexColumnVector)
     -> ComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@Matrix@@QEBA?AVComplexColumnVector@@AEAVMatrixType@@AEBV2@AEAH@Z"]
    pub fn Matrix_solve13(this: *const Matrix, typ: *mut MatrixType,
                          b: *const ComplexColumnVector,
                          info: *mut octave_idx_type) -> ComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@Matrix@@QEBA?AVComplexColumnVector@@AEAVMatrixType@@AEBV2@AEAHAEAN@Z"]
    pub fn Matrix_solve14(this: *const Matrix, typ: *mut MatrixType,
                          b: *const ComplexColumnVector,
                          info: *mut octave_idx_type, rcon: *mut f64)
     -> ComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@Matrix@@QEBA?AVComplexColumnVector@@AEAVMatrixType@@AEBV2@AEAHAEANP6AXN@ZW4blas_trans_type@@@Z"]
    pub fn Matrix_solve15(this: *const Matrix, typ: *mut MatrixType,
                          b: *const ComplexColumnVector,
                          info: *mut octave_idx_type, rcon: *mut f64,
                          sing_handler: Matrix_solve_singularity_handler,
                          transt: blas_trans_type) -> ComplexColumnVector;
}
extern "C" {
    #[link_name = "?solve@Matrix@@QEBA?AV1@AEBV1@@Z"]
    pub fn Matrix_solve16(this: *const Matrix, b: *const Matrix) -> Matrix;
}
extern "C" {
    #[link_name = "?solve@Matrix@@QEBA?AV1@AEBV1@AEAH@Z"]
    pub fn Matrix_solve17(this: *const Matrix, b: *const Matrix,
                          info: *mut octave_idx_type) -> Matrix;
}
extern "C" {
    #[link_name = "?solve@Matrix@@QEBA?AV1@AEBV1@AEAHAEAN@Z"]
    pub fn Matrix_solve18(this: *const Matrix, b: *const Matrix,
                          info: *mut octave_idx_type, rcon: *mut f64)
     -> Matrix;
}
extern "C" {
    #[link_name =
          "?solve@Matrix@@QEBA?AV1@AEBV1@AEAHAEANP6AXN@ZW4blas_trans_type@@@Z"]
    pub fn Matrix_solve19(this: *const Matrix, b: *const Matrix,
                          info: *mut octave_idx_type, rcon: *mut f64,
                          sing_handler: Matrix_solve_singularity_handler,
                          transt: blas_trans_type) -> Matrix;
}
extern "C" {
    #[link_name = "?solve@Matrix@@QEBA?AVComplexMatrix@@AEBV2@@Z"]
    pub fn Matrix_solve20(this: *const Matrix, b: *const ComplexMatrix)
     -> ComplexMatrix;
}
extern "C" {
    #[link_name = "?solve@Matrix@@QEBA?AVComplexMatrix@@AEBV2@AEAH@Z"]
    pub fn Matrix_solve21(this: *const Matrix, b: *const ComplexMatrix,
                          info: *mut octave_idx_type) -> ComplexMatrix;
}
extern "C" {
    #[link_name = "?solve@Matrix@@QEBA?AVComplexMatrix@@AEBV2@AEAHAEAN@Z"]
    pub fn Matrix_solve22(this: *const Matrix, b: *const ComplexMatrix,
                          info: *mut octave_idx_type, rcon: *mut f64)
     -> ComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@Matrix@@QEBA?AVComplexMatrix@@AEBV2@AEAHAEANP6AXN@ZW4blas_trans_type@@@Z"]
    pub fn Matrix_solve23(this: *const Matrix, b: *const ComplexMatrix,
                          info: *mut octave_idx_type, rcon: *mut f64,
                          sing_handler: Matrix_solve_singularity_handler,
                          transt: blas_trans_type) -> ComplexMatrix;
}
extern "C" {
    #[link_name = "?solve@Matrix@@QEBA?AVColumnVector@@AEBV2@@Z"]
    pub fn Matrix_solve24(this: *const Matrix, b: *const ColumnVector)
     -> ColumnVector;
}
extern "C" {
    #[link_name = "?solve@Matrix@@QEBA?AVColumnVector@@AEBV2@AEAH@Z"]
    pub fn Matrix_solve25(this: *const Matrix, b: *const ColumnVector,
                          info: *mut octave_idx_type) -> ColumnVector;
}
extern "C" {
    #[link_name = "?solve@Matrix@@QEBA?AVColumnVector@@AEBV2@AEAHAEAN@Z"]
    pub fn Matrix_solve26(this: *const Matrix, b: *const ColumnVector,
                          info: *mut octave_idx_type, rcon: *mut f64)
     -> ColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@Matrix@@QEBA?AVColumnVector@@AEBV2@AEAHAEANP6AXN@ZW4blas_trans_type@@@Z"]
    pub fn Matrix_solve27(this: *const Matrix, b: *const ColumnVector,
                          info: *mut octave_idx_type, rcon: *mut f64,
                          sing_handler: Matrix_solve_singularity_handler,
                          transt: blas_trans_type) -> ColumnVector;
}
extern "C" {
    #[link_name = "?solve@Matrix@@QEBA?AVComplexColumnVector@@AEBV2@@Z"]
    pub fn Matrix_solve28(this: *const Matrix, b: *const ComplexColumnVector)
     -> ComplexColumnVector;
}
extern "C" {
    #[link_name = "?solve@Matrix@@QEBA?AVComplexColumnVector@@AEBV2@AEAH@Z"]
    pub fn Matrix_solve29(this: *const Matrix, b: *const ComplexColumnVector,
                          info: *mut octave_idx_type) -> ComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@Matrix@@QEBA?AVComplexColumnVector@@AEBV2@AEAHAEAN@Z"]
    pub fn Matrix_solve30(this: *const Matrix, b: *const ComplexColumnVector,
                          info: *mut octave_idx_type, rcon: *mut f64)
     -> ComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@Matrix@@QEBA?AVComplexColumnVector@@AEBV2@AEAHAEANP6AXN@ZW4blas_trans_type@@@Z"]
    pub fn Matrix_solve31(this: *const Matrix, b: *const ComplexColumnVector,
                          info: *mut octave_idx_type, rcon: *mut f64,
                          sing_handler: Matrix_solve_singularity_handler,
                          transt: blas_trans_type) -> ComplexColumnVector;
}
extern "C" {
    #[link_name = "?lssolve@Matrix@@QEBA?AV1@AEBV1@@Z"]
    pub fn Matrix_lssolve(this: *const Matrix, b: *const Matrix) -> Matrix;
}
extern "C" {
    #[link_name = "?lssolve@Matrix@@QEBA?AV1@AEBV1@AEAH@Z"]
    pub fn Matrix_lssolve1(this: *const Matrix, b: *const Matrix,
                           info: *mut octave_idx_type) -> Matrix;
}
extern "C" {
    #[link_name = "?lssolve@Matrix@@QEBA?AV1@AEBV1@AEAH1@Z"]
    pub fn Matrix_lssolve2(this: *const Matrix, b: *const Matrix,
                           info: *mut octave_idx_type,
                           rank: *mut octave_idx_type) -> Matrix;
}
extern "C" {
    #[link_name = "?lssolve@Matrix@@QEBA?AV1@AEBV1@AEAH1AEAN@Z"]
    pub fn Matrix_lssolve3(this: *const Matrix, b: *const Matrix,
                           info: *mut octave_idx_type,
                           rank: *mut octave_idx_type, rcon: *mut f64)
     -> Matrix;
}
extern "C" {
    #[link_name = "?lssolve@Matrix@@QEBA?AVComplexMatrix@@AEBV2@@Z"]
    pub fn Matrix_lssolve4(this: *const Matrix, b: *const ComplexMatrix)
     -> ComplexMatrix;
}
extern "C" {
    #[link_name = "?lssolve@Matrix@@QEBA?AVComplexMatrix@@AEBV2@AEAH@Z"]
    pub fn Matrix_lssolve5(this: *const Matrix, b: *const ComplexMatrix,
                           info: *mut octave_idx_type) -> ComplexMatrix;
}
extern "C" {
    #[link_name = "?lssolve@Matrix@@QEBA?AVComplexMatrix@@AEBV2@AEAH1@Z"]
    pub fn Matrix_lssolve6(this: *const Matrix, b: *const ComplexMatrix,
                           info: *mut octave_idx_type,
                           rank: *mut octave_idx_type) -> ComplexMatrix;
}
extern "C" {
    #[link_name = "?lssolve@Matrix@@QEBA?AVComplexMatrix@@AEBV2@AEAH1AEAN@Z"]
    pub fn Matrix_lssolve7(this: *const Matrix, b: *const ComplexMatrix,
                           info: *mut octave_idx_type,
                           rank: *mut octave_idx_type, rcon: *mut f64)
     -> ComplexMatrix;
}
extern "C" {
    #[link_name = "?lssolve@Matrix@@QEBA?AVColumnVector@@AEBV2@@Z"]
    pub fn Matrix_lssolve8(this: *const Matrix, b: *const ColumnVector)
     -> ColumnVector;
}
extern "C" {
    #[link_name = "?lssolve@Matrix@@QEBA?AVColumnVector@@AEBV2@AEAH@Z"]
    pub fn Matrix_lssolve9(this: *const Matrix, b: *const ColumnVector,
                           info: *mut octave_idx_type) -> ColumnVector;
}
extern "C" {
    #[link_name = "?lssolve@Matrix@@QEBA?AVColumnVector@@AEBV2@AEAH1@Z"]
    pub fn Matrix_lssolve10(this: *const Matrix, b: *const ColumnVector,
                            info: *mut octave_idx_type,
                            rank: *mut octave_idx_type) -> ColumnVector;
}
extern "C" {
    #[link_name = "?lssolve@Matrix@@QEBA?AVColumnVector@@AEBV2@AEAH1AEAN@Z"]
    pub fn Matrix_lssolve11(this: *const Matrix, b: *const ColumnVector,
                            info: *mut octave_idx_type,
                            rank: *mut octave_idx_type, rcon: *mut f64)
     -> ColumnVector;
}
extern "C" {
    #[link_name = "?lssolve@Matrix@@QEBA?AVComplexColumnVector@@AEBV2@@Z"]
    pub fn Matrix_lssolve12(this: *const Matrix,
                            b: *const ComplexColumnVector)
     -> ComplexColumnVector;
}
extern "C" {
    #[link_name = "?lssolve@Matrix@@QEBA?AVComplexColumnVector@@AEBV2@AEAH@Z"]
    pub fn Matrix_lssolve13(this: *const Matrix,
                            b: *const ComplexColumnVector,
                            info: *mut octave_idx_type)
     -> ComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?lssolve@Matrix@@QEBA?AVComplexColumnVector@@AEBV2@AEAH1@Z"]
    pub fn Matrix_lssolve14(this: *const Matrix,
                            b: *const ComplexColumnVector,
                            info: *mut octave_idx_type,
                            rank: *mut octave_idx_type)
     -> ComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?lssolve@Matrix@@QEBA?AVComplexColumnVector@@AEBV2@AEAH1AEAN@Z"]
    pub fn Matrix_lssolve15(this: *const Matrix,
                            b: *const ComplexColumnVector,
                            info: *mut octave_idx_type,
                            rank: *mut octave_idx_type, rcon: *mut f64)
     -> ComplexColumnVector;
}
extern "C" {
    #[link_name = "?all@Matrix@@QEBA?AVboolMatrix@@H@Z"]
    pub fn Matrix_all(this: *const Matrix, dim: ::std::os::raw::c_int)
     -> boolMatrix;
}
extern "C" {
    #[link_name = "?any@Matrix@@QEBA?AVboolMatrix@@H@Z"]
    pub fn Matrix_any(this: *const Matrix, dim: ::std::os::raw::c_int)
     -> boolMatrix;
}
extern "C" {
    #[link_name = "?cumprod@Matrix@@QEBA?AV1@H@Z"]
    pub fn Matrix_cumprod(this: *const Matrix, dim: ::std::os::raw::c_int)
     -> Matrix;
}
extern "C" {
    #[link_name = "?cumsum@Matrix@@QEBA?AV1@H@Z"]
    pub fn Matrix_cumsum(this: *const Matrix, dim: ::std::os::raw::c_int)
     -> Matrix;
}
extern "C" {
    #[link_name = "?prod@Matrix@@QEBA?AV1@H@Z"]
    pub fn Matrix_prod(this: *const Matrix, dim: ::std::os::raw::c_int)
     -> Matrix;
}
extern "C" {
    #[link_name = "?sum@Matrix@@QEBA?AV1@H@Z"]
    pub fn Matrix_sum(this: *const Matrix, dim: ::std::os::raw::c_int)
     -> Matrix;
}
extern "C" {
    #[link_name = "?sumsq@Matrix@@QEBA?AV1@H@Z"]
    pub fn Matrix_sumsq(this: *const Matrix, dim: ::std::os::raw::c_int)
     -> Matrix;
}
extern "C" {
    #[link_name = "?abs@Matrix@@QEBA?AV1@XZ"]
    pub fn Matrix_abs(this: *const Matrix) -> Matrix;
}
extern "C" {
    #[link_name = "?diag@Matrix@@QEBA?AV1@H@Z"]
    pub fn Matrix_diag(this: *const Matrix, k: octave_idx_type) -> Matrix;
}
extern "C" {
    #[link_name = "?diag@Matrix@@QEBA?AVDiagMatrix@@HH@Z"]
    pub fn Matrix_diag1(this: *const Matrix, m: octave_idx_type,
                        n: octave_idx_type) -> DiagMatrix;
}
extern "C" {
    #[link_name = "?row_min@Matrix@@QEBA?AVColumnVector@@XZ"]
    pub fn Matrix_row_min(this: *const Matrix) -> ColumnVector;
}
extern "C" {
    #[link_name = "?row_max@Matrix@@QEBA?AVColumnVector@@XZ"]
    pub fn Matrix_row_max(this: *const Matrix) -> ColumnVector;
}
extern "C" {
    #[link_name = "?row_min@Matrix@@QEBA?AVColumnVector@@AEAV?$Array@H@@@Z"]
    pub fn Matrix_row_min1(this: *const Matrix,
                           index: *mut Array<::std::os::raw::c_int>)
     -> ColumnVector;
}
extern "C" {
    #[link_name = "?row_max@Matrix@@QEBA?AVColumnVector@@AEAV?$Array@H@@@Z"]
    pub fn Matrix_row_max1(this: *const Matrix,
                           index: *mut Array<::std::os::raw::c_int>)
     -> ColumnVector;
}
extern "C" {
    #[link_name = "?column_min@Matrix@@QEBA?AVRowVector@@XZ"]
    pub fn Matrix_column_min(this: *const Matrix) -> RowVector;
}
extern "C" {
    #[link_name = "?column_max@Matrix@@QEBA?AVRowVector@@XZ"]
    pub fn Matrix_column_max(this: *const Matrix) -> RowVector;
}
extern "C" {
    #[link_name = "?column_min@Matrix@@QEBA?AVRowVector@@AEAV?$Array@H@@@Z"]
    pub fn Matrix_column_min1(this: *const Matrix,
                              index: *mut Array<::std::os::raw::c_int>)
     -> RowVector;
}
extern "C" {
    #[link_name = "?column_max@Matrix@@QEBA?AVRowVector@@AEAV?$Array@H@@@Z"]
    pub fn Matrix_column_max1(this: *const Matrix,
                              index: *mut Array<::std::os::raw::c_int>)
     -> RowVector;
}
extern "C" {
    #[link_name = "??0Matrix@@QEAA@AEBVRowVector@@@Z"]
    pub fn Matrix_Matrix(this: *mut Matrix, rv: *const RowVector);
}
extern "C" {
    #[link_name = "??0Matrix@@QEAA@AEBVColumnVector@@@Z"]
    pub fn Matrix_Matrix1(this: *mut Matrix, cv: *const ColumnVector);
}
extern "C" {
    #[link_name = "??0Matrix@@QEAA@AEBVDiagMatrix@@@Z"]
    pub fn Matrix_Matrix2(this: *mut Matrix, a: *const DiagMatrix);
}
extern "C" {
    #[link_name = "??0Matrix@@QEAA@AEBV?$MDiagArray2@N@@@Z"]
    pub fn Matrix_Matrix3(this: *mut Matrix, a: *const MDiagArray2<f64>);
}
extern "C" {
    #[link_name = "??0Matrix@@QEAA@AEBV?$DiagArray2@N@@@Z"]
    pub fn Matrix_Matrix4(this: *mut Matrix, a: *const DiagArray2<f64>);
}
extern "C" {
    #[link_name = "??0Matrix@@QEAA@AEBVPermMatrix@@@Z"]
    pub fn Matrix_Matrix5(this: *mut Matrix, a: *const PermMatrix);
}
extern "C" {
    #[link_name = "??0Matrix@@QEAA@AEBVboolMatrix@@@Z"]
    pub fn Matrix_Matrix6(this: *mut Matrix, a: *const boolMatrix);
}
extern "C" {
    #[link_name = "??0Matrix@@QEAA@AEBVcharMatrix@@@Z"]
    pub fn Matrix_Matrix7(this: *mut Matrix, a: *const charMatrix);
}
impl Matrix {
    #[inline]
    pub unsafe fn is_symmetric(&self) -> bool { Matrix_is_symmetric(self) }
    #[inline]
    pub unsafe fn insert(&mut self, a: *const Matrix, r: octave_idx_type,
                         c: octave_idx_type) -> *mut Matrix {
        Matrix_insert(self, a, r, c)
    }
    #[inline]
    pub unsafe fn insert1(&mut self, a: *const RowVector, r: octave_idx_type,
                          c: octave_idx_type) -> *mut Matrix {
        Matrix_insert1(self, a, r, c)
    }
    #[inline]
    pub unsafe fn insert2(&mut self, a: *const ColumnVector,
                          r: octave_idx_type, c: octave_idx_type)
     -> *mut Matrix {
        Matrix_insert2(self, a, r, c)
    }
    #[inline]
    pub unsafe fn insert3(&mut self, a: *const DiagMatrix, r: octave_idx_type,
                          c: octave_idx_type) -> *mut Matrix {
        Matrix_insert3(self, a, r, c)
    }
    #[inline]
    pub unsafe fn fill(&mut self, val: f64) -> *mut Matrix {
        Matrix_fill(self, val)
    }
    #[inline]
    pub unsafe fn fill1(&mut self, val: f64, r1: octave_idx_type,
                        c1: octave_idx_type, r2: octave_idx_type,
                        c2: octave_idx_type) -> *mut Matrix {
        Matrix_fill1(self, val, r1, c1, r2, c2)
    }
    #[inline]
    pub unsafe fn append(&self, a: *const Matrix) -> Matrix {
        Matrix_append(self, a)
    }
    #[inline]
    pub unsafe fn append1(&self, a: *const RowVector) -> Matrix {
        Matrix_append1(self, a)
    }
    #[inline]
    pub unsafe fn append2(&self, a: *const ColumnVector) -> Matrix {
        Matrix_append2(self, a)
    }
    #[inline]
    pub unsafe fn append3(&self, a: *const DiagMatrix) -> Matrix {
        Matrix_append3(self, a)
    }
    #[inline]
    pub unsafe fn stack(&self, a: *const Matrix) -> Matrix {
        Matrix_stack(self, a)
    }
    #[inline]
    pub unsafe fn stack1(&self, a: *const RowVector) -> Matrix {
        Matrix_stack1(self, a)
    }
    #[inline]
    pub unsafe fn stack2(&self, a: *const ColumnVector) -> Matrix {
        Matrix_stack2(self, a)
    }
    #[inline]
    pub unsafe fn stack3(&self, a: *const DiagMatrix) -> Matrix {
        Matrix_stack3(self, a)
    }
    #[inline]
    pub unsafe fn extract(&self, r1: octave_idx_type, c1: octave_idx_type,
                          r2: octave_idx_type, c2: octave_idx_type)
     -> Matrix {
        Matrix_extract(self, r1, c1, r2, c2)
    }
    #[inline]
    pub unsafe fn extract_n(&self, r1: octave_idx_type, c1: octave_idx_type,
                            nr: octave_idx_type, nc: octave_idx_type)
     -> Matrix {
        Matrix_extract_n(self, r1, c1, nr, nc)
    }
    #[inline]
    pub unsafe fn row(&self, i: octave_idx_type) -> RowVector {
        Matrix_row(self, i)
    }
    #[inline]
    pub unsafe fn column(&self, i: octave_idx_type) -> ColumnVector {
        Matrix_column(self, i)
    }
    #[inline]
    pub unsafe fn inverse(&self) -> Matrix { Matrix_inverse(self) }
    #[inline]
    pub unsafe fn inverse1(&self, info: *mut octave_idx_type) -> Matrix {
        Matrix_inverse1(self, info)
    }
    #[inline]
    pub unsafe fn inverse2(&self, info: *mut octave_idx_type, rcon: *mut f64,
                           force: bool, calc_cond: bool) -> Matrix {
        Matrix_inverse2(self, info, rcon, force, calc_cond)
    }
    #[inline]
    pub unsafe fn inverse3(&self, mattype: *mut MatrixType) -> Matrix {
        Matrix_inverse3(self, mattype)
    }
    #[inline]
    pub unsafe fn inverse4(&self, mattype: *mut MatrixType,
                           info: *mut octave_idx_type) -> Matrix {
        Matrix_inverse4(self, mattype, info)
    }
    #[inline]
    pub unsafe fn inverse5(&self, mattype: *mut MatrixType,
                           info: *mut octave_idx_type, rcon: *mut f64,
                           force: bool, calc_cond: bool) -> Matrix {
        Matrix_inverse5(self, mattype, info, rcon, force, calc_cond)
    }
    #[inline]
    pub unsafe fn pseudo_inverse(&self, tol: f64) -> Matrix {
        Matrix_pseudo_inverse(self, tol)
    }
    #[inline]
    pub unsafe fn fourier(&self) -> ComplexMatrix { Matrix_fourier(self) }
    #[inline]
    pub unsafe fn ifourier(&self) -> ComplexMatrix { Matrix_ifourier(self) }
    #[inline]
    pub unsafe fn fourier2d(&self) -> ComplexMatrix { Matrix_fourier2d(self) }
    #[inline]
    pub unsafe fn ifourier2d(&self) -> ComplexMatrix {
        Matrix_ifourier2d(self)
    }
    #[inline]
    pub unsafe fn determinant(&self) -> DET { Matrix_determinant(self) }
    #[inline]
    pub unsafe fn determinant1(&self, info: *mut octave_idx_type) -> DET {
        Matrix_determinant1(self, info)
    }
    #[inline]
    pub unsafe fn determinant2(&self, info: *mut octave_idx_type,
                               rcon: *mut f64, calc_cond: bool) -> DET {
        Matrix_determinant2(self, info, rcon, calc_cond)
    }
    #[inline]
    pub unsafe fn determinant3(&self, mattype: *mut MatrixType,
                               info: *mut octave_idx_type, rcon: *mut f64,
                               calc_cond: bool) -> DET {
        Matrix_determinant3(self, mattype, info, rcon, calc_cond)
    }
    #[inline]
    pub unsafe fn rcond(&self) -> f64 { Matrix_rcond(self) }
    #[inline]
    pub unsafe fn rcond1(&self, mattype: *mut MatrixType) -> f64 {
        Matrix_rcond1(self, mattype)
    }
    #[inline]
    pub unsafe fn solve(&self, typ: *mut MatrixType, b: *const Matrix)
     -> Matrix {
        Matrix_solve(self, typ, b)
    }
    #[inline]
    pub unsafe fn solve1(&self, typ: *mut MatrixType, b: *const Matrix,
                         info: *mut octave_idx_type) -> Matrix {
        Matrix_solve1(self, typ, b, info)
    }
    #[inline]
    pub unsafe fn solve2(&self, typ: *mut MatrixType, b: *const Matrix,
                         info: *mut octave_idx_type, rcon: *mut f64)
     -> Matrix {
        Matrix_solve2(self, typ, b, info, rcon)
    }
    #[inline]
    pub unsafe fn solve3(&self, typ: *mut MatrixType, b: *const Matrix,
                         info: *mut octave_idx_type, rcon: *mut f64,
                         sing_handler: Matrix_solve_singularity_handler,
                         singular_fallback: bool, transt: blas_trans_type)
     -> Matrix {
        Matrix_solve3(self, typ, b, info, rcon, sing_handler,
                      singular_fallback, transt)
    }
    #[inline]
    pub unsafe fn solve4(&self, typ: *mut MatrixType, b: *const ComplexMatrix)
     -> ComplexMatrix {
        Matrix_solve4(self, typ, b)
    }
    #[inline]
    pub unsafe fn solve5(&self, typ: *mut MatrixType, b: *const ComplexMatrix,
                         info: *mut octave_idx_type) -> ComplexMatrix {
        Matrix_solve5(self, typ, b, info)
    }
    #[inline]
    pub unsafe fn solve6(&self, typ: *mut MatrixType, b: *const ComplexMatrix,
                         info: *mut octave_idx_type, rcon: *mut f64)
     -> ComplexMatrix {
        Matrix_solve6(self, typ, b, info, rcon)
    }
    #[inline]
    pub unsafe fn solve7(&self, typ: *mut MatrixType, b: *const ComplexMatrix,
                         info: *mut octave_idx_type, rcon: *mut f64,
                         sing_handler: Matrix_solve_singularity_handler,
                         singular_fallback: bool, transt: blas_trans_type)
     -> ComplexMatrix {
        Matrix_solve7(self, typ, b, info, rcon, sing_handler,
                      singular_fallback, transt)
    }
    #[inline]
    pub unsafe fn solve8(&self, typ: *mut MatrixType, b: *const ColumnVector)
     -> ColumnVector {
        Matrix_solve8(self, typ, b)
    }
    #[inline]
    pub unsafe fn solve9(&self, typ: *mut MatrixType, b: *const ColumnVector,
                         info: *mut octave_idx_type) -> ColumnVector {
        Matrix_solve9(self, typ, b, info)
    }
    #[inline]
    pub unsafe fn solve10(&self, typ: *mut MatrixType, b: *const ColumnVector,
                          info: *mut octave_idx_type, rcon: *mut f64)
     -> ColumnVector {
        Matrix_solve10(self, typ, b, info, rcon)
    }
    #[inline]
    pub unsafe fn solve11(&self, typ: *mut MatrixType, b: *const ColumnVector,
                          info: *mut octave_idx_type, rcon: *mut f64,
                          sing_handler: Matrix_solve_singularity_handler,
                          transt: blas_trans_type) -> ColumnVector {
        Matrix_solve11(self, typ, b, info, rcon, sing_handler, transt)
    }
    #[inline]
    pub unsafe fn solve12(&self, typ: *mut MatrixType,
                          b: *const ComplexColumnVector)
     -> ComplexColumnVector {
        Matrix_solve12(self, typ, b)
    }
    #[inline]
    pub unsafe fn solve13(&self, typ: *mut MatrixType,
                          b: *const ComplexColumnVector,
                          info: *mut octave_idx_type) -> ComplexColumnVector {
        Matrix_solve13(self, typ, b, info)
    }
    #[inline]
    pub unsafe fn solve14(&self, typ: *mut MatrixType,
                          b: *const ComplexColumnVector,
                          info: *mut octave_idx_type, rcon: *mut f64)
     -> ComplexColumnVector {
        Matrix_solve14(self, typ, b, info, rcon)
    }
    #[inline]
    pub unsafe fn solve15(&self, typ: *mut MatrixType,
                          b: *const ComplexColumnVector,
                          info: *mut octave_idx_type, rcon: *mut f64,
                          sing_handler: Matrix_solve_singularity_handler,
                          transt: blas_trans_type) -> ComplexColumnVector {
        Matrix_solve15(self, typ, b, info, rcon, sing_handler, transt)
    }
    #[inline]
    pub unsafe fn solve16(&self, b: *const Matrix) -> Matrix {
        Matrix_solve16(self, b)
    }
    #[inline]
    pub unsafe fn solve17(&self, b: *const Matrix, info: *mut octave_idx_type)
     -> Matrix {
        Matrix_solve17(self, b, info)
    }
    #[inline]
    pub unsafe fn solve18(&self, b: *const Matrix, info: *mut octave_idx_type,
                          rcon: *mut f64) -> Matrix {
        Matrix_solve18(self, b, info, rcon)
    }
    #[inline]
    pub unsafe fn solve19(&self, b: *const Matrix, info: *mut octave_idx_type,
                          rcon: *mut f64,
                          sing_handler: Matrix_solve_singularity_handler,
                          transt: blas_trans_type) -> Matrix {
        Matrix_solve19(self, b, info, rcon, sing_handler, transt)
    }
    #[inline]
    pub unsafe fn solve20(&self, b: *const ComplexMatrix) -> ComplexMatrix {
        Matrix_solve20(self, b)
    }
    #[inline]
    pub unsafe fn solve21(&self, b: *const ComplexMatrix,
                          info: *mut octave_idx_type) -> ComplexMatrix {
        Matrix_solve21(self, b, info)
    }
    #[inline]
    pub unsafe fn solve22(&self, b: *const ComplexMatrix,
                          info: *mut octave_idx_type, rcon: *mut f64)
     -> ComplexMatrix {
        Matrix_solve22(self, b, info, rcon)
    }
    #[inline]
    pub unsafe fn solve23(&self, b: *const ComplexMatrix,
                          info: *mut octave_idx_type, rcon: *mut f64,
                          sing_handler: Matrix_solve_singularity_handler,
                          transt: blas_trans_type) -> ComplexMatrix {
        Matrix_solve23(self, b, info, rcon, sing_handler, transt)
    }
    #[inline]
    pub unsafe fn solve24(&self, b: *const ColumnVector) -> ColumnVector {
        Matrix_solve24(self, b)
    }
    #[inline]
    pub unsafe fn solve25(&self, b: *const ColumnVector,
                          info: *mut octave_idx_type) -> ColumnVector {
        Matrix_solve25(self, b, info)
    }
    #[inline]
    pub unsafe fn solve26(&self, b: *const ColumnVector,
                          info: *mut octave_idx_type, rcon: *mut f64)
     -> ColumnVector {
        Matrix_solve26(self, b, info, rcon)
    }
    #[inline]
    pub unsafe fn solve27(&self, b: *const ColumnVector,
                          info: *mut octave_idx_type, rcon: *mut f64,
                          sing_handler: Matrix_solve_singularity_handler,
                          transt: blas_trans_type) -> ColumnVector {
        Matrix_solve27(self, b, info, rcon, sing_handler, transt)
    }
    #[inline]
    pub unsafe fn solve28(&self, b: *const ComplexColumnVector)
     -> ComplexColumnVector {
        Matrix_solve28(self, b)
    }
    #[inline]
    pub unsafe fn solve29(&self, b: *const ComplexColumnVector,
                          info: *mut octave_idx_type) -> ComplexColumnVector {
        Matrix_solve29(self, b, info)
    }
    #[inline]
    pub unsafe fn solve30(&self, b: *const ComplexColumnVector,
                          info: *mut octave_idx_type, rcon: *mut f64)
     -> ComplexColumnVector {
        Matrix_solve30(self, b, info, rcon)
    }
    #[inline]
    pub unsafe fn solve31(&self, b: *const ComplexColumnVector,
                          info: *mut octave_idx_type, rcon: *mut f64,
                          sing_handler: Matrix_solve_singularity_handler,
                          transt: blas_trans_type) -> ComplexColumnVector {
        Matrix_solve31(self, b, info, rcon, sing_handler, transt)
    }
    #[inline]
    pub unsafe fn lssolve(&self, b: *const Matrix) -> Matrix {
        Matrix_lssolve(self, b)
    }
    #[inline]
    pub unsafe fn lssolve1(&self, b: *const Matrix,
                           info: *mut octave_idx_type) -> Matrix {
        Matrix_lssolve1(self, b, info)
    }
    #[inline]
    pub unsafe fn lssolve2(&self, b: *const Matrix,
                           info: *mut octave_idx_type,
                           rank: *mut octave_idx_type) -> Matrix {
        Matrix_lssolve2(self, b, info, rank)
    }
    #[inline]
    pub unsafe fn lssolve3(&self, b: *const Matrix,
                           info: *mut octave_idx_type,
                           rank: *mut octave_idx_type, rcon: *mut f64)
     -> Matrix {
        Matrix_lssolve3(self, b, info, rank, rcon)
    }
    #[inline]
    pub unsafe fn lssolve4(&self, b: *const ComplexMatrix) -> ComplexMatrix {
        Matrix_lssolve4(self, b)
    }
    #[inline]
    pub unsafe fn lssolve5(&self, b: *const ComplexMatrix,
                           info: *mut octave_idx_type) -> ComplexMatrix {
        Matrix_lssolve5(self, b, info)
    }
    #[inline]
    pub unsafe fn lssolve6(&self, b: *const ComplexMatrix,
                           info: *mut octave_idx_type,
                           rank: *mut octave_idx_type) -> ComplexMatrix {
        Matrix_lssolve6(self, b, info, rank)
    }
    #[inline]
    pub unsafe fn lssolve7(&self, b: *const ComplexMatrix,
                           info: *mut octave_idx_type,
                           rank: *mut octave_idx_type, rcon: *mut f64)
     -> ComplexMatrix {
        Matrix_lssolve7(self, b, info, rank, rcon)
    }
    #[inline]
    pub unsafe fn lssolve8(&self, b: *const ColumnVector) -> ColumnVector {
        Matrix_lssolve8(self, b)
    }
    #[inline]
    pub unsafe fn lssolve9(&self, b: *const ColumnVector,
                           info: *mut octave_idx_type) -> ColumnVector {
        Matrix_lssolve9(self, b, info)
    }
    #[inline]
    pub unsafe fn lssolve10(&self, b: *const ColumnVector,
                            info: *mut octave_idx_type,
                            rank: *mut octave_idx_type) -> ColumnVector {
        Matrix_lssolve10(self, b, info, rank)
    }
    #[inline]
    pub unsafe fn lssolve11(&self, b: *const ColumnVector,
                            info: *mut octave_idx_type,
                            rank: *mut octave_idx_type, rcon: *mut f64)
     -> ColumnVector {
        Matrix_lssolve11(self, b, info, rank, rcon)
    }
    #[inline]
    pub unsafe fn lssolve12(&self, b: *const ComplexColumnVector)
     -> ComplexColumnVector {
        Matrix_lssolve12(self, b)
    }
    #[inline]
    pub unsafe fn lssolve13(&self, b: *const ComplexColumnVector,
                            info: *mut octave_idx_type)
     -> ComplexColumnVector {
        Matrix_lssolve13(self, b, info)
    }
    #[inline]
    pub unsafe fn lssolve14(&self, b: *const ComplexColumnVector,
                            info: *mut octave_idx_type,
                            rank: *mut octave_idx_type)
     -> ComplexColumnVector {
        Matrix_lssolve14(self, b, info, rank)
    }
    #[inline]
    pub unsafe fn lssolve15(&self, b: *const ComplexColumnVector,
                            info: *mut octave_idx_type,
                            rank: *mut octave_idx_type, rcon: *mut f64)
     -> ComplexColumnVector {
        Matrix_lssolve15(self, b, info, rank, rcon)
    }
    #[inline]
    pub unsafe fn all(&self, dim: ::std::os::raw::c_int) -> boolMatrix {
        Matrix_all(self, dim)
    }
    #[inline]
    pub unsafe fn any(&self, dim: ::std::os::raw::c_int) -> boolMatrix {
        Matrix_any(self, dim)
    }
    #[inline]
    pub unsafe fn cumprod(&self, dim: ::std::os::raw::c_int) -> Matrix {
        Matrix_cumprod(self, dim)
    }
    #[inline]
    pub unsafe fn cumsum(&self, dim: ::std::os::raw::c_int) -> Matrix {
        Matrix_cumsum(self, dim)
    }
    #[inline]
    pub unsafe fn prod(&self, dim: ::std::os::raw::c_int) -> Matrix {
        Matrix_prod(self, dim)
    }
    #[inline]
    pub unsafe fn sum(&self, dim: ::std::os::raw::c_int) -> Matrix {
        Matrix_sum(self, dim)
    }
    #[inline]
    pub unsafe fn sumsq(&self, dim: ::std::os::raw::c_int) -> Matrix {
        Matrix_sumsq(self, dim)
    }
    #[inline]
    pub unsafe fn abs(&self) -> Matrix { Matrix_abs(self) }
    #[inline]
    pub unsafe fn diag(&self, k: octave_idx_type) -> Matrix {
        Matrix_diag(self, k)
    }
    #[inline]
    pub unsafe fn diag1(&self, m: octave_idx_type, n: octave_idx_type)
     -> DiagMatrix {
        Matrix_diag1(self, m, n)
    }
    #[inline]
    pub unsafe fn row_min(&self) -> ColumnVector { Matrix_row_min(self) }
    #[inline]
    pub unsafe fn row_max(&self) -> ColumnVector { Matrix_row_max(self) }
    #[inline]
    pub unsafe fn row_min1(&self, index: *mut Array<::std::os::raw::c_int>)
     -> ColumnVector {
        Matrix_row_min1(self, index)
    }
    #[inline]
    pub unsafe fn row_max1(&self, index: *mut Array<::std::os::raw::c_int>)
     -> ColumnVector {
        Matrix_row_max1(self, index)
    }
    #[inline]
    pub unsafe fn column_min(&self) -> RowVector { Matrix_column_min(self) }
    #[inline]
    pub unsafe fn column_max(&self) -> RowVector { Matrix_column_max(self) }
    #[inline]
    pub unsafe fn column_min1(&self, index: *mut Array<::std::os::raw::c_int>)
     -> RowVector {
        Matrix_column_min1(self, index)
    }
    #[inline]
    pub unsafe fn column_max1(&self, index: *mut Array<::std::os::raw::c_int>)
     -> RowVector {
        Matrix_column_max1(self, index)
    }
    #[inline]
    pub unsafe fn new(rv: *const RowVector) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        Matrix_Matrix(&mut __bindgen_tmp, rv);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(cv: *const ColumnVector) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        Matrix_Matrix1(&mut __bindgen_tmp, cv);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new2(a: *const DiagMatrix) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        Matrix_Matrix2(&mut __bindgen_tmp, a);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new3(a: *const MDiagArray2<f64>) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        Matrix_Matrix3(&mut __bindgen_tmp, a);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new4(a: *const DiagArray2<f64>) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        Matrix_Matrix4(&mut __bindgen_tmp, a);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new5(a: *const PermMatrix) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        Matrix_Matrix5(&mut __bindgen_tmp, a);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new6(a: *const boolMatrix) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        Matrix_Matrix6(&mut __bindgen_tmp, a);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new7(a: *const charMatrix) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        Matrix_Matrix7(&mut __bindgen_tmp, a);
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct ComplexMatrix {
    pub _base: ComplexNDArray,
}
pub type ComplexMatrix_column_vector_type = ComplexColumnVector;
pub type ComplexMatrix_row_vector_type = ComplexRowVector;
pub type ComplexMatrix_real_column_vector_type = ColumnVector;
pub type ComplexMatrix_real_row_vector_type = RowVector;
pub type ComplexMatrix_real_matrix_type = Matrix;
pub type ComplexMatrix_complex_matrix_type = ComplexMatrix;
pub type ComplexMatrix_real_diag_matrix_type = DiagMatrix;
pub type ComplexMatrix_complex_diag_matrix_type = ComplexDiagMatrix;
pub type ComplexMatrix_real_elt_type = f64;
pub type ComplexMatrix_complex_elt_type = Complex;
pub type ComplexMatrix_solve_singularity_handler =
    ::std::option::Option<unsafe extern "C" fn(rcon: f64)>;
#[test]
fn bindgen_test_layout_ComplexMatrix() {
    assert_eq!(::std::mem::size_of::<ComplexMatrix>() , 40usize , concat ! (
               "Size of: " , stringify ! ( ComplexMatrix ) ));
    assert_eq! (::std::mem::align_of::<ComplexMatrix>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ComplexMatrix ) ));
}
extern "C" {
    #[link_name = "?is_hermitian@ComplexMatrix@@QEBA_NXZ"]
    pub fn ComplexMatrix_is_hermitian(this: *const ComplexMatrix) -> bool;
}
extern "C" {
    #[link_name = "?insert@ComplexMatrix@@QEAAAEAV1@AEBVMatrix@@HH@Z"]
    pub fn ComplexMatrix_insert(this: *mut ComplexMatrix, a: *const Matrix,
                                r: octave_idx_type, c: octave_idx_type)
     -> *mut ComplexMatrix;
}
extern "C" {
    #[link_name = "?insert@ComplexMatrix@@QEAAAEAV1@AEBVRowVector@@HH@Z"]
    pub fn ComplexMatrix_insert1(this: *mut ComplexMatrix,
                                 a: *const RowVector, r: octave_idx_type,
                                 c: octave_idx_type) -> *mut ComplexMatrix;
}
extern "C" {
    #[link_name = "?insert@ComplexMatrix@@QEAAAEAV1@AEBVColumnVector@@HH@Z"]
    pub fn ComplexMatrix_insert2(this: *mut ComplexMatrix,
                                 a: *const ColumnVector, r: octave_idx_type,
                                 c: octave_idx_type) -> *mut ComplexMatrix;
}
extern "C" {
    #[link_name = "?insert@ComplexMatrix@@QEAAAEAV1@AEBVDiagMatrix@@HH@Z"]
    pub fn ComplexMatrix_insert3(this: *mut ComplexMatrix,
                                 a: *const DiagMatrix, r: octave_idx_type,
                                 c: octave_idx_type) -> *mut ComplexMatrix;
}
extern "C" {
    #[link_name = "?insert@ComplexMatrix@@QEAAAEAV1@AEBV1@HH@Z"]
    pub fn ComplexMatrix_insert4(this: *mut ComplexMatrix,
                                 a: *const ComplexMatrix, r: octave_idx_type,
                                 c: octave_idx_type) -> *mut ComplexMatrix;
}
extern "C" {
    #[link_name =
          "?insert@ComplexMatrix@@QEAAAEAV1@AEBVComplexRowVector@@HH@Z"]
    pub fn ComplexMatrix_insert5(this: *mut ComplexMatrix,
                                 a: *const ComplexRowVector,
                                 r: octave_idx_type, c: octave_idx_type)
     -> *mut ComplexMatrix;
}
extern "C" {
    #[link_name =
          "?insert@ComplexMatrix@@QEAAAEAV1@AEBVComplexColumnVector@@HH@Z"]
    pub fn ComplexMatrix_insert6(this: *mut ComplexMatrix,
                                 a: *const ComplexColumnVector,
                                 r: octave_idx_type, c: octave_idx_type)
     -> *mut ComplexMatrix;
}
extern "C" {
    #[link_name =
          "?insert@ComplexMatrix@@QEAAAEAV1@AEBVComplexDiagMatrix@@HH@Z"]
    pub fn ComplexMatrix_insert7(this: *mut ComplexMatrix,
                                 a: *const ComplexDiagMatrix,
                                 r: octave_idx_type, c: octave_idx_type)
     -> *mut ComplexMatrix;
}
extern "C" {
    #[link_name = "?fill@ComplexMatrix@@QEAAAEAV1@N@Z"]
    pub fn ComplexMatrix_fill(this: *mut ComplexMatrix, val: f64)
     -> *mut ComplexMatrix;
}
extern "C" {
    #[link_name = "?fill@ComplexMatrix@@QEAAAEAV1@AEBU?$complex@N@std@@@Z"]
    pub fn ComplexMatrix_fill1(this: *mut ComplexMatrix, val: *const Complex)
     -> *mut ComplexMatrix;
}
extern "C" {
    #[link_name = "?fill@ComplexMatrix@@QEAAAEAV1@NHHHH@Z"]
    pub fn ComplexMatrix_fill2(this: *mut ComplexMatrix, val: f64,
                               r1: octave_idx_type, c1: octave_idx_type,
                               r2: octave_idx_type, c2: octave_idx_type)
     -> *mut ComplexMatrix;
}
extern "C" {
    #[link_name =
          "?fill@ComplexMatrix@@QEAAAEAV1@AEBU?$complex@N@std@@HHHH@Z"]
    pub fn ComplexMatrix_fill3(this: *mut ComplexMatrix, val: *const Complex,
                               r1: octave_idx_type, c1: octave_idx_type,
                               r2: octave_idx_type, c2: octave_idx_type)
     -> *mut ComplexMatrix;
}
extern "C" {
    #[link_name = "?append@ComplexMatrix@@QEBA?AV1@AEBVMatrix@@@Z"]
    pub fn ComplexMatrix_append(this: *const ComplexMatrix, a: *const Matrix)
     -> ComplexMatrix;
}
extern "C" {
    #[link_name = "?append@ComplexMatrix@@QEBA?AV1@AEBVRowVector@@@Z"]
    pub fn ComplexMatrix_append1(this: *const ComplexMatrix,
                                 a: *const RowVector) -> ComplexMatrix;
}
extern "C" {
    #[link_name = "?append@ComplexMatrix@@QEBA?AV1@AEBVColumnVector@@@Z"]
    pub fn ComplexMatrix_append2(this: *const ComplexMatrix,
                                 a: *const ColumnVector) -> ComplexMatrix;
}
extern "C" {
    #[link_name = "?append@ComplexMatrix@@QEBA?AV1@AEBVDiagMatrix@@@Z"]
    pub fn ComplexMatrix_append3(this: *const ComplexMatrix,
                                 a: *const DiagMatrix) -> ComplexMatrix;
}
extern "C" {
    #[link_name = "?append@ComplexMatrix@@QEBA?AV1@AEBV1@@Z"]
    pub fn ComplexMatrix_append4(this: *const ComplexMatrix,
                                 a: *const ComplexMatrix) -> ComplexMatrix;
}
extern "C" {
    #[link_name = "?append@ComplexMatrix@@QEBA?AV1@AEBVComplexRowVector@@@Z"]
    pub fn ComplexMatrix_append5(this: *const ComplexMatrix,
                                 a: *const ComplexRowVector) -> ComplexMatrix;
}
extern "C" {
    #[link_name =
          "?append@ComplexMatrix@@QEBA?AV1@AEBVComplexColumnVector@@@Z"]
    pub fn ComplexMatrix_append6(this: *const ComplexMatrix,
                                 a: *const ComplexColumnVector)
     -> ComplexMatrix;
}
extern "C" {
    #[link_name = "?append@ComplexMatrix@@QEBA?AV1@AEBVComplexDiagMatrix@@@Z"]
    pub fn ComplexMatrix_append7(this: *const ComplexMatrix,
                                 a: *const ComplexDiagMatrix)
     -> ComplexMatrix;
}
extern "C" {
    #[link_name = "?stack@ComplexMatrix@@QEBA?AV1@AEBVMatrix@@@Z"]
    pub fn ComplexMatrix_stack(this: *const ComplexMatrix, a: *const Matrix)
     -> ComplexMatrix;
}
extern "C" {
    #[link_name = "?stack@ComplexMatrix@@QEBA?AV1@AEBVRowVector@@@Z"]
    pub fn ComplexMatrix_stack1(this: *const ComplexMatrix,
                                a: *const RowVector) -> ComplexMatrix;
}
extern "C" {
    #[link_name = "?stack@ComplexMatrix@@QEBA?AV1@AEBVColumnVector@@@Z"]
    pub fn ComplexMatrix_stack2(this: *const ComplexMatrix,
                                a: *const ColumnVector) -> ComplexMatrix;
}
extern "C" {
    #[link_name = "?stack@ComplexMatrix@@QEBA?AV1@AEBVDiagMatrix@@@Z"]
    pub fn ComplexMatrix_stack3(this: *const ComplexMatrix,
                                a: *const DiagMatrix) -> ComplexMatrix;
}
extern "C" {
    #[link_name = "?stack@ComplexMatrix@@QEBA?AV1@AEBV1@@Z"]
    pub fn ComplexMatrix_stack4(this: *const ComplexMatrix,
                                a: *const ComplexMatrix) -> ComplexMatrix;
}
extern "C" {
    #[link_name = "?stack@ComplexMatrix@@QEBA?AV1@AEBVComplexRowVector@@@Z"]
    pub fn ComplexMatrix_stack5(this: *const ComplexMatrix,
                                a: *const ComplexRowVector) -> ComplexMatrix;
}
extern "C" {
    #[link_name =
          "?stack@ComplexMatrix@@QEBA?AV1@AEBVComplexColumnVector@@@Z"]
    pub fn ComplexMatrix_stack6(this: *const ComplexMatrix,
                                a: *const ComplexColumnVector)
     -> ComplexMatrix;
}
extern "C" {
    #[link_name = "?stack@ComplexMatrix@@QEBA?AV1@AEBVComplexDiagMatrix@@@Z"]
    pub fn ComplexMatrix_stack7(this: *const ComplexMatrix,
                                a: *const ComplexDiagMatrix) -> ComplexMatrix;
}
extern "C" {
    #[link_name = "?extract@ComplexMatrix@@QEBA?AV1@HHHH@Z"]
    pub fn ComplexMatrix_extract(this: *const ComplexMatrix,
                                 r1: octave_idx_type, c1: octave_idx_type,
                                 r2: octave_idx_type, c2: octave_idx_type)
     -> ComplexMatrix;
}
extern "C" {
    #[link_name = "?extract_n@ComplexMatrix@@QEBA?AV1@HHHH@Z"]
    pub fn ComplexMatrix_extract_n(this: *const ComplexMatrix,
                                   r1: octave_idx_type, c1: octave_idx_type,
                                   nr: octave_idx_type, nc: octave_idx_type)
     -> ComplexMatrix;
}
extern "C" {
    #[link_name = "?row@ComplexMatrix@@QEBA?AVComplexRowVector@@H@Z"]
    pub fn ComplexMatrix_row(this: *const ComplexMatrix, i: octave_idx_type)
     -> ComplexRowVector;
}
extern "C" {
    #[link_name = "?column@ComplexMatrix@@QEBA?AVComplexColumnVector@@H@Z"]
    pub fn ComplexMatrix_column(this: *const ComplexMatrix,
                                i: octave_idx_type) -> ComplexColumnVector;
}
extern "C" {
    #[link_name = "?inverse@ComplexMatrix@@QEBA?AV1@XZ"]
    pub fn ComplexMatrix_inverse(this: *const ComplexMatrix) -> ComplexMatrix;
}
extern "C" {
    #[link_name = "?inverse@ComplexMatrix@@QEBA?AV1@AEAH@Z"]
    pub fn ComplexMatrix_inverse1(this: *const ComplexMatrix,
                                  info: *mut octave_idx_type)
     -> ComplexMatrix;
}
extern "C" {
    #[link_name = "?inverse@ComplexMatrix@@QEBA?AV1@AEAHAEAN_N2@Z"]
    pub fn ComplexMatrix_inverse2(this: *const ComplexMatrix,
                                  info: *mut octave_idx_type, rcon: *mut f64,
                                  force: bool, calc_cond: bool)
     -> ComplexMatrix;
}
extern "C" {
    #[link_name = "?inverse@ComplexMatrix@@QEBA?AV1@AEAVMatrixType@@@Z"]
    pub fn ComplexMatrix_inverse3(this: *const ComplexMatrix,
                                  mattype: *mut MatrixType) -> ComplexMatrix;
}
extern "C" {
    #[link_name = "?inverse@ComplexMatrix@@QEBA?AV1@AEAVMatrixType@@AEAH@Z"]
    pub fn ComplexMatrix_inverse4(this: *const ComplexMatrix,
                                  mattype: *mut MatrixType,
                                  info: *mut octave_idx_type)
     -> ComplexMatrix;
}
extern "C" {
    #[link_name =
          "?inverse@ComplexMatrix@@QEBA?AV1@AEAVMatrixType@@AEAHAEAN_N3@Z"]
    pub fn ComplexMatrix_inverse5(this: *const ComplexMatrix,
                                  mattype: *mut MatrixType,
                                  info: *mut octave_idx_type, rcon: *mut f64,
                                  force: bool, calc_cond: bool)
     -> ComplexMatrix;
}
extern "C" {
    #[link_name = "?pseudo_inverse@ComplexMatrix@@QEBA?AV1@N@Z"]
    pub fn ComplexMatrix_pseudo_inverse(this: *const ComplexMatrix, tol: f64)
     -> ComplexMatrix;
}
extern "C" {
    #[link_name = "?fourier@ComplexMatrix@@QEBA?AV1@XZ"]
    pub fn ComplexMatrix_fourier(this: *const ComplexMatrix) -> ComplexMatrix;
}
extern "C" {
    #[link_name = "?ifourier@ComplexMatrix@@QEBA?AV1@XZ"]
    pub fn ComplexMatrix_ifourier(this: *const ComplexMatrix)
     -> ComplexMatrix;
}
extern "C" {
    #[link_name = "?fourier2d@ComplexMatrix@@QEBA?AV1@XZ"]
    pub fn ComplexMatrix_fourier2d(this: *const ComplexMatrix)
     -> ComplexMatrix;
}
extern "C" {
    #[link_name = "?ifourier2d@ComplexMatrix@@QEBA?AV1@XZ"]
    pub fn ComplexMatrix_ifourier2d(this: *const ComplexMatrix)
     -> ComplexMatrix;
}
extern "C" {
    #[link_name =
          "?determinant@ComplexMatrix@@QEBA?AV?$base_det@U?$complex@N@std@@@@XZ"]
    pub fn ComplexMatrix_determinant(this: *const ComplexMatrix)
     -> ComplexDET;
}
extern "C" {
    #[link_name =
          "?determinant@ComplexMatrix@@QEBA?AV?$base_det@U?$complex@N@std@@@@AEAH@Z"]
    pub fn ComplexMatrix_determinant1(this: *const ComplexMatrix,
                                      info: *mut octave_idx_type)
     -> ComplexDET;
}
extern "C" {
    #[link_name =
          "?determinant@ComplexMatrix@@QEBA?AV?$base_det@U?$complex@N@std@@@@AEAHAEAN_N@Z"]
    pub fn ComplexMatrix_determinant2(this: *const ComplexMatrix,
                                      info: *mut octave_idx_type,
                                      rcon: *mut f64, calc_cond: bool)
     -> ComplexDET;
}
extern "C" {
    #[link_name =
          "?determinant@ComplexMatrix@@QEBA?AV?$base_det@U?$complex@N@std@@@@AEAVMatrixType@@AEAHAEAN_N@Z"]
    pub fn ComplexMatrix_determinant3(this: *const ComplexMatrix,
                                      mattype: *mut MatrixType,
                                      info: *mut octave_idx_type,
                                      rcon: *mut f64, calc_cond: bool)
     -> ComplexDET;
}
extern "C" {
    #[link_name = "?rcond@ComplexMatrix@@QEBANXZ"]
    pub fn ComplexMatrix_rcond(this: *const ComplexMatrix) -> f64;
}
extern "C" {
    #[link_name = "?rcond@ComplexMatrix@@QEBANAEAVMatrixType@@@Z"]
    pub fn ComplexMatrix_rcond1(this: *const ComplexMatrix,
                                mattype: *mut MatrixType) -> f64;
}
extern "C" {
    #[link_name =
          "?solve@ComplexMatrix@@QEBA?AV1@AEAVMatrixType@@AEBVMatrix@@@Z"]
    pub fn ComplexMatrix_solve(this: *const ComplexMatrix,
                               typ: *mut MatrixType, b: *const Matrix)
     -> ComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@ComplexMatrix@@QEBA?AV1@AEAVMatrixType@@AEBVMatrix@@AEAH@Z"]
    pub fn ComplexMatrix_solve1(this: *const ComplexMatrix,
                                typ: *mut MatrixType, b: *const Matrix,
                                info: *mut octave_idx_type) -> ComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@ComplexMatrix@@QEBA?AV1@AEAVMatrixType@@AEBVMatrix@@AEAHAEAN@Z"]
    pub fn ComplexMatrix_solve2(this: *const ComplexMatrix,
                                typ: *mut MatrixType, b: *const Matrix,
                                info: *mut octave_idx_type, rcon: *mut f64)
     -> ComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@ComplexMatrix@@QEBA?AV1@AEAVMatrixType@@AEBVMatrix@@AEAHAEANP6AXN@Z_NW4blas_trans_type@@@Z"]
    pub fn ComplexMatrix_solve3(this: *const ComplexMatrix,
                                typ: *mut MatrixType, b: *const Matrix,
                                info: *mut octave_idx_type, rcon: *mut f64,
                                sing_handler:
                                    ComplexMatrix_solve_singularity_handler,
                                singular_fallback: bool,
                                transt: blas_trans_type) -> ComplexMatrix;
}
extern "C" {
    #[link_name = "?solve@ComplexMatrix@@QEBA?AV1@AEAVMatrixType@@AEBV1@@Z"]
    pub fn ComplexMatrix_solve4(this: *const ComplexMatrix,
                                typ: *mut MatrixType, b: *const ComplexMatrix)
     -> ComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@ComplexMatrix@@QEBA?AV1@AEAVMatrixType@@AEBV1@AEAH@Z"]
    pub fn ComplexMatrix_solve5(this: *const ComplexMatrix,
                                typ: *mut MatrixType, b: *const ComplexMatrix,
                                info: *mut octave_idx_type) -> ComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@ComplexMatrix@@QEBA?AV1@AEAVMatrixType@@AEBV1@AEAHAEAN@Z"]
    pub fn ComplexMatrix_solve6(this: *const ComplexMatrix,
                                typ: *mut MatrixType, b: *const ComplexMatrix,
                                info: *mut octave_idx_type, rcon: *mut f64)
     -> ComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@ComplexMatrix@@QEBA?AV1@AEAVMatrixType@@AEBV1@AEAHAEANP6AXN@Z_NW4blas_trans_type@@@Z"]
    pub fn ComplexMatrix_solve7(this: *const ComplexMatrix,
                                typ: *mut MatrixType, b: *const ComplexMatrix,
                                info: *mut octave_idx_type, rcon: *mut f64,
                                sing_handler:
                                    ComplexMatrix_solve_singularity_handler,
                                singular_fallback: bool,
                                transt: blas_trans_type) -> ComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@ComplexMatrix@@QEBA?AVComplexColumnVector@@AEAVMatrixType@@AEBVColumnVector@@@Z"]
    pub fn ComplexMatrix_solve8(this: *const ComplexMatrix,
                                typ: *mut MatrixType, b: *const ColumnVector)
     -> ComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@ComplexMatrix@@QEBA?AVComplexColumnVector@@AEAVMatrixType@@AEBVColumnVector@@AEAH@Z"]
    pub fn ComplexMatrix_solve9(this: *const ComplexMatrix,
                                typ: *mut MatrixType, b: *const ColumnVector,
                                info: *mut octave_idx_type)
     -> ComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@ComplexMatrix@@QEBA?AVComplexColumnVector@@AEAVMatrixType@@AEBVColumnVector@@AEAHAEAN@Z"]
    pub fn ComplexMatrix_solve10(this: *const ComplexMatrix,
                                 typ: *mut MatrixType, b: *const ColumnVector,
                                 info: *mut octave_idx_type, rcon: *mut f64)
     -> ComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@ComplexMatrix@@QEBA?AVComplexColumnVector@@AEAVMatrixType@@AEBVColumnVector@@AEAHAEANP6AXN@ZW4blas_trans_type@@@Z"]
    pub fn ComplexMatrix_solve11(this: *const ComplexMatrix,
                                 typ: *mut MatrixType, b: *const ColumnVector,
                                 info: *mut octave_idx_type, rcon: *mut f64,
                                 sing_handler:
                                     ComplexMatrix_solve_singularity_handler,
                                 transt: blas_trans_type)
     -> ComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@ComplexMatrix@@QEBA?AVComplexColumnVector@@AEAVMatrixType@@AEBV2@@Z"]
    pub fn ComplexMatrix_solve12(this: *const ComplexMatrix,
                                 typ: *mut MatrixType,
                                 b: *const ComplexColumnVector)
     -> ComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@ComplexMatrix@@QEBA?AVComplexColumnVector@@AEAVMatrixType@@AEBV2@AEAH@Z"]
    pub fn ComplexMatrix_solve13(this: *const ComplexMatrix,
                                 typ: *mut MatrixType,
                                 b: *const ComplexColumnVector,
                                 info: *mut octave_idx_type)
     -> ComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@ComplexMatrix@@QEBA?AVComplexColumnVector@@AEAVMatrixType@@AEBV2@AEAHAEAN@Z"]
    pub fn ComplexMatrix_solve14(this: *const ComplexMatrix,
                                 typ: *mut MatrixType,
                                 b: *const ComplexColumnVector,
                                 info: *mut octave_idx_type, rcon: *mut f64)
     -> ComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@ComplexMatrix@@QEBA?AVComplexColumnVector@@AEAVMatrixType@@AEBV2@AEAHAEANP6AXN@ZW4blas_trans_type@@@Z"]
    pub fn ComplexMatrix_solve15(this: *const ComplexMatrix,
                                 typ: *mut MatrixType,
                                 b: *const ComplexColumnVector,
                                 info: *mut octave_idx_type, rcon: *mut f64,
                                 sing_handler:
                                     ComplexMatrix_solve_singularity_handler,
                                 transt: blas_trans_type)
     -> ComplexColumnVector;
}
extern "C" {
    #[link_name = "?solve@ComplexMatrix@@QEBA?AV1@AEBVMatrix@@@Z"]
    pub fn ComplexMatrix_solve16(this: *const ComplexMatrix, b: *const Matrix)
     -> ComplexMatrix;
}
extern "C" {
    #[link_name = "?solve@ComplexMatrix@@QEBA?AV1@AEBVMatrix@@AEAH@Z"]
    pub fn ComplexMatrix_solve17(this: *const ComplexMatrix, b: *const Matrix,
                                 info: *mut octave_idx_type) -> ComplexMatrix;
}
extern "C" {
    #[link_name = "?solve@ComplexMatrix@@QEBA?AV1@AEBVMatrix@@AEAHAEAN@Z"]
    pub fn ComplexMatrix_solve18(this: *const ComplexMatrix, b: *const Matrix,
                                 info: *mut octave_idx_type, rcon: *mut f64)
     -> ComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@ComplexMatrix@@QEBA?AV1@AEBVMatrix@@AEAHAEANP6AXN@ZW4blas_trans_type@@@Z"]
    pub fn ComplexMatrix_solve19(this: *const ComplexMatrix, b: *const Matrix,
                                 info: *mut octave_idx_type, rcon: *mut f64,
                                 sing_handler:
                                     ComplexMatrix_solve_singularity_handler,
                                 transt: blas_trans_type) -> ComplexMatrix;
}
extern "C" {
    #[link_name = "?solve@ComplexMatrix@@QEBA?AV1@AEBV1@@Z"]
    pub fn ComplexMatrix_solve20(this: *const ComplexMatrix,
                                 b: *const ComplexMatrix) -> ComplexMatrix;
}
extern "C" {
    #[link_name = "?solve@ComplexMatrix@@QEBA?AV1@AEBV1@AEAH@Z"]
    pub fn ComplexMatrix_solve21(this: *const ComplexMatrix,
                                 b: *const ComplexMatrix,
                                 info: *mut octave_idx_type) -> ComplexMatrix;
}
extern "C" {
    #[link_name = "?solve@ComplexMatrix@@QEBA?AV1@AEBV1@AEAHAEAN@Z"]
    pub fn ComplexMatrix_solve22(this: *const ComplexMatrix,
                                 b: *const ComplexMatrix,
                                 info: *mut octave_idx_type, rcon: *mut f64)
     -> ComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@ComplexMatrix@@QEBA?AV1@AEBV1@AEAHAEANP6AXN@ZW4blas_trans_type@@@Z"]
    pub fn ComplexMatrix_solve23(this: *const ComplexMatrix,
                                 b: *const ComplexMatrix,
                                 info: *mut octave_idx_type, rcon: *mut f64,
                                 sing_handler:
                                     ComplexMatrix_solve_singularity_handler,
                                 transt: blas_trans_type) -> ComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@ComplexMatrix@@QEBA?AVComplexColumnVector@@AEBVColumnVector@@@Z"]
    pub fn ComplexMatrix_solve24(this: *const ComplexMatrix,
                                 b: *const ColumnVector)
     -> ComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@ComplexMatrix@@QEBA?AVComplexColumnVector@@AEBVColumnVector@@AEAH@Z"]
    pub fn ComplexMatrix_solve25(this: *const ComplexMatrix,
                                 b: *const ColumnVector,
                                 info: *mut octave_idx_type)
     -> ComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@ComplexMatrix@@QEBA?AVComplexColumnVector@@AEBVColumnVector@@AEAHAEAN@Z"]
    pub fn ComplexMatrix_solve26(this: *const ComplexMatrix,
                                 b: *const ColumnVector,
                                 info: *mut octave_idx_type, rcon: *mut f64)
     -> ComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@ComplexMatrix@@QEBA?AVComplexColumnVector@@AEBVColumnVector@@AEAHAEANP6AXN@ZW4blas_trans_type@@@Z"]
    pub fn ComplexMatrix_solve27(this: *const ComplexMatrix,
                                 b: *const ColumnVector,
                                 info: *mut octave_idx_type, rcon: *mut f64,
                                 sing_handler:
                                     ComplexMatrix_solve_singularity_handler,
                                 transt: blas_trans_type)
     -> ComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@ComplexMatrix@@QEBA?AVComplexColumnVector@@AEBV2@@Z"]
    pub fn ComplexMatrix_solve28(this: *const ComplexMatrix,
                                 b: *const ComplexColumnVector)
     -> ComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@ComplexMatrix@@QEBA?AVComplexColumnVector@@AEBV2@AEAH@Z"]
    pub fn ComplexMatrix_solve29(this: *const ComplexMatrix,
                                 b: *const ComplexColumnVector,
                                 info: *mut octave_idx_type)
     -> ComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@ComplexMatrix@@QEBA?AVComplexColumnVector@@AEBV2@AEAHAEAN@Z"]
    pub fn ComplexMatrix_solve30(this: *const ComplexMatrix,
                                 b: *const ComplexColumnVector,
                                 info: *mut octave_idx_type, rcon: *mut f64)
     -> ComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@ComplexMatrix@@QEBA?AVComplexColumnVector@@AEBV2@AEAHAEANP6AXN@ZW4blas_trans_type@@@Z"]
    pub fn ComplexMatrix_solve31(this: *const ComplexMatrix,
                                 b: *const ComplexColumnVector,
                                 info: *mut octave_idx_type, rcon: *mut f64,
                                 sing_handler:
                                     ComplexMatrix_solve_singularity_handler,
                                 transt: blas_trans_type)
     -> ComplexColumnVector;
}
extern "C" {
    #[link_name = "?lssolve@ComplexMatrix@@QEBA?AV1@AEBVMatrix@@@Z"]
    pub fn ComplexMatrix_lssolve(this: *const ComplexMatrix, b: *const Matrix)
     -> ComplexMatrix;
}
extern "C" {
    #[link_name = "?lssolve@ComplexMatrix@@QEBA?AV1@AEBVMatrix@@AEAH@Z"]
    pub fn ComplexMatrix_lssolve1(this: *const ComplexMatrix,
                                  b: *const Matrix,
                                  info: *mut octave_idx_type)
     -> ComplexMatrix;
}
extern "C" {
    #[link_name = "?lssolve@ComplexMatrix@@QEBA?AV1@AEBVMatrix@@AEAH1@Z"]
    pub fn ComplexMatrix_lssolve2(this: *const ComplexMatrix,
                                  b: *const Matrix,
                                  info: *mut octave_idx_type,
                                  rank: *mut octave_idx_type)
     -> ComplexMatrix;
}
extern "C" {
    #[link_name = "?lssolve@ComplexMatrix@@QEBA?AV1@AEBVMatrix@@AEAH1AEAN@Z"]
    pub fn ComplexMatrix_lssolve3(this: *const ComplexMatrix,
                                  b: *const Matrix,
                                  info: *mut octave_idx_type,
                                  rank: *mut octave_idx_type, rcon: *mut f64)
     -> ComplexMatrix;
}
extern "C" {
    #[link_name = "?lssolve@ComplexMatrix@@QEBA?AV1@AEBV1@@Z"]
    pub fn ComplexMatrix_lssolve4(this: *const ComplexMatrix,
                                  b: *const ComplexMatrix) -> ComplexMatrix;
}
extern "C" {
    #[link_name = "?lssolve@ComplexMatrix@@QEBA?AV1@AEBV1@AEAH@Z"]
    pub fn ComplexMatrix_lssolve5(this: *const ComplexMatrix,
                                  b: *const ComplexMatrix,
                                  info: *mut octave_idx_type)
     -> ComplexMatrix;
}
extern "C" {
    #[link_name = "?lssolve@ComplexMatrix@@QEBA?AV1@AEBV1@AEAH1@Z"]
    pub fn ComplexMatrix_lssolve6(this: *const ComplexMatrix,
                                  b: *const ComplexMatrix,
                                  info: *mut octave_idx_type,
                                  rank: *mut octave_idx_type)
     -> ComplexMatrix;
}
extern "C" {
    #[link_name = "?lssolve@ComplexMatrix@@QEBA?AV1@AEBV1@AEAH1AEAN@Z"]
    pub fn ComplexMatrix_lssolve7(this: *const ComplexMatrix,
                                  b: *const ComplexMatrix,
                                  info: *mut octave_idx_type,
                                  rank: *mut octave_idx_type, rcon: *mut f64)
     -> ComplexMatrix;
}
extern "C" {
    #[link_name =
          "?lssolve@ComplexMatrix@@QEBA?AVComplexColumnVector@@AEBVColumnVector@@@Z"]
    pub fn ComplexMatrix_lssolve8(this: *const ComplexMatrix,
                                  b: *const ColumnVector)
     -> ComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?lssolve@ComplexMatrix@@QEBA?AVComplexColumnVector@@AEBVColumnVector@@AEAH@Z"]
    pub fn ComplexMatrix_lssolve9(this: *const ComplexMatrix,
                                  b: *const ColumnVector,
                                  info: *mut octave_idx_type)
     -> ComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?lssolve@ComplexMatrix@@QEBA?AVComplexColumnVector@@AEBVColumnVector@@AEAH1@Z"]
    pub fn ComplexMatrix_lssolve10(this: *const ComplexMatrix,
                                   b: *const ColumnVector,
                                   info: *mut octave_idx_type,
                                   rank: *mut octave_idx_type)
     -> ComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?lssolve@ComplexMatrix@@QEBA?AVComplexColumnVector@@AEBVColumnVector@@AEAH1AEAN@Z"]
    pub fn ComplexMatrix_lssolve11(this: *const ComplexMatrix,
                                   b: *const ColumnVector,
                                   info: *mut octave_idx_type,
                                   rank: *mut octave_idx_type, rcon: *mut f64)
     -> ComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?lssolve@ComplexMatrix@@QEBA?AVComplexColumnVector@@AEBV2@@Z"]
    pub fn ComplexMatrix_lssolve12(this: *const ComplexMatrix,
                                   b: *const ComplexColumnVector)
     -> ComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?lssolve@ComplexMatrix@@QEBA?AVComplexColumnVector@@AEBV2@AEAH@Z"]
    pub fn ComplexMatrix_lssolve13(this: *const ComplexMatrix,
                                   b: *const ComplexColumnVector,
                                   info: *mut octave_idx_type)
     -> ComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?lssolve@ComplexMatrix@@QEBA?AVComplexColumnVector@@AEBV2@AEAH1@Z"]
    pub fn ComplexMatrix_lssolve14(this: *const ComplexMatrix,
                                   b: *const ComplexColumnVector,
                                   info: *mut octave_idx_type,
                                   rank: *mut octave_idx_type)
     -> ComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?lssolve@ComplexMatrix@@QEBA?AVComplexColumnVector@@AEBV2@AEAH1AEAN@Z"]
    pub fn ComplexMatrix_lssolve15(this: *const ComplexMatrix,
                                   b: *const ComplexColumnVector,
                                   info: *mut octave_idx_type,
                                   rank: *mut octave_idx_type, rcon: *mut f64)
     -> ComplexColumnVector;
}
extern "C" {
    #[link_name = "?all@ComplexMatrix@@QEBA?AVboolMatrix@@H@Z"]
    pub fn ComplexMatrix_all(this: *const ComplexMatrix,
                             dim: ::std::os::raw::c_int) -> boolMatrix;
}
extern "C" {
    #[link_name = "?any@ComplexMatrix@@QEBA?AVboolMatrix@@H@Z"]
    pub fn ComplexMatrix_any(this: *const ComplexMatrix,
                             dim: ::std::os::raw::c_int) -> boolMatrix;
}
extern "C" {
    #[link_name = "?cumprod@ComplexMatrix@@QEBA?AV1@H@Z"]
    pub fn ComplexMatrix_cumprod(this: *const ComplexMatrix,
                                 dim: ::std::os::raw::c_int) -> ComplexMatrix;
}
extern "C" {
    #[link_name = "?cumsum@ComplexMatrix@@QEBA?AV1@H@Z"]
    pub fn ComplexMatrix_cumsum(this: *const ComplexMatrix,
                                dim: ::std::os::raw::c_int) -> ComplexMatrix;
}
extern "C" {
    #[link_name = "?prod@ComplexMatrix@@QEBA?AV1@H@Z"]
    pub fn ComplexMatrix_prod(this: *const ComplexMatrix,
                              dim: ::std::os::raw::c_int) -> ComplexMatrix;
}
extern "C" {
    #[link_name = "?sum@ComplexMatrix@@QEBA?AV1@H@Z"]
    pub fn ComplexMatrix_sum(this: *const ComplexMatrix,
                             dim: ::std::os::raw::c_int) -> ComplexMatrix;
}
extern "C" {
    #[link_name = "?sumsq@ComplexMatrix@@QEBA?AV1@H@Z"]
    pub fn ComplexMatrix_sumsq(this: *const ComplexMatrix,
                               dim: ::std::os::raw::c_int) -> ComplexMatrix;
}
extern "C" {
    #[link_name = "?abs@ComplexMatrix@@QEBA?AVMatrix@@XZ"]
    pub fn ComplexMatrix_abs(this: *const ComplexMatrix) -> Matrix;
}
extern "C" {
    #[link_name = "?diag@ComplexMatrix@@QEBA?AV1@H@Z"]
    pub fn ComplexMatrix_diag(this: *const ComplexMatrix, k: octave_idx_type)
     -> ComplexMatrix;
}
extern "C" {
    #[link_name = "?diag@ComplexMatrix@@QEBA?AVComplexDiagMatrix@@HH@Z"]
    pub fn ComplexMatrix_diag1(this: *const ComplexMatrix, m: octave_idx_type,
                               n: octave_idx_type) -> ComplexDiagMatrix;
}
extern "C" {
    #[link_name = "?row_is_real_only@ComplexMatrix@@QEBA_NH@Z"]
    pub fn ComplexMatrix_row_is_real_only(this: *const ComplexMatrix,
                                          arg1: octave_idx_type) -> bool;
}
extern "C" {
    #[link_name = "?column_is_real_only@ComplexMatrix@@QEBA_NH@Z"]
    pub fn ComplexMatrix_column_is_real_only(this: *const ComplexMatrix,
                                             arg1: octave_idx_type) -> bool;
}
extern "C" {
    #[link_name = "?row_min@ComplexMatrix@@QEBA?AVComplexColumnVector@@XZ"]
    pub fn ComplexMatrix_row_min(this: *const ComplexMatrix)
     -> ComplexColumnVector;
}
extern "C" {
    #[link_name = "?row_max@ComplexMatrix@@QEBA?AVComplexColumnVector@@XZ"]
    pub fn ComplexMatrix_row_max(this: *const ComplexMatrix)
     -> ComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?row_min@ComplexMatrix@@QEBA?AVComplexColumnVector@@AEAV?$Array@H@@@Z"]
    pub fn ComplexMatrix_row_min1(this: *const ComplexMatrix,
                                  index: *mut Array<::std::os::raw::c_int>)
     -> ComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?row_max@ComplexMatrix@@QEBA?AVComplexColumnVector@@AEAV?$Array@H@@@Z"]
    pub fn ComplexMatrix_row_max1(this: *const ComplexMatrix,
                                  index: *mut Array<::std::os::raw::c_int>)
     -> ComplexColumnVector;
}
extern "C" {
    #[link_name = "?column_min@ComplexMatrix@@QEBA?AVComplexRowVector@@XZ"]
    pub fn ComplexMatrix_column_min(this: *const ComplexMatrix)
     -> ComplexRowVector;
}
extern "C" {
    #[link_name = "?column_max@ComplexMatrix@@QEBA?AVComplexRowVector@@XZ"]
    pub fn ComplexMatrix_column_max(this: *const ComplexMatrix)
     -> ComplexRowVector;
}
extern "C" {
    #[link_name =
          "?column_min@ComplexMatrix@@QEBA?AVComplexRowVector@@AEAV?$Array@H@@@Z"]
    pub fn ComplexMatrix_column_min1(this: *const ComplexMatrix,
                                     index: *mut Array<::std::os::raw::c_int>)
     -> ComplexRowVector;
}
extern "C" {
    #[link_name =
          "?column_max@ComplexMatrix@@QEBA?AVComplexRowVector@@AEAV?$Array@H@@@Z"]
    pub fn ComplexMatrix_column_max1(this: *const ComplexMatrix,
                                     index: *mut Array<::std::os::raw::c_int>)
     -> ComplexRowVector;
}
extern "C" {
    #[link_name = "??0ComplexMatrix@@QEAA@AEBVMatrix@@0@Z"]
    pub fn ComplexMatrix_ComplexMatrix(this: *mut ComplexMatrix,
                                       re: *const Matrix, im: *const Matrix);
}
extern "C" {
    #[link_name = "??0ComplexMatrix@@QEAA@AEBVMatrix@@@Z"]
    pub fn ComplexMatrix_ComplexMatrix1(this: *mut ComplexMatrix,
                                        a: *const Matrix);
}
extern "C" {
    #[link_name = "??0ComplexMatrix@@QEAA@AEBVRowVector@@@Z"]
    pub fn ComplexMatrix_ComplexMatrix2(this: *mut ComplexMatrix,
                                        rv: *const RowVector);
}
extern "C" {
    #[link_name = "??0ComplexMatrix@@QEAA@AEBVColumnVector@@@Z"]
    pub fn ComplexMatrix_ComplexMatrix3(this: *mut ComplexMatrix,
                                        cv: *const ColumnVector);
}
extern "C" {
    #[link_name = "??0ComplexMatrix@@QEAA@AEBVDiagMatrix@@@Z"]
    pub fn ComplexMatrix_ComplexMatrix4(this: *mut ComplexMatrix,
                                        a: *const DiagMatrix);
}
extern "C" {
    #[link_name = "??0ComplexMatrix@@QEAA@AEBV?$MDiagArray2@N@@@Z"]
    pub fn ComplexMatrix_ComplexMatrix5(this: *mut ComplexMatrix,
                                        a: *const MDiagArray2<f64>);
}
extern "C" {
    #[link_name = "??0ComplexMatrix@@QEAA@AEBV?$DiagArray2@N@@@Z"]
    pub fn ComplexMatrix_ComplexMatrix6(this: *mut ComplexMatrix,
                                        a: *const DiagArray2<f64>);
}
extern "C" {
    #[link_name = "??0ComplexMatrix@@QEAA@AEBVComplexRowVector@@@Z"]
    pub fn ComplexMatrix_ComplexMatrix7(this: *mut ComplexMatrix,
                                        rv: *const ComplexRowVector);
}
extern "C" {
    #[link_name = "??0ComplexMatrix@@QEAA@AEBVComplexColumnVector@@@Z"]
    pub fn ComplexMatrix_ComplexMatrix8(this: *mut ComplexMatrix,
                                        cv: *const ComplexColumnVector);
}
extern "C" {
    #[link_name = "??0ComplexMatrix@@QEAA@AEBVComplexDiagMatrix@@@Z"]
    pub fn ComplexMatrix_ComplexMatrix9(this: *mut ComplexMatrix,
                                        a: *const ComplexDiagMatrix);
}
extern "C" {
    #[link_name =
          "??0ComplexMatrix@@QEAA@AEBV?$MDiagArray2@U?$complex@N@std@@@@@Z"]
    pub fn ComplexMatrix_ComplexMatrix10(this: *mut ComplexMatrix,
                                         a:
                                             *const MDiagArray2<std_complex<f64>>);
}
extern "C" {
    #[link_name =
          "??0ComplexMatrix@@QEAA@AEBV?$DiagArray2@U?$complex@N@std@@@@@Z"]
    pub fn ComplexMatrix_ComplexMatrix11(this: *mut ComplexMatrix,
                                         a:
                                             *const DiagArray2<std_complex<f64>>);
}
extern "C" {
    #[link_name = "??0ComplexMatrix@@QEAA@AEBVboolMatrix@@@Z"]
    pub fn ComplexMatrix_ComplexMatrix12(this: *mut ComplexMatrix,
                                         a: *const boolMatrix);
}
extern "C" {
    #[link_name = "??0ComplexMatrix@@QEAA@AEBVcharMatrix@@@Z"]
    pub fn ComplexMatrix_ComplexMatrix13(this: *mut ComplexMatrix,
                                         a: *const charMatrix);
}
impl ComplexMatrix {
    #[inline]
    pub unsafe fn is_hermitian(&self) -> bool {
        ComplexMatrix_is_hermitian(self)
    }
    #[inline]
    pub unsafe fn insert(&mut self, a: *const Matrix, r: octave_idx_type,
                         c: octave_idx_type) -> *mut ComplexMatrix {
        ComplexMatrix_insert(self, a, r, c)
    }
    #[inline]
    pub unsafe fn insert1(&mut self, a: *const RowVector, r: octave_idx_type,
                          c: octave_idx_type) -> *mut ComplexMatrix {
        ComplexMatrix_insert1(self, a, r, c)
    }
    #[inline]
    pub unsafe fn insert2(&mut self, a: *const ColumnVector,
                          r: octave_idx_type, c: octave_idx_type)
     -> *mut ComplexMatrix {
        ComplexMatrix_insert2(self, a, r, c)
    }
    #[inline]
    pub unsafe fn insert3(&mut self, a: *const DiagMatrix, r: octave_idx_type,
                          c: octave_idx_type) -> *mut ComplexMatrix {
        ComplexMatrix_insert3(self, a, r, c)
    }
    #[inline]
    pub unsafe fn insert4(&mut self, a: *const ComplexMatrix,
                          r: octave_idx_type, c: octave_idx_type)
     -> *mut ComplexMatrix {
        ComplexMatrix_insert4(self, a, r, c)
    }
    #[inline]
    pub unsafe fn insert5(&mut self, a: *const ComplexRowVector,
                          r: octave_idx_type, c: octave_idx_type)
     -> *mut ComplexMatrix {
        ComplexMatrix_insert5(self, a, r, c)
    }
    #[inline]
    pub unsafe fn insert6(&mut self, a: *const ComplexColumnVector,
                          r: octave_idx_type, c: octave_idx_type)
     -> *mut ComplexMatrix {
        ComplexMatrix_insert6(self, a, r, c)
    }
    #[inline]
    pub unsafe fn insert7(&mut self, a: *const ComplexDiagMatrix,
                          r: octave_idx_type, c: octave_idx_type)
     -> *mut ComplexMatrix {
        ComplexMatrix_insert7(self, a, r, c)
    }
    #[inline]
    pub unsafe fn fill(&mut self, val: f64) -> *mut ComplexMatrix {
        ComplexMatrix_fill(self, val)
    }
    #[inline]
    pub unsafe fn fill1(&mut self, val: *const Complex)
     -> *mut ComplexMatrix {
        ComplexMatrix_fill1(self, val)
    }
    #[inline]
    pub unsafe fn fill2(&mut self, val: f64, r1: octave_idx_type,
                        c1: octave_idx_type, r2: octave_idx_type,
                        c2: octave_idx_type) -> *mut ComplexMatrix {
        ComplexMatrix_fill2(self, val, r1, c1, r2, c2)
    }
    #[inline]
    pub unsafe fn fill3(&mut self, val: *const Complex, r1: octave_idx_type,
                        c1: octave_idx_type, r2: octave_idx_type,
                        c2: octave_idx_type) -> *mut ComplexMatrix {
        ComplexMatrix_fill3(self, val, r1, c1, r2, c2)
    }
    #[inline]
    pub unsafe fn append(&self, a: *const Matrix) -> ComplexMatrix {
        ComplexMatrix_append(self, a)
    }
    #[inline]
    pub unsafe fn append1(&self, a: *const RowVector) -> ComplexMatrix {
        ComplexMatrix_append1(self, a)
    }
    #[inline]
    pub unsafe fn append2(&self, a: *const ColumnVector) -> ComplexMatrix {
        ComplexMatrix_append2(self, a)
    }
    #[inline]
    pub unsafe fn append3(&self, a: *const DiagMatrix) -> ComplexMatrix {
        ComplexMatrix_append3(self, a)
    }
    #[inline]
    pub unsafe fn append4(&self, a: *const ComplexMatrix) -> ComplexMatrix {
        ComplexMatrix_append4(self, a)
    }
    #[inline]
    pub unsafe fn append5(&self, a: *const ComplexRowVector)
     -> ComplexMatrix {
        ComplexMatrix_append5(self, a)
    }
    #[inline]
    pub unsafe fn append6(&self, a: *const ComplexColumnVector)
     -> ComplexMatrix {
        ComplexMatrix_append6(self, a)
    }
    #[inline]
    pub unsafe fn append7(&self, a: *const ComplexDiagMatrix)
     -> ComplexMatrix {
        ComplexMatrix_append7(self, a)
    }
    #[inline]
    pub unsafe fn stack(&self, a: *const Matrix) -> ComplexMatrix {
        ComplexMatrix_stack(self, a)
    }
    #[inline]
    pub unsafe fn stack1(&self, a: *const RowVector) -> ComplexMatrix {
        ComplexMatrix_stack1(self, a)
    }
    #[inline]
    pub unsafe fn stack2(&self, a: *const ColumnVector) -> ComplexMatrix {
        ComplexMatrix_stack2(self, a)
    }
    #[inline]
    pub unsafe fn stack3(&self, a: *const DiagMatrix) -> ComplexMatrix {
        ComplexMatrix_stack3(self, a)
    }
    #[inline]
    pub unsafe fn stack4(&self, a: *const ComplexMatrix) -> ComplexMatrix {
        ComplexMatrix_stack4(self, a)
    }
    #[inline]
    pub unsafe fn stack5(&self, a: *const ComplexRowVector) -> ComplexMatrix {
        ComplexMatrix_stack5(self, a)
    }
    #[inline]
    pub unsafe fn stack6(&self, a: *const ComplexColumnVector)
     -> ComplexMatrix {
        ComplexMatrix_stack6(self, a)
    }
    #[inline]
    pub unsafe fn stack7(&self, a: *const ComplexDiagMatrix)
     -> ComplexMatrix {
        ComplexMatrix_stack7(self, a)
    }
    #[inline]
    pub unsafe fn extract(&self, r1: octave_idx_type, c1: octave_idx_type,
                          r2: octave_idx_type, c2: octave_idx_type)
     -> ComplexMatrix {
        ComplexMatrix_extract(self, r1, c1, r2, c2)
    }
    #[inline]
    pub unsafe fn extract_n(&self, r1: octave_idx_type, c1: octave_idx_type,
                            nr: octave_idx_type, nc: octave_idx_type)
     -> ComplexMatrix {
        ComplexMatrix_extract_n(self, r1, c1, nr, nc)
    }
    #[inline]
    pub unsafe fn row(&self, i: octave_idx_type) -> ComplexRowVector {
        ComplexMatrix_row(self, i)
    }
    #[inline]
    pub unsafe fn column(&self, i: octave_idx_type) -> ComplexColumnVector {
        ComplexMatrix_column(self, i)
    }
    #[inline]
    pub unsafe fn inverse(&self) -> ComplexMatrix {
        ComplexMatrix_inverse(self)
    }
    #[inline]
    pub unsafe fn inverse1(&self, info: *mut octave_idx_type)
     -> ComplexMatrix {
        ComplexMatrix_inverse1(self, info)
    }
    #[inline]
    pub unsafe fn inverse2(&self, info: *mut octave_idx_type, rcon: *mut f64,
                           force: bool, calc_cond: bool) -> ComplexMatrix {
        ComplexMatrix_inverse2(self, info, rcon, force, calc_cond)
    }
    #[inline]
    pub unsafe fn inverse3(&self, mattype: *mut MatrixType) -> ComplexMatrix {
        ComplexMatrix_inverse3(self, mattype)
    }
    #[inline]
    pub unsafe fn inverse4(&self, mattype: *mut MatrixType,
                           info: *mut octave_idx_type) -> ComplexMatrix {
        ComplexMatrix_inverse4(self, mattype, info)
    }
    #[inline]
    pub unsafe fn inverse5(&self, mattype: *mut MatrixType,
                           info: *mut octave_idx_type, rcon: *mut f64,
                           force: bool, calc_cond: bool) -> ComplexMatrix {
        ComplexMatrix_inverse5(self, mattype, info, rcon, force, calc_cond)
    }
    #[inline]
    pub unsafe fn pseudo_inverse(&self, tol: f64) -> ComplexMatrix {
        ComplexMatrix_pseudo_inverse(self, tol)
    }
    #[inline]
    pub unsafe fn fourier(&self) -> ComplexMatrix {
        ComplexMatrix_fourier(self)
    }
    #[inline]
    pub unsafe fn ifourier(&self) -> ComplexMatrix {
        ComplexMatrix_ifourier(self)
    }
    #[inline]
    pub unsafe fn fourier2d(&self) -> ComplexMatrix {
        ComplexMatrix_fourier2d(self)
    }
    #[inline]
    pub unsafe fn ifourier2d(&self) -> ComplexMatrix {
        ComplexMatrix_ifourier2d(self)
    }
    #[inline]
    pub unsafe fn determinant(&self) -> ComplexDET {
        ComplexMatrix_determinant(self)
    }
    #[inline]
    pub unsafe fn determinant1(&self, info: *mut octave_idx_type)
     -> ComplexDET {
        ComplexMatrix_determinant1(self, info)
    }
    #[inline]
    pub unsafe fn determinant2(&self, info: *mut octave_idx_type,
                               rcon: *mut f64, calc_cond: bool)
     -> ComplexDET {
        ComplexMatrix_determinant2(self, info, rcon, calc_cond)
    }
    #[inline]
    pub unsafe fn determinant3(&self, mattype: *mut MatrixType,
                               info: *mut octave_idx_type, rcon: *mut f64,
                               calc_cond: bool) -> ComplexDET {
        ComplexMatrix_determinant3(self, mattype, info, rcon, calc_cond)
    }
    #[inline]
    pub unsafe fn rcond(&self) -> f64 { ComplexMatrix_rcond(self) }
    #[inline]
    pub unsafe fn rcond1(&self, mattype: *mut MatrixType) -> f64 {
        ComplexMatrix_rcond1(self, mattype)
    }
    #[inline]
    pub unsafe fn solve(&self, typ: *mut MatrixType, b: *const Matrix)
     -> ComplexMatrix {
        ComplexMatrix_solve(self, typ, b)
    }
    #[inline]
    pub unsafe fn solve1(&self, typ: *mut MatrixType, b: *const Matrix,
                         info: *mut octave_idx_type) -> ComplexMatrix {
        ComplexMatrix_solve1(self, typ, b, info)
    }
    #[inline]
    pub unsafe fn solve2(&self, typ: *mut MatrixType, b: *const Matrix,
                         info: *mut octave_idx_type, rcon: *mut f64)
     -> ComplexMatrix {
        ComplexMatrix_solve2(self, typ, b, info, rcon)
    }
    #[inline]
    pub unsafe fn solve3(&self, typ: *mut MatrixType, b: *const Matrix,
                         info: *mut octave_idx_type, rcon: *mut f64,
                         sing_handler:
                             ComplexMatrix_solve_singularity_handler,
                         singular_fallback: bool, transt: blas_trans_type)
     -> ComplexMatrix {
        ComplexMatrix_solve3(self, typ, b, info, rcon, sing_handler,
                             singular_fallback, transt)
    }
    #[inline]
    pub unsafe fn solve4(&self, typ: *mut MatrixType, b: *const ComplexMatrix)
     -> ComplexMatrix {
        ComplexMatrix_solve4(self, typ, b)
    }
    #[inline]
    pub unsafe fn solve5(&self, typ: *mut MatrixType, b: *const ComplexMatrix,
                         info: *mut octave_idx_type) -> ComplexMatrix {
        ComplexMatrix_solve5(self, typ, b, info)
    }
    #[inline]
    pub unsafe fn solve6(&self, typ: *mut MatrixType, b: *const ComplexMatrix,
                         info: *mut octave_idx_type, rcon: *mut f64)
     -> ComplexMatrix {
        ComplexMatrix_solve6(self, typ, b, info, rcon)
    }
    #[inline]
    pub unsafe fn solve7(&self, typ: *mut MatrixType, b: *const ComplexMatrix,
                         info: *mut octave_idx_type, rcon: *mut f64,
                         sing_handler:
                             ComplexMatrix_solve_singularity_handler,
                         singular_fallback: bool, transt: blas_trans_type)
     -> ComplexMatrix {
        ComplexMatrix_solve7(self, typ, b, info, rcon, sing_handler,
                             singular_fallback, transt)
    }
    #[inline]
    pub unsafe fn solve8(&self, typ: *mut MatrixType, b: *const ColumnVector)
     -> ComplexColumnVector {
        ComplexMatrix_solve8(self, typ, b)
    }
    #[inline]
    pub unsafe fn solve9(&self, typ: *mut MatrixType, b: *const ColumnVector,
                         info: *mut octave_idx_type) -> ComplexColumnVector {
        ComplexMatrix_solve9(self, typ, b, info)
    }
    #[inline]
    pub unsafe fn solve10(&self, typ: *mut MatrixType, b: *const ColumnVector,
                          info: *mut octave_idx_type, rcon: *mut f64)
     -> ComplexColumnVector {
        ComplexMatrix_solve10(self, typ, b, info, rcon)
    }
    #[inline]
    pub unsafe fn solve11(&self, typ: *mut MatrixType, b: *const ColumnVector,
                          info: *mut octave_idx_type, rcon: *mut f64,
                          sing_handler:
                              ComplexMatrix_solve_singularity_handler,
                          transt: blas_trans_type) -> ComplexColumnVector {
        ComplexMatrix_solve11(self, typ, b, info, rcon, sing_handler, transt)
    }
    #[inline]
    pub unsafe fn solve12(&self, typ: *mut MatrixType,
                          b: *const ComplexColumnVector)
     -> ComplexColumnVector {
        ComplexMatrix_solve12(self, typ, b)
    }
    #[inline]
    pub unsafe fn solve13(&self, typ: *mut MatrixType,
                          b: *const ComplexColumnVector,
                          info: *mut octave_idx_type) -> ComplexColumnVector {
        ComplexMatrix_solve13(self, typ, b, info)
    }
    #[inline]
    pub unsafe fn solve14(&self, typ: *mut MatrixType,
                          b: *const ComplexColumnVector,
                          info: *mut octave_idx_type, rcon: *mut f64)
     -> ComplexColumnVector {
        ComplexMatrix_solve14(self, typ, b, info, rcon)
    }
    #[inline]
    pub unsafe fn solve15(&self, typ: *mut MatrixType,
                          b: *const ComplexColumnVector,
                          info: *mut octave_idx_type, rcon: *mut f64,
                          sing_handler:
                              ComplexMatrix_solve_singularity_handler,
                          transt: blas_trans_type) -> ComplexColumnVector {
        ComplexMatrix_solve15(self, typ, b, info, rcon, sing_handler, transt)
    }
    #[inline]
    pub unsafe fn solve16(&self, b: *const Matrix) -> ComplexMatrix {
        ComplexMatrix_solve16(self, b)
    }
    #[inline]
    pub unsafe fn solve17(&self, b: *const Matrix, info: *mut octave_idx_type)
     -> ComplexMatrix {
        ComplexMatrix_solve17(self, b, info)
    }
    #[inline]
    pub unsafe fn solve18(&self, b: *const Matrix, info: *mut octave_idx_type,
                          rcon: *mut f64) -> ComplexMatrix {
        ComplexMatrix_solve18(self, b, info, rcon)
    }
    #[inline]
    pub unsafe fn solve19(&self, b: *const Matrix, info: *mut octave_idx_type,
                          rcon: *mut f64,
                          sing_handler:
                              ComplexMatrix_solve_singularity_handler,
                          transt: blas_trans_type) -> ComplexMatrix {
        ComplexMatrix_solve19(self, b, info, rcon, sing_handler, transt)
    }
    #[inline]
    pub unsafe fn solve20(&self, b: *const ComplexMatrix) -> ComplexMatrix {
        ComplexMatrix_solve20(self, b)
    }
    #[inline]
    pub unsafe fn solve21(&self, b: *const ComplexMatrix,
                          info: *mut octave_idx_type) -> ComplexMatrix {
        ComplexMatrix_solve21(self, b, info)
    }
    #[inline]
    pub unsafe fn solve22(&self, b: *const ComplexMatrix,
                          info: *mut octave_idx_type, rcon: *mut f64)
     -> ComplexMatrix {
        ComplexMatrix_solve22(self, b, info, rcon)
    }
    #[inline]
    pub unsafe fn solve23(&self, b: *const ComplexMatrix,
                          info: *mut octave_idx_type, rcon: *mut f64,
                          sing_handler:
                              ComplexMatrix_solve_singularity_handler,
                          transt: blas_trans_type) -> ComplexMatrix {
        ComplexMatrix_solve23(self, b, info, rcon, sing_handler, transt)
    }
    #[inline]
    pub unsafe fn solve24(&self, b: *const ColumnVector)
     -> ComplexColumnVector {
        ComplexMatrix_solve24(self, b)
    }
    #[inline]
    pub unsafe fn solve25(&self, b: *const ColumnVector,
                          info: *mut octave_idx_type) -> ComplexColumnVector {
        ComplexMatrix_solve25(self, b, info)
    }
    #[inline]
    pub unsafe fn solve26(&self, b: *const ColumnVector,
                          info: *mut octave_idx_type, rcon: *mut f64)
     -> ComplexColumnVector {
        ComplexMatrix_solve26(self, b, info, rcon)
    }
    #[inline]
    pub unsafe fn solve27(&self, b: *const ColumnVector,
                          info: *mut octave_idx_type, rcon: *mut f64,
                          sing_handler:
                              ComplexMatrix_solve_singularity_handler,
                          transt: blas_trans_type) -> ComplexColumnVector {
        ComplexMatrix_solve27(self, b, info, rcon, sing_handler, transt)
    }
    #[inline]
    pub unsafe fn solve28(&self, b: *const ComplexColumnVector)
     -> ComplexColumnVector {
        ComplexMatrix_solve28(self, b)
    }
    #[inline]
    pub unsafe fn solve29(&self, b: *const ComplexColumnVector,
                          info: *mut octave_idx_type) -> ComplexColumnVector {
        ComplexMatrix_solve29(self, b, info)
    }
    #[inline]
    pub unsafe fn solve30(&self, b: *const ComplexColumnVector,
                          info: *mut octave_idx_type, rcon: *mut f64)
     -> ComplexColumnVector {
        ComplexMatrix_solve30(self, b, info, rcon)
    }
    #[inline]
    pub unsafe fn solve31(&self, b: *const ComplexColumnVector,
                          info: *mut octave_idx_type, rcon: *mut f64,
                          sing_handler:
                              ComplexMatrix_solve_singularity_handler,
                          transt: blas_trans_type) -> ComplexColumnVector {
        ComplexMatrix_solve31(self, b, info, rcon, sing_handler, transt)
    }
    #[inline]
    pub unsafe fn lssolve(&self, b: *const Matrix) -> ComplexMatrix {
        ComplexMatrix_lssolve(self, b)
    }
    #[inline]
    pub unsafe fn lssolve1(&self, b: *const Matrix,
                           info: *mut octave_idx_type) -> ComplexMatrix {
        ComplexMatrix_lssolve1(self, b, info)
    }
    #[inline]
    pub unsafe fn lssolve2(&self, b: *const Matrix,
                           info: *mut octave_idx_type,
                           rank: *mut octave_idx_type) -> ComplexMatrix {
        ComplexMatrix_lssolve2(self, b, info, rank)
    }
    #[inline]
    pub unsafe fn lssolve3(&self, b: *const Matrix,
                           info: *mut octave_idx_type,
                           rank: *mut octave_idx_type, rcon: *mut f64)
     -> ComplexMatrix {
        ComplexMatrix_lssolve3(self, b, info, rank, rcon)
    }
    #[inline]
    pub unsafe fn lssolve4(&self, b: *const ComplexMatrix) -> ComplexMatrix {
        ComplexMatrix_lssolve4(self, b)
    }
    #[inline]
    pub unsafe fn lssolve5(&self, b: *const ComplexMatrix,
                           info: *mut octave_idx_type) -> ComplexMatrix {
        ComplexMatrix_lssolve5(self, b, info)
    }
    #[inline]
    pub unsafe fn lssolve6(&self, b: *const ComplexMatrix,
                           info: *mut octave_idx_type,
                           rank: *mut octave_idx_type) -> ComplexMatrix {
        ComplexMatrix_lssolve6(self, b, info, rank)
    }
    #[inline]
    pub unsafe fn lssolve7(&self, b: *const ComplexMatrix,
                           info: *mut octave_idx_type,
                           rank: *mut octave_idx_type, rcon: *mut f64)
     -> ComplexMatrix {
        ComplexMatrix_lssolve7(self, b, info, rank, rcon)
    }
    #[inline]
    pub unsafe fn lssolve8(&self, b: *const ColumnVector)
     -> ComplexColumnVector {
        ComplexMatrix_lssolve8(self, b)
    }
    #[inline]
    pub unsafe fn lssolve9(&self, b: *const ColumnVector,
                           info: *mut octave_idx_type)
     -> ComplexColumnVector {
        ComplexMatrix_lssolve9(self, b, info)
    }
    #[inline]
    pub unsafe fn lssolve10(&self, b: *const ColumnVector,
                            info: *mut octave_idx_type,
                            rank: *mut octave_idx_type)
     -> ComplexColumnVector {
        ComplexMatrix_lssolve10(self, b, info, rank)
    }
    #[inline]
    pub unsafe fn lssolve11(&self, b: *const ColumnVector,
                            info: *mut octave_idx_type,
                            rank: *mut octave_idx_type, rcon: *mut f64)
     -> ComplexColumnVector {
        ComplexMatrix_lssolve11(self, b, info, rank, rcon)
    }
    #[inline]
    pub unsafe fn lssolve12(&self, b: *const ComplexColumnVector)
     -> ComplexColumnVector {
        ComplexMatrix_lssolve12(self, b)
    }
    #[inline]
    pub unsafe fn lssolve13(&self, b: *const ComplexColumnVector,
                            info: *mut octave_idx_type)
     -> ComplexColumnVector {
        ComplexMatrix_lssolve13(self, b, info)
    }
    #[inline]
    pub unsafe fn lssolve14(&self, b: *const ComplexColumnVector,
                            info: *mut octave_idx_type,
                            rank: *mut octave_idx_type)
     -> ComplexColumnVector {
        ComplexMatrix_lssolve14(self, b, info, rank)
    }
    #[inline]
    pub unsafe fn lssolve15(&self, b: *const ComplexColumnVector,
                            info: *mut octave_idx_type,
                            rank: *mut octave_idx_type, rcon: *mut f64)
     -> ComplexColumnVector {
        ComplexMatrix_lssolve15(self, b, info, rank, rcon)
    }
    #[inline]
    pub unsafe fn all(&self, dim: ::std::os::raw::c_int) -> boolMatrix {
        ComplexMatrix_all(self, dim)
    }
    #[inline]
    pub unsafe fn any(&self, dim: ::std::os::raw::c_int) -> boolMatrix {
        ComplexMatrix_any(self, dim)
    }
    #[inline]
    pub unsafe fn cumprod(&self, dim: ::std::os::raw::c_int)
     -> ComplexMatrix {
        ComplexMatrix_cumprod(self, dim)
    }
    #[inline]
    pub unsafe fn cumsum(&self, dim: ::std::os::raw::c_int) -> ComplexMatrix {
        ComplexMatrix_cumsum(self, dim)
    }
    #[inline]
    pub unsafe fn prod(&self, dim: ::std::os::raw::c_int) -> ComplexMatrix {
        ComplexMatrix_prod(self, dim)
    }
    #[inline]
    pub unsafe fn sum(&self, dim: ::std::os::raw::c_int) -> ComplexMatrix {
        ComplexMatrix_sum(self, dim)
    }
    #[inline]
    pub unsafe fn sumsq(&self, dim: ::std::os::raw::c_int) -> ComplexMatrix {
        ComplexMatrix_sumsq(self, dim)
    }
    #[inline]
    pub unsafe fn abs(&self) -> Matrix { ComplexMatrix_abs(self) }
    #[inline]
    pub unsafe fn diag(&self, k: octave_idx_type) -> ComplexMatrix {
        ComplexMatrix_diag(self, k)
    }
    #[inline]
    pub unsafe fn diag1(&self, m: octave_idx_type, n: octave_idx_type)
     -> ComplexDiagMatrix {
        ComplexMatrix_diag1(self, m, n)
    }
    #[inline]
    pub unsafe fn row_is_real_only(&self, arg1: octave_idx_type) -> bool {
        ComplexMatrix_row_is_real_only(self, arg1)
    }
    #[inline]
    pub unsafe fn column_is_real_only(&self, arg1: octave_idx_type) -> bool {
        ComplexMatrix_column_is_real_only(self, arg1)
    }
    #[inline]
    pub unsafe fn row_min(&self) -> ComplexColumnVector {
        ComplexMatrix_row_min(self)
    }
    #[inline]
    pub unsafe fn row_max(&self) -> ComplexColumnVector {
        ComplexMatrix_row_max(self)
    }
    #[inline]
    pub unsafe fn row_min1(&self, index: *mut Array<::std::os::raw::c_int>)
     -> ComplexColumnVector {
        ComplexMatrix_row_min1(self, index)
    }
    #[inline]
    pub unsafe fn row_max1(&self, index: *mut Array<::std::os::raw::c_int>)
     -> ComplexColumnVector {
        ComplexMatrix_row_max1(self, index)
    }
    #[inline]
    pub unsafe fn column_min(&self) -> ComplexRowVector {
        ComplexMatrix_column_min(self)
    }
    #[inline]
    pub unsafe fn column_max(&self) -> ComplexRowVector {
        ComplexMatrix_column_max(self)
    }
    #[inline]
    pub unsafe fn column_min1(&self, index: *mut Array<::std::os::raw::c_int>)
     -> ComplexRowVector {
        ComplexMatrix_column_min1(self, index)
    }
    #[inline]
    pub unsafe fn column_max1(&self, index: *mut Array<::std::os::raw::c_int>)
     -> ComplexRowVector {
        ComplexMatrix_column_max1(self, index)
    }
    #[inline]
    pub unsafe fn new(re: *const Matrix, im: *const Matrix) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        ComplexMatrix_ComplexMatrix(&mut __bindgen_tmp, re, im);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(a: *const Matrix) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        ComplexMatrix_ComplexMatrix1(&mut __bindgen_tmp, a);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new2(rv: *const RowVector) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        ComplexMatrix_ComplexMatrix2(&mut __bindgen_tmp, rv);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new3(cv: *const ColumnVector) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        ComplexMatrix_ComplexMatrix3(&mut __bindgen_tmp, cv);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new4(a: *const DiagMatrix) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        ComplexMatrix_ComplexMatrix4(&mut __bindgen_tmp, a);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new5(a: *const MDiagArray2<f64>) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        ComplexMatrix_ComplexMatrix5(&mut __bindgen_tmp, a);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new6(a: *const DiagArray2<f64>) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        ComplexMatrix_ComplexMatrix6(&mut __bindgen_tmp, a);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new7(rv: *const ComplexRowVector) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        ComplexMatrix_ComplexMatrix7(&mut __bindgen_tmp, rv);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new8(cv: *const ComplexColumnVector) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        ComplexMatrix_ComplexMatrix8(&mut __bindgen_tmp, cv);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new9(a: *const ComplexDiagMatrix) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        ComplexMatrix_ComplexMatrix9(&mut __bindgen_tmp, a);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new10(a: *const MDiagArray2<std_complex<f64>>) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        ComplexMatrix_ComplexMatrix10(&mut __bindgen_tmp, a);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new11(a: *const DiagArray2<std_complex<f64>>) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        ComplexMatrix_ComplexMatrix11(&mut __bindgen_tmp, a);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new12(a: *const boolMatrix) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        ComplexMatrix_ComplexMatrix12(&mut __bindgen_tmp, a);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new13(a: *const charMatrix) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        ComplexMatrix_ComplexMatrix13(&mut __bindgen_tmp, a);
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct FloatMatrix {
    pub _base: FloatNDArray,
}
pub type FloatMatrix_column_vector_type = FloatColumnVector;
pub type FloatMatrix_row_vector_type = FloatRowVector;
pub type FloatMatrix_real_column_vector_type = FloatColumnVector;
pub type FloatMatrix_real_row_vector_type = FloatRowVector;
pub type FloatMatrix_real_matrix_type = FloatMatrix;
pub type FloatMatrix_complex_matrix_type = FloatComplexMatrix;
pub type FloatMatrix_real_diag_matrix_type = FloatDiagMatrix;
pub type FloatMatrix_complex_diag_matrix_type = FloatComplexDiagMatrix;
pub type FloatMatrix_real_elt_type = f32;
pub type FloatMatrix_complex_elt_type = FloatComplex;
pub type FloatMatrix_solve_singularity_handler =
    ::std::option::Option<unsafe extern "C" fn(rcon: f32)>;
#[test]
fn bindgen_test_layout_FloatMatrix() {
    assert_eq!(::std::mem::size_of::<FloatMatrix>() , 40usize , concat ! (
               "Size of: " , stringify ! ( FloatMatrix ) ));
    assert_eq! (::std::mem::align_of::<FloatMatrix>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( FloatMatrix ) ));
}
extern "C" {
    #[link_name = "?is_symmetric@FloatMatrix@@QEBA_NXZ"]
    pub fn FloatMatrix_is_symmetric(this: *const FloatMatrix) -> bool;
}
extern "C" {
    #[link_name = "?insert@FloatMatrix@@QEAAAEAV1@AEBV1@HH@Z"]
    pub fn FloatMatrix_insert(this: *mut FloatMatrix, a: *const FloatMatrix,
                              r: octave_idx_type, c: octave_idx_type)
     -> *mut FloatMatrix;
}
extern "C" {
    #[link_name = "?insert@FloatMatrix@@QEAAAEAV1@AEBVFloatRowVector@@HH@Z"]
    pub fn FloatMatrix_insert1(this: *mut FloatMatrix,
                               a: *const FloatRowVector, r: octave_idx_type,
                               c: octave_idx_type) -> *mut FloatMatrix;
}
extern "C" {
    #[link_name =
          "?insert@FloatMatrix@@QEAAAEAV1@AEBVFloatColumnVector@@HH@Z"]
    pub fn FloatMatrix_insert2(this: *mut FloatMatrix,
                               a: *const FloatColumnVector,
                               r: octave_idx_type, c: octave_idx_type)
     -> *mut FloatMatrix;
}
extern "C" {
    #[link_name = "?insert@FloatMatrix@@QEAAAEAV1@AEBVFloatDiagMatrix@@HH@Z"]
    pub fn FloatMatrix_insert3(this: *mut FloatMatrix,
                               a: *const FloatDiagMatrix, r: octave_idx_type,
                               c: octave_idx_type) -> *mut FloatMatrix;
}
extern "C" {
    #[link_name = "?fill@FloatMatrix@@QEAAAEAV1@M@Z"]
    pub fn FloatMatrix_fill(this: *mut FloatMatrix, val: f32)
     -> *mut FloatMatrix;
}
extern "C" {
    #[link_name = "?fill@FloatMatrix@@QEAAAEAV1@MHHHH@Z"]
    pub fn FloatMatrix_fill1(this: *mut FloatMatrix, val: f32,
                             r1: octave_idx_type, c1: octave_idx_type,
                             r2: octave_idx_type, c2: octave_idx_type)
     -> *mut FloatMatrix;
}
extern "C" {
    #[link_name = "?append@FloatMatrix@@QEBA?AV1@AEBV1@@Z"]
    pub fn FloatMatrix_append(this: *const FloatMatrix, a: *const FloatMatrix)
     -> FloatMatrix;
}
extern "C" {
    #[link_name = "?append@FloatMatrix@@QEBA?AV1@AEBVFloatRowVector@@@Z"]
    pub fn FloatMatrix_append1(this: *const FloatMatrix,
                               a: *const FloatRowVector) -> FloatMatrix;
}
extern "C" {
    #[link_name = "?append@FloatMatrix@@QEBA?AV1@AEBVFloatColumnVector@@@Z"]
    pub fn FloatMatrix_append2(this: *const FloatMatrix,
                               a: *const FloatColumnVector) -> FloatMatrix;
}
extern "C" {
    #[link_name = "?append@FloatMatrix@@QEBA?AV1@AEBVFloatDiagMatrix@@@Z"]
    pub fn FloatMatrix_append3(this: *const FloatMatrix,
                               a: *const FloatDiagMatrix) -> FloatMatrix;
}
extern "C" {
    #[link_name = "?stack@FloatMatrix@@QEBA?AV1@AEBV1@@Z"]
    pub fn FloatMatrix_stack(this: *const FloatMatrix, a: *const FloatMatrix)
     -> FloatMatrix;
}
extern "C" {
    #[link_name = "?stack@FloatMatrix@@QEBA?AV1@AEBVFloatRowVector@@@Z"]
    pub fn FloatMatrix_stack1(this: *const FloatMatrix,
                              a: *const FloatRowVector) -> FloatMatrix;
}
extern "C" {
    #[link_name = "?stack@FloatMatrix@@QEBA?AV1@AEBVFloatColumnVector@@@Z"]
    pub fn FloatMatrix_stack2(this: *const FloatMatrix,
                              a: *const FloatColumnVector) -> FloatMatrix;
}
extern "C" {
    #[link_name = "?stack@FloatMatrix@@QEBA?AV1@AEBVFloatDiagMatrix@@@Z"]
    pub fn FloatMatrix_stack3(this: *const FloatMatrix,
                              a: *const FloatDiagMatrix) -> FloatMatrix;
}
extern "C" {
    #[link_name = "?extract@FloatMatrix@@QEBA?AV1@HHHH@Z"]
    pub fn FloatMatrix_extract(this: *const FloatMatrix, r1: octave_idx_type,
                               c1: octave_idx_type, r2: octave_idx_type,
                               c2: octave_idx_type) -> FloatMatrix;
}
extern "C" {
    #[link_name = "?extract_n@FloatMatrix@@QEBA?AV1@HHHH@Z"]
    pub fn FloatMatrix_extract_n(this: *const FloatMatrix,
                                 r1: octave_idx_type, c1: octave_idx_type,
                                 nr: octave_idx_type, nc: octave_idx_type)
     -> FloatMatrix;
}
extern "C" {
    #[link_name = "?row@FloatMatrix@@QEBA?AVFloatRowVector@@H@Z"]
    pub fn FloatMatrix_row(this: *const FloatMatrix, i: octave_idx_type)
     -> FloatRowVector;
}
extern "C" {
    #[link_name = "?column@FloatMatrix@@QEBA?AVFloatColumnVector@@H@Z"]
    pub fn FloatMatrix_column(this: *const FloatMatrix, i: octave_idx_type)
     -> FloatColumnVector;
}
extern "C" {
    #[link_name = "?inverse@FloatMatrix@@QEBA?AV1@XZ"]
    pub fn FloatMatrix_inverse(this: *const FloatMatrix) -> FloatMatrix;
}
extern "C" {
    #[link_name = "?inverse@FloatMatrix@@QEBA?AV1@AEAH@Z"]
    pub fn FloatMatrix_inverse1(this: *const FloatMatrix,
                                info: *mut octave_idx_type) -> FloatMatrix;
}
extern "C" {
    #[link_name = "?inverse@FloatMatrix@@QEBA?AV1@AEAHAEAM_N2@Z"]
    pub fn FloatMatrix_inverse2(this: *const FloatMatrix,
                                info: *mut octave_idx_type, rcon: *mut f32,
                                force: bool, calc_cond: bool) -> FloatMatrix;
}
extern "C" {
    #[link_name = "?inverse@FloatMatrix@@QEBA?AV1@AEAVMatrixType@@@Z"]
    pub fn FloatMatrix_inverse3(this: *const FloatMatrix,
                                mattype: *mut MatrixType) -> FloatMatrix;
}
extern "C" {
    #[link_name = "?inverse@FloatMatrix@@QEBA?AV1@AEAVMatrixType@@AEAH@Z"]
    pub fn FloatMatrix_inverse4(this: *const FloatMatrix,
                                mattype: *mut MatrixType,
                                info: *mut octave_idx_type) -> FloatMatrix;
}
extern "C" {
    #[link_name =
          "?inverse@FloatMatrix@@QEBA?AV1@AEAVMatrixType@@AEAHAEAM_N3@Z"]
    pub fn FloatMatrix_inverse5(this: *const FloatMatrix,
                                mattype: *mut MatrixType,
                                info: *mut octave_idx_type, rcon: *mut f32,
                                force: bool, calc_cond: bool) -> FloatMatrix;
}
extern "C" {
    #[link_name = "?pseudo_inverse@FloatMatrix@@QEBA?AV1@M@Z"]
    pub fn FloatMatrix_pseudo_inverse(this: *const FloatMatrix, tol: f32)
     -> FloatMatrix;
}
extern "C" {
    #[link_name = "?fourier@FloatMatrix@@QEBA?AVFloatComplexMatrix@@XZ"]
    pub fn FloatMatrix_fourier(this: *const FloatMatrix)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name = "?ifourier@FloatMatrix@@QEBA?AVFloatComplexMatrix@@XZ"]
    pub fn FloatMatrix_ifourier(this: *const FloatMatrix)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name = "?fourier2d@FloatMatrix@@QEBA?AVFloatComplexMatrix@@XZ"]
    pub fn FloatMatrix_fourier2d(this: *const FloatMatrix)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name = "?ifourier2d@FloatMatrix@@QEBA?AVFloatComplexMatrix@@XZ"]
    pub fn FloatMatrix_ifourier2d(this: *const FloatMatrix)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name = "?determinant@FloatMatrix@@QEBA?AV?$base_det@M@@XZ"]
    pub fn FloatMatrix_determinant(this: *const FloatMatrix) -> FloatDET;
}
extern "C" {
    #[link_name = "?determinant@FloatMatrix@@QEBA?AV?$base_det@M@@AEAH@Z"]
    pub fn FloatMatrix_determinant1(this: *const FloatMatrix,
                                    info: *mut octave_idx_type) -> FloatDET;
}
extern "C" {
    #[link_name =
          "?determinant@FloatMatrix@@QEBA?AV?$base_det@M@@AEAHAEAM_N@Z"]
    pub fn FloatMatrix_determinant2(this: *const FloatMatrix,
                                    info: *mut octave_idx_type,
                                    rcon: *mut f32, calc_cond: bool)
     -> FloatDET;
}
extern "C" {
    #[link_name =
          "?determinant@FloatMatrix@@QEBA?AV?$base_det@M@@AEAVMatrixType@@AEAHAEAM_N@Z"]
    pub fn FloatMatrix_determinant3(this: *const FloatMatrix,
                                    mattype: *mut MatrixType,
                                    info: *mut octave_idx_type,
                                    rcon: *mut f32, calc_cond: bool)
     -> FloatDET;
}
extern "C" {
    #[link_name = "?rcond@FloatMatrix@@QEBAMXZ"]
    pub fn FloatMatrix_rcond(this: *const FloatMatrix) -> f32;
}
extern "C" {
    #[link_name = "?rcond@FloatMatrix@@QEBAMAEAVMatrixType@@@Z"]
    pub fn FloatMatrix_rcond1(this: *const FloatMatrix,
                              mattype: *mut MatrixType) -> f32;
}
extern "C" {
    #[link_name = "?solve@FloatMatrix@@QEBA?AV1@AEAVMatrixType@@AEBV1@@Z"]
    pub fn FloatMatrix_solve(this: *const FloatMatrix, typ: *mut MatrixType,
                             b: *const FloatMatrix) -> FloatMatrix;
}
extern "C" {
    #[link_name = "?solve@FloatMatrix@@QEBA?AV1@AEAVMatrixType@@AEBV1@AEAH@Z"]
    pub fn FloatMatrix_solve1(this: *const FloatMatrix, typ: *mut MatrixType,
                              b: *const FloatMatrix,
                              info: *mut octave_idx_type) -> FloatMatrix;
}
extern "C" {
    #[link_name =
          "?solve@FloatMatrix@@QEBA?AV1@AEAVMatrixType@@AEBV1@AEAHAEAM@Z"]
    pub fn FloatMatrix_solve2(this: *const FloatMatrix, typ: *mut MatrixType,
                              b: *const FloatMatrix,
                              info: *mut octave_idx_type, rcon: *mut f32)
     -> FloatMatrix;
}
extern "C" {
    #[link_name =
          "?solve@FloatMatrix@@QEBA?AV1@AEAVMatrixType@@AEBV1@AEAHAEAMP6AXM@Z_NW4blas_trans_type@@@Z"]
    pub fn FloatMatrix_solve3(this: *const FloatMatrix, typ: *mut MatrixType,
                              b: *const FloatMatrix,
                              info: *mut octave_idx_type, rcon: *mut f32,
                              sing_handler:
                                  FloatMatrix_solve_singularity_handler,
                              singular_fallback: bool,
                              transt: blas_trans_type) -> FloatMatrix;
}
extern "C" {
    #[link_name =
          "?solve@FloatMatrix@@QEBA?AVFloatComplexMatrix@@AEAVMatrixType@@AEBV2@@Z"]
    pub fn FloatMatrix_solve4(this: *const FloatMatrix, typ: *mut MatrixType,
                              b: *const FloatComplexMatrix)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@FloatMatrix@@QEBA?AVFloatComplexMatrix@@AEAVMatrixType@@AEBV2@AEAH@Z"]
    pub fn FloatMatrix_solve5(this: *const FloatMatrix, typ: *mut MatrixType,
                              b: *const FloatComplexMatrix,
                              info: *mut octave_idx_type)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@FloatMatrix@@QEBA?AVFloatComplexMatrix@@AEAVMatrixType@@AEBV2@AEAHAEAM@Z"]
    pub fn FloatMatrix_solve6(this: *const FloatMatrix, typ: *mut MatrixType,
                              b: *const FloatComplexMatrix,
                              info: *mut octave_idx_type, rcon: *mut f32)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@FloatMatrix@@QEBA?AVFloatComplexMatrix@@AEAVMatrixType@@AEBV2@AEAHAEAMP6AXM@Z_NW4blas_trans_type@@@Z"]
    pub fn FloatMatrix_solve7(this: *const FloatMatrix, typ: *mut MatrixType,
                              b: *const FloatComplexMatrix,
                              info: *mut octave_idx_type, rcon: *mut f32,
                              sing_handler:
                                  FloatMatrix_solve_singularity_handler,
                              singular_fallback: bool,
                              transt: blas_trans_type) -> FloatComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@FloatMatrix@@QEBA?AVFloatColumnVector@@AEAVMatrixType@@AEBV2@@Z"]
    pub fn FloatMatrix_solve8(this: *const FloatMatrix, typ: *mut MatrixType,
                              b: *const FloatColumnVector)
     -> FloatColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@FloatMatrix@@QEBA?AVFloatColumnVector@@AEAVMatrixType@@AEBV2@AEAH@Z"]
    pub fn FloatMatrix_solve9(this: *const FloatMatrix, typ: *mut MatrixType,
                              b: *const FloatColumnVector,
                              info: *mut octave_idx_type)
     -> FloatColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@FloatMatrix@@QEBA?AVFloatColumnVector@@AEAVMatrixType@@AEBV2@AEAHAEAM@Z"]
    pub fn FloatMatrix_solve10(this: *const FloatMatrix, typ: *mut MatrixType,
                               b: *const FloatColumnVector,
                               info: *mut octave_idx_type, rcon: *mut f32)
     -> FloatColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@FloatMatrix@@QEBA?AVFloatColumnVector@@AEAVMatrixType@@AEBV2@AEAHAEAMP6AXM@ZW4blas_trans_type@@@Z"]
    pub fn FloatMatrix_solve11(this: *const FloatMatrix, typ: *mut MatrixType,
                               b: *const FloatColumnVector,
                               info: *mut octave_idx_type, rcon: *mut f32,
                               sing_handler:
                                   FloatMatrix_solve_singularity_handler,
                               transt: blas_trans_type) -> FloatColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@FloatMatrix@@QEBA?AVFloatComplexColumnVector@@AEAVMatrixType@@AEBV2@@Z"]
    pub fn FloatMatrix_solve12(this: *const FloatMatrix, typ: *mut MatrixType,
                               b: *const FloatComplexColumnVector)
     -> FloatComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@FloatMatrix@@QEBA?AVFloatComplexColumnVector@@AEAVMatrixType@@AEBV2@AEAH@Z"]
    pub fn FloatMatrix_solve13(this: *const FloatMatrix, typ: *mut MatrixType,
                               b: *const FloatComplexColumnVector,
                               info: *mut octave_idx_type)
     -> FloatComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@FloatMatrix@@QEBA?AVFloatComplexColumnVector@@AEAVMatrixType@@AEBV2@AEAHAEAM@Z"]
    pub fn FloatMatrix_solve14(this: *const FloatMatrix, typ: *mut MatrixType,
                               b: *const FloatComplexColumnVector,
                               info: *mut octave_idx_type, rcon: *mut f32)
     -> FloatComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@FloatMatrix@@QEBA?AVFloatComplexColumnVector@@AEAVMatrixType@@AEBV2@AEAHAEAMP6AXM@ZW4blas_trans_type@@@Z"]
    pub fn FloatMatrix_solve15(this: *const FloatMatrix, typ: *mut MatrixType,
                               b: *const FloatComplexColumnVector,
                               info: *mut octave_idx_type, rcon: *mut f32,
                               sing_handler:
                                   FloatMatrix_solve_singularity_handler,
                               transt: blas_trans_type)
     -> FloatComplexColumnVector;
}
extern "C" {
    #[link_name = "?solve@FloatMatrix@@QEBA?AV1@AEBV1@@Z"]
    pub fn FloatMatrix_solve16(this: *const FloatMatrix,
                               b: *const FloatMatrix) -> FloatMatrix;
}
extern "C" {
    #[link_name = "?solve@FloatMatrix@@QEBA?AV1@AEBV1@AEAH@Z"]
    pub fn FloatMatrix_solve17(this: *const FloatMatrix,
                               b: *const FloatMatrix,
                               info: *mut octave_idx_type) -> FloatMatrix;
}
extern "C" {
    #[link_name = "?solve@FloatMatrix@@QEBA?AV1@AEBV1@AEAHAEAM@Z"]
    pub fn FloatMatrix_solve18(this: *const FloatMatrix,
                               b: *const FloatMatrix,
                               info: *mut octave_idx_type, rcon: *mut f32)
     -> FloatMatrix;
}
extern "C" {
    #[link_name =
          "?solve@FloatMatrix@@QEBA?AV1@AEBV1@AEAHAEAMP6AXM@ZW4blas_trans_type@@@Z"]
    pub fn FloatMatrix_solve19(this: *const FloatMatrix,
                               b: *const FloatMatrix,
                               info: *mut octave_idx_type, rcon: *mut f32,
                               sing_handler:
                                   FloatMatrix_solve_singularity_handler,
                               transt: blas_trans_type) -> FloatMatrix;
}
extern "C" {
    #[link_name = "?solve@FloatMatrix@@QEBA?AVFloatComplexMatrix@@AEBV2@@Z"]
    pub fn FloatMatrix_solve20(this: *const FloatMatrix,
                               b: *const FloatComplexMatrix)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@FloatMatrix@@QEBA?AVFloatComplexMatrix@@AEBV2@AEAH@Z"]
    pub fn FloatMatrix_solve21(this: *const FloatMatrix,
                               b: *const FloatComplexMatrix,
                               info: *mut octave_idx_type)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@FloatMatrix@@QEBA?AVFloatComplexMatrix@@AEBV2@AEAHAEAM@Z"]
    pub fn FloatMatrix_solve22(this: *const FloatMatrix,
                               b: *const FloatComplexMatrix,
                               info: *mut octave_idx_type, rcon: *mut f32)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@FloatMatrix@@QEBA?AVFloatComplexMatrix@@AEBV2@AEAHAEAMP6AXM@ZW4blas_trans_type@@@Z"]
    pub fn FloatMatrix_solve23(this: *const FloatMatrix,
                               b: *const FloatComplexMatrix,
                               info: *mut octave_idx_type, rcon: *mut f32,
                               sing_handler:
                                   FloatMatrix_solve_singularity_handler,
                               transt: blas_trans_type) -> FloatComplexMatrix;
}
extern "C" {
    #[link_name = "?solve@FloatMatrix@@QEBA?AVFloatColumnVector@@AEBV2@@Z"]
    pub fn FloatMatrix_solve24(this: *const FloatMatrix,
                               b: *const FloatColumnVector)
     -> FloatColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@FloatMatrix@@QEBA?AVFloatColumnVector@@AEBV2@AEAH@Z"]
    pub fn FloatMatrix_solve25(this: *const FloatMatrix,
                               b: *const FloatColumnVector,
                               info: *mut octave_idx_type)
     -> FloatColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@FloatMatrix@@QEBA?AVFloatColumnVector@@AEBV2@AEAHAEAM@Z"]
    pub fn FloatMatrix_solve26(this: *const FloatMatrix,
                               b: *const FloatColumnVector,
                               info: *mut octave_idx_type, rcon: *mut f32)
     -> FloatColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@FloatMatrix@@QEBA?AVFloatColumnVector@@AEBV2@AEAHAEAMP6AXM@ZW4blas_trans_type@@@Z"]
    pub fn FloatMatrix_solve27(this: *const FloatMatrix,
                               b: *const FloatColumnVector,
                               info: *mut octave_idx_type, rcon: *mut f32,
                               sing_handler:
                                   FloatMatrix_solve_singularity_handler,
                               transt: blas_trans_type) -> FloatColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@FloatMatrix@@QEBA?AVFloatComplexColumnVector@@AEBV2@@Z"]
    pub fn FloatMatrix_solve28(this: *const FloatMatrix,
                               b: *const FloatComplexColumnVector)
     -> FloatComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@FloatMatrix@@QEBA?AVFloatComplexColumnVector@@AEBV2@AEAH@Z"]
    pub fn FloatMatrix_solve29(this: *const FloatMatrix,
                               b: *const FloatComplexColumnVector,
                               info: *mut octave_idx_type)
     -> FloatComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@FloatMatrix@@QEBA?AVFloatComplexColumnVector@@AEBV2@AEAHAEAM@Z"]
    pub fn FloatMatrix_solve30(this: *const FloatMatrix,
                               b: *const FloatComplexColumnVector,
                               info: *mut octave_idx_type, rcon: *mut f32)
     -> FloatComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@FloatMatrix@@QEBA?AVFloatComplexColumnVector@@AEBV2@AEAHAEAMP6AXM@ZW4blas_trans_type@@@Z"]
    pub fn FloatMatrix_solve31(this: *const FloatMatrix,
                               b: *const FloatComplexColumnVector,
                               info: *mut octave_idx_type, rcon: *mut f32,
                               sing_handler:
                                   FloatMatrix_solve_singularity_handler,
                               transt: blas_trans_type)
     -> FloatComplexColumnVector;
}
extern "C" {
    #[link_name = "?lssolve@FloatMatrix@@QEBA?AV1@AEBV1@@Z"]
    pub fn FloatMatrix_lssolve(this: *const FloatMatrix,
                               b: *const FloatMatrix) -> FloatMatrix;
}
extern "C" {
    #[link_name = "?lssolve@FloatMatrix@@QEBA?AV1@AEBV1@AEAH@Z"]
    pub fn FloatMatrix_lssolve1(this: *const FloatMatrix,
                                b: *const FloatMatrix,
                                info: *mut octave_idx_type) -> FloatMatrix;
}
extern "C" {
    #[link_name = "?lssolve@FloatMatrix@@QEBA?AV1@AEBV1@AEAH1@Z"]
    pub fn FloatMatrix_lssolve2(this: *const FloatMatrix,
                                b: *const FloatMatrix,
                                info: *mut octave_idx_type,
                                rank: *mut octave_idx_type) -> FloatMatrix;
}
extern "C" {
    #[link_name = "?lssolve@FloatMatrix@@QEBA?AV1@AEBV1@AEAH1AEAM@Z"]
    pub fn FloatMatrix_lssolve3(this: *const FloatMatrix,
                                b: *const FloatMatrix,
                                info: *mut octave_idx_type,
                                rank: *mut octave_idx_type, rcon: *mut f32)
     -> FloatMatrix;
}
extern "C" {
    #[link_name = "?lssolve@FloatMatrix@@QEBA?AVFloatComplexMatrix@@AEBV2@@Z"]
    pub fn FloatMatrix_lssolve4(this: *const FloatMatrix,
                                b: *const FloatComplexMatrix)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name =
          "?lssolve@FloatMatrix@@QEBA?AVFloatComplexMatrix@@AEBV2@AEAH@Z"]
    pub fn FloatMatrix_lssolve5(this: *const FloatMatrix,
                                b: *const FloatComplexMatrix,
                                info: *mut octave_idx_type)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name =
          "?lssolve@FloatMatrix@@QEBA?AVFloatComplexMatrix@@AEBV2@AEAH1@Z"]
    pub fn FloatMatrix_lssolve6(this: *const FloatMatrix,
                                b: *const FloatComplexMatrix,
                                info: *mut octave_idx_type,
                                rank: *mut octave_idx_type)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name =
          "?lssolve@FloatMatrix@@QEBA?AVFloatComplexMatrix@@AEBV2@AEAH1AEAM@Z"]
    pub fn FloatMatrix_lssolve7(this: *const FloatMatrix,
                                b: *const FloatComplexMatrix,
                                info: *mut octave_idx_type,
                                rank: *mut octave_idx_type, rcon: *mut f32)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name = "?lssolve@FloatMatrix@@QEBA?AVFloatColumnVector@@AEBV2@@Z"]
    pub fn FloatMatrix_lssolve8(this: *const FloatMatrix,
                                b: *const FloatColumnVector)
     -> FloatColumnVector;
}
extern "C" {
    #[link_name =
          "?lssolve@FloatMatrix@@QEBA?AVFloatColumnVector@@AEBV2@AEAH@Z"]
    pub fn FloatMatrix_lssolve9(this: *const FloatMatrix,
                                b: *const FloatColumnVector,
                                info: *mut octave_idx_type)
     -> FloatColumnVector;
}
extern "C" {
    #[link_name =
          "?lssolve@FloatMatrix@@QEBA?AVFloatColumnVector@@AEBV2@AEAH1@Z"]
    pub fn FloatMatrix_lssolve10(this: *const FloatMatrix,
                                 b: *const FloatColumnVector,
                                 info: *mut octave_idx_type,
                                 rank: *mut octave_idx_type)
     -> FloatColumnVector;
}
extern "C" {
    #[link_name =
          "?lssolve@FloatMatrix@@QEBA?AVFloatColumnVector@@AEBV2@AEAH1AEAM@Z"]
    pub fn FloatMatrix_lssolve11(this: *const FloatMatrix,
                                 b: *const FloatColumnVector,
                                 info: *mut octave_idx_type,
                                 rank: *mut octave_idx_type, rcon: *mut f32)
     -> FloatColumnVector;
}
extern "C" {
    #[link_name =
          "?lssolve@FloatMatrix@@QEBA?AVFloatComplexColumnVector@@AEBV2@@Z"]
    pub fn FloatMatrix_lssolve12(this: *const FloatMatrix,
                                 b: *const FloatComplexColumnVector)
     -> FloatComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?lssolve@FloatMatrix@@QEBA?AVFloatComplexColumnVector@@AEBV2@AEAH@Z"]
    pub fn FloatMatrix_lssolve13(this: *const FloatMatrix,
                                 b: *const FloatComplexColumnVector,
                                 info: *mut octave_idx_type)
     -> FloatComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?lssolve@FloatMatrix@@QEBA?AVFloatComplexColumnVector@@AEBV2@AEAH1@Z"]
    pub fn FloatMatrix_lssolve14(this: *const FloatMatrix,
                                 b: *const FloatComplexColumnVector,
                                 info: *mut octave_idx_type,
                                 rank: *mut octave_idx_type)
     -> FloatComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?lssolve@FloatMatrix@@QEBA?AVFloatComplexColumnVector@@AEBV2@AEAH1AEAM@Z"]
    pub fn FloatMatrix_lssolve15(this: *const FloatMatrix,
                                 b: *const FloatComplexColumnVector,
                                 info: *mut octave_idx_type,
                                 rank: *mut octave_idx_type, rcon: *mut f32)
     -> FloatComplexColumnVector;
}
extern "C" {
    #[link_name = "?cumprod@FloatMatrix@@QEBA?AV1@H@Z"]
    pub fn FloatMatrix_cumprod(this: *const FloatMatrix,
                               dim: ::std::os::raw::c_int) -> FloatMatrix;
}
extern "C" {
    #[link_name = "?cumsum@FloatMatrix@@QEBA?AV1@H@Z"]
    pub fn FloatMatrix_cumsum(this: *const FloatMatrix,
                              dim: ::std::os::raw::c_int) -> FloatMatrix;
}
extern "C" {
    #[link_name = "?prod@FloatMatrix@@QEBA?AV1@H@Z"]
    pub fn FloatMatrix_prod(this: *const FloatMatrix,
                            dim: ::std::os::raw::c_int) -> FloatMatrix;
}
extern "C" {
    #[link_name = "?sum@FloatMatrix@@QEBA?AV1@H@Z"]
    pub fn FloatMatrix_sum(this: *const FloatMatrix,
                           dim: ::std::os::raw::c_int) -> FloatMatrix;
}
extern "C" {
    #[link_name = "?sumsq@FloatMatrix@@QEBA?AV1@H@Z"]
    pub fn FloatMatrix_sumsq(this: *const FloatMatrix,
                             dim: ::std::os::raw::c_int) -> FloatMatrix;
}
extern "C" {
    #[link_name = "?abs@FloatMatrix@@QEBA?AV1@XZ"]
    pub fn FloatMatrix_abs(this: *const FloatMatrix) -> FloatMatrix;
}
extern "C" {
    #[link_name = "?diag@FloatMatrix@@QEBA?AV1@H@Z"]
    pub fn FloatMatrix_diag(this: *const FloatMatrix, k: octave_idx_type)
     -> FloatMatrix;
}
extern "C" {
    #[link_name = "?diag@FloatMatrix@@QEBA?AVFloatDiagMatrix@@HH@Z"]
    pub fn FloatMatrix_diag1(this: *const FloatMatrix, m: octave_idx_type,
                             n: octave_idx_type) -> FloatDiagMatrix;
}
extern "C" {
    #[link_name = "?row_min@FloatMatrix@@QEBA?AVFloatColumnVector@@XZ"]
    pub fn FloatMatrix_row_min(this: *const FloatMatrix) -> FloatColumnVector;
}
extern "C" {
    #[link_name = "?row_max@FloatMatrix@@QEBA?AVFloatColumnVector@@XZ"]
    pub fn FloatMatrix_row_max(this: *const FloatMatrix) -> FloatColumnVector;
}
extern "C" {
    #[link_name =
          "?row_min@FloatMatrix@@QEBA?AVFloatColumnVector@@AEAV?$Array@H@@@Z"]
    pub fn FloatMatrix_row_min1(this: *const FloatMatrix,
                                index: *mut Array<::std::os::raw::c_int>)
     -> FloatColumnVector;
}
extern "C" {
    #[link_name =
          "?row_max@FloatMatrix@@QEBA?AVFloatColumnVector@@AEAV?$Array@H@@@Z"]
    pub fn FloatMatrix_row_max1(this: *const FloatMatrix,
                                index: *mut Array<::std::os::raw::c_int>)
     -> FloatColumnVector;
}
extern "C" {
    #[link_name = "?column_min@FloatMatrix@@QEBA?AVFloatRowVector@@XZ"]
    pub fn FloatMatrix_column_min(this: *const FloatMatrix) -> FloatRowVector;
}
extern "C" {
    #[link_name = "?column_max@FloatMatrix@@QEBA?AVFloatRowVector@@XZ"]
    pub fn FloatMatrix_column_max(this: *const FloatMatrix) -> FloatRowVector;
}
extern "C" {
    #[link_name =
          "?column_min@FloatMatrix@@QEBA?AVFloatRowVector@@AEAV?$Array@H@@@Z"]
    pub fn FloatMatrix_column_min1(this: *const FloatMatrix,
                                   index: *mut Array<::std::os::raw::c_int>)
     -> FloatRowVector;
}
extern "C" {
    #[link_name =
          "?column_max@FloatMatrix@@QEBA?AVFloatRowVector@@AEAV?$Array@H@@@Z"]
    pub fn FloatMatrix_column_max1(this: *const FloatMatrix,
                                   index: *mut Array<::std::os::raw::c_int>)
     -> FloatRowVector;
}
extern "C" {
    #[link_name = "??0FloatMatrix@@QEAA@AEBVFloatRowVector@@@Z"]
    pub fn FloatMatrix_FloatMatrix(this: *mut FloatMatrix,
                                   rv: *const FloatRowVector);
}
extern "C" {
    #[link_name = "??0FloatMatrix@@QEAA@AEBVFloatColumnVector@@@Z"]
    pub fn FloatMatrix_FloatMatrix1(this: *mut FloatMatrix,
                                    cv: *const FloatColumnVector);
}
extern "C" {
    #[link_name = "??0FloatMatrix@@QEAA@AEBVFloatDiagMatrix@@@Z"]
    pub fn FloatMatrix_FloatMatrix2(this: *mut FloatMatrix,
                                    a: *const FloatDiagMatrix);
}
extern "C" {
    #[link_name = "??0FloatMatrix@@QEAA@AEBV?$MDiagArray2@M@@@Z"]
    pub fn FloatMatrix_FloatMatrix3(this: *mut FloatMatrix,
                                    a: *const MDiagArray2<f32>);
}
extern "C" {
    #[link_name = "??0FloatMatrix@@QEAA@AEBV?$DiagArray2@M@@@Z"]
    pub fn FloatMatrix_FloatMatrix4(this: *mut FloatMatrix,
                                    a: *const DiagArray2<f32>);
}
extern "C" {
    #[link_name = "??0FloatMatrix@@QEAA@AEBVPermMatrix@@@Z"]
    pub fn FloatMatrix_FloatMatrix5(this: *mut FloatMatrix,
                                    a: *const PermMatrix);
}
extern "C" {
    #[link_name = "??0FloatMatrix@@QEAA@AEBVboolMatrix@@@Z"]
    pub fn FloatMatrix_FloatMatrix6(this: *mut FloatMatrix,
                                    a: *const boolMatrix);
}
extern "C" {
    #[link_name = "??0FloatMatrix@@QEAA@AEBVcharMatrix@@@Z"]
    pub fn FloatMatrix_FloatMatrix7(this: *mut FloatMatrix,
                                    a: *const charMatrix);
}
impl FloatMatrix {
    #[inline]
    pub unsafe fn is_symmetric(&self) -> bool {
        FloatMatrix_is_symmetric(self)
    }
    #[inline]
    pub unsafe fn insert(&mut self, a: *const FloatMatrix, r: octave_idx_type,
                         c: octave_idx_type) -> *mut FloatMatrix {
        FloatMatrix_insert(self, a, r, c)
    }
    #[inline]
    pub unsafe fn insert1(&mut self, a: *const FloatRowVector,
                          r: octave_idx_type, c: octave_idx_type)
     -> *mut FloatMatrix {
        FloatMatrix_insert1(self, a, r, c)
    }
    #[inline]
    pub unsafe fn insert2(&mut self, a: *const FloatColumnVector,
                          r: octave_idx_type, c: octave_idx_type)
     -> *mut FloatMatrix {
        FloatMatrix_insert2(self, a, r, c)
    }
    #[inline]
    pub unsafe fn insert3(&mut self, a: *const FloatDiagMatrix,
                          r: octave_idx_type, c: octave_idx_type)
     -> *mut FloatMatrix {
        FloatMatrix_insert3(self, a, r, c)
    }
    #[inline]
    pub unsafe fn fill(&mut self, val: f32) -> *mut FloatMatrix {
        FloatMatrix_fill(self, val)
    }
    #[inline]
    pub unsafe fn fill1(&mut self, val: f32, r1: octave_idx_type,
                        c1: octave_idx_type, r2: octave_idx_type,
                        c2: octave_idx_type) -> *mut FloatMatrix {
        FloatMatrix_fill1(self, val, r1, c1, r2, c2)
    }
    #[inline]
    pub unsafe fn append(&self, a: *const FloatMatrix) -> FloatMatrix {
        FloatMatrix_append(self, a)
    }
    #[inline]
    pub unsafe fn append1(&self, a: *const FloatRowVector) -> FloatMatrix {
        FloatMatrix_append1(self, a)
    }
    #[inline]
    pub unsafe fn append2(&self, a: *const FloatColumnVector) -> FloatMatrix {
        FloatMatrix_append2(self, a)
    }
    #[inline]
    pub unsafe fn append3(&self, a: *const FloatDiagMatrix) -> FloatMatrix {
        FloatMatrix_append3(self, a)
    }
    #[inline]
    pub unsafe fn stack(&self, a: *const FloatMatrix) -> FloatMatrix {
        FloatMatrix_stack(self, a)
    }
    #[inline]
    pub unsafe fn stack1(&self, a: *const FloatRowVector) -> FloatMatrix {
        FloatMatrix_stack1(self, a)
    }
    #[inline]
    pub unsafe fn stack2(&self, a: *const FloatColumnVector) -> FloatMatrix {
        FloatMatrix_stack2(self, a)
    }
    #[inline]
    pub unsafe fn stack3(&self, a: *const FloatDiagMatrix) -> FloatMatrix {
        FloatMatrix_stack3(self, a)
    }
    #[inline]
    pub unsafe fn extract(&self, r1: octave_idx_type, c1: octave_idx_type,
                          r2: octave_idx_type, c2: octave_idx_type)
     -> FloatMatrix {
        FloatMatrix_extract(self, r1, c1, r2, c2)
    }
    #[inline]
    pub unsafe fn extract_n(&self, r1: octave_idx_type, c1: octave_idx_type,
                            nr: octave_idx_type, nc: octave_idx_type)
     -> FloatMatrix {
        FloatMatrix_extract_n(self, r1, c1, nr, nc)
    }
    #[inline]
    pub unsafe fn row(&self, i: octave_idx_type) -> FloatRowVector {
        FloatMatrix_row(self, i)
    }
    #[inline]
    pub unsafe fn column(&self, i: octave_idx_type) -> FloatColumnVector {
        FloatMatrix_column(self, i)
    }
    #[inline]
    pub unsafe fn inverse(&self) -> FloatMatrix { FloatMatrix_inverse(self) }
    #[inline]
    pub unsafe fn inverse1(&self, info: *mut octave_idx_type) -> FloatMatrix {
        FloatMatrix_inverse1(self, info)
    }
    #[inline]
    pub unsafe fn inverse2(&self, info: *mut octave_idx_type, rcon: *mut f32,
                           force: bool, calc_cond: bool) -> FloatMatrix {
        FloatMatrix_inverse2(self, info, rcon, force, calc_cond)
    }
    #[inline]
    pub unsafe fn inverse3(&self, mattype: *mut MatrixType) -> FloatMatrix {
        FloatMatrix_inverse3(self, mattype)
    }
    #[inline]
    pub unsafe fn inverse4(&self, mattype: *mut MatrixType,
                           info: *mut octave_idx_type) -> FloatMatrix {
        FloatMatrix_inverse4(self, mattype, info)
    }
    #[inline]
    pub unsafe fn inverse5(&self, mattype: *mut MatrixType,
                           info: *mut octave_idx_type, rcon: *mut f32,
                           force: bool, calc_cond: bool) -> FloatMatrix {
        FloatMatrix_inverse5(self, mattype, info, rcon, force, calc_cond)
    }
    #[inline]
    pub unsafe fn pseudo_inverse(&self, tol: f32) -> FloatMatrix {
        FloatMatrix_pseudo_inverse(self, tol)
    }
    #[inline]
    pub unsafe fn fourier(&self) -> FloatComplexMatrix {
        FloatMatrix_fourier(self)
    }
    #[inline]
    pub unsafe fn ifourier(&self) -> FloatComplexMatrix {
        FloatMatrix_ifourier(self)
    }
    #[inline]
    pub unsafe fn fourier2d(&self) -> FloatComplexMatrix {
        FloatMatrix_fourier2d(self)
    }
    #[inline]
    pub unsafe fn ifourier2d(&self) -> FloatComplexMatrix {
        FloatMatrix_ifourier2d(self)
    }
    #[inline]
    pub unsafe fn determinant(&self) -> FloatDET {
        FloatMatrix_determinant(self)
    }
    #[inline]
    pub unsafe fn determinant1(&self, info: *mut octave_idx_type)
     -> FloatDET {
        FloatMatrix_determinant1(self, info)
    }
    #[inline]
    pub unsafe fn determinant2(&self, info: *mut octave_idx_type,
                               rcon: *mut f32, calc_cond: bool) -> FloatDET {
        FloatMatrix_determinant2(self, info, rcon, calc_cond)
    }
    #[inline]
    pub unsafe fn determinant3(&self, mattype: *mut MatrixType,
                               info: *mut octave_idx_type, rcon: *mut f32,
                               calc_cond: bool) -> FloatDET {
        FloatMatrix_determinant3(self, mattype, info, rcon, calc_cond)
    }
    #[inline]
    pub unsafe fn rcond(&self) -> f32 { FloatMatrix_rcond(self) }
    #[inline]
    pub unsafe fn rcond1(&self, mattype: *mut MatrixType) -> f32 {
        FloatMatrix_rcond1(self, mattype)
    }
    #[inline]
    pub unsafe fn solve(&self, typ: *mut MatrixType, b: *const FloatMatrix)
     -> FloatMatrix {
        FloatMatrix_solve(self, typ, b)
    }
    #[inline]
    pub unsafe fn solve1(&self, typ: *mut MatrixType, b: *const FloatMatrix,
                         info: *mut octave_idx_type) -> FloatMatrix {
        FloatMatrix_solve1(self, typ, b, info)
    }
    #[inline]
    pub unsafe fn solve2(&self, typ: *mut MatrixType, b: *const FloatMatrix,
                         info: *mut octave_idx_type, rcon: *mut f32)
     -> FloatMatrix {
        FloatMatrix_solve2(self, typ, b, info, rcon)
    }
    #[inline]
    pub unsafe fn solve3(&self, typ: *mut MatrixType, b: *const FloatMatrix,
                         info: *mut octave_idx_type, rcon: *mut f32,
                         sing_handler: FloatMatrix_solve_singularity_handler,
                         singular_fallback: bool, transt: blas_trans_type)
     -> FloatMatrix {
        FloatMatrix_solve3(self, typ, b, info, rcon, sing_handler,
                           singular_fallback, transt)
    }
    #[inline]
    pub unsafe fn solve4(&self, typ: *mut MatrixType,
                         b: *const FloatComplexMatrix) -> FloatComplexMatrix {
        FloatMatrix_solve4(self, typ, b)
    }
    #[inline]
    pub unsafe fn solve5(&self, typ: *mut MatrixType,
                         b: *const FloatComplexMatrix,
                         info: *mut octave_idx_type) -> FloatComplexMatrix {
        FloatMatrix_solve5(self, typ, b, info)
    }
    #[inline]
    pub unsafe fn solve6(&self, typ: *mut MatrixType,
                         b: *const FloatComplexMatrix,
                         info: *mut octave_idx_type, rcon: *mut f32)
     -> FloatComplexMatrix {
        FloatMatrix_solve6(self, typ, b, info, rcon)
    }
    #[inline]
    pub unsafe fn solve7(&self, typ: *mut MatrixType,
                         b: *const FloatComplexMatrix,
                         info: *mut octave_idx_type, rcon: *mut f32,
                         sing_handler: FloatMatrix_solve_singularity_handler,
                         singular_fallback: bool, transt: blas_trans_type)
     -> FloatComplexMatrix {
        FloatMatrix_solve7(self, typ, b, info, rcon, sing_handler,
                           singular_fallback, transt)
    }
    #[inline]
    pub unsafe fn solve8(&self, typ: *mut MatrixType,
                         b: *const FloatColumnVector) -> FloatColumnVector {
        FloatMatrix_solve8(self, typ, b)
    }
    #[inline]
    pub unsafe fn solve9(&self, typ: *mut MatrixType,
                         b: *const FloatColumnVector,
                         info: *mut octave_idx_type) -> FloatColumnVector {
        FloatMatrix_solve9(self, typ, b, info)
    }
    #[inline]
    pub unsafe fn solve10(&self, typ: *mut MatrixType,
                          b: *const FloatColumnVector,
                          info: *mut octave_idx_type, rcon: *mut f32)
     -> FloatColumnVector {
        FloatMatrix_solve10(self, typ, b, info, rcon)
    }
    #[inline]
    pub unsafe fn solve11(&self, typ: *mut MatrixType,
                          b: *const FloatColumnVector,
                          info: *mut octave_idx_type, rcon: *mut f32,
                          sing_handler: FloatMatrix_solve_singularity_handler,
                          transt: blas_trans_type) -> FloatColumnVector {
        FloatMatrix_solve11(self, typ, b, info, rcon, sing_handler, transt)
    }
    #[inline]
    pub unsafe fn solve12(&self, typ: *mut MatrixType,
                          b: *const FloatComplexColumnVector)
     -> FloatComplexColumnVector {
        FloatMatrix_solve12(self, typ, b)
    }
    #[inline]
    pub unsafe fn solve13(&self, typ: *mut MatrixType,
                          b: *const FloatComplexColumnVector,
                          info: *mut octave_idx_type)
     -> FloatComplexColumnVector {
        FloatMatrix_solve13(self, typ, b, info)
    }
    #[inline]
    pub unsafe fn solve14(&self, typ: *mut MatrixType,
                          b: *const FloatComplexColumnVector,
                          info: *mut octave_idx_type, rcon: *mut f32)
     -> FloatComplexColumnVector {
        FloatMatrix_solve14(self, typ, b, info, rcon)
    }
    #[inline]
    pub unsafe fn solve15(&self, typ: *mut MatrixType,
                          b: *const FloatComplexColumnVector,
                          info: *mut octave_idx_type, rcon: *mut f32,
                          sing_handler: FloatMatrix_solve_singularity_handler,
                          transt: blas_trans_type)
     -> FloatComplexColumnVector {
        FloatMatrix_solve15(self, typ, b, info, rcon, sing_handler, transt)
    }
    #[inline]
    pub unsafe fn solve16(&self, b: *const FloatMatrix) -> FloatMatrix {
        FloatMatrix_solve16(self, b)
    }
    #[inline]
    pub unsafe fn solve17(&self, b: *const FloatMatrix,
                          info: *mut octave_idx_type) -> FloatMatrix {
        FloatMatrix_solve17(self, b, info)
    }
    #[inline]
    pub unsafe fn solve18(&self, b: *const FloatMatrix,
                          info: *mut octave_idx_type, rcon: *mut f32)
     -> FloatMatrix {
        FloatMatrix_solve18(self, b, info, rcon)
    }
    #[inline]
    pub unsafe fn solve19(&self, b: *const FloatMatrix,
                          info: *mut octave_idx_type, rcon: *mut f32,
                          sing_handler: FloatMatrix_solve_singularity_handler,
                          transt: blas_trans_type) -> FloatMatrix {
        FloatMatrix_solve19(self, b, info, rcon, sing_handler, transt)
    }
    #[inline]
    pub unsafe fn solve20(&self, b: *const FloatComplexMatrix)
     -> FloatComplexMatrix {
        FloatMatrix_solve20(self, b)
    }
    #[inline]
    pub unsafe fn solve21(&self, b: *const FloatComplexMatrix,
                          info: *mut octave_idx_type) -> FloatComplexMatrix {
        FloatMatrix_solve21(self, b, info)
    }
    #[inline]
    pub unsafe fn solve22(&self, b: *const FloatComplexMatrix,
                          info: *mut octave_idx_type, rcon: *mut f32)
     -> FloatComplexMatrix {
        FloatMatrix_solve22(self, b, info, rcon)
    }
    #[inline]
    pub unsafe fn solve23(&self, b: *const FloatComplexMatrix,
                          info: *mut octave_idx_type, rcon: *mut f32,
                          sing_handler: FloatMatrix_solve_singularity_handler,
                          transt: blas_trans_type) -> FloatComplexMatrix {
        FloatMatrix_solve23(self, b, info, rcon, sing_handler, transt)
    }
    #[inline]
    pub unsafe fn solve24(&self, b: *const FloatColumnVector)
     -> FloatColumnVector {
        FloatMatrix_solve24(self, b)
    }
    #[inline]
    pub unsafe fn solve25(&self, b: *const FloatColumnVector,
                          info: *mut octave_idx_type) -> FloatColumnVector {
        FloatMatrix_solve25(self, b, info)
    }
    #[inline]
    pub unsafe fn solve26(&self, b: *const FloatColumnVector,
                          info: *mut octave_idx_type, rcon: *mut f32)
     -> FloatColumnVector {
        FloatMatrix_solve26(self, b, info, rcon)
    }
    #[inline]
    pub unsafe fn solve27(&self, b: *const FloatColumnVector,
                          info: *mut octave_idx_type, rcon: *mut f32,
                          sing_handler: FloatMatrix_solve_singularity_handler,
                          transt: blas_trans_type) -> FloatColumnVector {
        FloatMatrix_solve27(self, b, info, rcon, sing_handler, transt)
    }
    #[inline]
    pub unsafe fn solve28(&self, b: *const FloatComplexColumnVector)
     -> FloatComplexColumnVector {
        FloatMatrix_solve28(self, b)
    }
    #[inline]
    pub unsafe fn solve29(&self, b: *const FloatComplexColumnVector,
                          info: *mut octave_idx_type)
     -> FloatComplexColumnVector {
        FloatMatrix_solve29(self, b, info)
    }
    #[inline]
    pub unsafe fn solve30(&self, b: *const FloatComplexColumnVector,
                          info: *mut octave_idx_type, rcon: *mut f32)
     -> FloatComplexColumnVector {
        FloatMatrix_solve30(self, b, info, rcon)
    }
    #[inline]
    pub unsafe fn solve31(&self, b: *const FloatComplexColumnVector,
                          info: *mut octave_idx_type, rcon: *mut f32,
                          sing_handler: FloatMatrix_solve_singularity_handler,
                          transt: blas_trans_type)
     -> FloatComplexColumnVector {
        FloatMatrix_solve31(self, b, info, rcon, sing_handler, transt)
    }
    #[inline]
    pub unsafe fn lssolve(&self, b: *const FloatMatrix) -> FloatMatrix {
        FloatMatrix_lssolve(self, b)
    }
    #[inline]
    pub unsafe fn lssolve1(&self, b: *const FloatMatrix,
                           info: *mut octave_idx_type) -> FloatMatrix {
        FloatMatrix_lssolve1(self, b, info)
    }
    #[inline]
    pub unsafe fn lssolve2(&self, b: *const FloatMatrix,
                           info: *mut octave_idx_type,
                           rank: *mut octave_idx_type) -> FloatMatrix {
        FloatMatrix_lssolve2(self, b, info, rank)
    }
    #[inline]
    pub unsafe fn lssolve3(&self, b: *const FloatMatrix,
                           info: *mut octave_idx_type,
                           rank: *mut octave_idx_type, rcon: *mut f32)
     -> FloatMatrix {
        FloatMatrix_lssolve3(self, b, info, rank, rcon)
    }
    #[inline]
    pub unsafe fn lssolve4(&self, b: *const FloatComplexMatrix)
     -> FloatComplexMatrix {
        FloatMatrix_lssolve4(self, b)
    }
    #[inline]
    pub unsafe fn lssolve5(&self, b: *const FloatComplexMatrix,
                           info: *mut octave_idx_type) -> FloatComplexMatrix {
        FloatMatrix_lssolve5(self, b, info)
    }
    #[inline]
    pub unsafe fn lssolve6(&self, b: *const FloatComplexMatrix,
                           info: *mut octave_idx_type,
                           rank: *mut octave_idx_type) -> FloatComplexMatrix {
        FloatMatrix_lssolve6(self, b, info, rank)
    }
    #[inline]
    pub unsafe fn lssolve7(&self, b: *const FloatComplexMatrix,
                           info: *mut octave_idx_type,
                           rank: *mut octave_idx_type, rcon: *mut f32)
     -> FloatComplexMatrix {
        FloatMatrix_lssolve7(self, b, info, rank, rcon)
    }
    #[inline]
    pub unsafe fn lssolve8(&self, b: *const FloatColumnVector)
     -> FloatColumnVector {
        FloatMatrix_lssolve8(self, b)
    }
    #[inline]
    pub unsafe fn lssolve9(&self, b: *const FloatColumnVector,
                           info: *mut octave_idx_type) -> FloatColumnVector {
        FloatMatrix_lssolve9(self, b, info)
    }
    #[inline]
    pub unsafe fn lssolve10(&self, b: *const FloatColumnVector,
                            info: *mut octave_idx_type,
                            rank: *mut octave_idx_type) -> FloatColumnVector {
        FloatMatrix_lssolve10(self, b, info, rank)
    }
    #[inline]
    pub unsafe fn lssolve11(&self, b: *const FloatColumnVector,
                            info: *mut octave_idx_type,
                            rank: *mut octave_idx_type, rcon: *mut f32)
     -> FloatColumnVector {
        FloatMatrix_lssolve11(self, b, info, rank, rcon)
    }
    #[inline]
    pub unsafe fn lssolve12(&self, b: *const FloatComplexColumnVector)
     -> FloatComplexColumnVector {
        FloatMatrix_lssolve12(self, b)
    }
    #[inline]
    pub unsafe fn lssolve13(&self, b: *const FloatComplexColumnVector,
                            info: *mut octave_idx_type)
     -> FloatComplexColumnVector {
        FloatMatrix_lssolve13(self, b, info)
    }
    #[inline]
    pub unsafe fn lssolve14(&self, b: *const FloatComplexColumnVector,
                            info: *mut octave_idx_type,
                            rank: *mut octave_idx_type)
     -> FloatComplexColumnVector {
        FloatMatrix_lssolve14(self, b, info, rank)
    }
    #[inline]
    pub unsafe fn lssolve15(&self, b: *const FloatComplexColumnVector,
                            info: *mut octave_idx_type,
                            rank: *mut octave_idx_type, rcon: *mut f32)
     -> FloatComplexColumnVector {
        FloatMatrix_lssolve15(self, b, info, rank, rcon)
    }
    #[inline]
    pub unsafe fn cumprod(&self, dim: ::std::os::raw::c_int) -> FloatMatrix {
        FloatMatrix_cumprod(self, dim)
    }
    #[inline]
    pub unsafe fn cumsum(&self, dim: ::std::os::raw::c_int) -> FloatMatrix {
        FloatMatrix_cumsum(self, dim)
    }
    #[inline]
    pub unsafe fn prod(&self, dim: ::std::os::raw::c_int) -> FloatMatrix {
        FloatMatrix_prod(self, dim)
    }
    #[inline]
    pub unsafe fn sum(&self, dim: ::std::os::raw::c_int) -> FloatMatrix {
        FloatMatrix_sum(self, dim)
    }
    #[inline]
    pub unsafe fn sumsq(&self, dim: ::std::os::raw::c_int) -> FloatMatrix {
        FloatMatrix_sumsq(self, dim)
    }
    #[inline]
    pub unsafe fn abs(&self) -> FloatMatrix { FloatMatrix_abs(self) }
    #[inline]
    pub unsafe fn diag(&self, k: octave_idx_type) -> FloatMatrix {
        FloatMatrix_diag(self, k)
    }
    #[inline]
    pub unsafe fn diag1(&self, m: octave_idx_type, n: octave_idx_type)
     -> FloatDiagMatrix {
        FloatMatrix_diag1(self, m, n)
    }
    #[inline]
    pub unsafe fn row_min(&self) -> FloatColumnVector {
        FloatMatrix_row_min(self)
    }
    #[inline]
    pub unsafe fn row_max(&self) -> FloatColumnVector {
        FloatMatrix_row_max(self)
    }
    #[inline]
    pub unsafe fn row_min1(&self, index: *mut Array<::std::os::raw::c_int>)
     -> FloatColumnVector {
        FloatMatrix_row_min1(self, index)
    }
    #[inline]
    pub unsafe fn row_max1(&self, index: *mut Array<::std::os::raw::c_int>)
     -> FloatColumnVector {
        FloatMatrix_row_max1(self, index)
    }
    #[inline]
    pub unsafe fn column_min(&self) -> FloatRowVector {
        FloatMatrix_column_min(self)
    }
    #[inline]
    pub unsafe fn column_max(&self) -> FloatRowVector {
        FloatMatrix_column_max(self)
    }
    #[inline]
    pub unsafe fn column_min1(&self, index: *mut Array<::std::os::raw::c_int>)
     -> FloatRowVector {
        FloatMatrix_column_min1(self, index)
    }
    #[inline]
    pub unsafe fn column_max1(&self, index: *mut Array<::std::os::raw::c_int>)
     -> FloatRowVector {
        FloatMatrix_column_max1(self, index)
    }
    #[inline]
    pub unsafe fn new(rv: *const FloatRowVector) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        FloatMatrix_FloatMatrix(&mut __bindgen_tmp, rv);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(cv: *const FloatColumnVector) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        FloatMatrix_FloatMatrix1(&mut __bindgen_tmp, cv);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new2(a: *const FloatDiagMatrix) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        FloatMatrix_FloatMatrix2(&mut __bindgen_tmp, a);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new3(a: *const MDiagArray2<f32>) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        FloatMatrix_FloatMatrix3(&mut __bindgen_tmp, a);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new4(a: *const DiagArray2<f32>) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        FloatMatrix_FloatMatrix4(&mut __bindgen_tmp, a);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new5(a: *const PermMatrix) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        FloatMatrix_FloatMatrix5(&mut __bindgen_tmp, a);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new6(a: *const boolMatrix) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        FloatMatrix_FloatMatrix6(&mut __bindgen_tmp, a);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new7(a: *const charMatrix) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        FloatMatrix_FloatMatrix7(&mut __bindgen_tmp, a);
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct FloatComplexMatrix {
    pub _base: FloatComplexNDArray,
}
pub type FloatComplexMatrix_column_vector_type = FloatComplexColumnVector;
pub type FloatComplexMatrix_row_vector_type = FloatComplexRowVector;
pub type FloatComplexMatrix_real_column_vector_type = FloatColumnVector;
pub type FloatComplexMatrix_real_row_vector_type = FloatRowVector;
pub type FloatComplexMatrix_real_matrix_type = FloatMatrix;
pub type FloatComplexMatrix_complex_matrix_type = FloatComplexMatrix;
pub type FloatComplexMatrix_real_diag_matrix_type = FloatDiagMatrix;
pub type FloatComplexMatrix_complex_diag_matrix_type = FloatComplexDiagMatrix;
pub type FloatComplexMatrix_real_elt_type = f32;
pub type FloatComplexMatrix_complex_elt_type = FloatComplex;
pub type FloatComplexMatrix_solve_singularity_handler =
    ::std::option::Option<unsafe extern "C" fn(rcon: f32)>;
#[test]
fn bindgen_test_layout_FloatComplexMatrix() {
    assert_eq!(::std::mem::size_of::<FloatComplexMatrix>() , 40usize , concat
               ! ( "Size of: " , stringify ! ( FloatComplexMatrix ) ));
    assert_eq! (::std::mem::align_of::<FloatComplexMatrix>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( FloatComplexMatrix ) ));
}
extern "C" {
    #[link_name = "?is_hermitian@FloatComplexMatrix@@QEBA_NXZ"]
    pub fn FloatComplexMatrix_is_hermitian(this: *const FloatComplexMatrix)
     -> bool;
}
extern "C" {
    #[link_name =
          "?insert@FloatComplexMatrix@@QEAAAEAV1@AEBVFloatMatrix@@HH@Z"]
    pub fn FloatComplexMatrix_insert(this: *mut FloatComplexMatrix,
                                     a: *const FloatMatrix,
                                     r: octave_idx_type, c: octave_idx_type)
     -> *mut FloatComplexMatrix;
}
extern "C" {
    #[link_name =
          "?insert@FloatComplexMatrix@@QEAAAEAV1@AEBVFloatRowVector@@HH@Z"]
    pub fn FloatComplexMatrix_insert1(this: *mut FloatComplexMatrix,
                                      a: *const FloatRowVector,
                                      r: octave_idx_type, c: octave_idx_type)
     -> *mut FloatComplexMatrix;
}
extern "C" {
    #[link_name =
          "?insert@FloatComplexMatrix@@QEAAAEAV1@AEBVFloatColumnVector@@HH@Z"]
    pub fn FloatComplexMatrix_insert2(this: *mut FloatComplexMatrix,
                                      a: *const FloatColumnVector,
                                      r: octave_idx_type, c: octave_idx_type)
     -> *mut FloatComplexMatrix;
}
extern "C" {
    #[link_name =
          "?insert@FloatComplexMatrix@@QEAAAEAV1@AEBVFloatDiagMatrix@@HH@Z"]
    pub fn FloatComplexMatrix_insert3(this: *mut FloatComplexMatrix,
                                      a: *const FloatDiagMatrix,
                                      r: octave_idx_type, c: octave_idx_type)
     -> *mut FloatComplexMatrix;
}
extern "C" {
    #[link_name = "?insert@FloatComplexMatrix@@QEAAAEAV1@AEBV1@HH@Z"]
    pub fn FloatComplexMatrix_insert4(this: *mut FloatComplexMatrix,
                                      a: *const FloatComplexMatrix,
                                      r: octave_idx_type, c: octave_idx_type)
     -> *mut FloatComplexMatrix;
}
extern "C" {
    #[link_name =
          "?insert@FloatComplexMatrix@@QEAAAEAV1@AEBVFloatComplexRowVector@@HH@Z"]
    pub fn FloatComplexMatrix_insert5(this: *mut FloatComplexMatrix,
                                      a: *const FloatComplexRowVector,
                                      r: octave_idx_type, c: octave_idx_type)
     -> *mut FloatComplexMatrix;
}
extern "C" {
    #[link_name =
          "?insert@FloatComplexMatrix@@QEAAAEAV1@AEBVFloatComplexColumnVector@@HH@Z"]
    pub fn FloatComplexMatrix_insert6(this: *mut FloatComplexMatrix,
                                      a: *const FloatComplexColumnVector,
                                      r: octave_idx_type, c: octave_idx_type)
     -> *mut FloatComplexMatrix;
}
extern "C" {
    #[link_name =
          "?insert@FloatComplexMatrix@@QEAAAEAV1@AEBVFloatComplexDiagMatrix@@HH@Z"]
    pub fn FloatComplexMatrix_insert7(this: *mut FloatComplexMatrix,
                                      a: *const FloatComplexDiagMatrix,
                                      r: octave_idx_type, c: octave_idx_type)
     -> *mut FloatComplexMatrix;
}
extern "C" {
    #[link_name = "?fill@FloatComplexMatrix@@QEAAAEAV1@M@Z"]
    pub fn FloatComplexMatrix_fill(this: *mut FloatComplexMatrix, val: f32)
     -> *mut FloatComplexMatrix;
}
extern "C" {
    #[link_name =
          "?fill@FloatComplexMatrix@@QEAAAEAV1@AEBU?$complex@M@std@@@Z"]
    pub fn FloatComplexMatrix_fill1(this: *mut FloatComplexMatrix,
                                    val: *const FloatComplex)
     -> *mut FloatComplexMatrix;
}
extern "C" {
    #[link_name = "?fill@FloatComplexMatrix@@QEAAAEAV1@MHHHH@Z"]
    pub fn FloatComplexMatrix_fill2(this: *mut FloatComplexMatrix, val: f32,
                                    r1: octave_idx_type, c1: octave_idx_type,
                                    r2: octave_idx_type, c2: octave_idx_type)
     -> *mut FloatComplexMatrix;
}
extern "C" {
    #[link_name =
          "?fill@FloatComplexMatrix@@QEAAAEAV1@AEBU?$complex@M@std@@HHHH@Z"]
    pub fn FloatComplexMatrix_fill3(this: *mut FloatComplexMatrix,
                                    val: *const FloatComplex,
                                    r1: octave_idx_type, c1: octave_idx_type,
                                    r2: octave_idx_type, c2: octave_idx_type)
     -> *mut FloatComplexMatrix;
}
extern "C" {
    #[link_name = "?append@FloatComplexMatrix@@QEBA?AV1@AEBVFloatMatrix@@@Z"]
    pub fn FloatComplexMatrix_append(this: *const FloatComplexMatrix,
                                     a: *const FloatMatrix)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name =
          "?append@FloatComplexMatrix@@QEBA?AV1@AEBVFloatRowVector@@@Z"]
    pub fn FloatComplexMatrix_append1(this: *const FloatComplexMatrix,
                                      a: *const FloatRowVector)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name =
          "?append@FloatComplexMatrix@@QEBA?AV1@AEBVFloatColumnVector@@@Z"]
    pub fn FloatComplexMatrix_append2(this: *const FloatComplexMatrix,
                                      a: *const FloatColumnVector)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name =
          "?append@FloatComplexMatrix@@QEBA?AV1@AEBVFloatDiagMatrix@@@Z"]
    pub fn FloatComplexMatrix_append3(this: *const FloatComplexMatrix,
                                      a: *const FloatDiagMatrix)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name = "?append@FloatComplexMatrix@@QEBA?AV1@AEBV1@@Z"]
    pub fn FloatComplexMatrix_append4(this: *const FloatComplexMatrix,
                                      a: *const FloatComplexMatrix)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name =
          "?append@FloatComplexMatrix@@QEBA?AV1@AEBVFloatComplexRowVector@@@Z"]
    pub fn FloatComplexMatrix_append5(this: *const FloatComplexMatrix,
                                      a: *const FloatComplexRowVector)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name =
          "?append@FloatComplexMatrix@@QEBA?AV1@AEBVFloatComplexColumnVector@@@Z"]
    pub fn FloatComplexMatrix_append6(this: *const FloatComplexMatrix,
                                      a: *const FloatComplexColumnVector)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name =
          "?append@FloatComplexMatrix@@QEBA?AV1@AEBVFloatComplexDiagMatrix@@@Z"]
    pub fn FloatComplexMatrix_append7(this: *const FloatComplexMatrix,
                                      a: *const FloatComplexDiagMatrix)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name = "?stack@FloatComplexMatrix@@QEBA?AV1@AEBVFloatMatrix@@@Z"]
    pub fn FloatComplexMatrix_stack(this: *const FloatComplexMatrix,
                                    a: *const FloatMatrix)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name =
          "?stack@FloatComplexMatrix@@QEBA?AV1@AEBVFloatRowVector@@@Z"]
    pub fn FloatComplexMatrix_stack1(this: *const FloatComplexMatrix,
                                     a: *const FloatRowVector)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name =
          "?stack@FloatComplexMatrix@@QEBA?AV1@AEBVFloatColumnVector@@@Z"]
    pub fn FloatComplexMatrix_stack2(this: *const FloatComplexMatrix,
                                     a: *const FloatColumnVector)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name =
          "?stack@FloatComplexMatrix@@QEBA?AV1@AEBVFloatDiagMatrix@@@Z"]
    pub fn FloatComplexMatrix_stack3(this: *const FloatComplexMatrix,
                                     a: *const FloatDiagMatrix)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name = "?stack@FloatComplexMatrix@@QEBA?AV1@AEBV1@@Z"]
    pub fn FloatComplexMatrix_stack4(this: *const FloatComplexMatrix,
                                     a: *const FloatComplexMatrix)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name =
          "?stack@FloatComplexMatrix@@QEBA?AV1@AEBVFloatComplexRowVector@@@Z"]
    pub fn FloatComplexMatrix_stack5(this: *const FloatComplexMatrix,
                                     a: *const FloatComplexRowVector)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name =
          "?stack@FloatComplexMatrix@@QEBA?AV1@AEBVFloatComplexColumnVector@@@Z"]
    pub fn FloatComplexMatrix_stack6(this: *const FloatComplexMatrix,
                                     a: *const FloatComplexColumnVector)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name =
          "?stack@FloatComplexMatrix@@QEBA?AV1@AEBVFloatComplexDiagMatrix@@@Z"]
    pub fn FloatComplexMatrix_stack7(this: *const FloatComplexMatrix,
                                     a: *const FloatComplexDiagMatrix)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name = "?extract@FloatComplexMatrix@@QEBA?AV1@HHHH@Z"]
    pub fn FloatComplexMatrix_extract(this: *const FloatComplexMatrix,
                                      r1: octave_idx_type,
                                      c1: octave_idx_type,
                                      r2: octave_idx_type,
                                      c2: octave_idx_type)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name = "?extract_n@FloatComplexMatrix@@QEBA?AV1@HHHH@Z"]
    pub fn FloatComplexMatrix_extract_n(this: *const FloatComplexMatrix,
                                        r1: octave_idx_type,
                                        c1: octave_idx_type,
                                        nr: octave_idx_type,
                                        nc: octave_idx_type)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name =
          "?row@FloatComplexMatrix@@QEBA?AVFloatComplexRowVector@@H@Z"]
    pub fn FloatComplexMatrix_row(this: *const FloatComplexMatrix,
                                  i: octave_idx_type)
     -> FloatComplexRowVector;
}
extern "C" {
    #[link_name =
          "?column@FloatComplexMatrix@@QEBA?AVFloatComplexColumnVector@@H@Z"]
    pub fn FloatComplexMatrix_column(this: *const FloatComplexMatrix,
                                     i: octave_idx_type)
     -> FloatComplexColumnVector;
}
extern "C" {
    #[link_name = "?inverse@FloatComplexMatrix@@QEBA?AV1@XZ"]
    pub fn FloatComplexMatrix_inverse(this: *const FloatComplexMatrix)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name = "?inverse@FloatComplexMatrix@@QEBA?AV1@AEAH@Z"]
    pub fn FloatComplexMatrix_inverse1(this: *const FloatComplexMatrix,
                                       info: *mut octave_idx_type)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name = "?inverse@FloatComplexMatrix@@QEBA?AV1@AEAHAEAM_N2@Z"]
    pub fn FloatComplexMatrix_inverse2(this: *const FloatComplexMatrix,
                                       info: *mut octave_idx_type,
                                       rcon: *mut f32, force: bool,
                                       calc_cond: bool) -> FloatComplexMatrix;
}
extern "C" {
    #[link_name = "?inverse@FloatComplexMatrix@@QEBA?AV1@AEAVMatrixType@@@Z"]
    pub fn FloatComplexMatrix_inverse3(this: *const FloatComplexMatrix,
                                       mattype: *mut MatrixType)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name =
          "?inverse@FloatComplexMatrix@@QEBA?AV1@AEAVMatrixType@@AEAH@Z"]
    pub fn FloatComplexMatrix_inverse4(this: *const FloatComplexMatrix,
                                       mattype: *mut MatrixType,
                                       info: *mut octave_idx_type)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name =
          "?inverse@FloatComplexMatrix@@QEBA?AV1@AEAVMatrixType@@AEAHAEAM_N3@Z"]
    pub fn FloatComplexMatrix_inverse5(this: *const FloatComplexMatrix,
                                       mattype: *mut MatrixType,
                                       info: *mut octave_idx_type,
                                       rcon: *mut f32, force: bool,
                                       calc_cond: bool) -> FloatComplexMatrix;
}
extern "C" {
    #[link_name = "?pseudo_inverse@FloatComplexMatrix@@QEBA?AV1@M@Z"]
    pub fn FloatComplexMatrix_pseudo_inverse(this: *const FloatComplexMatrix,
                                             tol: f32) -> FloatComplexMatrix;
}
extern "C" {
    #[link_name = "?fourier@FloatComplexMatrix@@QEBA?AV1@XZ"]
    pub fn FloatComplexMatrix_fourier(this: *const FloatComplexMatrix)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name = "?ifourier@FloatComplexMatrix@@QEBA?AV1@XZ"]
    pub fn FloatComplexMatrix_ifourier(this: *const FloatComplexMatrix)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name = "?fourier2d@FloatComplexMatrix@@QEBA?AV1@XZ"]
    pub fn FloatComplexMatrix_fourier2d(this: *const FloatComplexMatrix)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name = "?ifourier2d@FloatComplexMatrix@@QEBA?AV1@XZ"]
    pub fn FloatComplexMatrix_ifourier2d(this: *const FloatComplexMatrix)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name =
          "?determinant@FloatComplexMatrix@@QEBA?AV?$base_det@U?$complex@M@std@@@@XZ"]
    pub fn FloatComplexMatrix_determinant(this: *const FloatComplexMatrix)
     -> FloatComplexDET;
}
extern "C" {
    #[link_name =
          "?determinant@FloatComplexMatrix@@QEBA?AV?$base_det@U?$complex@M@std@@@@AEAH@Z"]
    pub fn FloatComplexMatrix_determinant1(this: *const FloatComplexMatrix,
                                           info: *mut octave_idx_type)
     -> FloatComplexDET;
}
extern "C" {
    #[link_name =
          "?determinant@FloatComplexMatrix@@QEBA?AV?$base_det@U?$complex@M@std@@@@AEAHAEAM_N@Z"]
    pub fn FloatComplexMatrix_determinant2(this: *const FloatComplexMatrix,
                                           info: *mut octave_idx_type,
                                           rcon: *mut f32, calc_cond: bool)
     -> FloatComplexDET;
}
extern "C" {
    #[link_name =
          "?determinant@FloatComplexMatrix@@QEBA?AV?$base_det@U?$complex@M@std@@@@AEAVMatrixType@@AEAHAEAM_N@Z"]
    pub fn FloatComplexMatrix_determinant3(this: *const FloatComplexMatrix,
                                           mattype: *mut MatrixType,
                                           info: *mut octave_idx_type,
                                           rcon: *mut f32, calc_cond: bool)
     -> FloatComplexDET;
}
extern "C" {
    #[link_name = "?rcond@FloatComplexMatrix@@QEBAMXZ"]
    pub fn FloatComplexMatrix_rcond(this: *const FloatComplexMatrix) -> f32;
}
extern "C" {
    #[link_name = "?rcond@FloatComplexMatrix@@QEBAMAEAVMatrixType@@@Z"]
    pub fn FloatComplexMatrix_rcond1(this: *const FloatComplexMatrix,
                                     mattype: *mut MatrixType) -> f32;
}
extern "C" {
    #[link_name =
          "?solve@FloatComplexMatrix@@QEBA?AV1@AEAVMatrixType@@AEBVFloatMatrix@@@Z"]
    pub fn FloatComplexMatrix_solve(this: *const FloatComplexMatrix,
                                    typ: *mut MatrixType,
                                    b: *const FloatMatrix)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@FloatComplexMatrix@@QEBA?AV1@AEAVMatrixType@@AEBVFloatMatrix@@AEAH@Z"]
    pub fn FloatComplexMatrix_solve1(this: *const FloatComplexMatrix,
                                     typ: *mut MatrixType,
                                     b: *const FloatMatrix,
                                     info: *mut octave_idx_type)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@FloatComplexMatrix@@QEBA?AV1@AEAVMatrixType@@AEBVFloatMatrix@@AEAHAEAM@Z"]
    pub fn FloatComplexMatrix_solve2(this: *const FloatComplexMatrix,
                                     typ: *mut MatrixType,
                                     b: *const FloatMatrix,
                                     info: *mut octave_idx_type,
                                     rcon: *mut f32) -> FloatComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@FloatComplexMatrix@@QEBA?AV1@AEAVMatrixType@@AEBVFloatMatrix@@AEAHAEAMP6AXM@Z_NW4blas_trans_type@@@Z"]
    pub fn FloatComplexMatrix_solve3(this: *const FloatComplexMatrix,
                                     typ: *mut MatrixType,
                                     b: *const FloatMatrix,
                                     info: *mut octave_idx_type,
                                     rcon: *mut f32,
                                     sing_handler:
                                         FloatComplexMatrix_solve_singularity_handler,
                                     singular_fallback: bool,
                                     transt: blas_trans_type)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@FloatComplexMatrix@@QEBA?AV1@AEAVMatrixType@@AEBV1@@Z"]
    pub fn FloatComplexMatrix_solve4(this: *const FloatComplexMatrix,
                                     typ: *mut MatrixType,
                                     b: *const FloatComplexMatrix)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@FloatComplexMatrix@@QEBA?AV1@AEAVMatrixType@@AEBV1@AEAH@Z"]
    pub fn FloatComplexMatrix_solve5(this: *const FloatComplexMatrix,
                                     typ: *mut MatrixType,
                                     b: *const FloatComplexMatrix,
                                     info: *mut octave_idx_type)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@FloatComplexMatrix@@QEBA?AV1@AEAVMatrixType@@AEBV1@AEAHAEAM@Z"]
    pub fn FloatComplexMatrix_solve6(this: *const FloatComplexMatrix,
                                     typ: *mut MatrixType,
                                     b: *const FloatComplexMatrix,
                                     info: *mut octave_idx_type,
                                     rcon: *mut f32) -> FloatComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@FloatComplexMatrix@@QEBA?AV1@AEAVMatrixType@@AEBV1@AEAHAEAMP6AXM@Z_NW4blas_trans_type@@@Z"]
    pub fn FloatComplexMatrix_solve7(this: *const FloatComplexMatrix,
                                     typ: *mut MatrixType,
                                     b: *const FloatComplexMatrix,
                                     info: *mut octave_idx_type,
                                     rcon: *mut f32,
                                     sing_handler:
                                         FloatComplexMatrix_solve_singularity_handler,
                                     singular_fallback: bool,
                                     transt: blas_trans_type)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@FloatComplexMatrix@@QEBA?AVFloatComplexColumnVector@@AEAVMatrixType@@AEBVFloatColumnVector@@@Z"]
    pub fn FloatComplexMatrix_solve8(this: *const FloatComplexMatrix,
                                     typ: *mut MatrixType,
                                     b: *const FloatColumnVector)
     -> FloatComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@FloatComplexMatrix@@QEBA?AVFloatComplexColumnVector@@AEAVMatrixType@@AEBVFloatColumnVector@@AEAH@Z"]
    pub fn FloatComplexMatrix_solve9(this: *const FloatComplexMatrix,
                                     typ: *mut MatrixType,
                                     b: *const FloatColumnVector,
                                     info: *mut octave_idx_type)
     -> FloatComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@FloatComplexMatrix@@QEBA?AVFloatComplexColumnVector@@AEAVMatrixType@@AEBVFloatColumnVector@@AEAHAEAM@Z"]
    pub fn FloatComplexMatrix_solve10(this: *const FloatComplexMatrix,
                                      typ: *mut MatrixType,
                                      b: *const FloatColumnVector,
                                      info: *mut octave_idx_type,
                                      rcon: *mut f32)
     -> FloatComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@FloatComplexMatrix@@QEBA?AVFloatComplexColumnVector@@AEAVMatrixType@@AEBVFloatColumnVector@@AEAHAEAMP6AXM@ZW4blas_trans_type@@@Z"]
    pub fn FloatComplexMatrix_solve11(this: *const FloatComplexMatrix,
                                      typ: *mut MatrixType,
                                      b: *const FloatColumnVector,
                                      info: *mut octave_idx_type,
                                      rcon: *mut f32,
                                      sing_handler:
                                          FloatComplexMatrix_solve_singularity_handler,
                                      transt: blas_trans_type)
     -> FloatComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@FloatComplexMatrix@@QEBA?AVFloatComplexColumnVector@@AEAVMatrixType@@AEBV2@@Z"]
    pub fn FloatComplexMatrix_solve12(this: *const FloatComplexMatrix,
                                      typ: *mut MatrixType,
                                      b: *const FloatComplexColumnVector)
     -> FloatComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@FloatComplexMatrix@@QEBA?AVFloatComplexColumnVector@@AEAVMatrixType@@AEBV2@AEAH@Z"]
    pub fn FloatComplexMatrix_solve13(this: *const FloatComplexMatrix,
                                      typ: *mut MatrixType,
                                      b: *const FloatComplexColumnVector,
                                      info: *mut octave_idx_type)
     -> FloatComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@FloatComplexMatrix@@QEBA?AVFloatComplexColumnVector@@AEAVMatrixType@@AEBV2@AEAHAEAM@Z"]
    pub fn FloatComplexMatrix_solve14(this: *const FloatComplexMatrix,
                                      typ: *mut MatrixType,
                                      b: *const FloatComplexColumnVector,
                                      info: *mut octave_idx_type,
                                      rcon: *mut f32)
     -> FloatComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@FloatComplexMatrix@@QEBA?AVFloatComplexColumnVector@@AEAVMatrixType@@AEBV2@AEAHAEAMP6AXM@ZW4blas_trans_type@@@Z"]
    pub fn FloatComplexMatrix_solve15(this: *const FloatComplexMatrix,
                                      typ: *mut MatrixType,
                                      b: *const FloatComplexColumnVector,
                                      info: *mut octave_idx_type,
                                      rcon: *mut f32,
                                      sing_handler:
                                          FloatComplexMatrix_solve_singularity_handler,
                                      transt: blas_trans_type)
     -> FloatComplexColumnVector;
}
extern "C" {
    #[link_name = "?solve@FloatComplexMatrix@@QEBA?AV1@AEBVFloatMatrix@@@Z"]
    pub fn FloatComplexMatrix_solve16(this: *const FloatComplexMatrix,
                                      b: *const FloatMatrix)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@FloatComplexMatrix@@QEBA?AV1@AEBVFloatMatrix@@AEAH@Z"]
    pub fn FloatComplexMatrix_solve17(this: *const FloatComplexMatrix,
                                      b: *const FloatMatrix,
                                      info: *mut octave_idx_type)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@FloatComplexMatrix@@QEBA?AV1@AEBVFloatMatrix@@AEAHAEAM@Z"]
    pub fn FloatComplexMatrix_solve18(this: *const FloatComplexMatrix,
                                      b: *const FloatMatrix,
                                      info: *mut octave_idx_type,
                                      rcon: *mut f32) -> FloatComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@FloatComplexMatrix@@QEBA?AV1@AEBVFloatMatrix@@AEAHAEAMP6AXM@ZW4blas_trans_type@@@Z"]
    pub fn FloatComplexMatrix_solve19(this: *const FloatComplexMatrix,
                                      b: *const FloatMatrix,
                                      info: *mut octave_idx_type,
                                      rcon: *mut f32,
                                      sing_handler:
                                          FloatComplexMatrix_solve_singularity_handler,
                                      transt: blas_trans_type)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name = "?solve@FloatComplexMatrix@@QEBA?AV1@AEBV1@@Z"]
    pub fn FloatComplexMatrix_solve20(this: *const FloatComplexMatrix,
                                      b: *const FloatComplexMatrix)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name = "?solve@FloatComplexMatrix@@QEBA?AV1@AEBV1@AEAH@Z"]
    pub fn FloatComplexMatrix_solve21(this: *const FloatComplexMatrix,
                                      b: *const FloatComplexMatrix,
                                      info: *mut octave_idx_type)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name = "?solve@FloatComplexMatrix@@QEBA?AV1@AEBV1@AEAHAEAM@Z"]
    pub fn FloatComplexMatrix_solve22(this: *const FloatComplexMatrix,
                                      b: *const FloatComplexMatrix,
                                      info: *mut octave_idx_type,
                                      rcon: *mut f32) -> FloatComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@FloatComplexMatrix@@QEBA?AV1@AEBV1@AEAHAEAMP6AXM@ZW4blas_trans_type@@@Z"]
    pub fn FloatComplexMatrix_solve23(this: *const FloatComplexMatrix,
                                      b: *const FloatComplexMatrix,
                                      info: *mut octave_idx_type,
                                      rcon: *mut f32,
                                      sing_handler:
                                          FloatComplexMatrix_solve_singularity_handler,
                                      transt: blas_trans_type)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@FloatComplexMatrix@@QEBA?AVFloatComplexColumnVector@@AEBVFloatColumnVector@@@Z"]
    pub fn FloatComplexMatrix_solve24(this: *const FloatComplexMatrix,
                                      b: *const FloatColumnVector)
     -> FloatComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@FloatComplexMatrix@@QEBA?AVFloatComplexColumnVector@@AEBVFloatColumnVector@@AEAH@Z"]
    pub fn FloatComplexMatrix_solve25(this: *const FloatComplexMatrix,
                                      b: *const FloatColumnVector,
                                      info: *mut octave_idx_type)
     -> FloatComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@FloatComplexMatrix@@QEBA?AVFloatComplexColumnVector@@AEBVFloatColumnVector@@AEAHAEAM@Z"]
    pub fn FloatComplexMatrix_solve26(this: *const FloatComplexMatrix,
                                      b: *const FloatColumnVector,
                                      info: *mut octave_idx_type,
                                      rcon: *mut f32)
     -> FloatComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@FloatComplexMatrix@@QEBA?AVFloatComplexColumnVector@@AEBVFloatColumnVector@@AEAHAEAMP6AXM@ZW4blas_trans_type@@@Z"]
    pub fn FloatComplexMatrix_solve27(this: *const FloatComplexMatrix,
                                      b: *const FloatColumnVector,
                                      info: *mut octave_idx_type,
                                      rcon: *mut f32,
                                      sing_handler:
                                          FloatComplexMatrix_solve_singularity_handler,
                                      transt: blas_trans_type)
     -> FloatComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@FloatComplexMatrix@@QEBA?AVFloatComplexColumnVector@@AEBV2@@Z"]
    pub fn FloatComplexMatrix_solve28(this: *const FloatComplexMatrix,
                                      b: *const FloatComplexColumnVector)
     -> FloatComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@FloatComplexMatrix@@QEBA?AVFloatComplexColumnVector@@AEBV2@AEAH@Z"]
    pub fn FloatComplexMatrix_solve29(this: *const FloatComplexMatrix,
                                      b: *const FloatComplexColumnVector,
                                      info: *mut octave_idx_type)
     -> FloatComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@FloatComplexMatrix@@QEBA?AVFloatComplexColumnVector@@AEBV2@AEAHAEAM@Z"]
    pub fn FloatComplexMatrix_solve30(this: *const FloatComplexMatrix,
                                      b: *const FloatComplexColumnVector,
                                      info: *mut octave_idx_type,
                                      rcon: *mut f32)
     -> FloatComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@FloatComplexMatrix@@QEBA?AVFloatComplexColumnVector@@AEBV2@AEAHAEAMP6AXM@ZW4blas_trans_type@@@Z"]
    pub fn FloatComplexMatrix_solve31(this: *const FloatComplexMatrix,
                                      b: *const FloatComplexColumnVector,
                                      info: *mut octave_idx_type,
                                      rcon: *mut f32,
                                      sing_handler:
                                          FloatComplexMatrix_solve_singularity_handler,
                                      transt: blas_trans_type)
     -> FloatComplexColumnVector;
}
extern "C" {
    #[link_name = "?lssolve@FloatComplexMatrix@@QEBA?AV1@AEBVFloatMatrix@@@Z"]
    pub fn FloatComplexMatrix_lssolve(this: *const FloatComplexMatrix,
                                      b: *const FloatMatrix)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name =
          "?lssolve@FloatComplexMatrix@@QEBA?AV1@AEBVFloatMatrix@@AEAH@Z"]
    pub fn FloatComplexMatrix_lssolve1(this: *const FloatComplexMatrix,
                                       b: *const FloatMatrix,
                                       info: *mut octave_idx_type)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name =
          "?lssolve@FloatComplexMatrix@@QEBA?AV1@AEBVFloatMatrix@@AEAH1@Z"]
    pub fn FloatComplexMatrix_lssolve2(this: *const FloatComplexMatrix,
                                       b: *const FloatMatrix,
                                       info: *mut octave_idx_type,
                                       rank: *mut octave_idx_type)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name =
          "?lssolve@FloatComplexMatrix@@QEBA?AV1@AEBVFloatMatrix@@AEAH1AEAM@Z"]
    pub fn FloatComplexMatrix_lssolve3(this: *const FloatComplexMatrix,
                                       b: *const FloatMatrix,
                                       info: *mut octave_idx_type,
                                       rank: *mut octave_idx_type,
                                       rcon: *mut f32) -> FloatComplexMatrix;
}
extern "C" {
    #[link_name = "?lssolve@FloatComplexMatrix@@QEBA?AV1@AEBV1@@Z"]
    pub fn FloatComplexMatrix_lssolve4(this: *const FloatComplexMatrix,
                                       b: *const FloatComplexMatrix)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name = "?lssolve@FloatComplexMatrix@@QEBA?AV1@AEBV1@AEAH@Z"]
    pub fn FloatComplexMatrix_lssolve5(this: *const FloatComplexMatrix,
                                       b: *const FloatComplexMatrix,
                                       info: *mut octave_idx_type)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name = "?lssolve@FloatComplexMatrix@@QEBA?AV1@AEBV1@AEAH1@Z"]
    pub fn FloatComplexMatrix_lssolve6(this: *const FloatComplexMatrix,
                                       b: *const FloatComplexMatrix,
                                       info: *mut octave_idx_type,
                                       rank: *mut octave_idx_type)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name = "?lssolve@FloatComplexMatrix@@QEBA?AV1@AEBV1@AEAH1AEAM@Z"]
    pub fn FloatComplexMatrix_lssolve7(this: *const FloatComplexMatrix,
                                       b: *const FloatComplexMatrix,
                                       info: *mut octave_idx_type,
                                       rank: *mut octave_idx_type,
                                       rcon: *mut f32) -> FloatComplexMatrix;
}
extern "C" {
    #[link_name =
          "?lssolve@FloatComplexMatrix@@QEBA?AVFloatComplexColumnVector@@AEBVFloatColumnVector@@@Z"]
    pub fn FloatComplexMatrix_lssolve8(this: *const FloatComplexMatrix,
                                       b: *const FloatColumnVector)
     -> FloatComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?lssolve@FloatComplexMatrix@@QEBA?AVFloatComplexColumnVector@@AEBVFloatColumnVector@@AEAH@Z"]
    pub fn FloatComplexMatrix_lssolve9(this: *const FloatComplexMatrix,
                                       b: *const FloatColumnVector,
                                       info: *mut octave_idx_type)
     -> FloatComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?lssolve@FloatComplexMatrix@@QEBA?AVFloatComplexColumnVector@@AEBVFloatColumnVector@@AEAH1@Z"]
    pub fn FloatComplexMatrix_lssolve10(this: *const FloatComplexMatrix,
                                        b: *const FloatColumnVector,
                                        info: *mut octave_idx_type,
                                        rank: *mut octave_idx_type)
     -> FloatComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?lssolve@FloatComplexMatrix@@QEBA?AVFloatComplexColumnVector@@AEBVFloatColumnVector@@AEAH1AEAM@Z"]
    pub fn FloatComplexMatrix_lssolve11(this: *const FloatComplexMatrix,
                                        b: *const FloatColumnVector,
                                        info: *mut octave_idx_type,
                                        rank: *mut octave_idx_type,
                                        rcon: *mut f32)
     -> FloatComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?lssolve@FloatComplexMatrix@@QEBA?AVFloatComplexColumnVector@@AEBV2@@Z"]
    pub fn FloatComplexMatrix_lssolve12(this: *const FloatComplexMatrix,
                                        b: *const FloatComplexColumnVector)
     -> FloatComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?lssolve@FloatComplexMatrix@@QEBA?AVFloatComplexColumnVector@@AEBV2@AEAH@Z"]
    pub fn FloatComplexMatrix_lssolve13(this: *const FloatComplexMatrix,
                                        b: *const FloatComplexColumnVector,
                                        info: *mut octave_idx_type)
     -> FloatComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?lssolve@FloatComplexMatrix@@QEBA?AVFloatComplexColumnVector@@AEBV2@AEAH1@Z"]
    pub fn FloatComplexMatrix_lssolve14(this: *const FloatComplexMatrix,
                                        b: *const FloatComplexColumnVector,
                                        info: *mut octave_idx_type,
                                        rank: *mut octave_idx_type)
     -> FloatComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?lssolve@FloatComplexMatrix@@QEBA?AVFloatComplexColumnVector@@AEBV2@AEAH1AEAM@Z"]
    pub fn FloatComplexMatrix_lssolve15(this: *const FloatComplexMatrix,
                                        b: *const FloatComplexColumnVector,
                                        info: *mut octave_idx_type,
                                        rank: *mut octave_idx_type,
                                        rcon: *mut f32)
     -> FloatComplexColumnVector;
}
extern "C" {
    #[link_name = "?all@FloatComplexMatrix@@QEBA?AVboolMatrix@@H@Z"]
    pub fn FloatComplexMatrix_all(this: *const FloatComplexMatrix,
                                  dim: ::std::os::raw::c_int) -> boolMatrix;
}
extern "C" {
    #[link_name = "?any@FloatComplexMatrix@@QEBA?AVboolMatrix@@H@Z"]
    pub fn FloatComplexMatrix_any(this: *const FloatComplexMatrix,
                                  dim: ::std::os::raw::c_int) -> boolMatrix;
}
extern "C" {
    #[link_name = "?cumprod@FloatComplexMatrix@@QEBA?AV1@H@Z"]
    pub fn FloatComplexMatrix_cumprod(this: *const FloatComplexMatrix,
                                      dim: ::std::os::raw::c_int)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name = "?cumsum@FloatComplexMatrix@@QEBA?AV1@H@Z"]
    pub fn FloatComplexMatrix_cumsum(this: *const FloatComplexMatrix,
                                     dim: ::std::os::raw::c_int)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name = "?prod@FloatComplexMatrix@@QEBA?AV1@H@Z"]
    pub fn FloatComplexMatrix_prod(this: *const FloatComplexMatrix,
                                   dim: ::std::os::raw::c_int)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name = "?sum@FloatComplexMatrix@@QEBA?AV1@H@Z"]
    pub fn FloatComplexMatrix_sum(this: *const FloatComplexMatrix,
                                  dim: ::std::os::raw::c_int)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name = "?sumsq@FloatComplexMatrix@@QEBA?AV1@H@Z"]
    pub fn FloatComplexMatrix_sumsq(this: *const FloatComplexMatrix,
                                    dim: ::std::os::raw::c_int)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name = "?abs@FloatComplexMatrix@@QEBA?AVFloatMatrix@@XZ"]
    pub fn FloatComplexMatrix_abs(this: *const FloatComplexMatrix)
     -> FloatMatrix;
}
extern "C" {
    #[link_name = "?diag@FloatComplexMatrix@@QEBA?AV1@H@Z"]
    pub fn FloatComplexMatrix_diag(this: *const FloatComplexMatrix,
                                   k: octave_idx_type) -> FloatComplexMatrix;
}
extern "C" {
    #[link_name =
          "?diag@FloatComplexMatrix@@QEBA?AVFloatComplexDiagMatrix@@HH@Z"]
    pub fn FloatComplexMatrix_diag1(this: *const FloatComplexMatrix,
                                    m: octave_idx_type, n: octave_idx_type)
     -> FloatComplexDiagMatrix;
}
extern "C" {
    #[link_name = "?row_is_real_only@FloatComplexMatrix@@QEBA_NH@Z"]
    pub fn FloatComplexMatrix_row_is_real_only(this:
                                                   *const FloatComplexMatrix,
                                               arg1: octave_idx_type) -> bool;
}
extern "C" {
    #[link_name = "?column_is_real_only@FloatComplexMatrix@@QEBA_NH@Z"]
    pub fn FloatComplexMatrix_column_is_real_only(this:
                                                      *const FloatComplexMatrix,
                                                  arg1: octave_idx_type)
     -> bool;
}
extern "C" {
    #[link_name =
          "?row_min@FloatComplexMatrix@@QEBA?AVFloatComplexColumnVector@@XZ"]
    pub fn FloatComplexMatrix_row_min(this: *const FloatComplexMatrix)
     -> FloatComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?row_max@FloatComplexMatrix@@QEBA?AVFloatComplexColumnVector@@XZ"]
    pub fn FloatComplexMatrix_row_max(this: *const FloatComplexMatrix)
     -> FloatComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?row_min@FloatComplexMatrix@@QEBA?AVFloatComplexColumnVector@@AEAV?$Array@H@@@Z"]
    pub fn FloatComplexMatrix_row_min1(this: *const FloatComplexMatrix,
                                       index:
                                           *mut Array<::std::os::raw::c_int>)
     -> FloatComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?row_max@FloatComplexMatrix@@QEBA?AVFloatComplexColumnVector@@AEAV?$Array@H@@@Z"]
    pub fn FloatComplexMatrix_row_max1(this: *const FloatComplexMatrix,
                                       index:
                                           *mut Array<::std::os::raw::c_int>)
     -> FloatComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?column_min@FloatComplexMatrix@@QEBA?AVFloatComplexRowVector@@XZ"]
    pub fn FloatComplexMatrix_column_min(this: *const FloatComplexMatrix)
     -> FloatComplexRowVector;
}
extern "C" {
    #[link_name =
          "?column_max@FloatComplexMatrix@@QEBA?AVFloatComplexRowVector@@XZ"]
    pub fn FloatComplexMatrix_column_max(this: *const FloatComplexMatrix)
     -> FloatComplexRowVector;
}
extern "C" {
    #[link_name =
          "?column_min@FloatComplexMatrix@@QEBA?AVFloatComplexRowVector@@AEAV?$Array@H@@@Z"]
    pub fn FloatComplexMatrix_column_min1(this: *const FloatComplexMatrix,
                                          index:
                                              *mut Array<::std::os::raw::c_int>)
     -> FloatComplexRowVector;
}
extern "C" {
    #[link_name =
          "?column_max@FloatComplexMatrix@@QEBA?AVFloatComplexRowVector@@AEAV?$Array@H@@@Z"]
    pub fn FloatComplexMatrix_column_max1(this: *const FloatComplexMatrix,
                                          index:
                                              *mut Array<::std::os::raw::c_int>)
     -> FloatComplexRowVector;
}
extern "C" {
    #[link_name = "??0FloatComplexMatrix@@QEAA@AEBVFloatMatrix@@@Z"]
    pub fn FloatComplexMatrix_FloatComplexMatrix(this:
                                                     *mut FloatComplexMatrix,
                                                 a: *const FloatMatrix);
}
extern "C" {
    #[link_name = "??0FloatComplexMatrix@@QEAA@AEBVFloatRowVector@@@Z"]
    pub fn FloatComplexMatrix_FloatComplexMatrix1(this:
                                                      *mut FloatComplexMatrix,
                                                  rv: *const FloatRowVector);
}
extern "C" {
    #[link_name = "??0FloatComplexMatrix@@QEAA@AEBVFloatColumnVector@@@Z"]
    pub fn FloatComplexMatrix_FloatComplexMatrix2(this:
                                                      *mut FloatComplexMatrix,
                                                  cv:
                                                      *const FloatColumnVector);
}
extern "C" {
    #[link_name = "??0FloatComplexMatrix@@QEAA@AEBVFloatDiagMatrix@@@Z"]
    pub fn FloatComplexMatrix_FloatComplexMatrix3(this:
                                                      *mut FloatComplexMatrix,
                                                  a: *const FloatDiagMatrix);
}
extern "C" {
    #[link_name = "??0FloatComplexMatrix@@QEAA@AEBV?$MDiagArray2@M@@@Z"]
    pub fn FloatComplexMatrix_FloatComplexMatrix4(this:
                                                      *mut FloatComplexMatrix,
                                                  a: *const MDiagArray2<f32>);
}
extern "C" {
    #[link_name = "??0FloatComplexMatrix@@QEAA@AEBV?$DiagArray2@M@@@Z"]
    pub fn FloatComplexMatrix_FloatComplexMatrix5(this:
                                                      *mut FloatComplexMatrix,
                                                  a: *const DiagArray2<f32>);
}
extern "C" {
    #[link_name = "??0FloatComplexMatrix@@QEAA@AEBVFloatComplexRowVector@@@Z"]
    pub fn FloatComplexMatrix_FloatComplexMatrix6(this:
                                                      *mut FloatComplexMatrix,
                                                  rv:
                                                      *const FloatComplexRowVector);
}
extern "C" {
    #[link_name =
          "??0FloatComplexMatrix@@QEAA@AEBVFloatComplexColumnVector@@@Z"]
    pub fn FloatComplexMatrix_FloatComplexMatrix7(this:
                                                      *mut FloatComplexMatrix,
                                                  cv:
                                                      *const FloatComplexColumnVector);
}
extern "C" {
    #[link_name =
          "??0FloatComplexMatrix@@QEAA@AEBVFloatComplexDiagMatrix@@@Z"]
    pub fn FloatComplexMatrix_FloatComplexMatrix8(this:
                                                      *mut FloatComplexMatrix,
                                                  a:
                                                      *const FloatComplexDiagMatrix);
}
extern "C" {
    #[link_name =
          "??0FloatComplexMatrix@@QEAA@AEBV?$MDiagArray2@U?$complex@M@std@@@@@Z"]
    pub fn FloatComplexMatrix_FloatComplexMatrix9(this:
                                                      *mut FloatComplexMatrix,
                                                  a:
                                                      *const MDiagArray2<std_complex<f32>>);
}
extern "C" {
    #[link_name =
          "??0FloatComplexMatrix@@QEAA@AEBV?$DiagArray2@U?$complex@M@std@@@@@Z"]
    pub fn FloatComplexMatrix_FloatComplexMatrix10(this:
                                                       *mut FloatComplexMatrix,
                                                   a:
                                                       *const DiagArray2<std_complex<f32>>);
}
extern "C" {
    #[link_name = "??0FloatComplexMatrix@@QEAA@AEBVboolMatrix@@@Z"]
    pub fn FloatComplexMatrix_FloatComplexMatrix11(this:
                                                       *mut FloatComplexMatrix,
                                                   a: *const boolMatrix);
}
extern "C" {
    #[link_name = "??0FloatComplexMatrix@@QEAA@AEBVcharMatrix@@@Z"]
    pub fn FloatComplexMatrix_FloatComplexMatrix12(this:
                                                       *mut FloatComplexMatrix,
                                                   a: *const charMatrix);
}
extern "C" {
    #[link_name = "??0FloatComplexMatrix@@QEAA@AEBVFloatMatrix@@0@Z"]
    pub fn FloatComplexMatrix_FloatComplexMatrix13(this:
                                                       *mut FloatComplexMatrix,
                                                   re: *const FloatMatrix,
                                                   im: *const FloatMatrix);
}
impl FloatComplexMatrix {
    #[inline]
    pub unsafe fn is_hermitian(&self) -> bool {
        FloatComplexMatrix_is_hermitian(self)
    }
    #[inline]
    pub unsafe fn insert(&mut self, a: *const FloatMatrix, r: octave_idx_type,
                         c: octave_idx_type) -> *mut FloatComplexMatrix {
        FloatComplexMatrix_insert(self, a, r, c)
    }
    #[inline]
    pub unsafe fn insert1(&mut self, a: *const FloatRowVector,
                          r: octave_idx_type, c: octave_idx_type)
     -> *mut FloatComplexMatrix {
        FloatComplexMatrix_insert1(self, a, r, c)
    }
    #[inline]
    pub unsafe fn insert2(&mut self, a: *const FloatColumnVector,
                          r: octave_idx_type, c: octave_idx_type)
     -> *mut FloatComplexMatrix {
        FloatComplexMatrix_insert2(self, a, r, c)
    }
    #[inline]
    pub unsafe fn insert3(&mut self, a: *const FloatDiagMatrix,
                          r: octave_idx_type, c: octave_idx_type)
     -> *mut FloatComplexMatrix {
        FloatComplexMatrix_insert3(self, a, r, c)
    }
    #[inline]
    pub unsafe fn insert4(&mut self, a: *const FloatComplexMatrix,
                          r: octave_idx_type, c: octave_idx_type)
     -> *mut FloatComplexMatrix {
        FloatComplexMatrix_insert4(self, a, r, c)
    }
    #[inline]
    pub unsafe fn insert5(&mut self, a: *const FloatComplexRowVector,
                          r: octave_idx_type, c: octave_idx_type)
     -> *mut FloatComplexMatrix {
        FloatComplexMatrix_insert5(self, a, r, c)
    }
    #[inline]
    pub unsafe fn insert6(&mut self, a: *const FloatComplexColumnVector,
                          r: octave_idx_type, c: octave_idx_type)
     -> *mut FloatComplexMatrix {
        FloatComplexMatrix_insert6(self, a, r, c)
    }
    #[inline]
    pub unsafe fn insert7(&mut self, a: *const FloatComplexDiagMatrix,
                          r: octave_idx_type, c: octave_idx_type)
     -> *mut FloatComplexMatrix {
        FloatComplexMatrix_insert7(self, a, r, c)
    }
    #[inline]
    pub unsafe fn fill(&mut self, val: f32) -> *mut FloatComplexMatrix {
        FloatComplexMatrix_fill(self, val)
    }
    #[inline]
    pub unsafe fn fill1(&mut self, val: *const FloatComplex)
     -> *mut FloatComplexMatrix {
        FloatComplexMatrix_fill1(self, val)
    }
    #[inline]
    pub unsafe fn fill2(&mut self, val: f32, r1: octave_idx_type,
                        c1: octave_idx_type, r2: octave_idx_type,
                        c2: octave_idx_type) -> *mut FloatComplexMatrix {
        FloatComplexMatrix_fill2(self, val, r1, c1, r2, c2)
    }
    #[inline]
    pub unsafe fn fill3(&mut self, val: *const FloatComplex,
                        r1: octave_idx_type, c1: octave_idx_type,
                        r2: octave_idx_type, c2: octave_idx_type)
     -> *mut FloatComplexMatrix {
        FloatComplexMatrix_fill3(self, val, r1, c1, r2, c2)
    }
    #[inline]
    pub unsafe fn append(&self, a: *const FloatMatrix) -> FloatComplexMatrix {
        FloatComplexMatrix_append(self, a)
    }
    #[inline]
    pub unsafe fn append1(&self, a: *const FloatRowVector)
     -> FloatComplexMatrix {
        FloatComplexMatrix_append1(self, a)
    }
    #[inline]
    pub unsafe fn append2(&self, a: *const FloatColumnVector)
     -> FloatComplexMatrix {
        FloatComplexMatrix_append2(self, a)
    }
    #[inline]
    pub unsafe fn append3(&self, a: *const FloatDiagMatrix)
     -> FloatComplexMatrix {
        FloatComplexMatrix_append3(self, a)
    }
    #[inline]
    pub unsafe fn append4(&self, a: *const FloatComplexMatrix)
     -> FloatComplexMatrix {
        FloatComplexMatrix_append4(self, a)
    }
    #[inline]
    pub unsafe fn append5(&self, a: *const FloatComplexRowVector)
     -> FloatComplexMatrix {
        FloatComplexMatrix_append5(self, a)
    }
    #[inline]
    pub unsafe fn append6(&self, a: *const FloatComplexColumnVector)
     -> FloatComplexMatrix {
        FloatComplexMatrix_append6(self, a)
    }
    #[inline]
    pub unsafe fn append7(&self, a: *const FloatComplexDiagMatrix)
     -> FloatComplexMatrix {
        FloatComplexMatrix_append7(self, a)
    }
    #[inline]
    pub unsafe fn stack(&self, a: *const FloatMatrix) -> FloatComplexMatrix {
        FloatComplexMatrix_stack(self, a)
    }
    #[inline]
    pub unsafe fn stack1(&self, a: *const FloatRowVector)
     -> FloatComplexMatrix {
        FloatComplexMatrix_stack1(self, a)
    }
    #[inline]
    pub unsafe fn stack2(&self, a: *const FloatColumnVector)
     -> FloatComplexMatrix {
        FloatComplexMatrix_stack2(self, a)
    }
    #[inline]
    pub unsafe fn stack3(&self, a: *const FloatDiagMatrix)
     -> FloatComplexMatrix {
        FloatComplexMatrix_stack3(self, a)
    }
    #[inline]
    pub unsafe fn stack4(&self, a: *const FloatComplexMatrix)
     -> FloatComplexMatrix {
        FloatComplexMatrix_stack4(self, a)
    }
    #[inline]
    pub unsafe fn stack5(&self, a: *const FloatComplexRowVector)
     -> FloatComplexMatrix {
        FloatComplexMatrix_stack5(self, a)
    }
    #[inline]
    pub unsafe fn stack6(&self, a: *const FloatComplexColumnVector)
     -> FloatComplexMatrix {
        FloatComplexMatrix_stack6(self, a)
    }
    #[inline]
    pub unsafe fn stack7(&self, a: *const FloatComplexDiagMatrix)
     -> FloatComplexMatrix {
        FloatComplexMatrix_stack7(self, a)
    }
    #[inline]
    pub unsafe fn extract(&self, r1: octave_idx_type, c1: octave_idx_type,
                          r2: octave_idx_type, c2: octave_idx_type)
     -> FloatComplexMatrix {
        FloatComplexMatrix_extract(self, r1, c1, r2, c2)
    }
    #[inline]
    pub unsafe fn extract_n(&self, r1: octave_idx_type, c1: octave_idx_type,
                            nr: octave_idx_type, nc: octave_idx_type)
     -> FloatComplexMatrix {
        FloatComplexMatrix_extract_n(self, r1, c1, nr, nc)
    }
    #[inline]
    pub unsafe fn row(&self, i: octave_idx_type) -> FloatComplexRowVector {
        FloatComplexMatrix_row(self, i)
    }
    #[inline]
    pub unsafe fn column(&self, i: octave_idx_type)
     -> FloatComplexColumnVector {
        FloatComplexMatrix_column(self, i)
    }
    #[inline]
    pub unsafe fn inverse(&self) -> FloatComplexMatrix {
        FloatComplexMatrix_inverse(self)
    }
    #[inline]
    pub unsafe fn inverse1(&self, info: *mut octave_idx_type)
     -> FloatComplexMatrix {
        FloatComplexMatrix_inverse1(self, info)
    }
    #[inline]
    pub unsafe fn inverse2(&self, info: *mut octave_idx_type, rcon: *mut f32,
                           force: bool, calc_cond: bool)
     -> FloatComplexMatrix {
        FloatComplexMatrix_inverse2(self, info, rcon, force, calc_cond)
    }
    #[inline]
    pub unsafe fn inverse3(&self, mattype: *mut MatrixType)
     -> FloatComplexMatrix {
        FloatComplexMatrix_inverse3(self, mattype)
    }
    #[inline]
    pub unsafe fn inverse4(&self, mattype: *mut MatrixType,
                           info: *mut octave_idx_type) -> FloatComplexMatrix {
        FloatComplexMatrix_inverse4(self, mattype, info)
    }
    #[inline]
    pub unsafe fn inverse5(&self, mattype: *mut MatrixType,
                           info: *mut octave_idx_type, rcon: *mut f32,
                           force: bool, calc_cond: bool)
     -> FloatComplexMatrix {
        FloatComplexMatrix_inverse5(self, mattype, info, rcon, force,
                                    calc_cond)
    }
    #[inline]
    pub unsafe fn pseudo_inverse(&self, tol: f32) -> FloatComplexMatrix {
        FloatComplexMatrix_pseudo_inverse(self, tol)
    }
    #[inline]
    pub unsafe fn fourier(&self) -> FloatComplexMatrix {
        FloatComplexMatrix_fourier(self)
    }
    #[inline]
    pub unsafe fn ifourier(&self) -> FloatComplexMatrix {
        FloatComplexMatrix_ifourier(self)
    }
    #[inline]
    pub unsafe fn fourier2d(&self) -> FloatComplexMatrix {
        FloatComplexMatrix_fourier2d(self)
    }
    #[inline]
    pub unsafe fn ifourier2d(&self) -> FloatComplexMatrix {
        FloatComplexMatrix_ifourier2d(self)
    }
    #[inline]
    pub unsafe fn determinant(&self) -> FloatComplexDET {
        FloatComplexMatrix_determinant(self)
    }
    #[inline]
    pub unsafe fn determinant1(&self, info: *mut octave_idx_type)
     -> FloatComplexDET {
        FloatComplexMatrix_determinant1(self, info)
    }
    #[inline]
    pub unsafe fn determinant2(&self, info: *mut octave_idx_type,
                               rcon: *mut f32, calc_cond: bool)
     -> FloatComplexDET {
        FloatComplexMatrix_determinant2(self, info, rcon, calc_cond)
    }
    #[inline]
    pub unsafe fn determinant3(&self, mattype: *mut MatrixType,
                               info: *mut octave_idx_type, rcon: *mut f32,
                               calc_cond: bool) -> FloatComplexDET {
        FloatComplexMatrix_determinant3(self, mattype, info, rcon, calc_cond)
    }
    #[inline]
    pub unsafe fn rcond(&self) -> f32 { FloatComplexMatrix_rcond(self) }
    #[inline]
    pub unsafe fn rcond1(&self, mattype: *mut MatrixType) -> f32 {
        FloatComplexMatrix_rcond1(self, mattype)
    }
    #[inline]
    pub unsafe fn solve(&self, typ: *mut MatrixType, b: *const FloatMatrix)
     -> FloatComplexMatrix {
        FloatComplexMatrix_solve(self, typ, b)
    }
    #[inline]
    pub unsafe fn solve1(&self, typ: *mut MatrixType, b: *const FloatMatrix,
                         info: *mut octave_idx_type) -> FloatComplexMatrix {
        FloatComplexMatrix_solve1(self, typ, b, info)
    }
    #[inline]
    pub unsafe fn solve2(&self, typ: *mut MatrixType, b: *const FloatMatrix,
                         info: *mut octave_idx_type, rcon: *mut f32)
     -> FloatComplexMatrix {
        FloatComplexMatrix_solve2(self, typ, b, info, rcon)
    }
    #[inline]
    pub unsafe fn solve3(&self, typ: *mut MatrixType, b: *const FloatMatrix,
                         info: *mut octave_idx_type, rcon: *mut f32,
                         sing_handler:
                             FloatComplexMatrix_solve_singularity_handler,
                         singular_fallback: bool, transt: blas_trans_type)
     -> FloatComplexMatrix {
        FloatComplexMatrix_solve3(self, typ, b, info, rcon, sing_handler,
                                  singular_fallback, transt)
    }
    #[inline]
    pub unsafe fn solve4(&self, typ: *mut MatrixType,
                         b: *const FloatComplexMatrix) -> FloatComplexMatrix {
        FloatComplexMatrix_solve4(self, typ, b)
    }
    #[inline]
    pub unsafe fn solve5(&self, typ: *mut MatrixType,
                         b: *const FloatComplexMatrix,
                         info: *mut octave_idx_type) -> FloatComplexMatrix {
        FloatComplexMatrix_solve5(self, typ, b, info)
    }
    #[inline]
    pub unsafe fn solve6(&self, typ: *mut MatrixType,
                         b: *const FloatComplexMatrix,
                         info: *mut octave_idx_type, rcon: *mut f32)
     -> FloatComplexMatrix {
        FloatComplexMatrix_solve6(self, typ, b, info, rcon)
    }
    #[inline]
    pub unsafe fn solve7(&self, typ: *mut MatrixType,
                         b: *const FloatComplexMatrix,
                         info: *mut octave_idx_type, rcon: *mut f32,
                         sing_handler:
                             FloatComplexMatrix_solve_singularity_handler,
                         singular_fallback: bool, transt: blas_trans_type)
     -> FloatComplexMatrix {
        FloatComplexMatrix_solve7(self, typ, b, info, rcon, sing_handler,
                                  singular_fallback, transt)
    }
    #[inline]
    pub unsafe fn solve8(&self, typ: *mut MatrixType,
                         b: *const FloatColumnVector)
     -> FloatComplexColumnVector {
        FloatComplexMatrix_solve8(self, typ, b)
    }
    #[inline]
    pub unsafe fn solve9(&self, typ: *mut MatrixType,
                         b: *const FloatColumnVector,
                         info: *mut octave_idx_type)
     -> FloatComplexColumnVector {
        FloatComplexMatrix_solve9(self, typ, b, info)
    }
    #[inline]
    pub unsafe fn solve10(&self, typ: *mut MatrixType,
                          b: *const FloatColumnVector,
                          info: *mut octave_idx_type, rcon: *mut f32)
     -> FloatComplexColumnVector {
        FloatComplexMatrix_solve10(self, typ, b, info, rcon)
    }
    #[inline]
    pub unsafe fn solve11(&self, typ: *mut MatrixType,
                          b: *const FloatColumnVector,
                          info: *mut octave_idx_type, rcon: *mut f32,
                          sing_handler:
                              FloatComplexMatrix_solve_singularity_handler,
                          transt: blas_trans_type)
     -> FloatComplexColumnVector {
        FloatComplexMatrix_solve11(self, typ, b, info, rcon, sing_handler,
                                   transt)
    }
    #[inline]
    pub unsafe fn solve12(&self, typ: *mut MatrixType,
                          b: *const FloatComplexColumnVector)
     -> FloatComplexColumnVector {
        FloatComplexMatrix_solve12(self, typ, b)
    }
    #[inline]
    pub unsafe fn solve13(&self, typ: *mut MatrixType,
                          b: *const FloatComplexColumnVector,
                          info: *mut octave_idx_type)
     -> FloatComplexColumnVector {
        FloatComplexMatrix_solve13(self, typ, b, info)
    }
    #[inline]
    pub unsafe fn solve14(&self, typ: *mut MatrixType,
                          b: *const FloatComplexColumnVector,
                          info: *mut octave_idx_type, rcon: *mut f32)
     -> FloatComplexColumnVector {
        FloatComplexMatrix_solve14(self, typ, b, info, rcon)
    }
    #[inline]
    pub unsafe fn solve15(&self, typ: *mut MatrixType,
                          b: *const FloatComplexColumnVector,
                          info: *mut octave_idx_type, rcon: *mut f32,
                          sing_handler:
                              FloatComplexMatrix_solve_singularity_handler,
                          transt: blas_trans_type)
     -> FloatComplexColumnVector {
        FloatComplexMatrix_solve15(self, typ, b, info, rcon, sing_handler,
                                   transt)
    }
    #[inline]
    pub unsafe fn solve16(&self, b: *const FloatMatrix)
     -> FloatComplexMatrix {
        FloatComplexMatrix_solve16(self, b)
    }
    #[inline]
    pub unsafe fn solve17(&self, b: *const FloatMatrix,
                          info: *mut octave_idx_type) -> FloatComplexMatrix {
        FloatComplexMatrix_solve17(self, b, info)
    }
    #[inline]
    pub unsafe fn solve18(&self, b: *const FloatMatrix,
                          info: *mut octave_idx_type, rcon: *mut f32)
     -> FloatComplexMatrix {
        FloatComplexMatrix_solve18(self, b, info, rcon)
    }
    #[inline]
    pub unsafe fn solve19(&self, b: *const FloatMatrix,
                          info: *mut octave_idx_type, rcon: *mut f32,
                          sing_handler:
                              FloatComplexMatrix_solve_singularity_handler,
                          transt: blas_trans_type) -> FloatComplexMatrix {
        FloatComplexMatrix_solve19(self, b, info, rcon, sing_handler, transt)
    }
    #[inline]
    pub unsafe fn solve20(&self, b: *const FloatComplexMatrix)
     -> FloatComplexMatrix {
        FloatComplexMatrix_solve20(self, b)
    }
    #[inline]
    pub unsafe fn solve21(&self, b: *const FloatComplexMatrix,
                          info: *mut octave_idx_type) -> FloatComplexMatrix {
        FloatComplexMatrix_solve21(self, b, info)
    }
    #[inline]
    pub unsafe fn solve22(&self, b: *const FloatComplexMatrix,
                          info: *mut octave_idx_type, rcon: *mut f32)
     -> FloatComplexMatrix {
        FloatComplexMatrix_solve22(self, b, info, rcon)
    }
    #[inline]
    pub unsafe fn solve23(&self, b: *const FloatComplexMatrix,
                          info: *mut octave_idx_type, rcon: *mut f32,
                          sing_handler:
                              FloatComplexMatrix_solve_singularity_handler,
                          transt: blas_trans_type) -> FloatComplexMatrix {
        FloatComplexMatrix_solve23(self, b, info, rcon, sing_handler, transt)
    }
    #[inline]
    pub unsafe fn solve24(&self, b: *const FloatColumnVector)
     -> FloatComplexColumnVector {
        FloatComplexMatrix_solve24(self, b)
    }
    #[inline]
    pub unsafe fn solve25(&self, b: *const FloatColumnVector,
                          info: *mut octave_idx_type)
     -> FloatComplexColumnVector {
        FloatComplexMatrix_solve25(self, b, info)
    }
    #[inline]
    pub unsafe fn solve26(&self, b: *const FloatColumnVector,
                          info: *mut octave_idx_type, rcon: *mut f32)
     -> FloatComplexColumnVector {
        FloatComplexMatrix_solve26(self, b, info, rcon)
    }
    #[inline]
    pub unsafe fn solve27(&self, b: *const FloatColumnVector,
                          info: *mut octave_idx_type, rcon: *mut f32,
                          sing_handler:
                              FloatComplexMatrix_solve_singularity_handler,
                          transt: blas_trans_type)
     -> FloatComplexColumnVector {
        FloatComplexMatrix_solve27(self, b, info, rcon, sing_handler, transt)
    }
    #[inline]
    pub unsafe fn solve28(&self, b: *const FloatComplexColumnVector)
     -> FloatComplexColumnVector {
        FloatComplexMatrix_solve28(self, b)
    }
    #[inline]
    pub unsafe fn solve29(&self, b: *const FloatComplexColumnVector,
                          info: *mut octave_idx_type)
     -> FloatComplexColumnVector {
        FloatComplexMatrix_solve29(self, b, info)
    }
    #[inline]
    pub unsafe fn solve30(&self, b: *const FloatComplexColumnVector,
                          info: *mut octave_idx_type, rcon: *mut f32)
     -> FloatComplexColumnVector {
        FloatComplexMatrix_solve30(self, b, info, rcon)
    }
    #[inline]
    pub unsafe fn solve31(&self, b: *const FloatComplexColumnVector,
                          info: *mut octave_idx_type, rcon: *mut f32,
                          sing_handler:
                              FloatComplexMatrix_solve_singularity_handler,
                          transt: blas_trans_type)
     -> FloatComplexColumnVector {
        FloatComplexMatrix_solve31(self, b, info, rcon, sing_handler, transt)
    }
    #[inline]
    pub unsafe fn lssolve(&self, b: *const FloatMatrix)
     -> FloatComplexMatrix {
        FloatComplexMatrix_lssolve(self, b)
    }
    #[inline]
    pub unsafe fn lssolve1(&self, b: *const FloatMatrix,
                           info: *mut octave_idx_type) -> FloatComplexMatrix {
        FloatComplexMatrix_lssolve1(self, b, info)
    }
    #[inline]
    pub unsafe fn lssolve2(&self, b: *const FloatMatrix,
                           info: *mut octave_idx_type,
                           rank: *mut octave_idx_type) -> FloatComplexMatrix {
        FloatComplexMatrix_lssolve2(self, b, info, rank)
    }
    #[inline]
    pub unsafe fn lssolve3(&self, b: *const FloatMatrix,
                           info: *mut octave_idx_type,
                           rank: *mut octave_idx_type, rcon: *mut f32)
     -> FloatComplexMatrix {
        FloatComplexMatrix_lssolve3(self, b, info, rank, rcon)
    }
    #[inline]
    pub unsafe fn lssolve4(&self, b: *const FloatComplexMatrix)
     -> FloatComplexMatrix {
        FloatComplexMatrix_lssolve4(self, b)
    }
    #[inline]
    pub unsafe fn lssolve5(&self, b: *const FloatComplexMatrix,
                           info: *mut octave_idx_type) -> FloatComplexMatrix {
        FloatComplexMatrix_lssolve5(self, b, info)
    }
    #[inline]
    pub unsafe fn lssolve6(&self, b: *const FloatComplexMatrix,
                           info: *mut octave_idx_type,
                           rank: *mut octave_idx_type) -> FloatComplexMatrix {
        FloatComplexMatrix_lssolve6(self, b, info, rank)
    }
    #[inline]
    pub unsafe fn lssolve7(&self, b: *const FloatComplexMatrix,
                           info: *mut octave_idx_type,
                           rank: *mut octave_idx_type, rcon: *mut f32)
     -> FloatComplexMatrix {
        FloatComplexMatrix_lssolve7(self, b, info, rank, rcon)
    }
    #[inline]
    pub unsafe fn lssolve8(&self, b: *const FloatColumnVector)
     -> FloatComplexColumnVector {
        FloatComplexMatrix_lssolve8(self, b)
    }
    #[inline]
    pub unsafe fn lssolve9(&self, b: *const FloatColumnVector,
                           info: *mut octave_idx_type)
     -> FloatComplexColumnVector {
        FloatComplexMatrix_lssolve9(self, b, info)
    }
    #[inline]
    pub unsafe fn lssolve10(&self, b: *const FloatColumnVector,
                            info: *mut octave_idx_type,
                            rank: *mut octave_idx_type)
     -> FloatComplexColumnVector {
        FloatComplexMatrix_lssolve10(self, b, info, rank)
    }
    #[inline]
    pub unsafe fn lssolve11(&self, b: *const FloatColumnVector,
                            info: *mut octave_idx_type,
                            rank: *mut octave_idx_type, rcon: *mut f32)
     -> FloatComplexColumnVector {
        FloatComplexMatrix_lssolve11(self, b, info, rank, rcon)
    }
    #[inline]
    pub unsafe fn lssolve12(&self, b: *const FloatComplexColumnVector)
     -> FloatComplexColumnVector {
        FloatComplexMatrix_lssolve12(self, b)
    }
    #[inline]
    pub unsafe fn lssolve13(&self, b: *const FloatComplexColumnVector,
                            info: *mut octave_idx_type)
     -> FloatComplexColumnVector {
        FloatComplexMatrix_lssolve13(self, b, info)
    }
    #[inline]
    pub unsafe fn lssolve14(&self, b: *const FloatComplexColumnVector,
                            info: *mut octave_idx_type,
                            rank: *mut octave_idx_type)
     -> FloatComplexColumnVector {
        FloatComplexMatrix_lssolve14(self, b, info, rank)
    }
    #[inline]
    pub unsafe fn lssolve15(&self, b: *const FloatComplexColumnVector,
                            info: *mut octave_idx_type,
                            rank: *mut octave_idx_type, rcon: *mut f32)
     -> FloatComplexColumnVector {
        FloatComplexMatrix_lssolve15(self, b, info, rank, rcon)
    }
    #[inline]
    pub unsafe fn all(&self, dim: ::std::os::raw::c_int) -> boolMatrix {
        FloatComplexMatrix_all(self, dim)
    }
    #[inline]
    pub unsafe fn any(&self, dim: ::std::os::raw::c_int) -> boolMatrix {
        FloatComplexMatrix_any(self, dim)
    }
    #[inline]
    pub unsafe fn cumprod(&self, dim: ::std::os::raw::c_int)
     -> FloatComplexMatrix {
        FloatComplexMatrix_cumprod(self, dim)
    }
    #[inline]
    pub unsafe fn cumsum(&self, dim: ::std::os::raw::c_int)
     -> FloatComplexMatrix {
        FloatComplexMatrix_cumsum(self, dim)
    }
    #[inline]
    pub unsafe fn prod(&self, dim: ::std::os::raw::c_int)
     -> FloatComplexMatrix {
        FloatComplexMatrix_prod(self, dim)
    }
    #[inline]
    pub unsafe fn sum(&self, dim: ::std::os::raw::c_int)
     -> FloatComplexMatrix {
        FloatComplexMatrix_sum(self, dim)
    }
    #[inline]
    pub unsafe fn sumsq(&self, dim: ::std::os::raw::c_int)
     -> FloatComplexMatrix {
        FloatComplexMatrix_sumsq(self, dim)
    }
    #[inline]
    pub unsafe fn abs(&self) -> FloatMatrix { FloatComplexMatrix_abs(self) }
    #[inline]
    pub unsafe fn diag(&self, k: octave_idx_type) -> FloatComplexMatrix {
        FloatComplexMatrix_diag(self, k)
    }
    #[inline]
    pub unsafe fn diag1(&self, m: octave_idx_type, n: octave_idx_type)
     -> FloatComplexDiagMatrix {
        FloatComplexMatrix_diag1(self, m, n)
    }
    #[inline]
    pub unsafe fn row_is_real_only(&self, arg1: octave_idx_type) -> bool {
        FloatComplexMatrix_row_is_real_only(self, arg1)
    }
    #[inline]
    pub unsafe fn column_is_real_only(&self, arg1: octave_idx_type) -> bool {
        FloatComplexMatrix_column_is_real_only(self, arg1)
    }
    #[inline]
    pub unsafe fn row_min(&self) -> FloatComplexColumnVector {
        FloatComplexMatrix_row_min(self)
    }
    #[inline]
    pub unsafe fn row_max(&self) -> FloatComplexColumnVector {
        FloatComplexMatrix_row_max(self)
    }
    #[inline]
    pub unsafe fn row_min1(&self, index: *mut Array<::std::os::raw::c_int>)
     -> FloatComplexColumnVector {
        FloatComplexMatrix_row_min1(self, index)
    }
    #[inline]
    pub unsafe fn row_max1(&self, index: *mut Array<::std::os::raw::c_int>)
     -> FloatComplexColumnVector {
        FloatComplexMatrix_row_max1(self, index)
    }
    #[inline]
    pub unsafe fn column_min(&self) -> FloatComplexRowVector {
        FloatComplexMatrix_column_min(self)
    }
    #[inline]
    pub unsafe fn column_max(&self) -> FloatComplexRowVector {
        FloatComplexMatrix_column_max(self)
    }
    #[inline]
    pub unsafe fn column_min1(&self, index: *mut Array<::std::os::raw::c_int>)
     -> FloatComplexRowVector {
        FloatComplexMatrix_column_min1(self, index)
    }
    #[inline]
    pub unsafe fn column_max1(&self, index: *mut Array<::std::os::raw::c_int>)
     -> FloatComplexRowVector {
        FloatComplexMatrix_column_max1(self, index)
    }
    #[inline]
    pub unsafe fn new(a: *const FloatMatrix) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        FloatComplexMatrix_FloatComplexMatrix(&mut __bindgen_tmp, a);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(rv: *const FloatRowVector) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        FloatComplexMatrix_FloatComplexMatrix1(&mut __bindgen_tmp, rv);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new2(cv: *const FloatColumnVector) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        FloatComplexMatrix_FloatComplexMatrix2(&mut __bindgen_tmp, cv);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new3(a: *const FloatDiagMatrix) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        FloatComplexMatrix_FloatComplexMatrix3(&mut __bindgen_tmp, a);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new4(a: *const MDiagArray2<f32>) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        FloatComplexMatrix_FloatComplexMatrix4(&mut __bindgen_tmp, a);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new5(a: *const DiagArray2<f32>) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        FloatComplexMatrix_FloatComplexMatrix5(&mut __bindgen_tmp, a);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new6(rv: *const FloatComplexRowVector) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        FloatComplexMatrix_FloatComplexMatrix6(&mut __bindgen_tmp, rv);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new7(cv: *const FloatComplexColumnVector) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        FloatComplexMatrix_FloatComplexMatrix7(&mut __bindgen_tmp, cv);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new8(a: *const FloatComplexDiagMatrix) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        FloatComplexMatrix_FloatComplexMatrix8(&mut __bindgen_tmp, a);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new9(a: *const MDiagArray2<std_complex<f32>>) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        FloatComplexMatrix_FloatComplexMatrix9(&mut __bindgen_tmp, a);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new10(a: *const DiagArray2<std_complex<f32>>) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        FloatComplexMatrix_FloatComplexMatrix10(&mut __bindgen_tmp, a);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new11(a: *const boolMatrix) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        FloatComplexMatrix_FloatComplexMatrix11(&mut __bindgen_tmp, a);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new12(a: *const charMatrix) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        FloatComplexMatrix_FloatComplexMatrix12(&mut __bindgen_tmp, a);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new13(re: *const FloatMatrix, im: *const FloatMatrix)
     -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        FloatComplexMatrix_FloatComplexMatrix13(&mut __bindgen_tmp, re, im);
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SparseMatrix {
    pub _base: MSparse<f64>,
}
pub type SparseMatrix_dense_matrix_type = Matrix;
pub type SparseMatrix_solve_singularity_handler =
    ::std::option::Option<unsafe extern "C" fn(rcond: f64)>;
#[test]
fn bindgen_test_layout_SparseMatrix() {
    assert_eq!(::std::mem::size_of::<SparseMatrix>() , 24usize , concat ! (
               "Size of: " , stringify ! ( SparseMatrix ) ));
    assert_eq! (::std::mem::align_of::<SparseMatrix>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( SparseMatrix ) ));
}
extern "C" {
    #[link_name = "?is_symmetric@SparseMatrix@@QEBA_NXZ"]
    pub fn SparseMatrix_is_symmetric(this: *const SparseMatrix) -> bool;
}
extern "C" {
    #[link_name = "?max@SparseMatrix@@QEBA?AV1@H@Z"]
    pub fn SparseMatrix_max(this: *const SparseMatrix,
                            dim: ::std::os::raw::c_int) -> SparseMatrix;
}
extern "C" {
    #[link_name = "?max@SparseMatrix@@QEBA?AV1@AEAV?$Array@H@@H@Z"]
    pub fn SparseMatrix_max1(this: *const SparseMatrix,
                             index: *mut Array<::std::os::raw::c_int>,
                             dim: ::std::os::raw::c_int) -> SparseMatrix;
}
extern "C" {
    #[link_name = "?min@SparseMatrix@@QEBA?AV1@H@Z"]
    pub fn SparseMatrix_min(this: *const SparseMatrix,
                            dim: ::std::os::raw::c_int) -> SparseMatrix;
}
extern "C" {
    #[link_name = "?min@SparseMatrix@@QEBA?AV1@AEAV?$Array@H@@H@Z"]
    pub fn SparseMatrix_min1(this: *const SparseMatrix,
                             index: *mut Array<::std::os::raw::c_int>,
                             dim: ::std::os::raw::c_int) -> SparseMatrix;
}
extern "C" {
    #[link_name = "?insert@SparseMatrix@@QEAAAEAV1@AEBV1@HH@Z"]
    pub fn SparseMatrix_insert(this: *mut SparseMatrix,
                               a: *const SparseMatrix, r: octave_idx_type,
                               c: octave_idx_type) -> *mut SparseMatrix;
}
extern "C" {
    #[link_name = "?insert@SparseMatrix@@QEAAAEAV1@AEBV1@AEBV?$Array@H@@@Z"]
    pub fn SparseMatrix_insert1(this: *mut SparseMatrix,
                                a: *const SparseMatrix,
                                indx: *const Array<::std::os::raw::c_int>)
     -> *mut SparseMatrix;
}
extern "C" {
    #[link_name = "?concat@SparseMatrix@@QEAA?AV1@AEBV1@AEBV?$Array@H@@@Z"]
    pub fn SparseMatrix_concat(this: *mut SparseMatrix,
                               rb: *const SparseMatrix,
                               ra_idx: *const Array<::std::os::raw::c_int>)
     -> SparseMatrix;
}
extern "C" {
    #[link_name =
          "?concat@SparseMatrix@@QEAA?AVSparseComplexMatrix@@AEBV2@AEBV?$Array@H@@@Z"]
    pub fn SparseMatrix_concat1(this: *mut SparseMatrix,
                                rb: *const SparseComplexMatrix,
                                ra_idx: *const Array<::std::os::raw::c_int>)
     -> SparseComplexMatrix;
}
extern "C" {
    #[link_name = "?row@SparseMatrix@@QEBA?AVRowVector@@H@Z"]
    pub fn SparseMatrix_row(this: *const SparseMatrix, i: octave_idx_type)
     -> RowVector;
}
extern "C" {
    #[link_name = "?column@SparseMatrix@@QEBA?AVColumnVector@@H@Z"]
    pub fn SparseMatrix_column(this: *const SparseMatrix, i: octave_idx_type)
     -> ColumnVector;
}
extern "C" {
    #[link_name = "?inverse@SparseMatrix@@QEBA?AV1@XZ"]
    pub fn SparseMatrix_inverse(this: *const SparseMatrix) -> SparseMatrix;
}
extern "C" {
    #[link_name = "?inverse@SparseMatrix@@QEBA?AV1@AEAVMatrixType@@@Z"]
    pub fn SparseMatrix_inverse1(this: *const SparseMatrix,
                                 mattype: *mut MatrixType) -> SparseMatrix;
}
extern "C" {
    #[link_name = "?inverse@SparseMatrix@@QEBA?AV1@AEAVMatrixType@@AEAH@Z"]
    pub fn SparseMatrix_inverse2(this: *const SparseMatrix,
                                 mattype: *mut MatrixType,
                                 info: *mut octave_idx_type) -> SparseMatrix;
}
extern "C" {
    #[link_name =
          "?inverse@SparseMatrix@@QEBA?AV1@AEAVMatrixType@@AEAHAEAN_N3@Z"]
    pub fn SparseMatrix_inverse3(this: *const SparseMatrix,
                                 mattype: *mut MatrixType,
                                 info: *mut octave_idx_type, rcond: *mut f64,
                                 force: bool, calc_cond: bool)
     -> SparseMatrix;
}
extern "C" {
    #[link_name = "?determinant@SparseMatrix@@QEBA?AV?$base_det@N@@XZ"]
    pub fn SparseMatrix_determinant(this: *const SparseMatrix) -> DET;
}
extern "C" {
    #[link_name = "?determinant@SparseMatrix@@QEBA?AV?$base_det@N@@AEAH@Z"]
    pub fn SparseMatrix_determinant1(this: *const SparseMatrix,
                                     info: *mut octave_idx_type) -> DET;
}
extern "C" {
    #[link_name =
          "?determinant@SparseMatrix@@QEBA?AV?$base_det@N@@AEAHAEAN_N@Z"]
    pub fn SparseMatrix_determinant2(this: *const SparseMatrix,
                                     info: *mut octave_idx_type,
                                     rcond: *mut f64, calc_cond: bool) -> DET;
}
extern "C" {
    #[link_name =
          "?solve@SparseMatrix@@QEBA?AVMatrix@@AEAVMatrixType@@AEBV2@@Z"]
    pub fn SparseMatrix_solve(this: *const SparseMatrix, typ: *mut MatrixType,
                              b: *const Matrix) -> Matrix;
}
extern "C" {
    #[link_name =
          "?solve@SparseMatrix@@QEBA?AVMatrix@@AEAVMatrixType@@AEBV2@AEAH@Z"]
    pub fn SparseMatrix_solve1(this: *const SparseMatrix,
                               typ: *mut MatrixType, b: *const Matrix,
                               info: *mut octave_idx_type) -> Matrix;
}
extern "C" {
    #[link_name =
          "?solve@SparseMatrix@@QEBA?AVMatrix@@AEAVMatrixType@@AEBV2@AEAHAEAN@Z"]
    pub fn SparseMatrix_solve2(this: *const SparseMatrix,
                               typ: *mut MatrixType, b: *const Matrix,
                               info: *mut octave_idx_type, rcond: *mut f64)
     -> Matrix;
}
extern "C" {
    #[link_name =
          "?solve@SparseMatrix@@QEBA?AVMatrix@@AEAVMatrixType@@AEBV2@AEAHAEANP6AXN@Z_N@Z"]
    pub fn SparseMatrix_solve3(this: *const SparseMatrix,
                               typ: *mut MatrixType, b: *const Matrix,
                               info: *mut octave_idx_type, rcond: *mut f64,
                               sing_handler:
                                   SparseMatrix_solve_singularity_handler,
                               singular_fallback: bool) -> Matrix;
}
extern "C" {
    #[link_name =
          "?solve@SparseMatrix@@QEBA?AVComplexMatrix@@AEAVMatrixType@@AEBV2@@Z"]
    pub fn SparseMatrix_solve4(this: *const SparseMatrix,
                               typ: *mut MatrixType, b: *const ComplexMatrix)
     -> ComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@SparseMatrix@@QEBA?AVComplexMatrix@@AEAVMatrixType@@AEBV2@AEAH@Z"]
    pub fn SparseMatrix_solve5(this: *const SparseMatrix,
                               typ: *mut MatrixType, b: *const ComplexMatrix,
                               info: *mut octave_idx_type) -> ComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@SparseMatrix@@QEBA?AVComplexMatrix@@AEAVMatrixType@@AEBV2@AEAHAEAN@Z"]
    pub fn SparseMatrix_solve6(this: *const SparseMatrix,
                               typ: *mut MatrixType, b: *const ComplexMatrix,
                               info: *mut octave_idx_type, rcond: *mut f64)
     -> ComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@SparseMatrix@@QEBA?AVComplexMatrix@@AEAVMatrixType@@AEBV2@AEAHAEANP6AXN@Z_N@Z"]
    pub fn SparseMatrix_solve7(this: *const SparseMatrix,
                               typ: *mut MatrixType, b: *const ComplexMatrix,
                               info: *mut octave_idx_type, rcond: *mut f64,
                               sing_handler:
                                   SparseMatrix_solve_singularity_handler,
                               singular_fallback: bool) -> ComplexMatrix;
}
extern "C" {
    #[link_name = "?solve@SparseMatrix@@QEBA?AV1@AEAVMatrixType@@AEBV1@@Z"]
    pub fn SparseMatrix_solve8(this: *const SparseMatrix,
                               typ: *mut MatrixType, b: *const SparseMatrix)
     -> SparseMatrix;
}
extern "C" {
    #[link_name =
          "?solve@SparseMatrix@@QEBA?AV1@AEAVMatrixType@@AEBV1@AEAH@Z"]
    pub fn SparseMatrix_solve9(this: *const SparseMatrix,
                               typ: *mut MatrixType, b: *const SparseMatrix,
                               info: *mut octave_idx_type) -> SparseMatrix;
}
extern "C" {
    #[link_name =
          "?solve@SparseMatrix@@QEBA?AV1@AEAVMatrixType@@AEBV1@AEAHAEAN@Z"]
    pub fn SparseMatrix_solve10(this: *const SparseMatrix,
                                typ: *mut MatrixType, b: *const SparseMatrix,
                                info: *mut octave_idx_type, rcond: *mut f64)
     -> SparseMatrix;
}
extern "C" {
    #[link_name =
          "?solve@SparseMatrix@@QEBA?AV1@AEAVMatrixType@@AEBV1@AEAHAEANP6AXN@Z_N@Z"]
    pub fn SparseMatrix_solve11(this: *const SparseMatrix,
                                typ: *mut MatrixType, b: *const SparseMatrix,
                                info: *mut octave_idx_type, rcond: *mut f64,
                                sing_handler:
                                    SparseMatrix_solve_singularity_handler,
                                singular_fallback: bool) -> SparseMatrix;
}
extern "C" {
    #[link_name =
          "?solve@SparseMatrix@@QEBA?AVSparseComplexMatrix@@AEAVMatrixType@@AEBV2@@Z"]
    pub fn SparseMatrix_solve12(this: *const SparseMatrix,
                                typ: *mut MatrixType,
                                b: *const SparseComplexMatrix)
     -> SparseComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@SparseMatrix@@QEBA?AVSparseComplexMatrix@@AEAVMatrixType@@AEBV2@AEAH@Z"]
    pub fn SparseMatrix_solve13(this: *const SparseMatrix,
                                typ: *mut MatrixType,
                                b: *const SparseComplexMatrix,
                                info: *mut octave_idx_type)
     -> SparseComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@SparseMatrix@@QEBA?AVSparseComplexMatrix@@AEAVMatrixType@@AEBV2@AEAHAEAN@Z"]
    pub fn SparseMatrix_solve14(this: *const SparseMatrix,
                                typ: *mut MatrixType,
                                b: *const SparseComplexMatrix,
                                info: *mut octave_idx_type, rcond: *mut f64)
     -> SparseComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@SparseMatrix@@QEBA?AVSparseComplexMatrix@@AEAVMatrixType@@AEBV2@AEAHAEANP6AXN@Z_N@Z"]
    pub fn SparseMatrix_solve15(this: *const SparseMatrix,
                                typ: *mut MatrixType,
                                b: *const SparseComplexMatrix,
                                info: *mut octave_idx_type, rcond: *mut f64,
                                sing_handler:
                                    SparseMatrix_solve_singularity_handler,
                                singular_fallabck: bool)
     -> SparseComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@SparseMatrix@@QEBA?AVColumnVector@@AEAVMatrixType@@AEBV2@@Z"]
    pub fn SparseMatrix_solve16(this: *const SparseMatrix,
                                typ: *mut MatrixType, b: *const ColumnVector)
     -> ColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@SparseMatrix@@QEBA?AVColumnVector@@AEAVMatrixType@@AEBV2@AEAH@Z"]
    pub fn SparseMatrix_solve17(this: *const SparseMatrix,
                                typ: *mut MatrixType, b: *const ColumnVector,
                                info: *mut octave_idx_type) -> ColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@SparseMatrix@@QEBA?AVColumnVector@@AEAVMatrixType@@AEBV2@AEAHAEAN@Z"]
    pub fn SparseMatrix_solve18(this: *const SparseMatrix,
                                typ: *mut MatrixType, b: *const ColumnVector,
                                info: *mut octave_idx_type, rcond: *mut f64)
     -> ColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@SparseMatrix@@QEBA?AVColumnVector@@AEAVMatrixType@@AEBV2@AEAHAEANP6AXN@Z@Z"]
    pub fn SparseMatrix_solve19(this: *const SparseMatrix,
                                typ: *mut MatrixType, b: *const ColumnVector,
                                info: *mut octave_idx_type, rcond: *mut f64,
                                sing_handler:
                                    SparseMatrix_solve_singularity_handler)
     -> ColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@SparseMatrix@@QEBA?AVComplexColumnVector@@AEAVMatrixType@@AEBV2@@Z"]
    pub fn SparseMatrix_solve20(this: *const SparseMatrix,
                                typ: *mut MatrixType,
                                b: *const ComplexColumnVector)
     -> ComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@SparseMatrix@@QEBA?AVComplexColumnVector@@AEAVMatrixType@@AEBV2@AEAH@Z"]
    pub fn SparseMatrix_solve21(this: *const SparseMatrix,
                                typ: *mut MatrixType,
                                b: *const ComplexColumnVector,
                                info: *mut octave_idx_type)
     -> ComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@SparseMatrix@@QEBA?AVComplexColumnVector@@AEAVMatrixType@@AEBV2@AEAHAEAN@Z"]
    pub fn SparseMatrix_solve22(this: *const SparseMatrix,
                                typ: *mut MatrixType,
                                b: *const ComplexColumnVector,
                                info: *mut octave_idx_type, rcond: *mut f64)
     -> ComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@SparseMatrix@@QEBA?AVComplexColumnVector@@AEAVMatrixType@@AEBV2@AEAHAEANP6AXN@Z@Z"]
    pub fn SparseMatrix_solve23(this: *const SparseMatrix,
                                typ: *mut MatrixType,
                                b: *const ComplexColumnVector,
                                info: *mut octave_idx_type, rcond: *mut f64,
                                sing_handler:
                                    SparseMatrix_solve_singularity_handler)
     -> ComplexColumnVector;
}
extern "C" {
    #[link_name = "?solve@SparseMatrix@@QEBA?AVMatrix@@AEBV2@@Z"]
    pub fn SparseMatrix_solve24(this: *const SparseMatrix, b: *const Matrix)
     -> Matrix;
}
extern "C" {
    #[link_name = "?solve@SparseMatrix@@QEBA?AVMatrix@@AEBV2@AEAH@Z"]
    pub fn SparseMatrix_solve25(this: *const SparseMatrix, b: *const Matrix,
                                info: *mut octave_idx_type) -> Matrix;
}
extern "C" {
    #[link_name = "?solve@SparseMatrix@@QEBA?AVMatrix@@AEBV2@AEAHAEAN@Z"]
    pub fn SparseMatrix_solve26(this: *const SparseMatrix, b: *const Matrix,
                                info: *mut octave_idx_type, rcond: *mut f64)
     -> Matrix;
}
extern "C" {
    #[link_name =
          "?solve@SparseMatrix@@QEBA?AVMatrix@@AEBV2@AEAHAEANP6AXN@Z@Z"]
    pub fn SparseMatrix_solve27(this: *const SparseMatrix, b: *const Matrix,
                                info: *mut octave_idx_type, rcond: *mut f64,
                                sing_handler:
                                    SparseMatrix_solve_singularity_handler)
     -> Matrix;
}
extern "C" {
    #[link_name = "?solve@SparseMatrix@@QEBA?AVComplexMatrix@@AEBV2@@Z"]
    pub fn SparseMatrix_solve28(this: *const SparseMatrix,
                                b: *const ComplexMatrix) -> ComplexMatrix;
}
extern "C" {
    #[link_name = "?solve@SparseMatrix@@QEBA?AVComplexMatrix@@AEBV2@AEAH@Z"]
    pub fn SparseMatrix_solve29(this: *const SparseMatrix,
                                b: *const ComplexMatrix,
                                info: *mut octave_idx_type) -> ComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@SparseMatrix@@QEBA?AVComplexMatrix@@AEBV2@AEAHAEAN@Z"]
    pub fn SparseMatrix_solve30(this: *const SparseMatrix,
                                b: *const ComplexMatrix,
                                info: *mut octave_idx_type, rcond: *mut f64)
     -> ComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@SparseMatrix@@QEBA?AVComplexMatrix@@AEBV2@AEAHAEANP6AXN@Z@Z"]
    pub fn SparseMatrix_solve31(this: *const SparseMatrix,
                                b: *const ComplexMatrix,
                                info: *mut octave_idx_type, rcond: *mut f64,
                                sing_handler:
                                    SparseMatrix_solve_singularity_handler)
     -> ComplexMatrix;
}
extern "C" {
    #[link_name = "?solve@SparseMatrix@@QEBA?AV1@AEBV1@@Z"]
    pub fn SparseMatrix_solve32(this: *const SparseMatrix,
                                b: *const SparseMatrix) -> SparseMatrix;
}
extern "C" {
    #[link_name = "?solve@SparseMatrix@@QEBA?AV1@AEBV1@AEAH@Z"]
    pub fn SparseMatrix_solve33(this: *const SparseMatrix,
                                b: *const SparseMatrix,
                                info: *mut octave_idx_type) -> SparseMatrix;
}
extern "C" {
    #[link_name = "?solve@SparseMatrix@@QEBA?AV1@AEBV1@AEAHAEAN@Z"]
    pub fn SparseMatrix_solve34(this: *const SparseMatrix,
                                b: *const SparseMatrix,
                                info: *mut octave_idx_type, rcond: *mut f64)
     -> SparseMatrix;
}
extern "C" {
    #[link_name = "?solve@SparseMatrix@@QEBA?AV1@AEBV1@AEAHAEANP6AXN@Z@Z"]
    pub fn SparseMatrix_solve35(this: *const SparseMatrix,
                                b: *const SparseMatrix,
                                info: *mut octave_idx_type, rcond: *mut f64,
                                sing_handler:
                                    SparseMatrix_solve_singularity_handler)
     -> SparseMatrix;
}
extern "C" {
    #[link_name = "?solve@SparseMatrix@@QEBA?AVSparseComplexMatrix@@AEBV2@@Z"]
    pub fn SparseMatrix_solve36(this: *const SparseMatrix,
                                b: *const SparseComplexMatrix)
     -> SparseComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@SparseMatrix@@QEBA?AVSparseComplexMatrix@@AEBV2@AEAH@Z"]
    pub fn SparseMatrix_solve37(this: *const SparseMatrix,
                                b: *const SparseComplexMatrix,
                                info: *mut octave_idx_type)
     -> SparseComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@SparseMatrix@@QEBA?AVSparseComplexMatrix@@AEBV2@AEAHAEAN@Z"]
    pub fn SparseMatrix_solve38(this: *const SparseMatrix,
                                b: *const SparseComplexMatrix,
                                info: *mut octave_idx_type, rcond: *mut f64)
     -> SparseComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@SparseMatrix@@QEBA?AVSparseComplexMatrix@@AEBV2@AEAHAEANP6AXN@Z@Z"]
    pub fn SparseMatrix_solve39(this: *const SparseMatrix,
                                b: *const SparseComplexMatrix,
                                info: *mut octave_idx_type, rcond: *mut f64,
                                sing_handler:
                                    SparseMatrix_solve_singularity_handler)
     -> SparseComplexMatrix;
}
extern "C" {
    #[link_name = "?solve@SparseMatrix@@QEBA?AVColumnVector@@AEBV2@@Z"]
    pub fn SparseMatrix_solve40(this: *const SparseMatrix,
                                b: *const ColumnVector) -> ColumnVector;
}
extern "C" {
    #[link_name = "?solve@SparseMatrix@@QEBA?AVColumnVector@@AEBV2@AEAH@Z"]
    pub fn SparseMatrix_solve41(this: *const SparseMatrix,
                                b: *const ColumnVector,
                                info: *mut octave_idx_type) -> ColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@SparseMatrix@@QEBA?AVColumnVector@@AEBV2@AEAHAEAN@Z"]
    pub fn SparseMatrix_solve42(this: *const SparseMatrix,
                                b: *const ColumnVector,
                                info: *mut octave_idx_type, rcond: *mut f64)
     -> ColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@SparseMatrix@@QEBA?AVColumnVector@@AEBV2@AEAHAEANP6AXN@Z@Z"]
    pub fn SparseMatrix_solve43(this: *const SparseMatrix,
                                b: *const ColumnVector,
                                info: *mut octave_idx_type, rcond: *mut f64,
                                sing_handler:
                                    SparseMatrix_solve_singularity_handler)
     -> ColumnVector;
}
extern "C" {
    #[link_name = "?solve@SparseMatrix@@QEBA?AVComplexColumnVector@@AEBV2@@Z"]
    pub fn SparseMatrix_solve44(this: *const SparseMatrix,
                                b: *const ComplexColumnVector)
     -> ComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@SparseMatrix@@QEBA?AVComplexColumnVector@@AEBV2@AEAH@Z"]
    pub fn SparseMatrix_solve45(this: *const SparseMatrix,
                                b: *const ComplexColumnVector,
                                info: *mut octave_idx_type)
     -> ComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@SparseMatrix@@QEBA?AVComplexColumnVector@@AEBV2@AEAHAEAN@Z"]
    pub fn SparseMatrix_solve46(this: *const SparseMatrix,
                                b: *const ComplexColumnVector,
                                info: *mut octave_idx_type, rcond: *mut f64)
     -> ComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@SparseMatrix@@QEBA?AVComplexColumnVector@@AEBV2@AEAHAEANP6AXN@Z@Z"]
    pub fn SparseMatrix_solve47(this: *const SparseMatrix,
                                b: *const ComplexColumnVector,
                                info: *mut octave_idx_type, rcond: *mut f64,
                                sing_handler:
                                    SparseMatrix_solve_singularity_handler)
     -> ComplexColumnVector;
}
extern "C" {
    #[link_name = "?any_element_is_negative@SparseMatrix@@QEBA_N_N@Z"]
    pub fn SparseMatrix_any_element_is_negative(this: *const SparseMatrix,
                                                arg1: bool) -> bool;
}
extern "C" {
    #[link_name = "?any_element_is_nan@SparseMatrix@@QEBA_NXZ"]
    pub fn SparseMatrix_any_element_is_nan(this: *const SparseMatrix) -> bool;
}
extern "C" {
    #[link_name = "?any_element_is_inf_or_nan@SparseMatrix@@QEBA_NXZ"]
    pub fn SparseMatrix_any_element_is_inf_or_nan(this: *const SparseMatrix)
     -> bool;
}
extern "C" {
    #[link_name = "?any_element_not_one_or_zero@SparseMatrix@@QEBA_NXZ"]
    pub fn SparseMatrix_any_element_not_one_or_zero(this: *const SparseMatrix)
     -> bool;
}
extern "C" {
    #[link_name = "?all_elements_are_zero@SparseMatrix@@QEBA_NXZ"]
    pub fn SparseMatrix_all_elements_are_zero(this: *const SparseMatrix)
     -> bool;
}
extern "C" {
    #[link_name =
          "?all_elements_are_int_or_inf_or_nan@SparseMatrix@@QEBA_NXZ"]
    pub fn SparseMatrix_all_elements_are_int_or_inf_or_nan(this:
                                                               *const SparseMatrix)
     -> bool;
}
extern "C" {
    #[link_name = "?all_integers@SparseMatrix@@QEBA_NAEAN0@Z"]
    pub fn SparseMatrix_all_integers(this: *const SparseMatrix,
                                     max_val: *mut f64, min_val: *mut f64)
     -> bool;
}
extern "C" {
    #[link_name = "?too_large_for_float@SparseMatrix@@QEBA_NXZ"]
    pub fn SparseMatrix_too_large_for_float(this: *const SparseMatrix)
     -> bool;
}
extern "C" {
    #[link_name = "?all@SparseMatrix@@QEBA?AVSparseBoolMatrix@@H@Z"]
    pub fn SparseMatrix_all(this: *const SparseMatrix,
                            dim: ::std::os::raw::c_int) -> SparseBoolMatrix;
}
extern "C" {
    #[link_name = "?any@SparseMatrix@@QEBA?AVSparseBoolMatrix@@H@Z"]
    pub fn SparseMatrix_any(this: *const SparseMatrix,
                            dim: ::std::os::raw::c_int) -> SparseBoolMatrix;
}
extern "C" {
    #[link_name = "?cumprod@SparseMatrix@@QEBA?AV1@H@Z"]
    pub fn SparseMatrix_cumprod(this: *const SparseMatrix,
                                dim: ::std::os::raw::c_int) -> SparseMatrix;
}
extern "C" {
    #[link_name = "?cumsum@SparseMatrix@@QEBA?AV1@H@Z"]
    pub fn SparseMatrix_cumsum(this: *const SparseMatrix,
                               dim: ::std::os::raw::c_int) -> SparseMatrix;
}
extern "C" {
    #[link_name = "?prod@SparseMatrix@@QEBA?AV1@H@Z"]
    pub fn SparseMatrix_prod(this: *const SparseMatrix,
                             dim: ::std::os::raw::c_int) -> SparseMatrix;
}
extern "C" {
    #[link_name = "?sum@SparseMatrix@@QEBA?AV1@H@Z"]
    pub fn SparseMatrix_sum(this: *const SparseMatrix,
                            dim: ::std::os::raw::c_int) -> SparseMatrix;
}
extern "C" {
    #[link_name = "?sumsq@SparseMatrix@@QEBA?AV1@H@Z"]
    pub fn SparseMatrix_sumsq(this: *const SparseMatrix,
                              dim: ::std::os::raw::c_int) -> SparseMatrix;
}
extern "C" {
    #[link_name = "?abs@SparseMatrix@@QEBA?AV1@XZ"]
    pub fn SparseMatrix_abs(this: *const SparseMatrix) -> SparseMatrix;
}
extern "C" {
    #[link_name = "?diag@SparseMatrix@@QEBA?AV1@H@Z"]
    pub fn SparseMatrix_diag(this: *const SparseMatrix, k: octave_idx_type)
     -> SparseMatrix;
}
extern "C" {
    #[link_name = "?matrix_value@SparseMatrix@@QEBA?AVMatrix@@XZ"]
    pub fn SparseMatrix_matrix_value(this: *const SparseMatrix) -> Matrix;
}
extern "C" {
    #[link_name = "?squeeze@SparseMatrix@@QEBA?AV1@XZ"]
    pub fn SparseMatrix_squeeze(this: *const SparseMatrix) -> SparseMatrix;
}
extern "C" {
    #[link_name = "?reshape@SparseMatrix@@QEBA?AV1@AEBVdim_vector@@@Z"]
    pub fn SparseMatrix_reshape(this: *const SparseMatrix,
                                new_dims: *const dim_vector) -> SparseMatrix;
}
extern "C" {
    #[link_name = "?permute@SparseMatrix@@QEBA?AV1@AEBV?$Array@H@@_N@Z"]
    pub fn SparseMatrix_permute(this: *const SparseMatrix,
                                vec: *const Array<::std::os::raw::c_int>,
                                inv: bool) -> SparseMatrix;
}
extern "C" {
    #[link_name = "?ipermute@SparseMatrix@@QEBA?AV1@AEBV?$Array@H@@@Z"]
    pub fn SparseMatrix_ipermute(this: *const SparseMatrix,
                                 vec: *const Array<::std::os::raw::c_int>)
     -> SparseMatrix;
}
extern "C" {
    #[link_name = "??0SparseMatrix@@QEAA@AEBVSparseBoolMatrix@@@Z"]
    pub fn SparseMatrix_SparseMatrix(this: *mut SparseMatrix,
                                     a: *const SparseBoolMatrix);
}
extern "C" {
    #[link_name = "??0SparseMatrix@@QEAA@AEBVDiagMatrix@@@Z"]
    pub fn SparseMatrix_SparseMatrix1(this: *mut SparseMatrix,
                                      a: *const DiagMatrix);
}
impl SparseMatrix {
    #[inline]
    pub unsafe fn is_symmetric(&self) -> bool {
        SparseMatrix_is_symmetric(self)
    }
    #[inline]
    pub unsafe fn max(&self, dim: ::std::os::raw::c_int) -> SparseMatrix {
        SparseMatrix_max(self, dim)
    }
    #[inline]
    pub unsafe fn max1(&self, index: *mut Array<::std::os::raw::c_int>,
                       dim: ::std::os::raw::c_int) -> SparseMatrix {
        SparseMatrix_max1(self, index, dim)
    }
    #[inline]
    pub unsafe fn min(&self, dim: ::std::os::raw::c_int) -> SparseMatrix {
        SparseMatrix_min(self, dim)
    }
    #[inline]
    pub unsafe fn min1(&self, index: *mut Array<::std::os::raw::c_int>,
                       dim: ::std::os::raw::c_int) -> SparseMatrix {
        SparseMatrix_min1(self, index, dim)
    }
    #[inline]
    pub unsafe fn insert(&mut self, a: *const SparseMatrix,
                         r: octave_idx_type, c: octave_idx_type)
     -> *mut SparseMatrix {
        SparseMatrix_insert(self, a, r, c)
    }
    #[inline]
    pub unsafe fn insert1(&mut self, a: *const SparseMatrix,
                          indx: *const Array<::std::os::raw::c_int>)
     -> *mut SparseMatrix {
        SparseMatrix_insert1(self, a, indx)
    }
    #[inline]
    pub unsafe fn concat(&mut self, rb: *const SparseMatrix,
                         ra_idx: *const Array<::std::os::raw::c_int>)
     -> SparseMatrix {
        SparseMatrix_concat(self, rb, ra_idx)
    }
    #[inline]
    pub unsafe fn concat1(&mut self, rb: *const SparseComplexMatrix,
                          ra_idx: *const Array<::std::os::raw::c_int>)
     -> SparseComplexMatrix {
        SparseMatrix_concat1(self, rb, ra_idx)
    }
    #[inline]
    pub unsafe fn row(&self, i: octave_idx_type) -> RowVector {
        SparseMatrix_row(self, i)
    }
    #[inline]
    pub unsafe fn column(&self, i: octave_idx_type) -> ColumnVector {
        SparseMatrix_column(self, i)
    }
    #[inline]
    pub unsafe fn inverse(&self) -> SparseMatrix {
        SparseMatrix_inverse(self)
    }
    #[inline]
    pub unsafe fn inverse1(&self, mattype: *mut MatrixType) -> SparseMatrix {
        SparseMatrix_inverse1(self, mattype)
    }
    #[inline]
    pub unsafe fn inverse2(&self, mattype: *mut MatrixType,
                           info: *mut octave_idx_type) -> SparseMatrix {
        SparseMatrix_inverse2(self, mattype, info)
    }
    #[inline]
    pub unsafe fn inverse3(&self, mattype: *mut MatrixType,
                           info: *mut octave_idx_type, rcond: *mut f64,
                           force: bool, calc_cond: bool) -> SparseMatrix {
        SparseMatrix_inverse3(self, mattype, info, rcond, force, calc_cond)
    }
    #[inline]
    pub unsafe fn determinant(&self) -> DET { SparseMatrix_determinant(self) }
    #[inline]
    pub unsafe fn determinant1(&self, info: *mut octave_idx_type) -> DET {
        SparseMatrix_determinant1(self, info)
    }
    #[inline]
    pub unsafe fn determinant2(&self, info: *mut octave_idx_type,
                               rcond: *mut f64, calc_cond: bool) -> DET {
        SparseMatrix_determinant2(self, info, rcond, calc_cond)
    }
    #[inline]
    pub unsafe fn solve(&self, typ: *mut MatrixType, b: *const Matrix)
     -> Matrix {
        SparseMatrix_solve(self, typ, b)
    }
    #[inline]
    pub unsafe fn solve1(&self, typ: *mut MatrixType, b: *const Matrix,
                         info: *mut octave_idx_type) -> Matrix {
        SparseMatrix_solve1(self, typ, b, info)
    }
    #[inline]
    pub unsafe fn solve2(&self, typ: *mut MatrixType, b: *const Matrix,
                         info: *mut octave_idx_type, rcond: *mut f64)
     -> Matrix {
        SparseMatrix_solve2(self, typ, b, info, rcond)
    }
    #[inline]
    pub unsafe fn solve3(&self, typ: *mut MatrixType, b: *const Matrix,
                         info: *mut octave_idx_type, rcond: *mut f64,
                         sing_handler: SparseMatrix_solve_singularity_handler,
                         singular_fallback: bool) -> Matrix {
        SparseMatrix_solve3(self, typ, b, info, rcond, sing_handler,
                            singular_fallback)
    }
    #[inline]
    pub unsafe fn solve4(&self, typ: *mut MatrixType, b: *const ComplexMatrix)
     -> ComplexMatrix {
        SparseMatrix_solve4(self, typ, b)
    }
    #[inline]
    pub unsafe fn solve5(&self, typ: *mut MatrixType, b: *const ComplexMatrix,
                         info: *mut octave_idx_type) -> ComplexMatrix {
        SparseMatrix_solve5(self, typ, b, info)
    }
    #[inline]
    pub unsafe fn solve6(&self, typ: *mut MatrixType, b: *const ComplexMatrix,
                         info: *mut octave_idx_type, rcond: *mut f64)
     -> ComplexMatrix {
        SparseMatrix_solve6(self, typ, b, info, rcond)
    }
    #[inline]
    pub unsafe fn solve7(&self, typ: *mut MatrixType, b: *const ComplexMatrix,
                         info: *mut octave_idx_type, rcond: *mut f64,
                         sing_handler: SparseMatrix_solve_singularity_handler,
                         singular_fallback: bool) -> ComplexMatrix {
        SparseMatrix_solve7(self, typ, b, info, rcond, sing_handler,
                            singular_fallback)
    }
    #[inline]
    pub unsafe fn solve8(&self, typ: *mut MatrixType, b: *const SparseMatrix)
     -> SparseMatrix {
        SparseMatrix_solve8(self, typ, b)
    }
    #[inline]
    pub unsafe fn solve9(&self, typ: *mut MatrixType, b: *const SparseMatrix,
                         info: *mut octave_idx_type) -> SparseMatrix {
        SparseMatrix_solve9(self, typ, b, info)
    }
    #[inline]
    pub unsafe fn solve10(&self, typ: *mut MatrixType, b: *const SparseMatrix,
                          info: *mut octave_idx_type, rcond: *mut f64)
     -> SparseMatrix {
        SparseMatrix_solve10(self, typ, b, info, rcond)
    }
    #[inline]
    pub unsafe fn solve11(&self, typ: *mut MatrixType, b: *const SparseMatrix,
                          info: *mut octave_idx_type, rcond: *mut f64,
                          sing_handler:
                              SparseMatrix_solve_singularity_handler,
                          singular_fallback: bool) -> SparseMatrix {
        SparseMatrix_solve11(self, typ, b, info, rcond, sing_handler,
                             singular_fallback)
    }
    #[inline]
    pub unsafe fn solve12(&self, typ: *mut MatrixType,
                          b: *const SparseComplexMatrix)
     -> SparseComplexMatrix {
        SparseMatrix_solve12(self, typ, b)
    }
    #[inline]
    pub unsafe fn solve13(&self, typ: *mut MatrixType,
                          b: *const SparseComplexMatrix,
                          info: *mut octave_idx_type) -> SparseComplexMatrix {
        SparseMatrix_solve13(self, typ, b, info)
    }
    #[inline]
    pub unsafe fn solve14(&self, typ: *mut MatrixType,
                          b: *const SparseComplexMatrix,
                          info: *mut octave_idx_type, rcond: *mut f64)
     -> SparseComplexMatrix {
        SparseMatrix_solve14(self, typ, b, info, rcond)
    }
    #[inline]
    pub unsafe fn solve15(&self, typ: *mut MatrixType,
                          b: *const SparseComplexMatrix,
                          info: *mut octave_idx_type, rcond: *mut f64,
                          sing_handler:
                              SparseMatrix_solve_singularity_handler,
                          singular_fallabck: bool) -> SparseComplexMatrix {
        SparseMatrix_solve15(self, typ, b, info, rcond, sing_handler,
                             singular_fallabck)
    }
    #[inline]
    pub unsafe fn solve16(&self, typ: *mut MatrixType, b: *const ColumnVector)
     -> ColumnVector {
        SparseMatrix_solve16(self, typ, b)
    }
    #[inline]
    pub unsafe fn solve17(&self, typ: *mut MatrixType, b: *const ColumnVector,
                          info: *mut octave_idx_type) -> ColumnVector {
        SparseMatrix_solve17(self, typ, b, info)
    }
    #[inline]
    pub unsafe fn solve18(&self, typ: *mut MatrixType, b: *const ColumnVector,
                          info: *mut octave_idx_type, rcond: *mut f64)
     -> ColumnVector {
        SparseMatrix_solve18(self, typ, b, info, rcond)
    }
    #[inline]
    pub unsafe fn solve19(&self, typ: *mut MatrixType, b: *const ColumnVector,
                          info: *mut octave_idx_type, rcond: *mut f64,
                          sing_handler:
                              SparseMatrix_solve_singularity_handler)
     -> ColumnVector {
        SparseMatrix_solve19(self, typ, b, info, rcond, sing_handler)
    }
    #[inline]
    pub unsafe fn solve20(&self, typ: *mut MatrixType,
                          b: *const ComplexColumnVector)
     -> ComplexColumnVector {
        SparseMatrix_solve20(self, typ, b)
    }
    #[inline]
    pub unsafe fn solve21(&self, typ: *mut MatrixType,
                          b: *const ComplexColumnVector,
                          info: *mut octave_idx_type) -> ComplexColumnVector {
        SparseMatrix_solve21(self, typ, b, info)
    }
    #[inline]
    pub unsafe fn solve22(&self, typ: *mut MatrixType,
                          b: *const ComplexColumnVector,
                          info: *mut octave_idx_type, rcond: *mut f64)
     -> ComplexColumnVector {
        SparseMatrix_solve22(self, typ, b, info, rcond)
    }
    #[inline]
    pub unsafe fn solve23(&self, typ: *mut MatrixType,
                          b: *const ComplexColumnVector,
                          info: *mut octave_idx_type, rcond: *mut f64,
                          sing_handler:
                              SparseMatrix_solve_singularity_handler)
     -> ComplexColumnVector {
        SparseMatrix_solve23(self, typ, b, info, rcond, sing_handler)
    }
    #[inline]
    pub unsafe fn solve24(&self, b: *const Matrix) -> Matrix {
        SparseMatrix_solve24(self, b)
    }
    #[inline]
    pub unsafe fn solve25(&self, b: *const Matrix, info: *mut octave_idx_type)
     -> Matrix {
        SparseMatrix_solve25(self, b, info)
    }
    #[inline]
    pub unsafe fn solve26(&self, b: *const Matrix, info: *mut octave_idx_type,
                          rcond: *mut f64) -> Matrix {
        SparseMatrix_solve26(self, b, info, rcond)
    }
    #[inline]
    pub unsafe fn solve27(&self, b: *const Matrix, info: *mut octave_idx_type,
                          rcond: *mut f64,
                          sing_handler:
                              SparseMatrix_solve_singularity_handler)
     -> Matrix {
        SparseMatrix_solve27(self, b, info, rcond, sing_handler)
    }
    #[inline]
    pub unsafe fn solve28(&self, b: *const ComplexMatrix) -> ComplexMatrix {
        SparseMatrix_solve28(self, b)
    }
    #[inline]
    pub unsafe fn solve29(&self, b: *const ComplexMatrix,
                          info: *mut octave_idx_type) -> ComplexMatrix {
        SparseMatrix_solve29(self, b, info)
    }
    #[inline]
    pub unsafe fn solve30(&self, b: *const ComplexMatrix,
                          info: *mut octave_idx_type, rcond: *mut f64)
     -> ComplexMatrix {
        SparseMatrix_solve30(self, b, info, rcond)
    }
    #[inline]
    pub unsafe fn solve31(&self, b: *const ComplexMatrix,
                          info: *mut octave_idx_type, rcond: *mut f64,
                          sing_handler:
                              SparseMatrix_solve_singularity_handler)
     -> ComplexMatrix {
        SparseMatrix_solve31(self, b, info, rcond, sing_handler)
    }
    #[inline]
    pub unsafe fn solve32(&self, b: *const SparseMatrix) -> SparseMatrix {
        SparseMatrix_solve32(self, b)
    }
    #[inline]
    pub unsafe fn solve33(&self, b: *const SparseMatrix,
                          info: *mut octave_idx_type) -> SparseMatrix {
        SparseMatrix_solve33(self, b, info)
    }
    #[inline]
    pub unsafe fn solve34(&self, b: *const SparseMatrix,
                          info: *mut octave_idx_type, rcond: *mut f64)
     -> SparseMatrix {
        SparseMatrix_solve34(self, b, info, rcond)
    }
    #[inline]
    pub unsafe fn solve35(&self, b: *const SparseMatrix,
                          info: *mut octave_idx_type, rcond: *mut f64,
                          sing_handler:
                              SparseMatrix_solve_singularity_handler)
     -> SparseMatrix {
        SparseMatrix_solve35(self, b, info, rcond, sing_handler)
    }
    #[inline]
    pub unsafe fn solve36(&self, b: *const SparseComplexMatrix)
     -> SparseComplexMatrix {
        SparseMatrix_solve36(self, b)
    }
    #[inline]
    pub unsafe fn solve37(&self, b: *const SparseComplexMatrix,
                          info: *mut octave_idx_type) -> SparseComplexMatrix {
        SparseMatrix_solve37(self, b, info)
    }
    #[inline]
    pub unsafe fn solve38(&self, b: *const SparseComplexMatrix,
                          info: *mut octave_idx_type, rcond: *mut f64)
     -> SparseComplexMatrix {
        SparseMatrix_solve38(self, b, info, rcond)
    }
    #[inline]
    pub unsafe fn solve39(&self, b: *const SparseComplexMatrix,
                          info: *mut octave_idx_type, rcond: *mut f64,
                          sing_handler:
                              SparseMatrix_solve_singularity_handler)
     -> SparseComplexMatrix {
        SparseMatrix_solve39(self, b, info, rcond, sing_handler)
    }
    #[inline]
    pub unsafe fn solve40(&self, b: *const ColumnVector) -> ColumnVector {
        SparseMatrix_solve40(self, b)
    }
    #[inline]
    pub unsafe fn solve41(&self, b: *const ColumnVector,
                          info: *mut octave_idx_type) -> ColumnVector {
        SparseMatrix_solve41(self, b, info)
    }
    #[inline]
    pub unsafe fn solve42(&self, b: *const ColumnVector,
                          info: *mut octave_idx_type, rcond: *mut f64)
     -> ColumnVector {
        SparseMatrix_solve42(self, b, info, rcond)
    }
    #[inline]
    pub unsafe fn solve43(&self, b: *const ColumnVector,
                          info: *mut octave_idx_type, rcond: *mut f64,
                          sing_handler:
                              SparseMatrix_solve_singularity_handler)
     -> ColumnVector {
        SparseMatrix_solve43(self, b, info, rcond, sing_handler)
    }
    #[inline]
    pub unsafe fn solve44(&self, b: *const ComplexColumnVector)
     -> ComplexColumnVector {
        SparseMatrix_solve44(self, b)
    }
    #[inline]
    pub unsafe fn solve45(&self, b: *const ComplexColumnVector,
                          info: *mut octave_idx_type) -> ComplexColumnVector {
        SparseMatrix_solve45(self, b, info)
    }
    #[inline]
    pub unsafe fn solve46(&self, b: *const ComplexColumnVector,
                          info: *mut octave_idx_type, rcond: *mut f64)
     -> ComplexColumnVector {
        SparseMatrix_solve46(self, b, info, rcond)
    }
    #[inline]
    pub unsafe fn solve47(&self, b: *const ComplexColumnVector,
                          info: *mut octave_idx_type, rcond: *mut f64,
                          sing_handler:
                              SparseMatrix_solve_singularity_handler)
     -> ComplexColumnVector {
        SparseMatrix_solve47(self, b, info, rcond, sing_handler)
    }
    #[inline]
    pub unsafe fn any_element_is_negative(&self, arg1: bool) -> bool {
        SparseMatrix_any_element_is_negative(self, arg1)
    }
    #[inline]
    pub unsafe fn any_element_is_nan(&self) -> bool {
        SparseMatrix_any_element_is_nan(self)
    }
    #[inline]
    pub unsafe fn any_element_is_inf_or_nan(&self) -> bool {
        SparseMatrix_any_element_is_inf_or_nan(self)
    }
    #[inline]
    pub unsafe fn any_element_not_one_or_zero(&self) -> bool {
        SparseMatrix_any_element_not_one_or_zero(self)
    }
    #[inline]
    pub unsafe fn all_elements_are_zero(&self) -> bool {
        SparseMatrix_all_elements_are_zero(self)
    }
    #[inline]
    pub unsafe fn all_elements_are_int_or_inf_or_nan(&self) -> bool {
        SparseMatrix_all_elements_are_int_or_inf_or_nan(self)
    }
    #[inline]
    pub unsafe fn all_integers(&self, max_val: *mut f64, min_val: *mut f64)
     -> bool {
        SparseMatrix_all_integers(self, max_val, min_val)
    }
    #[inline]
    pub unsafe fn too_large_for_float(&self) -> bool {
        SparseMatrix_too_large_for_float(self)
    }
    #[inline]
    pub unsafe fn all(&self, dim: ::std::os::raw::c_int) -> SparseBoolMatrix {
        SparseMatrix_all(self, dim)
    }
    #[inline]
    pub unsafe fn any(&self, dim: ::std::os::raw::c_int) -> SparseBoolMatrix {
        SparseMatrix_any(self, dim)
    }
    #[inline]
    pub unsafe fn cumprod(&self, dim: ::std::os::raw::c_int) -> SparseMatrix {
        SparseMatrix_cumprod(self, dim)
    }
    #[inline]
    pub unsafe fn cumsum(&self, dim: ::std::os::raw::c_int) -> SparseMatrix {
        SparseMatrix_cumsum(self, dim)
    }
    #[inline]
    pub unsafe fn prod(&self, dim: ::std::os::raw::c_int) -> SparseMatrix {
        SparseMatrix_prod(self, dim)
    }
    #[inline]
    pub unsafe fn sum(&self, dim: ::std::os::raw::c_int) -> SparseMatrix {
        SparseMatrix_sum(self, dim)
    }
    #[inline]
    pub unsafe fn sumsq(&self, dim: ::std::os::raw::c_int) -> SparseMatrix {
        SparseMatrix_sumsq(self, dim)
    }
    #[inline]
    pub unsafe fn abs(&self) -> SparseMatrix { SparseMatrix_abs(self) }
    #[inline]
    pub unsafe fn diag(&self, k: octave_idx_type) -> SparseMatrix {
        SparseMatrix_diag(self, k)
    }
    #[inline]
    pub unsafe fn matrix_value(&self) -> Matrix {
        SparseMatrix_matrix_value(self)
    }
    #[inline]
    pub unsafe fn squeeze(&self) -> SparseMatrix {
        SparseMatrix_squeeze(self)
    }
    #[inline]
    pub unsafe fn reshape(&self, new_dims: *const dim_vector)
     -> SparseMatrix {
        SparseMatrix_reshape(self, new_dims)
    }
    #[inline]
    pub unsafe fn permute(&self, vec: *const Array<::std::os::raw::c_int>,
                          inv: bool) -> SparseMatrix {
        SparseMatrix_permute(self, vec, inv)
    }
    #[inline]
    pub unsafe fn ipermute(&self, vec: *const Array<::std::os::raw::c_int>)
     -> SparseMatrix {
        SparseMatrix_ipermute(self, vec)
    }
    #[inline]
    pub unsafe fn new(a: *const SparseBoolMatrix) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        SparseMatrix_SparseMatrix(&mut __bindgen_tmp, a);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(a: *const DiagMatrix) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        SparseMatrix_SparseMatrix1(&mut __bindgen_tmp, a);
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SparseComplexMatrix {
    pub _base: MSparse<std_complex<f64>>,
}
pub type SparseComplexMatrix_dense_matrix_type = ComplexMatrix;
pub type SparseComplexMatrix_solve_singularity_handler =
    ::std::option::Option<unsafe extern "C" fn(rcond: f64)>;
#[test]
fn bindgen_test_layout_SparseComplexMatrix() {
    assert_eq!(::std::mem::size_of::<SparseComplexMatrix>() , 24usize , concat
               ! ( "Size of: " , stringify ! ( SparseComplexMatrix ) ));
    assert_eq! (::std::mem::align_of::<SparseComplexMatrix>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( SparseComplexMatrix ) ));
}
extern "C" {
    #[link_name = "?is_hermitian@SparseComplexMatrix@@QEBA_NXZ"]
    pub fn SparseComplexMatrix_is_hermitian(this: *const SparseComplexMatrix)
     -> bool;
}
extern "C" {
    #[link_name = "?max@SparseComplexMatrix@@QEBA?AV1@H@Z"]
    pub fn SparseComplexMatrix_max(this: *const SparseComplexMatrix,
                                   dim: ::std::os::raw::c_int)
     -> SparseComplexMatrix;
}
extern "C" {
    #[link_name = "?max@SparseComplexMatrix@@QEBA?AV1@AEAV?$Array@H@@H@Z"]
    pub fn SparseComplexMatrix_max1(this: *const SparseComplexMatrix,
                                    index: *mut Array<::std::os::raw::c_int>,
                                    dim: ::std::os::raw::c_int)
     -> SparseComplexMatrix;
}
extern "C" {
    #[link_name = "?min@SparseComplexMatrix@@QEBA?AV1@H@Z"]
    pub fn SparseComplexMatrix_min(this: *const SparseComplexMatrix,
                                   dim: ::std::os::raw::c_int)
     -> SparseComplexMatrix;
}
extern "C" {
    #[link_name = "?min@SparseComplexMatrix@@QEBA?AV1@AEAV?$Array@H@@H@Z"]
    pub fn SparseComplexMatrix_min1(this: *const SparseComplexMatrix,
                                    index: *mut Array<::std::os::raw::c_int>,
                                    dim: ::std::os::raw::c_int)
     -> SparseComplexMatrix;
}
extern "C" {
    #[link_name = "?insert@SparseComplexMatrix@@QEAAAEAV1@AEBV1@HH@Z"]
    pub fn SparseComplexMatrix_insert(this: *mut SparseComplexMatrix,
                                      a: *const SparseComplexMatrix,
                                      r: octave_idx_type, c: octave_idx_type)
     -> *mut SparseComplexMatrix;
}
extern "C" {
    #[link_name =
          "?insert@SparseComplexMatrix@@QEAAAEAV1@AEBVSparseMatrix@@HH@Z"]
    pub fn SparseComplexMatrix_insert1(this: *mut SparseComplexMatrix,
                                       a: *const SparseMatrix,
                                       r: octave_idx_type, c: octave_idx_type)
     -> *mut SparseComplexMatrix;
}
extern "C" {
    #[link_name =
          "?insert@SparseComplexMatrix@@QEAAAEAV1@AEBV1@AEBV?$Array@H@@@Z"]
    pub fn SparseComplexMatrix_insert2(this: *mut SparseComplexMatrix,
                                       a: *const SparseComplexMatrix,
                                       indx:
                                           *const Array<::std::os::raw::c_int>)
     -> *mut SparseComplexMatrix;
}
extern "C" {
    #[link_name =
          "?insert@SparseComplexMatrix@@QEAAAEAV1@AEBVSparseMatrix@@AEBV?$Array@H@@@Z"]
    pub fn SparseComplexMatrix_insert3(this: *mut SparseComplexMatrix,
                                       a: *const SparseMatrix,
                                       indx:
                                           *const Array<::std::os::raw::c_int>)
     -> *mut SparseComplexMatrix;
}
extern "C" {
    #[link_name =
          "?concat@SparseComplexMatrix@@QEAA?AV1@AEBV1@AEBV?$Array@H@@@Z"]
    pub fn SparseComplexMatrix_concat(this: *mut SparseComplexMatrix,
                                      rb: *const SparseComplexMatrix,
                                      ra_idx:
                                          *const Array<::std::os::raw::c_int>)
     -> SparseComplexMatrix;
}
extern "C" {
    #[link_name =
          "?concat@SparseComplexMatrix@@QEAA?AV1@AEBVSparseMatrix@@AEBV?$Array@H@@@Z"]
    pub fn SparseComplexMatrix_concat1(this: *mut SparseComplexMatrix,
                                       rb: *const SparseMatrix,
                                       ra_idx:
                                           *const Array<::std::os::raw::c_int>)
     -> SparseComplexMatrix;
}
extern "C" {
    #[link_name =
          "?matrix_value@SparseComplexMatrix@@QEBA?AVComplexMatrix@@XZ"]
    pub fn SparseComplexMatrix_matrix_value(this: *const SparseComplexMatrix)
     -> ComplexMatrix;
}
extern "C" {
    #[link_name = "?hermitian@SparseComplexMatrix@@QEBA?AV1@XZ"]
    pub fn SparseComplexMatrix_hermitian(this: *const SparseComplexMatrix)
     -> SparseComplexMatrix;
}
extern "C" {
    #[link_name = "?row@SparseComplexMatrix@@QEBA?AVComplexRowVector@@H@Z"]
    pub fn SparseComplexMatrix_row(this: *const SparseComplexMatrix,
                                   i: octave_idx_type) -> ComplexRowVector;
}
extern "C" {
    #[link_name =
          "?column@SparseComplexMatrix@@QEBA?AVComplexColumnVector@@H@Z"]
    pub fn SparseComplexMatrix_column(this: *const SparseComplexMatrix,
                                      i: octave_idx_type)
     -> ComplexColumnVector;
}
extern "C" {
    #[link_name = "?inverse@SparseComplexMatrix@@QEBA?AV1@XZ"]
    pub fn SparseComplexMatrix_inverse(this: *const SparseComplexMatrix)
     -> SparseComplexMatrix;
}
extern "C" {
    #[link_name = "?inverse@SparseComplexMatrix@@QEBA?AV1@AEAVMatrixType@@@Z"]
    pub fn SparseComplexMatrix_inverse1(this: *const SparseComplexMatrix,
                                        mattype: *mut MatrixType)
     -> SparseComplexMatrix;
}
extern "C" {
    #[link_name =
          "?inverse@SparseComplexMatrix@@QEBA?AV1@AEAVMatrixType@@AEAH@Z"]
    pub fn SparseComplexMatrix_inverse2(this: *const SparseComplexMatrix,
                                        mattype: *mut MatrixType,
                                        info: *mut octave_idx_type)
     -> SparseComplexMatrix;
}
extern "C" {
    #[link_name =
          "?inverse@SparseComplexMatrix@@QEBA?AV1@AEAVMatrixType@@AEAHAEAN_N3@Z"]
    pub fn SparseComplexMatrix_inverse3(this: *const SparseComplexMatrix,
                                        mattype: *mut MatrixType,
                                        info: *mut octave_idx_type,
                                        rcond: *mut f64, force: bool,
                                        calc_cond: bool)
     -> SparseComplexMatrix;
}
extern "C" {
    #[link_name =
          "?determinant@SparseComplexMatrix@@QEBA?AV?$base_det@U?$complex@N@std@@@@XZ"]
    pub fn SparseComplexMatrix_determinant(this: *const SparseComplexMatrix)
     -> ComplexDET;
}
extern "C" {
    #[link_name =
          "?determinant@SparseComplexMatrix@@QEBA?AV?$base_det@U?$complex@N@std@@@@AEAH@Z"]
    pub fn SparseComplexMatrix_determinant1(this: *const SparseComplexMatrix,
                                            info: *mut octave_idx_type)
     -> ComplexDET;
}
extern "C" {
    #[link_name =
          "?determinant@SparseComplexMatrix@@QEBA?AV?$base_det@U?$complex@N@std@@@@AEAHAEAN_N@Z"]
    pub fn SparseComplexMatrix_determinant2(this: *const SparseComplexMatrix,
                                            info: *mut octave_idx_type,
                                            rcond: *mut f64, calc_cond: bool)
     -> ComplexDET;
}
extern "C" {
    #[link_name =
          "?solve@SparseComplexMatrix@@QEBA?AVComplexMatrix@@AEAVMatrixType@@AEBVMatrix@@@Z"]
    pub fn SparseComplexMatrix_solve(this: *const SparseComplexMatrix,
                                     typ: *mut MatrixType, b: *const Matrix)
     -> ComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@SparseComplexMatrix@@QEBA?AVComplexMatrix@@AEAVMatrixType@@AEBVMatrix@@AEAH@Z"]
    pub fn SparseComplexMatrix_solve1(this: *const SparseComplexMatrix,
                                      typ: *mut MatrixType, b: *const Matrix,
                                      info: *mut octave_idx_type)
     -> ComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@SparseComplexMatrix@@QEBA?AVComplexMatrix@@AEAVMatrixType@@AEBVMatrix@@AEAHAEAN@Z"]
    pub fn SparseComplexMatrix_solve2(this: *const SparseComplexMatrix,
                                      typ: *mut MatrixType, b: *const Matrix,
                                      info: *mut octave_idx_type,
                                      rcond: *mut f64) -> ComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@SparseComplexMatrix@@QEBA?AVComplexMatrix@@AEAVMatrixType@@AEBVMatrix@@AEAHAEANP6AXN@Z_N@Z"]
    pub fn SparseComplexMatrix_solve3(this: *const SparseComplexMatrix,
                                      typ: *mut MatrixType, b: *const Matrix,
                                      info: *mut octave_idx_type,
                                      rcond: *mut f64,
                                      sing_handler:
                                          SparseComplexMatrix_solve_singularity_handler,
                                      singular_fallback: bool)
     -> ComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@SparseComplexMatrix@@QEBA?AVComplexMatrix@@AEAVMatrixType@@AEBV2@@Z"]
    pub fn SparseComplexMatrix_solve4(this: *const SparseComplexMatrix,
                                      typ: *mut MatrixType,
                                      b: *const ComplexMatrix)
     -> ComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@SparseComplexMatrix@@QEBA?AVComplexMatrix@@AEAVMatrixType@@AEBV2@AEAH@Z"]
    pub fn SparseComplexMatrix_solve5(this: *const SparseComplexMatrix,
                                      typ: *mut MatrixType,
                                      b: *const ComplexMatrix,
                                      info: *mut octave_idx_type)
     -> ComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@SparseComplexMatrix@@QEBA?AVComplexMatrix@@AEAVMatrixType@@AEBV2@AEAHAEAN@Z"]
    pub fn SparseComplexMatrix_solve6(this: *const SparseComplexMatrix,
                                      typ: *mut MatrixType,
                                      b: *const ComplexMatrix,
                                      info: *mut octave_idx_type,
                                      rcond: *mut f64) -> ComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@SparseComplexMatrix@@QEBA?AVComplexMatrix@@AEAVMatrixType@@AEBV2@AEAHAEANP6AXN@Z_N@Z"]
    pub fn SparseComplexMatrix_solve7(this: *const SparseComplexMatrix,
                                      typ: *mut MatrixType,
                                      b: *const ComplexMatrix,
                                      info: *mut octave_idx_type,
                                      rcond: *mut f64,
                                      sing_handler:
                                          SparseComplexMatrix_solve_singularity_handler,
                                      singular_fallback: bool)
     -> ComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@SparseComplexMatrix@@QEBA?AV1@AEAVMatrixType@@AEBVSparseMatrix@@@Z"]
    pub fn SparseComplexMatrix_solve8(this: *const SparseComplexMatrix,
                                      typ: *mut MatrixType,
                                      b: *const SparseMatrix)
     -> SparseComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@SparseComplexMatrix@@QEBA?AV1@AEAVMatrixType@@AEBVSparseMatrix@@AEAH@Z"]
    pub fn SparseComplexMatrix_solve9(this: *const SparseComplexMatrix,
                                      typ: *mut MatrixType,
                                      b: *const SparseMatrix,
                                      info: *mut octave_idx_type)
     -> SparseComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@SparseComplexMatrix@@QEBA?AV1@AEAVMatrixType@@AEBVSparseMatrix@@AEAHAEAN@Z"]
    pub fn SparseComplexMatrix_solve10(this: *const SparseComplexMatrix,
                                       typ: *mut MatrixType,
                                       b: *const SparseMatrix,
                                       info: *mut octave_idx_type,
                                       rcond: *mut f64)
     -> SparseComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@SparseComplexMatrix@@QEBA?AV1@AEAVMatrixType@@AEBVSparseMatrix@@AEAHAEANP6AXN@Z_N@Z"]
    pub fn SparseComplexMatrix_solve11(this: *const SparseComplexMatrix,
                                       typ: *mut MatrixType,
                                       b: *const SparseMatrix,
                                       info: *mut octave_idx_type,
                                       rcond: *mut f64,
                                       sing_handler:
                                           SparseComplexMatrix_solve_singularity_handler,
                                       singular_fallback: bool)
     -> SparseComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@SparseComplexMatrix@@QEBA?AV1@AEAVMatrixType@@AEBV1@@Z"]
    pub fn SparseComplexMatrix_solve12(this: *const SparseComplexMatrix,
                                       typ: *mut MatrixType,
                                       b: *const SparseComplexMatrix)
     -> SparseComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@SparseComplexMatrix@@QEBA?AV1@AEAVMatrixType@@AEBV1@AEAH@Z"]
    pub fn SparseComplexMatrix_solve13(this: *const SparseComplexMatrix,
                                       typ: *mut MatrixType,
                                       b: *const SparseComplexMatrix,
                                       info: *mut octave_idx_type)
     -> SparseComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@SparseComplexMatrix@@QEBA?AV1@AEAVMatrixType@@AEBV1@AEAHAEAN@Z"]
    pub fn SparseComplexMatrix_solve14(this: *const SparseComplexMatrix,
                                       typ: *mut MatrixType,
                                       b: *const SparseComplexMatrix,
                                       info: *mut octave_idx_type,
                                       rcond: *mut f64)
     -> SparseComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@SparseComplexMatrix@@QEBA?AV1@AEAVMatrixType@@AEBV1@AEAHAEANP6AXN@Z_N@Z"]
    pub fn SparseComplexMatrix_solve15(this: *const SparseComplexMatrix,
                                       typ: *mut MatrixType,
                                       b: *const SparseComplexMatrix,
                                       info: *mut octave_idx_type,
                                       rcond: *mut f64,
                                       sing_handler:
                                           SparseComplexMatrix_solve_singularity_handler,
                                       singular_fallback: bool)
     -> SparseComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@SparseComplexMatrix@@QEBA?AVComplexColumnVector@@AEAVMatrixType@@AEBVColumnVector@@@Z"]
    pub fn SparseComplexMatrix_solve16(this: *const SparseComplexMatrix,
                                       typ: *mut MatrixType,
                                       b: *const ColumnVector)
     -> ComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@SparseComplexMatrix@@QEBA?AVComplexColumnVector@@AEAVMatrixType@@AEBVColumnVector@@AEAH@Z"]
    pub fn SparseComplexMatrix_solve17(this: *const SparseComplexMatrix,
                                       typ: *mut MatrixType,
                                       b: *const ColumnVector,
                                       info: *mut octave_idx_type)
     -> ComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@SparseComplexMatrix@@QEBA?AVComplexColumnVector@@AEAVMatrixType@@AEBVColumnVector@@AEAHAEAN@Z"]
    pub fn SparseComplexMatrix_solve18(this: *const SparseComplexMatrix,
                                       typ: *mut MatrixType,
                                       b: *const ColumnVector,
                                       info: *mut octave_idx_type,
                                       rcond: *mut f64)
     -> ComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@SparseComplexMatrix@@QEBA?AVComplexColumnVector@@AEAVMatrixType@@AEBVColumnVector@@AEAHAEANP6AXN@Z@Z"]
    pub fn SparseComplexMatrix_solve19(this: *const SparseComplexMatrix,
                                       typ: *mut MatrixType,
                                       b: *const ColumnVector,
                                       info: *mut octave_idx_type,
                                       rcond: *mut f64,
                                       sing_handler:
                                           SparseComplexMatrix_solve_singularity_handler)
     -> ComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@SparseComplexMatrix@@QEBA?AVComplexColumnVector@@AEAVMatrixType@@AEBV2@@Z"]
    pub fn SparseComplexMatrix_solve20(this: *const SparseComplexMatrix,
                                       typ: *mut MatrixType,
                                       b: *const ComplexColumnVector)
     -> ComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@SparseComplexMatrix@@QEBA?AVComplexColumnVector@@AEAVMatrixType@@AEBV2@AEAH@Z"]
    pub fn SparseComplexMatrix_solve21(this: *const SparseComplexMatrix,
                                       typ: *mut MatrixType,
                                       b: *const ComplexColumnVector,
                                       info: *mut octave_idx_type)
     -> ComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@SparseComplexMatrix@@QEBA?AVComplexColumnVector@@AEAVMatrixType@@AEBV2@AEAHAEAN@Z"]
    pub fn SparseComplexMatrix_solve22(this: *const SparseComplexMatrix,
                                       typ: *mut MatrixType,
                                       b: *const ComplexColumnVector,
                                       info: *mut octave_idx_type,
                                       rcond: *mut f64)
     -> ComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@SparseComplexMatrix@@QEBA?AVComplexColumnVector@@AEAVMatrixType@@AEBV2@AEAHAEANP6AXN@Z@Z"]
    pub fn SparseComplexMatrix_solve23(this: *const SparseComplexMatrix,
                                       typ: *mut MatrixType,
                                       b: *const ComplexColumnVector,
                                       info: *mut octave_idx_type,
                                       rcond: *mut f64,
                                       sing_handler:
                                           SparseComplexMatrix_solve_singularity_handler)
     -> ComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@SparseComplexMatrix@@QEBA?AVComplexMatrix@@AEBVMatrix@@@Z"]
    pub fn SparseComplexMatrix_solve24(this: *const SparseComplexMatrix,
                                       b: *const Matrix) -> ComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@SparseComplexMatrix@@QEBA?AVComplexMatrix@@AEBVMatrix@@AEAH@Z"]
    pub fn SparseComplexMatrix_solve25(this: *const SparseComplexMatrix,
                                       b: *const Matrix,
                                       info: *mut octave_idx_type)
     -> ComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@SparseComplexMatrix@@QEBA?AVComplexMatrix@@AEBVMatrix@@AEAHAEAN@Z"]
    pub fn SparseComplexMatrix_solve26(this: *const SparseComplexMatrix,
                                       b: *const Matrix,
                                       info: *mut octave_idx_type,
                                       rcond: *mut f64) -> ComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@SparseComplexMatrix@@QEBA?AVComplexMatrix@@AEBVMatrix@@AEAHAEANP6AXN@Z@Z"]
    pub fn SparseComplexMatrix_solve27(this: *const SparseComplexMatrix,
                                       b: *const Matrix,
                                       info: *mut octave_idx_type,
                                       rcond: *mut f64,
                                       sing_handler:
                                           SparseComplexMatrix_solve_singularity_handler)
     -> ComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@SparseComplexMatrix@@QEBA?AVComplexMatrix@@AEBV2@@Z"]
    pub fn SparseComplexMatrix_solve28(this: *const SparseComplexMatrix,
                                       b: *const ComplexMatrix)
     -> ComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@SparseComplexMatrix@@QEBA?AVComplexMatrix@@AEBV2@AEAH@Z"]
    pub fn SparseComplexMatrix_solve29(this: *const SparseComplexMatrix,
                                       b: *const ComplexMatrix,
                                       info: *mut octave_idx_type)
     -> ComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@SparseComplexMatrix@@QEBA?AVComplexMatrix@@AEBV2@AEAHAEAN@Z"]
    pub fn SparseComplexMatrix_solve30(this: *const SparseComplexMatrix,
                                       b: *const ComplexMatrix,
                                       info: *mut octave_idx_type,
                                       rcond: *mut f64) -> ComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@SparseComplexMatrix@@QEBA?AVComplexMatrix@@AEBV2@AEAHAEANP6AXN@Z@Z"]
    pub fn SparseComplexMatrix_solve31(this: *const SparseComplexMatrix,
                                       b: *const ComplexMatrix,
                                       info: *mut octave_idx_type,
                                       rcond: *mut f64,
                                       sing_handler:
                                           SparseComplexMatrix_solve_singularity_handler)
     -> ComplexMatrix;
}
extern "C" {
    #[link_name = "?solve@SparseComplexMatrix@@QEBA?AV1@AEBVSparseMatrix@@@Z"]
    pub fn SparseComplexMatrix_solve32(this: *const SparseComplexMatrix,
                                       b: *const SparseMatrix)
     -> SparseComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@SparseComplexMatrix@@QEBA?AV1@AEBVSparseMatrix@@AEAH@Z"]
    pub fn SparseComplexMatrix_solve33(this: *const SparseComplexMatrix,
                                       b: *const SparseMatrix,
                                       info: *mut octave_idx_type)
     -> SparseComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@SparseComplexMatrix@@QEBA?AV1@AEBVSparseMatrix@@AEAHAEAN@Z"]
    pub fn SparseComplexMatrix_solve34(this: *const SparseComplexMatrix,
                                       b: *const SparseMatrix,
                                       info: *mut octave_idx_type,
                                       rcond: *mut f64)
     -> SparseComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@SparseComplexMatrix@@QEBA?AV1@AEBVSparseMatrix@@AEAHAEANP6AXN@Z@Z"]
    pub fn SparseComplexMatrix_solve35(this: *const SparseComplexMatrix,
                                       b: *const SparseMatrix,
                                       info: *mut octave_idx_type,
                                       rcond: *mut f64,
                                       sing_handler:
                                           SparseComplexMatrix_solve_singularity_handler)
     -> SparseComplexMatrix;
}
extern "C" {
    #[link_name = "?solve@SparseComplexMatrix@@QEBA?AV1@AEBV1@@Z"]
    pub fn SparseComplexMatrix_solve36(this: *const SparseComplexMatrix,
                                       b: *const SparseComplexMatrix)
     -> SparseComplexMatrix;
}
extern "C" {
    #[link_name = "?solve@SparseComplexMatrix@@QEBA?AV1@AEBV1@AEAH@Z"]
    pub fn SparseComplexMatrix_solve37(this: *const SparseComplexMatrix,
                                       b: *const SparseComplexMatrix,
                                       info: *mut octave_idx_type)
     -> SparseComplexMatrix;
}
extern "C" {
    #[link_name = "?solve@SparseComplexMatrix@@QEBA?AV1@AEBV1@AEAHAEAN@Z"]
    pub fn SparseComplexMatrix_solve38(this: *const SparseComplexMatrix,
                                       b: *const SparseComplexMatrix,
                                       info: *mut octave_idx_type,
                                       rcond: *mut f64)
     -> SparseComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@SparseComplexMatrix@@QEBA?AV1@AEBV1@AEAHAEANP6AXN@Z@Z"]
    pub fn SparseComplexMatrix_solve39(this: *const SparseComplexMatrix,
                                       b: *const SparseComplexMatrix,
                                       info: *mut octave_idx_type,
                                       rcond: *mut f64,
                                       sing_handler:
                                           SparseComplexMatrix_solve_singularity_handler)
     -> SparseComplexMatrix;
}
extern "C" {
    #[link_name =
          "?solve@SparseComplexMatrix@@QEBA?AVComplexColumnVector@@AEBVColumnVector@@@Z"]
    pub fn SparseComplexMatrix_solve40(this: *const SparseComplexMatrix,
                                       b: *const ColumnVector)
     -> ComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@SparseComplexMatrix@@QEBA?AVComplexColumnVector@@AEBVColumnVector@@AEAH@Z"]
    pub fn SparseComplexMatrix_solve41(this: *const SparseComplexMatrix,
                                       b: *const ColumnVector,
                                       info: *mut octave_idx_type)
     -> ComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@SparseComplexMatrix@@QEBA?AVComplexColumnVector@@AEBVColumnVector@@AEAHAEAN@Z"]
    pub fn SparseComplexMatrix_solve42(this: *const SparseComplexMatrix,
                                       b: *const ColumnVector,
                                       info: *mut octave_idx_type,
                                       rcond: *mut f64)
     -> ComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@SparseComplexMatrix@@QEBA?AVComplexColumnVector@@AEBVColumnVector@@AEAHAEANP6AXN@Z@Z"]
    pub fn SparseComplexMatrix_solve43(this: *const SparseComplexMatrix,
                                       b: *const ColumnVector,
                                       info: *mut octave_idx_type,
                                       rcond: *mut f64,
                                       sing_handler:
                                           SparseComplexMatrix_solve_singularity_handler)
     -> ComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@SparseComplexMatrix@@QEBA?AVComplexColumnVector@@AEBV2@@Z"]
    pub fn SparseComplexMatrix_solve44(this: *const SparseComplexMatrix,
                                       b: *const ComplexColumnVector)
     -> ComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@SparseComplexMatrix@@QEBA?AVComplexColumnVector@@AEBV2@AEAH@Z"]
    pub fn SparseComplexMatrix_solve45(this: *const SparseComplexMatrix,
                                       b: *const ComplexColumnVector,
                                       info: *mut octave_idx_type)
     -> ComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@SparseComplexMatrix@@QEBA?AVComplexColumnVector@@AEBV2@AEAHAEAN@Z"]
    pub fn SparseComplexMatrix_solve46(this: *const SparseComplexMatrix,
                                       b: *const ComplexColumnVector,
                                       info: *mut octave_idx_type,
                                       rcond: *mut f64)
     -> ComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?solve@SparseComplexMatrix@@QEBA?AVComplexColumnVector@@AEBV2@AEAHAEANP6AXN@Z@Z"]
    pub fn SparseComplexMatrix_solve47(this: *const SparseComplexMatrix,
                                       b: *const ComplexColumnVector,
                                       info: *mut octave_idx_type,
                                       rcond: *mut f64,
                                       sing_handler:
                                           SparseComplexMatrix_solve_singularity_handler)
     -> ComplexColumnVector;
}
extern "C" {
    #[link_name = "?squeeze@SparseComplexMatrix@@QEBA?AV1@XZ"]
    pub fn SparseComplexMatrix_squeeze(this: *const SparseComplexMatrix)
     -> SparseComplexMatrix;
}
extern "C" {
    #[link_name = "?reshape@SparseComplexMatrix@@QEBA?AV1@AEBVdim_vector@@@Z"]
    pub fn SparseComplexMatrix_reshape(this: *const SparseComplexMatrix,
                                       new_dims: *const dim_vector)
     -> SparseComplexMatrix;
}
extern "C" {
    #[link_name =
          "?permute@SparseComplexMatrix@@QEBA?AV1@AEBV?$Array@H@@_N@Z"]
    pub fn SparseComplexMatrix_permute(this: *const SparseComplexMatrix,
                                       vec:
                                           *const Array<::std::os::raw::c_int>,
                                       inv: bool) -> SparseComplexMatrix;
}
extern "C" {
    #[link_name = "?ipermute@SparseComplexMatrix@@QEBA?AV1@AEBV?$Array@H@@@Z"]
    pub fn SparseComplexMatrix_ipermute(this: *const SparseComplexMatrix,
                                        vec:
                                            *const Array<::std::os::raw::c_int>)
     -> SparseComplexMatrix;
}
extern "C" {
    #[link_name = "?any_element_is_nan@SparseComplexMatrix@@QEBA_NXZ"]
    pub fn SparseComplexMatrix_any_element_is_nan(this:
                                                      *const SparseComplexMatrix)
     -> bool;
}
extern "C" {
    #[link_name = "?any_element_is_inf_or_nan@SparseComplexMatrix@@QEBA_NXZ"]
    pub fn SparseComplexMatrix_any_element_is_inf_or_nan(this:
                                                             *const SparseComplexMatrix)
     -> bool;
}
extern "C" {
    #[link_name = "?all_elements_are_real@SparseComplexMatrix@@QEBA_NXZ"]
    pub fn SparseComplexMatrix_all_elements_are_real(this:
                                                         *const SparseComplexMatrix)
     -> bool;
}
extern "C" {
    #[link_name = "?all_integers@SparseComplexMatrix@@QEBA_NAEAN0@Z"]
    pub fn SparseComplexMatrix_all_integers(this: *const SparseComplexMatrix,
                                            max_val: *mut f64,
                                            min_val: *mut f64) -> bool;
}
extern "C" {
    #[link_name = "?too_large_for_float@SparseComplexMatrix@@QEBA_NXZ"]
    pub fn SparseComplexMatrix_too_large_for_float(this:
                                                       *const SparseComplexMatrix)
     -> bool;
}
extern "C" {
    #[link_name = "?all@SparseComplexMatrix@@QEBA?AVSparseBoolMatrix@@H@Z"]
    pub fn SparseComplexMatrix_all(this: *const SparseComplexMatrix,
                                   dim: ::std::os::raw::c_int)
     -> SparseBoolMatrix;
}
extern "C" {
    #[link_name = "?any@SparseComplexMatrix@@QEBA?AVSparseBoolMatrix@@H@Z"]
    pub fn SparseComplexMatrix_any(this: *const SparseComplexMatrix,
                                   dim: ::std::os::raw::c_int)
     -> SparseBoolMatrix;
}
extern "C" {
    #[link_name = "?cumprod@SparseComplexMatrix@@QEBA?AV1@H@Z"]
    pub fn SparseComplexMatrix_cumprod(this: *const SparseComplexMatrix,
                                       dim: ::std::os::raw::c_int)
     -> SparseComplexMatrix;
}
extern "C" {
    #[link_name = "?cumsum@SparseComplexMatrix@@QEBA?AV1@H@Z"]
    pub fn SparseComplexMatrix_cumsum(this: *const SparseComplexMatrix,
                                      dim: ::std::os::raw::c_int)
     -> SparseComplexMatrix;
}
extern "C" {
    #[link_name = "?prod@SparseComplexMatrix@@QEBA?AV1@H@Z"]
    pub fn SparseComplexMatrix_prod(this: *const SparseComplexMatrix,
                                    dim: ::std::os::raw::c_int)
     -> SparseComplexMatrix;
}
extern "C" {
    #[link_name = "?sum@SparseComplexMatrix@@QEBA?AV1@H@Z"]
    pub fn SparseComplexMatrix_sum(this: *const SparseComplexMatrix,
                                   dim: ::std::os::raw::c_int)
     -> SparseComplexMatrix;
}
extern "C" {
    #[link_name = "?sumsq@SparseComplexMatrix@@QEBA?AV1@H@Z"]
    pub fn SparseComplexMatrix_sumsq(this: *const SparseComplexMatrix,
                                     dim: ::std::os::raw::c_int)
     -> SparseComplexMatrix;
}
extern "C" {
    #[link_name = "?abs@SparseComplexMatrix@@QEBA?AVSparseMatrix@@XZ"]
    pub fn SparseComplexMatrix_abs(this: *const SparseComplexMatrix)
     -> SparseMatrix;
}
extern "C" {
    #[link_name = "?diag@SparseComplexMatrix@@QEBA?AV1@H@Z"]
    pub fn SparseComplexMatrix_diag(this: *const SparseComplexMatrix,
                                    k: octave_idx_type)
     -> SparseComplexMatrix;
}
extern "C" {
    #[link_name = "??0SparseComplexMatrix@@QEAA@AEBVSparseMatrix@@@Z"]
    pub fn SparseComplexMatrix_SparseComplexMatrix(this:
                                                       *mut SparseComplexMatrix,
                                                   a: *const SparseMatrix);
}
extern "C" {
    #[link_name = "??0SparseComplexMatrix@@QEAA@AEBVSparseBoolMatrix@@@Z"]
    pub fn SparseComplexMatrix_SparseComplexMatrix1(this:
                                                        *mut SparseComplexMatrix,
                                                    a:
                                                        *const SparseBoolMatrix);
}
extern "C" {
    #[link_name = "??0SparseComplexMatrix@@QEAA@AEBVComplexDiagMatrix@@@Z"]
    pub fn SparseComplexMatrix_SparseComplexMatrix2(this:
                                                        *mut SparseComplexMatrix,
                                                    a:
                                                        *const ComplexDiagMatrix);
}
impl SparseComplexMatrix {
    #[inline]
    pub unsafe fn is_hermitian(&self) -> bool {
        SparseComplexMatrix_is_hermitian(self)
    }
    #[inline]
    pub unsafe fn max(&self, dim: ::std::os::raw::c_int)
     -> SparseComplexMatrix {
        SparseComplexMatrix_max(self, dim)
    }
    #[inline]
    pub unsafe fn max1(&self, index: *mut Array<::std::os::raw::c_int>,
                       dim: ::std::os::raw::c_int) -> SparseComplexMatrix {
        SparseComplexMatrix_max1(self, index, dim)
    }
    #[inline]
    pub unsafe fn min(&self, dim: ::std::os::raw::c_int)
     -> SparseComplexMatrix {
        SparseComplexMatrix_min(self, dim)
    }
    #[inline]
    pub unsafe fn min1(&self, index: *mut Array<::std::os::raw::c_int>,
                       dim: ::std::os::raw::c_int) -> SparseComplexMatrix {
        SparseComplexMatrix_min1(self, index, dim)
    }
    #[inline]
    pub unsafe fn insert(&mut self, a: *const SparseComplexMatrix,
                         r: octave_idx_type, c: octave_idx_type)
     -> *mut SparseComplexMatrix {
        SparseComplexMatrix_insert(self, a, r, c)
    }
    #[inline]
    pub unsafe fn insert1(&mut self, a: *const SparseMatrix,
                          r: octave_idx_type, c: octave_idx_type)
     -> *mut SparseComplexMatrix {
        SparseComplexMatrix_insert1(self, a, r, c)
    }
    #[inline]
    pub unsafe fn insert2(&mut self, a: *const SparseComplexMatrix,
                          indx: *const Array<::std::os::raw::c_int>)
     -> *mut SparseComplexMatrix {
        SparseComplexMatrix_insert2(self, a, indx)
    }
    #[inline]
    pub unsafe fn insert3(&mut self, a: *const SparseMatrix,
                          indx: *const Array<::std::os::raw::c_int>)
     -> *mut SparseComplexMatrix {
        SparseComplexMatrix_insert3(self, a, indx)
    }
    #[inline]
    pub unsafe fn concat(&mut self, rb: *const SparseComplexMatrix,
                         ra_idx: *const Array<::std::os::raw::c_int>)
     -> SparseComplexMatrix {
        SparseComplexMatrix_concat(self, rb, ra_idx)
    }
    #[inline]
    pub unsafe fn concat1(&mut self, rb: *const SparseMatrix,
                          ra_idx: *const Array<::std::os::raw::c_int>)
     -> SparseComplexMatrix {
        SparseComplexMatrix_concat1(self, rb, ra_idx)
    }
    #[inline]
    pub unsafe fn matrix_value(&self) -> ComplexMatrix {
        SparseComplexMatrix_matrix_value(self)
    }
    #[inline]
    pub unsafe fn hermitian(&self) -> SparseComplexMatrix {
        SparseComplexMatrix_hermitian(self)
    }
    #[inline]
    pub unsafe fn row(&self, i: octave_idx_type) -> ComplexRowVector {
        SparseComplexMatrix_row(self, i)
    }
    #[inline]
    pub unsafe fn column(&self, i: octave_idx_type) -> ComplexColumnVector {
        SparseComplexMatrix_column(self, i)
    }
    #[inline]
    pub unsafe fn inverse(&self) -> SparseComplexMatrix {
        SparseComplexMatrix_inverse(self)
    }
    #[inline]
    pub unsafe fn inverse1(&self, mattype: *mut MatrixType)
     -> SparseComplexMatrix {
        SparseComplexMatrix_inverse1(self, mattype)
    }
    #[inline]
    pub unsafe fn inverse2(&self, mattype: *mut MatrixType,
                           info: *mut octave_idx_type)
     -> SparseComplexMatrix {
        SparseComplexMatrix_inverse2(self, mattype, info)
    }
    #[inline]
    pub unsafe fn inverse3(&self, mattype: *mut MatrixType,
                           info: *mut octave_idx_type, rcond: *mut f64,
                           force: bool, calc_cond: bool)
     -> SparseComplexMatrix {
        SparseComplexMatrix_inverse3(self, mattype, info, rcond, force,
                                     calc_cond)
    }
    #[inline]
    pub unsafe fn determinant(&self) -> ComplexDET {
        SparseComplexMatrix_determinant(self)
    }
    #[inline]
    pub unsafe fn determinant1(&self, info: *mut octave_idx_type)
     -> ComplexDET {
        SparseComplexMatrix_determinant1(self, info)
    }
    #[inline]
    pub unsafe fn determinant2(&self, info: *mut octave_idx_type,
                               rcond: *mut f64, calc_cond: bool)
     -> ComplexDET {
        SparseComplexMatrix_determinant2(self, info, rcond, calc_cond)
    }
    #[inline]
    pub unsafe fn solve(&self, typ: *mut MatrixType, b: *const Matrix)
     -> ComplexMatrix {
        SparseComplexMatrix_solve(self, typ, b)
    }
    #[inline]
    pub unsafe fn solve1(&self, typ: *mut MatrixType, b: *const Matrix,
                         info: *mut octave_idx_type) -> ComplexMatrix {
        SparseComplexMatrix_solve1(self, typ, b, info)
    }
    #[inline]
    pub unsafe fn solve2(&self, typ: *mut MatrixType, b: *const Matrix,
                         info: *mut octave_idx_type, rcond: *mut f64)
     -> ComplexMatrix {
        SparseComplexMatrix_solve2(self, typ, b, info, rcond)
    }
    #[inline]
    pub unsafe fn solve3(&self, typ: *mut MatrixType, b: *const Matrix,
                         info: *mut octave_idx_type, rcond: *mut f64,
                         sing_handler:
                             SparseComplexMatrix_solve_singularity_handler,
                         singular_fallback: bool) -> ComplexMatrix {
        SparseComplexMatrix_solve3(self, typ, b, info, rcond, sing_handler,
                                   singular_fallback)
    }
    #[inline]
    pub unsafe fn solve4(&self, typ: *mut MatrixType, b: *const ComplexMatrix)
     -> ComplexMatrix {
        SparseComplexMatrix_solve4(self, typ, b)
    }
    #[inline]
    pub unsafe fn solve5(&self, typ: *mut MatrixType, b: *const ComplexMatrix,
                         info: *mut octave_idx_type) -> ComplexMatrix {
        SparseComplexMatrix_solve5(self, typ, b, info)
    }
    #[inline]
    pub unsafe fn solve6(&self, typ: *mut MatrixType, b: *const ComplexMatrix,
                         info: *mut octave_idx_type, rcond: *mut f64)
     -> ComplexMatrix {
        SparseComplexMatrix_solve6(self, typ, b, info, rcond)
    }
    #[inline]
    pub unsafe fn solve7(&self, typ: *mut MatrixType, b: *const ComplexMatrix,
                         info: *mut octave_idx_type, rcond: *mut f64,
                         sing_handler:
                             SparseComplexMatrix_solve_singularity_handler,
                         singular_fallback: bool) -> ComplexMatrix {
        SparseComplexMatrix_solve7(self, typ, b, info, rcond, sing_handler,
                                   singular_fallback)
    }
    #[inline]
    pub unsafe fn solve8(&self, typ: *mut MatrixType, b: *const SparseMatrix)
     -> SparseComplexMatrix {
        SparseComplexMatrix_solve8(self, typ, b)
    }
    #[inline]
    pub unsafe fn solve9(&self, typ: *mut MatrixType, b: *const SparseMatrix,
                         info: *mut octave_idx_type) -> SparseComplexMatrix {
        SparseComplexMatrix_solve9(self, typ, b, info)
    }
    #[inline]
    pub unsafe fn solve10(&self, typ: *mut MatrixType, b: *const SparseMatrix,
                          info: *mut octave_idx_type, rcond: *mut f64)
     -> SparseComplexMatrix {
        SparseComplexMatrix_solve10(self, typ, b, info, rcond)
    }
    #[inline]
    pub unsafe fn solve11(&self, typ: *mut MatrixType, b: *const SparseMatrix,
                          info: *mut octave_idx_type, rcond: *mut f64,
                          sing_handler:
                              SparseComplexMatrix_solve_singularity_handler,
                          singular_fallback: bool) -> SparseComplexMatrix {
        SparseComplexMatrix_solve11(self, typ, b, info, rcond, sing_handler,
                                    singular_fallback)
    }
    #[inline]
    pub unsafe fn solve12(&self, typ: *mut MatrixType,
                          b: *const SparseComplexMatrix)
     -> SparseComplexMatrix {
        SparseComplexMatrix_solve12(self, typ, b)
    }
    #[inline]
    pub unsafe fn solve13(&self, typ: *mut MatrixType,
                          b: *const SparseComplexMatrix,
                          info: *mut octave_idx_type) -> SparseComplexMatrix {
        SparseComplexMatrix_solve13(self, typ, b, info)
    }
    #[inline]
    pub unsafe fn solve14(&self, typ: *mut MatrixType,
                          b: *const SparseComplexMatrix,
                          info: *mut octave_idx_type, rcond: *mut f64)
     -> SparseComplexMatrix {
        SparseComplexMatrix_solve14(self, typ, b, info, rcond)
    }
    #[inline]
    pub unsafe fn solve15(&self, typ: *mut MatrixType,
                          b: *const SparseComplexMatrix,
                          info: *mut octave_idx_type, rcond: *mut f64,
                          sing_handler:
                              SparseComplexMatrix_solve_singularity_handler,
                          singular_fallback: bool) -> SparseComplexMatrix {
        SparseComplexMatrix_solve15(self, typ, b, info, rcond, sing_handler,
                                    singular_fallback)
    }
    #[inline]
    pub unsafe fn solve16(&self, typ: *mut MatrixType, b: *const ColumnVector)
     -> ComplexColumnVector {
        SparseComplexMatrix_solve16(self, typ, b)
    }
    #[inline]
    pub unsafe fn solve17(&self, typ: *mut MatrixType, b: *const ColumnVector,
                          info: *mut octave_idx_type) -> ComplexColumnVector {
        SparseComplexMatrix_solve17(self, typ, b, info)
    }
    #[inline]
    pub unsafe fn solve18(&self, typ: *mut MatrixType, b: *const ColumnVector,
                          info: *mut octave_idx_type, rcond: *mut f64)
     -> ComplexColumnVector {
        SparseComplexMatrix_solve18(self, typ, b, info, rcond)
    }
    #[inline]
    pub unsafe fn solve19(&self, typ: *mut MatrixType, b: *const ColumnVector,
                          info: *mut octave_idx_type, rcond: *mut f64,
                          sing_handler:
                              SparseComplexMatrix_solve_singularity_handler)
     -> ComplexColumnVector {
        SparseComplexMatrix_solve19(self, typ, b, info, rcond, sing_handler)
    }
    #[inline]
    pub unsafe fn solve20(&self, typ: *mut MatrixType,
                          b: *const ComplexColumnVector)
     -> ComplexColumnVector {
        SparseComplexMatrix_solve20(self, typ, b)
    }
    #[inline]
    pub unsafe fn solve21(&self, typ: *mut MatrixType,
                          b: *const ComplexColumnVector,
                          info: *mut octave_idx_type) -> ComplexColumnVector {
        SparseComplexMatrix_solve21(self, typ, b, info)
    }
    #[inline]
    pub unsafe fn solve22(&self, typ: *mut MatrixType,
                          b: *const ComplexColumnVector,
                          info: *mut octave_idx_type, rcond: *mut f64)
     -> ComplexColumnVector {
        SparseComplexMatrix_solve22(self, typ, b, info, rcond)
    }
    #[inline]
    pub unsafe fn solve23(&self, typ: *mut MatrixType,
                          b: *const ComplexColumnVector,
                          info: *mut octave_idx_type, rcond: *mut f64,
                          sing_handler:
                              SparseComplexMatrix_solve_singularity_handler)
     -> ComplexColumnVector {
        SparseComplexMatrix_solve23(self, typ, b, info, rcond, sing_handler)
    }
    #[inline]
    pub unsafe fn solve24(&self, b: *const Matrix) -> ComplexMatrix {
        SparseComplexMatrix_solve24(self, b)
    }
    #[inline]
    pub unsafe fn solve25(&self, b: *const Matrix, info: *mut octave_idx_type)
     -> ComplexMatrix {
        SparseComplexMatrix_solve25(self, b, info)
    }
    #[inline]
    pub unsafe fn solve26(&self, b: *const Matrix, info: *mut octave_idx_type,
                          rcond: *mut f64) -> ComplexMatrix {
        SparseComplexMatrix_solve26(self, b, info, rcond)
    }
    #[inline]
    pub unsafe fn solve27(&self, b: *const Matrix, info: *mut octave_idx_type,
                          rcond: *mut f64,
                          sing_handler:
                              SparseComplexMatrix_solve_singularity_handler)
     -> ComplexMatrix {
        SparseComplexMatrix_solve27(self, b, info, rcond, sing_handler)
    }
    #[inline]
    pub unsafe fn solve28(&self, b: *const ComplexMatrix) -> ComplexMatrix {
        SparseComplexMatrix_solve28(self, b)
    }
    #[inline]
    pub unsafe fn solve29(&self, b: *const ComplexMatrix,
                          info: *mut octave_idx_type) -> ComplexMatrix {
        SparseComplexMatrix_solve29(self, b, info)
    }
    #[inline]
    pub unsafe fn solve30(&self, b: *const ComplexMatrix,
                          info: *mut octave_idx_type, rcond: *mut f64)
     -> ComplexMatrix {
        SparseComplexMatrix_solve30(self, b, info, rcond)
    }
    #[inline]
    pub unsafe fn solve31(&self, b: *const ComplexMatrix,
                          info: *mut octave_idx_type, rcond: *mut f64,
                          sing_handler:
                              SparseComplexMatrix_solve_singularity_handler)
     -> ComplexMatrix {
        SparseComplexMatrix_solve31(self, b, info, rcond, sing_handler)
    }
    #[inline]
    pub unsafe fn solve32(&self, b: *const SparseMatrix)
     -> SparseComplexMatrix {
        SparseComplexMatrix_solve32(self, b)
    }
    #[inline]
    pub unsafe fn solve33(&self, b: *const SparseMatrix,
                          info: *mut octave_idx_type) -> SparseComplexMatrix {
        SparseComplexMatrix_solve33(self, b, info)
    }
    #[inline]
    pub unsafe fn solve34(&self, b: *const SparseMatrix,
                          info: *mut octave_idx_type, rcond: *mut f64)
     -> SparseComplexMatrix {
        SparseComplexMatrix_solve34(self, b, info, rcond)
    }
    #[inline]
    pub unsafe fn solve35(&self, b: *const SparseMatrix,
                          info: *mut octave_idx_type, rcond: *mut f64,
                          sing_handler:
                              SparseComplexMatrix_solve_singularity_handler)
     -> SparseComplexMatrix {
        SparseComplexMatrix_solve35(self, b, info, rcond, sing_handler)
    }
    #[inline]
    pub unsafe fn solve36(&self, b: *const SparseComplexMatrix)
     -> SparseComplexMatrix {
        SparseComplexMatrix_solve36(self, b)
    }
    #[inline]
    pub unsafe fn solve37(&self, b: *const SparseComplexMatrix,
                          info: *mut octave_idx_type) -> SparseComplexMatrix {
        SparseComplexMatrix_solve37(self, b, info)
    }
    #[inline]
    pub unsafe fn solve38(&self, b: *const SparseComplexMatrix,
                          info: *mut octave_idx_type, rcond: *mut f64)
     -> SparseComplexMatrix {
        SparseComplexMatrix_solve38(self, b, info, rcond)
    }
    #[inline]
    pub unsafe fn solve39(&self, b: *const SparseComplexMatrix,
                          info: *mut octave_idx_type, rcond: *mut f64,
                          sing_handler:
                              SparseComplexMatrix_solve_singularity_handler)
     -> SparseComplexMatrix {
        SparseComplexMatrix_solve39(self, b, info, rcond, sing_handler)
    }
    #[inline]
    pub unsafe fn solve40(&self, b: *const ColumnVector)
     -> ComplexColumnVector {
        SparseComplexMatrix_solve40(self, b)
    }
    #[inline]
    pub unsafe fn solve41(&self, b: *const ColumnVector,
                          info: *mut octave_idx_type) -> ComplexColumnVector {
        SparseComplexMatrix_solve41(self, b, info)
    }
    #[inline]
    pub unsafe fn solve42(&self, b: *const ColumnVector,
                          info: *mut octave_idx_type, rcond: *mut f64)
     -> ComplexColumnVector {
        SparseComplexMatrix_solve42(self, b, info, rcond)
    }
    #[inline]
    pub unsafe fn solve43(&self, b: *const ColumnVector,
                          info: *mut octave_idx_type, rcond: *mut f64,
                          sing_handler:
                              SparseComplexMatrix_solve_singularity_handler)
     -> ComplexColumnVector {
        SparseComplexMatrix_solve43(self, b, info, rcond, sing_handler)
    }
    #[inline]
    pub unsafe fn solve44(&self, b: *const ComplexColumnVector)
     -> ComplexColumnVector {
        SparseComplexMatrix_solve44(self, b)
    }
    #[inline]
    pub unsafe fn solve45(&self, b: *const ComplexColumnVector,
                          info: *mut octave_idx_type) -> ComplexColumnVector {
        SparseComplexMatrix_solve45(self, b, info)
    }
    #[inline]
    pub unsafe fn solve46(&self, b: *const ComplexColumnVector,
                          info: *mut octave_idx_type, rcond: *mut f64)
     -> ComplexColumnVector {
        SparseComplexMatrix_solve46(self, b, info, rcond)
    }
    #[inline]
    pub unsafe fn solve47(&self, b: *const ComplexColumnVector,
                          info: *mut octave_idx_type, rcond: *mut f64,
                          sing_handler:
                              SparseComplexMatrix_solve_singularity_handler)
     -> ComplexColumnVector {
        SparseComplexMatrix_solve47(self, b, info, rcond, sing_handler)
    }
    #[inline]
    pub unsafe fn squeeze(&self) -> SparseComplexMatrix {
        SparseComplexMatrix_squeeze(self)
    }
    #[inline]
    pub unsafe fn reshape(&self, new_dims: *const dim_vector)
     -> SparseComplexMatrix {
        SparseComplexMatrix_reshape(self, new_dims)
    }
    #[inline]
    pub unsafe fn permute(&self, vec: *const Array<::std::os::raw::c_int>,
                          inv: bool) -> SparseComplexMatrix {
        SparseComplexMatrix_permute(self, vec, inv)
    }
    #[inline]
    pub unsafe fn ipermute(&self, vec: *const Array<::std::os::raw::c_int>)
     -> SparseComplexMatrix {
        SparseComplexMatrix_ipermute(self, vec)
    }
    #[inline]
    pub unsafe fn any_element_is_nan(&self) -> bool {
        SparseComplexMatrix_any_element_is_nan(self)
    }
    #[inline]
    pub unsafe fn any_element_is_inf_or_nan(&self) -> bool {
        SparseComplexMatrix_any_element_is_inf_or_nan(self)
    }
    #[inline]
    pub unsafe fn all_elements_are_real(&self) -> bool {
        SparseComplexMatrix_all_elements_are_real(self)
    }
    #[inline]
    pub unsafe fn all_integers(&self, max_val: *mut f64, min_val: *mut f64)
     -> bool {
        SparseComplexMatrix_all_integers(self, max_val, min_val)
    }
    #[inline]
    pub unsafe fn too_large_for_float(&self) -> bool {
        SparseComplexMatrix_too_large_for_float(self)
    }
    #[inline]
    pub unsafe fn all(&self, dim: ::std::os::raw::c_int) -> SparseBoolMatrix {
        SparseComplexMatrix_all(self, dim)
    }
    #[inline]
    pub unsafe fn any(&self, dim: ::std::os::raw::c_int) -> SparseBoolMatrix {
        SparseComplexMatrix_any(self, dim)
    }
    #[inline]
    pub unsafe fn cumprod(&self, dim: ::std::os::raw::c_int)
     -> SparseComplexMatrix {
        SparseComplexMatrix_cumprod(self, dim)
    }
    #[inline]
    pub unsafe fn cumsum(&self, dim: ::std::os::raw::c_int)
     -> SparseComplexMatrix {
        SparseComplexMatrix_cumsum(self, dim)
    }
    #[inline]
    pub unsafe fn prod(&self, dim: ::std::os::raw::c_int)
     -> SparseComplexMatrix {
        SparseComplexMatrix_prod(self, dim)
    }
    #[inline]
    pub unsafe fn sum(&self, dim: ::std::os::raw::c_int)
     -> SparseComplexMatrix {
        SparseComplexMatrix_sum(self, dim)
    }
    #[inline]
    pub unsafe fn sumsq(&self, dim: ::std::os::raw::c_int)
     -> SparseComplexMatrix {
        SparseComplexMatrix_sumsq(self, dim)
    }
    #[inline]
    pub unsafe fn abs(&self) -> SparseMatrix { SparseComplexMatrix_abs(self) }
    #[inline]
    pub unsafe fn diag(&self, k: octave_idx_type) -> SparseComplexMatrix {
        SparseComplexMatrix_diag(self, k)
    }
    #[inline]
    pub unsafe fn new(a: *const SparseMatrix) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        SparseComplexMatrix_SparseComplexMatrix(&mut __bindgen_tmp, a);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(a: *const SparseBoolMatrix) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        SparseComplexMatrix_SparseComplexMatrix1(&mut __bindgen_tmp, a);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new2(a: *const ComplexDiagMatrix) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        SparseComplexMatrix_SparseComplexMatrix2(&mut __bindgen_tmp, a);
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct MatrixType {
    pub typ: MatrixType_matrix_type,
    pub sp_bandden: f64,
    pub bandden: f64,
    pub upper_band: octave_idx_type,
    pub lower_band: octave_idx_type,
    pub dense: bool,
    pub full: bool,
    pub nperm: octave_idx_type,
    pub perm: *mut octave_idx_type,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum MatrixType_matrix_type {
    Unknown = 0,
    Full = 1,
    Diagonal = 2,
    Permuted_Diagonal = 3,
    Upper = 4,
    Lower = 5,
    Permuted_Upper = 6,
    Permuted_Lower = 7,
    Banded = 8,
    Hermitian = 9,
    Banded_Hermitian = 10,
    Tridiagonal = 11,
    Tridiagonal_Hermitian = 12,
    Rectangular = 13,
}
#[test]
fn bindgen_test_layout_MatrixType() {
    assert_eq!(::std::mem::size_of::<MatrixType>() , 48usize , concat ! (
               "Size of: " , stringify ! ( MatrixType ) ));
    assert_eq! (::std::mem::align_of::<MatrixType>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( MatrixType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MatrixType ) ) . typ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( MatrixType ) , "::" ,
                stringify ! ( typ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MatrixType ) ) . sp_bandden as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( MatrixType ) , "::" ,
                stringify ! ( sp_bandden ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MatrixType ) ) . bandden as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( MatrixType ) , "::" ,
                stringify ! ( bandden ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MatrixType ) ) . upper_band as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( MatrixType ) , "::" ,
                stringify ! ( upper_band ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MatrixType ) ) . lower_band as * const _
                as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( MatrixType ) , "::" ,
                stringify ! ( lower_band ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MatrixType ) ) . dense as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( MatrixType ) , "::" ,
                stringify ! ( dense ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MatrixType ) ) . full as * const _ as
                usize } , 33usize , concat ! (
                "Alignment of field: " , stringify ! ( MatrixType ) , "::" ,
                stringify ! ( full ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MatrixType ) ) . nperm as * const _ as
                usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( MatrixType ) , "::" ,
                stringify ! ( nperm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MatrixType ) ) . perm as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( MatrixType ) , "::" ,
                stringify ! ( perm ) ));
}
extern "C" {
    #[link_name = "?type@MatrixType@@QEAAH_N@Z"]
    pub fn MatrixType_type(this: *mut MatrixType, quiet: bool)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "?type@MatrixType@@QEAAHAEBVMatrix@@@Z"]
    pub fn MatrixType_type1(this: *mut MatrixType, a: *const Matrix)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "?type@MatrixType@@QEAAHAEBVComplexMatrix@@@Z"]
    pub fn MatrixType_type2(this: *mut MatrixType, a: *const ComplexMatrix)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "?type@MatrixType@@QEAAHAEBVFloatMatrix@@@Z"]
    pub fn MatrixType_type3(this: *mut MatrixType, a: *const FloatMatrix)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "?type@MatrixType@@QEAAHAEBVFloatComplexMatrix@@@Z"]
    pub fn MatrixType_type4(this: *mut MatrixType,
                            a: *const FloatComplexMatrix)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "?type@MatrixType@@QEAAHAEBVSparseMatrix@@@Z"]
    pub fn MatrixType_type5(this: *mut MatrixType, a: *const SparseMatrix)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "?type@MatrixType@@QEAAHAEBVSparseComplexMatrix@@@Z"]
    pub fn MatrixType_type6(this: *mut MatrixType,
                            a: *const SparseComplexMatrix)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "?info@MatrixType@@QEBAXXZ"]
    pub fn MatrixType_info(this: *const MatrixType);
}
extern "C" {
    #[link_name = "?mark_as_symmetric@MatrixType@@QEAAXXZ"]
    pub fn MatrixType_mark_as_symmetric(this: *mut MatrixType);
}
extern "C" {
    #[link_name = "?mark_as_unsymmetric@MatrixType@@QEAAXXZ"]
    pub fn MatrixType_mark_as_unsymmetric(this: *mut MatrixType);
}
extern "C" {
    #[link_name = "?mark_as_permuted@MatrixType@@QEAAXHPEBH@Z"]
    pub fn MatrixType_mark_as_permuted(this: *mut MatrixType,
                                       np: octave_idx_type,
                                       p: *const octave_idx_type);
}
extern "C" {
    #[link_name = "?mark_as_unpermuted@MatrixType@@QEAAXXZ"]
    pub fn MatrixType_mark_as_unpermuted(this: *mut MatrixType);
}
extern "C" {
    #[link_name = "?transpose@MatrixType@@QEBA?AV1@XZ"]
    pub fn MatrixType_transpose(this: *const MatrixType) -> MatrixType;
}
extern "C" {
    #[link_name = "??0MatrixType@@QEAA@XZ"]
    pub fn MatrixType_MatrixType(this: *mut MatrixType);
}
extern "C" {
    #[link_name = "??0MatrixType@@QEAA@AEBV0@@Z"]
    pub fn MatrixType_MatrixType1(this: *mut MatrixType,
                                  a: *const MatrixType);
}
extern "C" {
    #[link_name = "??0MatrixType@@QEAA@AEBVMatrix@@@Z"]
    pub fn MatrixType_MatrixType2(this: *mut MatrixType, a: *const Matrix);
}
extern "C" {
    #[link_name = "??0MatrixType@@QEAA@AEBVComplexMatrix@@@Z"]
    pub fn MatrixType_MatrixType3(this: *mut MatrixType,
                                  a: *const ComplexMatrix);
}
extern "C" {
    #[link_name = "??0MatrixType@@QEAA@AEBVFloatMatrix@@@Z"]
    pub fn MatrixType_MatrixType4(this: *mut MatrixType,
                                  a: *const FloatMatrix);
}
extern "C" {
    #[link_name = "??0MatrixType@@QEAA@AEBVFloatComplexMatrix@@@Z"]
    pub fn MatrixType_MatrixType5(this: *mut MatrixType,
                                  a: *const FloatComplexMatrix);
}
extern "C" {
    #[link_name = "??0MatrixType@@QEAA@W4matrix_type@0@_N@Z"]
    pub fn MatrixType_MatrixType6(this: *mut MatrixType,
                                  t: MatrixType_matrix_type, _full: bool);
}
extern "C" {
    #[link_name = "??0MatrixType@@QEAA@W4matrix_type@0@HPEBH_N@Z"]
    pub fn MatrixType_MatrixType7(this: *mut MatrixType,
                                  t: MatrixType_matrix_type,
                                  np: octave_idx_type,
                                  p: *const octave_idx_type, _full: bool);
}
extern "C" {
    #[link_name = "??0MatrixType@@QEAA@W4matrix_type@0@HH_N@Z"]
    pub fn MatrixType_MatrixType8(this: *mut MatrixType,
                                  t: MatrixType_matrix_type,
                                  ku: octave_idx_type, kl: octave_idx_type,
                                  _full: bool);
}
extern "C" {
    #[link_name = "??_DMatrixType@@QEAA@XZ"]
    pub fn MatrixType_MatrixType_destructor(this: *mut MatrixType);
}
impl MatrixType {
    #[inline]
    pub unsafe fn type_(&mut self, quiet: bool) -> ::std::os::raw::c_int {
        MatrixType_type(self, quiet)
    }
    #[inline]
    pub unsafe fn type1(&mut self, a: *const Matrix)
     -> ::std::os::raw::c_int {
        MatrixType_type1(self, a)
    }
    #[inline]
    pub unsafe fn type2(&mut self, a: *const ComplexMatrix)
     -> ::std::os::raw::c_int {
        MatrixType_type2(self, a)
    }
    #[inline]
    pub unsafe fn type3(&mut self, a: *const FloatMatrix)
     -> ::std::os::raw::c_int {
        MatrixType_type3(self, a)
    }
    #[inline]
    pub unsafe fn type4(&mut self, a: *const FloatComplexMatrix)
     -> ::std::os::raw::c_int {
        MatrixType_type4(self, a)
    }
    #[inline]
    pub unsafe fn type5(&mut self, a: *const SparseMatrix)
     -> ::std::os::raw::c_int {
        MatrixType_type5(self, a)
    }
    #[inline]
    pub unsafe fn type6(&mut self, a: *const SparseComplexMatrix)
     -> ::std::os::raw::c_int {
        MatrixType_type6(self, a)
    }
    #[inline]
    pub unsafe fn info(&self) { MatrixType_info(self) }
    #[inline]
    pub unsafe fn mark_as_symmetric(&mut self) {
        MatrixType_mark_as_symmetric(self)
    }
    #[inline]
    pub unsafe fn mark_as_unsymmetric(&mut self) {
        MatrixType_mark_as_unsymmetric(self)
    }
    #[inline]
    pub unsafe fn mark_as_permuted(&mut self, np: octave_idx_type,
                                   p: *const octave_idx_type) {
        MatrixType_mark_as_permuted(self, np, p)
    }
    #[inline]
    pub unsafe fn mark_as_unpermuted(&mut self) {
        MatrixType_mark_as_unpermuted(self)
    }
    #[inline]
    pub unsafe fn transpose(&self) -> MatrixType {
        MatrixType_transpose(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        MatrixType_MatrixType(&mut __bindgen_tmp);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(a: *const MatrixType) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        MatrixType_MatrixType1(&mut __bindgen_tmp, a);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new2(a: *const Matrix) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        MatrixType_MatrixType2(&mut __bindgen_tmp, a);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new3(a: *const ComplexMatrix) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        MatrixType_MatrixType3(&mut __bindgen_tmp, a);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new4(a: *const FloatMatrix) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        MatrixType_MatrixType4(&mut __bindgen_tmp, a);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new5(a: *const FloatComplexMatrix) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        MatrixType_MatrixType5(&mut __bindgen_tmp, a);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new6(t: MatrixType_matrix_type, _full: bool) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        MatrixType_MatrixType6(&mut __bindgen_tmp, t, _full);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new7(t: MatrixType_matrix_type, np: octave_idx_type,
                       p: *const octave_idx_type, _full: bool) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        MatrixType_MatrixType7(&mut __bindgen_tmp, t, np, p, _full);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new8(t: MatrixType_matrix_type, ku: octave_idx_type,
                       kl: octave_idx_type, _full: bool) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        MatrixType_MatrixType8(&mut __bindgen_tmp, t, ku, kl, _full);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        MatrixType_MatrixType_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct boolMatrix {
    pub _base: boolNDArray,
}
#[test]
fn bindgen_test_layout_boolMatrix() {
    assert_eq!(::std::mem::size_of::<boolMatrix>() , 40usize , concat ! (
               "Size of: " , stringify ! ( boolMatrix ) ));
    assert_eq! (::std::mem::align_of::<boolMatrix>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( boolMatrix ) ));
}
extern "C" {
    #[link_name = "?insert@boolMatrix@@QEAAAEAV1@AEBV1@HH@Z"]
    pub fn boolMatrix_insert(this: *mut boolMatrix, a: *const boolMatrix,
                             r: octave_idx_type, c: octave_idx_type)
     -> *mut boolMatrix;
}
extern "C" {
    #[link_name = "?diag@boolMatrix@@QEBA?AV1@H@Z"]
    pub fn boolMatrix_diag(this: *const boolMatrix, k: octave_idx_type)
     -> boolMatrix;
}
impl boolMatrix {
    #[inline]
    pub unsafe fn insert(&mut self, a: *const boolMatrix, r: octave_idx_type,
                         c: octave_idx_type) -> *mut boolMatrix {
        boolMatrix_insert(self, a, r, c)
    }
    #[inline]
    pub unsafe fn diag(&self, k: octave_idx_type) -> boolMatrix {
        boolMatrix_diag(self, k)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct charMatrix {
    pub _base: charNDArray,
}
#[test]
fn bindgen_test_layout_charMatrix() {
    assert_eq!(::std::mem::size_of::<charMatrix>() , 40usize , concat ! (
               "Size of: " , stringify ! ( charMatrix ) ));
    assert_eq! (::std::mem::align_of::<charMatrix>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( charMatrix ) ));
}
extern "C" {
    #[link_name = "?insert@charMatrix@@QEAAAEAV1@PEBDHH@Z"]
    pub fn charMatrix_insert(this: *mut charMatrix,
                             s: *const ::std::os::raw::c_char,
                             r: octave_idx_type, c: octave_idx_type)
     -> *mut charMatrix;
}
extern "C" {
    #[link_name = "?insert@charMatrix@@QEAAAEAV1@AEBV1@HH@Z"]
    pub fn charMatrix_insert1(this: *mut charMatrix, a: *const charMatrix,
                              r: octave_idx_type, c: octave_idx_type)
     -> *mut charMatrix;
}
extern "C" {
    #[link_name =
          "?row_as_string@charMatrix@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H_N@Z"]
    pub fn charMatrix_row_as_string(this: *const charMatrix,
                                    arg1: octave_idx_type, strip_ws: bool)
     -> std_string;
}
extern "C" {
    #[link_name = "?extract@charMatrix@@QEBA?AV1@HHHH@Z"]
    pub fn charMatrix_extract(this: *const charMatrix, r1: octave_idx_type,
                              c1: octave_idx_type, r2: octave_idx_type,
                              c2: octave_idx_type) -> charMatrix;
}
impl charMatrix {
    #[inline]
    pub unsafe fn insert(&mut self, s: *const ::std::os::raw::c_char,
                         r: octave_idx_type, c: octave_idx_type)
     -> *mut charMatrix {
        charMatrix_insert(self, s, r, c)
    }
    #[inline]
    pub unsafe fn insert1(&mut self, a: *const charMatrix, r: octave_idx_type,
                          c: octave_idx_type) -> *mut charMatrix {
        charMatrix_insert1(self, a, r, c)
    }
    #[inline]
    pub unsafe fn row_as_string(&self, arg1: octave_idx_type, strip_ws: bool)
     -> std_string {
        charMatrix_row_as_string(self, arg1, strip_ws)
    }
    #[inline]
    pub unsafe fn extract(&self, r1: octave_idx_type, c1: octave_idx_type,
                          r2: octave_idx_type, c2: octave_idx_type)
     -> charMatrix {
        charMatrix_extract(self, r1, c1, r2, c2)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct NDArray {
    pub _base: MArray<f64>,
}
#[test]
fn bindgen_test_layout_NDArray() {
    assert_eq!(::std::mem::size_of::<NDArray>() , 40usize , concat ! (
               "Size of: " , stringify ! ( NDArray ) ));
    assert_eq! (::std::mem::align_of::<NDArray>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( NDArray ) ));
}
extern "C" {
    #[link_name = "?any_element_is_negative@NDArray@@QEBA_N_N@Z"]
    pub fn NDArray_any_element_is_negative(this: *const NDArray, arg1: bool)
     -> bool;
}
extern "C" {
    #[link_name = "?any_element_is_positive@NDArray@@QEBA_N_N@Z"]
    pub fn NDArray_any_element_is_positive(this: *const NDArray, arg1: bool)
     -> bool;
}
extern "C" {
    #[link_name = "?any_element_is_nan@NDArray@@QEBA_NXZ"]
    pub fn NDArray_any_element_is_nan(this: *const NDArray) -> bool;
}
extern "C" {
    #[link_name = "?any_element_is_inf_or_nan@NDArray@@QEBA_NXZ"]
    pub fn NDArray_any_element_is_inf_or_nan(this: *const NDArray) -> bool;
}
extern "C" {
    #[link_name = "?any_element_not_one_or_zero@NDArray@@QEBA_NXZ"]
    pub fn NDArray_any_element_not_one_or_zero(this: *const NDArray) -> bool;
}
extern "C" {
    #[link_name = "?all_elements_are_zero@NDArray@@QEBA_NXZ"]
    pub fn NDArray_all_elements_are_zero(this: *const NDArray) -> bool;
}
extern "C" {
    #[link_name = "?all_elements_are_int_or_inf_or_nan@NDArray@@QEBA_NXZ"]
    pub fn NDArray_all_elements_are_int_or_inf_or_nan(this: *const NDArray)
     -> bool;
}
extern "C" {
    #[link_name = "?all_integers@NDArray@@QEBA_NAEAN0@Z"]
    pub fn NDArray_all_integers(this: *const NDArray, max_val: *mut f64,
                                min_val: *mut f64) -> bool;
}
extern "C" {
    #[link_name = "?all_integers@NDArray@@QEBA_NXZ"]
    pub fn NDArray_all_integers1(this: *const NDArray) -> bool;
}
extern "C" {
    #[link_name = "?too_large_for_float@NDArray@@QEBA_NXZ"]
    pub fn NDArray_too_large_for_float(this: *const NDArray) -> bool;
}
extern "C" {
    #[link_name = "?all@NDArray@@QEBA?AVboolNDArray@@H@Z"]
    pub fn NDArray_all(this: *const NDArray, dim: ::std::os::raw::c_int)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?any@NDArray@@QEBA?AVboolNDArray@@H@Z"]
    pub fn NDArray_any(this: *const NDArray, dim: ::std::os::raw::c_int)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?cumprod@NDArray@@QEBA?AV1@H@Z"]
    pub fn NDArray_cumprod(this: *const NDArray, dim: ::std::os::raw::c_int)
     -> NDArray;
}
extern "C" {
    #[link_name = "?cumsum@NDArray@@QEBA?AV1@H@Z"]
    pub fn NDArray_cumsum(this: *const NDArray, dim: ::std::os::raw::c_int)
     -> NDArray;
}
extern "C" {
    #[link_name = "?prod@NDArray@@QEBA?AV1@H@Z"]
    pub fn NDArray_prod(this: *const NDArray, dim: ::std::os::raw::c_int)
     -> NDArray;
}
extern "C" {
    #[link_name = "?sum@NDArray@@QEBA?AV1@H@Z"]
    pub fn NDArray_sum(this: *const NDArray, dim: ::std::os::raw::c_int)
     -> NDArray;
}
extern "C" {
    #[link_name = "?xsum@NDArray@@QEBA?AV1@H@Z"]
    pub fn NDArray_xsum(this: *const NDArray, dim: ::std::os::raw::c_int)
     -> NDArray;
}
extern "C" {
    #[link_name = "?sumsq@NDArray@@QEBA?AV1@H@Z"]
    pub fn NDArray_sumsq(this: *const NDArray, dim: ::std::os::raw::c_int)
     -> NDArray;
}
extern "C" {
    #[link_name = "?concat@NDArray@@QEAA?AV1@AEBV1@AEBV?$Array@H@@@Z"]
    pub fn NDArray_concat(this: *mut NDArray, rb: *const NDArray,
                          ra_idx: *const Array<::std::os::raw::c_int>)
     -> NDArray;
}
extern "C" {
    #[link_name =
          "?concat@NDArray@@QEAA?AVComplexNDArray@@AEBV2@AEBV?$Array@H@@@Z"]
    pub fn NDArray_concat1(this: *mut NDArray, rb: *const ComplexNDArray,
                           ra_idx: *const Array<::std::os::raw::c_int>)
     -> ComplexNDArray;
}
extern "C" {
    #[link_name =
          "?concat@NDArray@@QEAA?AVcharNDArray@@AEBV2@AEBV?$Array@H@@@Z"]
    pub fn NDArray_concat2(this: *mut NDArray, rb: *const charNDArray,
                           ra_idx: *const Array<::std::os::raw::c_int>)
     -> charNDArray;
}
extern "C" {
    #[link_name = "?max@NDArray@@QEBA?AV1@H@Z"]
    pub fn NDArray_max(this: *const NDArray, dim: ::std::os::raw::c_int)
     -> NDArray;
}
extern "C" {
    #[link_name = "?max@NDArray@@QEBA?AV1@AEAV?$Array@H@@H@Z"]
    pub fn NDArray_max1(this: *const NDArray,
                        index: *mut Array<::std::os::raw::c_int>,
                        dim: ::std::os::raw::c_int) -> NDArray;
}
extern "C" {
    #[link_name = "?min@NDArray@@QEBA?AV1@H@Z"]
    pub fn NDArray_min(this: *const NDArray, dim: ::std::os::raw::c_int)
     -> NDArray;
}
extern "C" {
    #[link_name = "?min@NDArray@@QEBA?AV1@AEAV?$Array@H@@H@Z"]
    pub fn NDArray_min1(this: *const NDArray,
                        index: *mut Array<::std::os::raw::c_int>,
                        dim: ::std::os::raw::c_int) -> NDArray;
}
extern "C" {
    #[link_name = "?cummax@NDArray@@QEBA?AV1@H@Z"]
    pub fn NDArray_cummax(this: *const NDArray, dim: ::std::os::raw::c_int)
     -> NDArray;
}
extern "C" {
    #[link_name = "?cummax@NDArray@@QEBA?AV1@AEAV?$Array@H@@H@Z"]
    pub fn NDArray_cummax1(this: *const NDArray,
                           index: *mut Array<::std::os::raw::c_int>,
                           dim: ::std::os::raw::c_int) -> NDArray;
}
extern "C" {
    #[link_name = "?cummin@NDArray@@QEBA?AV1@H@Z"]
    pub fn NDArray_cummin(this: *const NDArray, dim: ::std::os::raw::c_int)
     -> NDArray;
}
extern "C" {
    #[link_name = "?cummin@NDArray@@QEBA?AV1@AEAV?$Array@H@@H@Z"]
    pub fn NDArray_cummin1(this: *const NDArray,
                           index: *mut Array<::std::os::raw::c_int>,
                           dim: ::std::os::raw::c_int) -> NDArray;
}
extern "C" {
    #[link_name = "?diff@NDArray@@QEBA?AV1@HH@Z"]
    pub fn NDArray_diff(this: *const NDArray, order: octave_idx_type,
                        dim: ::std::os::raw::c_int) -> NDArray;
}
extern "C" {
    #[link_name = "?insert@NDArray@@QEAAAEAV1@AEBV1@HH@Z"]
    pub fn NDArray_insert(this: *mut NDArray, a: *const NDArray,
                          r: octave_idx_type, c: octave_idx_type)
     -> *mut NDArray;
}
extern "C" {
    #[link_name = "?insert@NDArray@@QEAAAEAV1@AEBV1@AEBV?$Array@H@@@Z"]
    pub fn NDArray_insert1(this: *mut NDArray, a: *const NDArray,
                           ra_idx: *const Array<::std::os::raw::c_int>)
     -> *mut NDArray;
}
extern "C" {
    #[link_name = "?abs@NDArray@@QEBA?AV1@XZ"]
    pub fn NDArray_abs(this: *const NDArray) -> NDArray;
}
extern "C" {
    #[link_name = "?isnan@NDArray@@QEBA?AVboolNDArray@@XZ"]
    pub fn NDArray_isnan(this: *const NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name = "?isinf@NDArray@@QEBA?AVboolNDArray@@XZ"]
    pub fn NDArray_isinf(this: *const NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name = "?isfinite@NDArray@@QEBA?AVboolNDArray@@XZ"]
    pub fn NDArray_isfinite(this: *const NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name = "?fourier@NDArray@@QEBA?AVComplexNDArray@@H@Z"]
    pub fn NDArray_fourier(this: *const NDArray, dim: ::std::os::raw::c_int)
     -> ComplexNDArray;
}
extern "C" {
    #[link_name = "?ifourier@NDArray@@QEBA?AVComplexNDArray@@H@Z"]
    pub fn NDArray_ifourier(this: *const NDArray, dim: ::std::os::raw::c_int)
     -> ComplexNDArray;
}
extern "C" {
    #[link_name = "?fourier2d@NDArray@@QEBA?AVComplexNDArray@@XZ"]
    pub fn NDArray_fourier2d(this: *const NDArray) -> ComplexNDArray;
}
extern "C" {
    #[link_name = "?ifourier2d@NDArray@@QEBA?AVComplexNDArray@@XZ"]
    pub fn NDArray_ifourier2d(this: *const NDArray) -> ComplexNDArray;
}
extern "C" {
    #[link_name = "?fourierNd@NDArray@@QEBA?AVComplexNDArray@@XZ"]
    pub fn NDArray_fourierNd(this: *const NDArray) -> ComplexNDArray;
}
extern "C" {
    #[link_name = "?ifourierNd@NDArray@@QEBA?AVComplexNDArray@@XZ"]
    pub fn NDArray_ifourierNd(this: *const NDArray) -> ComplexNDArray;
}
extern "C" {
    #[link_name =
          "?increment_index@NDArray@@SAXAEAV?$Array@H@@AEBVdim_vector@@H@Z"]
    pub fn NDArray_increment_index(ra_idx: *mut Array<::std::os::raw::c_int>,
                                   dimensions: *const dim_vector,
                                   start_dimension: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name =
          "?compute_index@NDArray@@SAHAEAV?$Array@H@@AEBVdim_vector@@@Z"]
    pub fn NDArray_compute_index(ra_idx: *mut Array<::std::os::raw::c_int>,
                                 dimensions: *const dim_vector)
     -> octave_idx_type;
}
extern "C" {
    #[link_name = "?diag@NDArray@@QEBA?AV1@H@Z"]
    pub fn NDArray_diag(this: *const NDArray, k: octave_idx_type) -> NDArray;
}
extern "C" {
    #[link_name = "?diag@NDArray@@QEBA?AV1@HH@Z"]
    pub fn NDArray_diag1(this: *const NDArray, m: octave_idx_type,
                         n: octave_idx_type) -> NDArray;
}
extern "C" {
    #[link_name = "??0NDArray@@QEAA@AEBV?$Array@H@@_N1@Z"]
    pub fn NDArray_NDArray(this: *mut NDArray,
                           a: *const Array<::std::os::raw::c_int>,
                           zero_based: bool, negative_to_nan: bool);
}
extern "C" {
    #[link_name = "??0NDArray@@QEAA@AEBVcharNDArray@@@Z"]
    pub fn NDArray_NDArray1(this: *mut NDArray, arg1: *const charNDArray);
}
impl NDArray {
    #[inline]
    pub unsafe fn any_element_is_negative(&self, arg1: bool) -> bool {
        NDArray_any_element_is_negative(self, arg1)
    }
    #[inline]
    pub unsafe fn any_element_is_positive(&self, arg1: bool) -> bool {
        NDArray_any_element_is_positive(self, arg1)
    }
    #[inline]
    pub unsafe fn any_element_is_nan(&self) -> bool {
        NDArray_any_element_is_nan(self)
    }
    #[inline]
    pub unsafe fn any_element_is_inf_or_nan(&self) -> bool {
        NDArray_any_element_is_inf_or_nan(self)
    }
    #[inline]
    pub unsafe fn any_element_not_one_or_zero(&self) -> bool {
        NDArray_any_element_not_one_or_zero(self)
    }
    #[inline]
    pub unsafe fn all_elements_are_zero(&self) -> bool {
        NDArray_all_elements_are_zero(self)
    }
    #[inline]
    pub unsafe fn all_elements_are_int_or_inf_or_nan(&self) -> bool {
        NDArray_all_elements_are_int_or_inf_or_nan(self)
    }
    #[inline]
    pub unsafe fn all_integers(&self, max_val: *mut f64, min_val: *mut f64)
     -> bool {
        NDArray_all_integers(self, max_val, min_val)
    }
    #[inline]
    pub unsafe fn all_integers1(&self) -> bool { NDArray_all_integers1(self) }
    #[inline]
    pub unsafe fn too_large_for_float(&self) -> bool {
        NDArray_too_large_for_float(self)
    }
    #[inline]
    pub unsafe fn all(&self, dim: ::std::os::raw::c_int) -> boolNDArray {
        NDArray_all(self, dim)
    }
    #[inline]
    pub unsafe fn any(&self, dim: ::std::os::raw::c_int) -> boolNDArray {
        NDArray_any(self, dim)
    }
    #[inline]
    pub unsafe fn cumprod(&self, dim: ::std::os::raw::c_int) -> NDArray {
        NDArray_cumprod(self, dim)
    }
    #[inline]
    pub unsafe fn cumsum(&self, dim: ::std::os::raw::c_int) -> NDArray {
        NDArray_cumsum(self, dim)
    }
    #[inline]
    pub unsafe fn prod(&self, dim: ::std::os::raw::c_int) -> NDArray {
        NDArray_prod(self, dim)
    }
    #[inline]
    pub unsafe fn sum(&self, dim: ::std::os::raw::c_int) -> NDArray {
        NDArray_sum(self, dim)
    }
    #[inline]
    pub unsafe fn xsum(&self, dim: ::std::os::raw::c_int) -> NDArray {
        NDArray_xsum(self, dim)
    }
    #[inline]
    pub unsafe fn sumsq(&self, dim: ::std::os::raw::c_int) -> NDArray {
        NDArray_sumsq(self, dim)
    }
    #[inline]
    pub unsafe fn concat(&mut self, rb: *const NDArray,
                         ra_idx: *const Array<::std::os::raw::c_int>)
     -> NDArray {
        NDArray_concat(self, rb, ra_idx)
    }
    #[inline]
    pub unsafe fn concat1(&mut self, rb: *const ComplexNDArray,
                          ra_idx: *const Array<::std::os::raw::c_int>)
     -> ComplexNDArray {
        NDArray_concat1(self, rb, ra_idx)
    }
    #[inline]
    pub unsafe fn concat2(&mut self, rb: *const charNDArray,
                          ra_idx: *const Array<::std::os::raw::c_int>)
     -> charNDArray {
        NDArray_concat2(self, rb, ra_idx)
    }
    #[inline]
    pub unsafe fn max(&self, dim: ::std::os::raw::c_int) -> NDArray {
        NDArray_max(self, dim)
    }
    #[inline]
    pub unsafe fn max1(&self, index: *mut Array<::std::os::raw::c_int>,
                       dim: ::std::os::raw::c_int) -> NDArray {
        NDArray_max1(self, index, dim)
    }
    #[inline]
    pub unsafe fn min(&self, dim: ::std::os::raw::c_int) -> NDArray {
        NDArray_min(self, dim)
    }
    #[inline]
    pub unsafe fn min1(&self, index: *mut Array<::std::os::raw::c_int>,
                       dim: ::std::os::raw::c_int) -> NDArray {
        NDArray_min1(self, index, dim)
    }
    #[inline]
    pub unsafe fn cummax(&self, dim: ::std::os::raw::c_int) -> NDArray {
        NDArray_cummax(self, dim)
    }
    #[inline]
    pub unsafe fn cummax1(&self, index: *mut Array<::std::os::raw::c_int>,
                          dim: ::std::os::raw::c_int) -> NDArray {
        NDArray_cummax1(self, index, dim)
    }
    #[inline]
    pub unsafe fn cummin(&self, dim: ::std::os::raw::c_int) -> NDArray {
        NDArray_cummin(self, dim)
    }
    #[inline]
    pub unsafe fn cummin1(&self, index: *mut Array<::std::os::raw::c_int>,
                          dim: ::std::os::raw::c_int) -> NDArray {
        NDArray_cummin1(self, index, dim)
    }
    #[inline]
    pub unsafe fn diff(&self, order: octave_idx_type,
                       dim: ::std::os::raw::c_int) -> NDArray {
        NDArray_diff(self, order, dim)
    }
    #[inline]
    pub unsafe fn insert(&mut self, a: *const NDArray, r: octave_idx_type,
                         c: octave_idx_type) -> *mut NDArray {
        NDArray_insert(self, a, r, c)
    }
    #[inline]
    pub unsafe fn insert1(&mut self, a: *const NDArray,
                          ra_idx: *const Array<::std::os::raw::c_int>)
     -> *mut NDArray {
        NDArray_insert1(self, a, ra_idx)
    }
    #[inline]
    pub unsafe fn abs(&self) -> NDArray { NDArray_abs(self) }
    #[inline]
    pub unsafe fn isnan(&self) -> boolNDArray { NDArray_isnan(self) }
    #[inline]
    pub unsafe fn isinf(&self) -> boolNDArray { NDArray_isinf(self) }
    #[inline]
    pub unsafe fn isfinite(&self) -> boolNDArray { NDArray_isfinite(self) }
    #[inline]
    pub unsafe fn fourier(&self, dim: ::std::os::raw::c_int)
     -> ComplexNDArray {
        NDArray_fourier(self, dim)
    }
    #[inline]
    pub unsafe fn ifourier(&self, dim: ::std::os::raw::c_int)
     -> ComplexNDArray {
        NDArray_ifourier(self, dim)
    }
    #[inline]
    pub unsafe fn fourier2d(&self) -> ComplexNDArray {
        NDArray_fourier2d(self)
    }
    #[inline]
    pub unsafe fn ifourier2d(&self) -> ComplexNDArray {
        NDArray_ifourier2d(self)
    }
    #[inline]
    pub unsafe fn fourierNd(&self) -> ComplexNDArray {
        NDArray_fourierNd(self)
    }
    #[inline]
    pub unsafe fn ifourierNd(&self) -> ComplexNDArray {
        NDArray_ifourierNd(self)
    }
    #[inline]
    pub unsafe fn increment_index(ra_idx: *mut Array<::std::os::raw::c_int>,
                                  dimensions: *const dim_vector,
                                  start_dimension: ::std::os::raw::c_int) {
        NDArray_increment_index(ra_idx, dimensions, start_dimension)
    }
    #[inline]
    pub unsafe fn compute_index(ra_idx: *mut Array<::std::os::raw::c_int>,
                                dimensions: *const dim_vector)
     -> octave_idx_type {
        NDArray_compute_index(ra_idx, dimensions)
    }
    #[inline]
    pub unsafe fn diag(&self, k: octave_idx_type) -> NDArray {
        NDArray_diag(self, k)
    }
    #[inline]
    pub unsafe fn diag1(&self, m: octave_idx_type, n: octave_idx_type)
     -> NDArray {
        NDArray_diag1(self, m, n)
    }
    #[inline]
    pub unsafe fn new(a: *const Array<::std::os::raw::c_int>,
                      zero_based: bool, negative_to_nan: bool) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        NDArray_NDArray(&mut __bindgen_tmp, a, zero_based, negative_to_nan);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(arg1: *const charNDArray) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        NDArray_NDArray1(&mut __bindgen_tmp, arg1);
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct ComplexNDArray {
    pub _base: MArray<std_complex<f64>>,
}
#[test]
fn bindgen_test_layout_ComplexNDArray() {
    assert_eq!(::std::mem::size_of::<ComplexNDArray>() , 40usize , concat ! (
               "Size of: " , stringify ! ( ComplexNDArray ) ));
    assert_eq! (::std::mem::align_of::<ComplexNDArray>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ComplexNDArray ) ));
}
extern "C" {
    #[link_name = "?any_element_is_nan@ComplexNDArray@@QEBA_NXZ"]
    pub fn ComplexNDArray_any_element_is_nan(this: *const ComplexNDArray)
     -> bool;
}
extern "C" {
    #[link_name = "?any_element_is_inf_or_nan@ComplexNDArray@@QEBA_NXZ"]
    pub fn ComplexNDArray_any_element_is_inf_or_nan(this:
                                                        *const ComplexNDArray)
     -> bool;
}
extern "C" {
    #[link_name = "?all_elements_are_real@ComplexNDArray@@QEBA_NXZ"]
    pub fn ComplexNDArray_all_elements_are_real(this: *const ComplexNDArray)
     -> bool;
}
extern "C" {
    #[link_name = "?all_integers@ComplexNDArray@@QEBA_NAEAN0@Z"]
    pub fn ComplexNDArray_all_integers(this: *const ComplexNDArray,
                                       max_val: *mut f64, min_val: *mut f64)
     -> bool;
}
extern "C" {
    #[link_name = "?too_large_for_float@ComplexNDArray@@QEBA_NXZ"]
    pub fn ComplexNDArray_too_large_for_float(this: *const ComplexNDArray)
     -> bool;
}
extern "C" {
    #[link_name = "?all@ComplexNDArray@@QEBA?AVboolNDArray@@H@Z"]
    pub fn ComplexNDArray_all(this: *const ComplexNDArray,
                              dim: ::std::os::raw::c_int) -> boolNDArray;
}
extern "C" {
    #[link_name = "?any@ComplexNDArray@@QEBA?AVboolNDArray@@H@Z"]
    pub fn ComplexNDArray_any(this: *const ComplexNDArray,
                              dim: ::std::os::raw::c_int) -> boolNDArray;
}
extern "C" {
    #[link_name = "?cumprod@ComplexNDArray@@QEBA?AV1@H@Z"]
    pub fn ComplexNDArray_cumprod(this: *const ComplexNDArray,
                                  dim: ::std::os::raw::c_int)
     -> ComplexNDArray;
}
extern "C" {
    #[link_name = "?cumsum@ComplexNDArray@@QEBA?AV1@H@Z"]
    pub fn ComplexNDArray_cumsum(this: *const ComplexNDArray,
                                 dim: ::std::os::raw::c_int)
     -> ComplexNDArray;
}
extern "C" {
    #[link_name = "?prod@ComplexNDArray@@QEBA?AV1@H@Z"]
    pub fn ComplexNDArray_prod(this: *const ComplexNDArray,
                               dim: ::std::os::raw::c_int) -> ComplexNDArray;
}
extern "C" {
    #[link_name = "?sum@ComplexNDArray@@QEBA?AV1@H@Z"]
    pub fn ComplexNDArray_sum(this: *const ComplexNDArray,
                              dim: ::std::os::raw::c_int) -> ComplexNDArray;
}
extern "C" {
    #[link_name = "?xsum@ComplexNDArray@@QEBA?AV1@H@Z"]
    pub fn ComplexNDArray_xsum(this: *const ComplexNDArray,
                               dim: ::std::os::raw::c_int) -> ComplexNDArray;
}
extern "C" {
    #[link_name = "?sumsq@ComplexNDArray@@QEBA?AV1@H@Z"]
    pub fn ComplexNDArray_sumsq(this: *const ComplexNDArray,
                                dim: ::std::os::raw::c_int) -> ComplexNDArray;
}
extern "C" {
    #[link_name = "?concat@ComplexNDArray@@QEAA?AV1@AEBV1@AEBV?$Array@H@@@Z"]
    pub fn ComplexNDArray_concat(this: *mut ComplexNDArray,
                                 rb: *const ComplexNDArray,
                                 ra_idx: *const Array<::std::os::raw::c_int>)
     -> ComplexNDArray;
}
extern "C" {
    #[link_name =
          "?concat@ComplexNDArray@@QEAA?AV1@AEBVNDArray@@AEBV?$Array@H@@@Z"]
    pub fn ComplexNDArray_concat1(this: *mut ComplexNDArray,
                                  rb: *const NDArray,
                                  ra_idx: *const Array<::std::os::raw::c_int>)
     -> ComplexNDArray;
}
extern "C" {
    #[link_name = "?max@ComplexNDArray@@QEBA?AV1@H@Z"]
    pub fn ComplexNDArray_max(this: *const ComplexNDArray,
                              dim: ::std::os::raw::c_int) -> ComplexNDArray;
}
extern "C" {
    #[link_name = "?max@ComplexNDArray@@QEBA?AV1@AEAV?$Array@H@@H@Z"]
    pub fn ComplexNDArray_max1(this: *const ComplexNDArray,
                               index: *mut Array<::std::os::raw::c_int>,
                               dim: ::std::os::raw::c_int) -> ComplexNDArray;
}
extern "C" {
    #[link_name = "?min@ComplexNDArray@@QEBA?AV1@H@Z"]
    pub fn ComplexNDArray_min(this: *const ComplexNDArray,
                              dim: ::std::os::raw::c_int) -> ComplexNDArray;
}
extern "C" {
    #[link_name = "?min@ComplexNDArray@@QEBA?AV1@AEAV?$Array@H@@H@Z"]
    pub fn ComplexNDArray_min1(this: *const ComplexNDArray,
                               index: *mut Array<::std::os::raw::c_int>,
                               dim: ::std::os::raw::c_int) -> ComplexNDArray;
}
extern "C" {
    #[link_name = "?cummax@ComplexNDArray@@QEBA?AV1@H@Z"]
    pub fn ComplexNDArray_cummax(this: *const ComplexNDArray,
                                 dim: ::std::os::raw::c_int)
     -> ComplexNDArray;
}
extern "C" {
    #[link_name = "?cummax@ComplexNDArray@@QEBA?AV1@AEAV?$Array@H@@H@Z"]
    pub fn ComplexNDArray_cummax1(this: *const ComplexNDArray,
                                  index: *mut Array<::std::os::raw::c_int>,
                                  dim: ::std::os::raw::c_int)
     -> ComplexNDArray;
}
extern "C" {
    #[link_name = "?cummin@ComplexNDArray@@QEBA?AV1@H@Z"]
    pub fn ComplexNDArray_cummin(this: *const ComplexNDArray,
                                 dim: ::std::os::raw::c_int)
     -> ComplexNDArray;
}
extern "C" {
    #[link_name = "?cummin@ComplexNDArray@@QEBA?AV1@AEAV?$Array@H@@H@Z"]
    pub fn ComplexNDArray_cummin1(this: *const ComplexNDArray,
                                  index: *mut Array<::std::os::raw::c_int>,
                                  dim: ::std::os::raw::c_int)
     -> ComplexNDArray;
}
extern "C" {
    #[link_name = "?diff@ComplexNDArray@@QEBA?AV1@HH@Z"]
    pub fn ComplexNDArray_diff(this: *const ComplexNDArray,
                               order: octave_idx_type,
                               dim: ::std::os::raw::c_int) -> ComplexNDArray;
}
extern "C" {
    #[link_name = "?insert@ComplexNDArray@@QEAAAEAV1@AEBVNDArray@@HH@Z"]
    pub fn ComplexNDArray_insert(this: *mut ComplexNDArray, a: *const NDArray,
                                 r: octave_idx_type, c: octave_idx_type)
     -> *mut ComplexNDArray;
}
extern "C" {
    #[link_name = "?insert@ComplexNDArray@@QEAAAEAV1@AEBV1@HH@Z"]
    pub fn ComplexNDArray_insert1(this: *mut ComplexNDArray,
                                  a: *const ComplexNDArray,
                                  r: octave_idx_type, c: octave_idx_type)
     -> *mut ComplexNDArray;
}
extern "C" {
    #[link_name = "?insert@ComplexNDArray@@QEAAAEAV1@AEBV1@AEBV?$Array@H@@@Z"]
    pub fn ComplexNDArray_insert2(this: *mut ComplexNDArray,
                                  a: *const ComplexNDArray,
                                  ra_idx: *const Array<::std::os::raw::c_int>)
     -> *mut ComplexNDArray;
}
extern "C" {
    #[link_name = "?abs@ComplexNDArray@@QEBA?AVNDArray@@XZ"]
    pub fn ComplexNDArray_abs(this: *const ComplexNDArray) -> NDArray;
}
extern "C" {
    #[link_name = "?isnan@ComplexNDArray@@QEBA?AVboolNDArray@@XZ"]
    pub fn ComplexNDArray_isnan(this: *const ComplexNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name = "?isinf@ComplexNDArray@@QEBA?AVboolNDArray@@XZ"]
    pub fn ComplexNDArray_isinf(this: *const ComplexNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name = "?isfinite@ComplexNDArray@@QEBA?AVboolNDArray@@XZ"]
    pub fn ComplexNDArray_isfinite(this: *const ComplexNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?fourier@ComplexNDArray@@QEBA?AV1@H@Z"]
    pub fn ComplexNDArray_fourier(this: *const ComplexNDArray,
                                  dim: ::std::os::raw::c_int)
     -> ComplexNDArray;
}
extern "C" {
    #[link_name = "?ifourier@ComplexNDArray@@QEBA?AV1@H@Z"]
    pub fn ComplexNDArray_ifourier(this: *const ComplexNDArray,
                                   dim: ::std::os::raw::c_int)
     -> ComplexNDArray;
}
extern "C" {
    #[link_name = "?fourier2d@ComplexNDArray@@QEBA?AV1@XZ"]
    pub fn ComplexNDArray_fourier2d(this: *const ComplexNDArray)
     -> ComplexNDArray;
}
extern "C" {
    #[link_name = "?ifourier2d@ComplexNDArray@@QEBA?AV1@XZ"]
    pub fn ComplexNDArray_ifourier2d(this: *const ComplexNDArray)
     -> ComplexNDArray;
}
extern "C" {
    #[link_name = "?fourierNd@ComplexNDArray@@QEBA?AV1@XZ"]
    pub fn ComplexNDArray_fourierNd(this: *const ComplexNDArray)
     -> ComplexNDArray;
}
extern "C" {
    #[link_name = "?ifourierNd@ComplexNDArray@@QEBA?AV1@XZ"]
    pub fn ComplexNDArray_ifourierNd(this: *const ComplexNDArray)
     -> ComplexNDArray;
}
extern "C" {
    #[link_name =
          "?increment_index@ComplexNDArray@@SAXAEAV?$Array@H@@AEBVdim_vector@@H@Z"]
    pub fn ComplexNDArray_increment_index(ra_idx:
                                              *mut Array<::std::os::raw::c_int>,
                                          dimensions: *const dim_vector,
                                          start_dimension:
                                              ::std::os::raw::c_int);
}
extern "C" {
    #[link_name =
          "?compute_index@ComplexNDArray@@SAHAEAV?$Array@H@@AEBVdim_vector@@@Z"]
    pub fn ComplexNDArray_compute_index(ra_idx:
                                            *mut Array<::std::os::raw::c_int>,
                                        dimensions: *const dim_vector)
     -> octave_idx_type;
}
extern "C" {
    #[link_name = "?diag@ComplexNDArray@@QEBA?AV1@H@Z"]
    pub fn ComplexNDArray_diag(this: *const ComplexNDArray,
                               k: octave_idx_type) -> ComplexNDArray;
}
extern "C" {
    #[link_name = "?diag@ComplexNDArray@@QEBA?AV1@HH@Z"]
    pub fn ComplexNDArray_diag1(this: *const ComplexNDArray,
                                m: octave_idx_type, n: octave_idx_type)
     -> ComplexNDArray;
}
extern "C" {
    #[link_name = "??0ComplexNDArray@@QEAA@AEBVcharNDArray@@@Z"]
    pub fn ComplexNDArray_ComplexNDArray(this: *mut ComplexNDArray,
                                         arg1: *const charNDArray);
}
impl ComplexNDArray {
    #[inline]
    pub unsafe fn any_element_is_nan(&self) -> bool {
        ComplexNDArray_any_element_is_nan(self)
    }
    #[inline]
    pub unsafe fn any_element_is_inf_or_nan(&self) -> bool {
        ComplexNDArray_any_element_is_inf_or_nan(self)
    }
    #[inline]
    pub unsafe fn all_elements_are_real(&self) -> bool {
        ComplexNDArray_all_elements_are_real(self)
    }
    #[inline]
    pub unsafe fn all_integers(&self, max_val: *mut f64, min_val: *mut f64)
     -> bool {
        ComplexNDArray_all_integers(self, max_val, min_val)
    }
    #[inline]
    pub unsafe fn too_large_for_float(&self) -> bool {
        ComplexNDArray_too_large_for_float(self)
    }
    #[inline]
    pub unsafe fn all(&self, dim: ::std::os::raw::c_int) -> boolNDArray {
        ComplexNDArray_all(self, dim)
    }
    #[inline]
    pub unsafe fn any(&self, dim: ::std::os::raw::c_int) -> boolNDArray {
        ComplexNDArray_any(self, dim)
    }
    #[inline]
    pub unsafe fn cumprod(&self, dim: ::std::os::raw::c_int)
     -> ComplexNDArray {
        ComplexNDArray_cumprod(self, dim)
    }
    #[inline]
    pub unsafe fn cumsum(&self, dim: ::std::os::raw::c_int)
     -> ComplexNDArray {
        ComplexNDArray_cumsum(self, dim)
    }
    #[inline]
    pub unsafe fn prod(&self, dim: ::std::os::raw::c_int) -> ComplexNDArray {
        ComplexNDArray_prod(self, dim)
    }
    #[inline]
    pub unsafe fn sum(&self, dim: ::std::os::raw::c_int) -> ComplexNDArray {
        ComplexNDArray_sum(self, dim)
    }
    #[inline]
    pub unsafe fn xsum(&self, dim: ::std::os::raw::c_int) -> ComplexNDArray {
        ComplexNDArray_xsum(self, dim)
    }
    #[inline]
    pub unsafe fn sumsq(&self, dim: ::std::os::raw::c_int) -> ComplexNDArray {
        ComplexNDArray_sumsq(self, dim)
    }
    #[inline]
    pub unsafe fn concat(&mut self, rb: *const ComplexNDArray,
                         ra_idx: *const Array<::std::os::raw::c_int>)
     -> ComplexNDArray {
        ComplexNDArray_concat(self, rb, ra_idx)
    }
    #[inline]
    pub unsafe fn concat1(&mut self, rb: *const NDArray,
                          ra_idx: *const Array<::std::os::raw::c_int>)
     -> ComplexNDArray {
        ComplexNDArray_concat1(self, rb, ra_idx)
    }
    #[inline]
    pub unsafe fn max(&self, dim: ::std::os::raw::c_int) -> ComplexNDArray {
        ComplexNDArray_max(self, dim)
    }
    #[inline]
    pub unsafe fn max1(&self, index: *mut Array<::std::os::raw::c_int>,
                       dim: ::std::os::raw::c_int) -> ComplexNDArray {
        ComplexNDArray_max1(self, index, dim)
    }
    #[inline]
    pub unsafe fn min(&self, dim: ::std::os::raw::c_int) -> ComplexNDArray {
        ComplexNDArray_min(self, dim)
    }
    #[inline]
    pub unsafe fn min1(&self, index: *mut Array<::std::os::raw::c_int>,
                       dim: ::std::os::raw::c_int) -> ComplexNDArray {
        ComplexNDArray_min1(self, index, dim)
    }
    #[inline]
    pub unsafe fn cummax(&self, dim: ::std::os::raw::c_int)
     -> ComplexNDArray {
        ComplexNDArray_cummax(self, dim)
    }
    #[inline]
    pub unsafe fn cummax1(&self, index: *mut Array<::std::os::raw::c_int>,
                          dim: ::std::os::raw::c_int) -> ComplexNDArray {
        ComplexNDArray_cummax1(self, index, dim)
    }
    #[inline]
    pub unsafe fn cummin(&self, dim: ::std::os::raw::c_int)
     -> ComplexNDArray {
        ComplexNDArray_cummin(self, dim)
    }
    #[inline]
    pub unsafe fn cummin1(&self, index: *mut Array<::std::os::raw::c_int>,
                          dim: ::std::os::raw::c_int) -> ComplexNDArray {
        ComplexNDArray_cummin1(self, index, dim)
    }
    #[inline]
    pub unsafe fn diff(&self, order: octave_idx_type,
                       dim: ::std::os::raw::c_int) -> ComplexNDArray {
        ComplexNDArray_diff(self, order, dim)
    }
    #[inline]
    pub unsafe fn insert(&mut self, a: *const NDArray, r: octave_idx_type,
                         c: octave_idx_type) -> *mut ComplexNDArray {
        ComplexNDArray_insert(self, a, r, c)
    }
    #[inline]
    pub unsafe fn insert1(&mut self, a: *const ComplexNDArray,
                          r: octave_idx_type, c: octave_idx_type)
     -> *mut ComplexNDArray {
        ComplexNDArray_insert1(self, a, r, c)
    }
    #[inline]
    pub unsafe fn insert2(&mut self, a: *const ComplexNDArray,
                          ra_idx: *const Array<::std::os::raw::c_int>)
     -> *mut ComplexNDArray {
        ComplexNDArray_insert2(self, a, ra_idx)
    }
    #[inline]
    pub unsafe fn abs(&self) -> NDArray { ComplexNDArray_abs(self) }
    #[inline]
    pub unsafe fn isnan(&self) -> boolNDArray { ComplexNDArray_isnan(self) }
    #[inline]
    pub unsafe fn isinf(&self) -> boolNDArray { ComplexNDArray_isinf(self) }
    #[inline]
    pub unsafe fn isfinite(&self) -> boolNDArray {
        ComplexNDArray_isfinite(self)
    }
    #[inline]
    pub unsafe fn fourier(&self, dim: ::std::os::raw::c_int)
     -> ComplexNDArray {
        ComplexNDArray_fourier(self, dim)
    }
    #[inline]
    pub unsafe fn ifourier(&self, dim: ::std::os::raw::c_int)
     -> ComplexNDArray {
        ComplexNDArray_ifourier(self, dim)
    }
    #[inline]
    pub unsafe fn fourier2d(&self) -> ComplexNDArray {
        ComplexNDArray_fourier2d(self)
    }
    #[inline]
    pub unsafe fn ifourier2d(&self) -> ComplexNDArray {
        ComplexNDArray_ifourier2d(self)
    }
    #[inline]
    pub unsafe fn fourierNd(&self) -> ComplexNDArray {
        ComplexNDArray_fourierNd(self)
    }
    #[inline]
    pub unsafe fn ifourierNd(&self) -> ComplexNDArray {
        ComplexNDArray_ifourierNd(self)
    }
    #[inline]
    pub unsafe fn increment_index(ra_idx: *mut Array<::std::os::raw::c_int>,
                                  dimensions: *const dim_vector,
                                  start_dimension: ::std::os::raw::c_int) {
        ComplexNDArray_increment_index(ra_idx, dimensions, start_dimension)
    }
    #[inline]
    pub unsafe fn compute_index(ra_idx: *mut Array<::std::os::raw::c_int>,
                                dimensions: *const dim_vector)
     -> octave_idx_type {
        ComplexNDArray_compute_index(ra_idx, dimensions)
    }
    #[inline]
    pub unsafe fn diag(&self, k: octave_idx_type) -> ComplexNDArray {
        ComplexNDArray_diag(self, k)
    }
    #[inline]
    pub unsafe fn diag1(&self, m: octave_idx_type, n: octave_idx_type)
     -> ComplexNDArray {
        ComplexNDArray_diag1(self, m, n)
    }
    #[inline]
    pub unsafe fn new(arg1: *const charNDArray) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        ComplexNDArray_ComplexNDArray(&mut __bindgen_tmp, arg1);
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct FloatNDArray {
    pub _base: MArray<f32>,
}
#[test]
fn bindgen_test_layout_FloatNDArray() {
    assert_eq!(::std::mem::size_of::<FloatNDArray>() , 40usize , concat ! (
               "Size of: " , stringify ! ( FloatNDArray ) ));
    assert_eq! (::std::mem::align_of::<FloatNDArray>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( FloatNDArray ) ));
}
extern "C" {
    #[link_name = "?any_element_is_negative@FloatNDArray@@QEBA_N_N@Z"]
    pub fn FloatNDArray_any_element_is_negative(this: *const FloatNDArray,
                                                arg1: bool) -> bool;
}
extern "C" {
    #[link_name = "?any_element_is_positive@FloatNDArray@@QEBA_N_N@Z"]
    pub fn FloatNDArray_any_element_is_positive(this: *const FloatNDArray,
                                                arg1: bool) -> bool;
}
extern "C" {
    #[link_name = "?any_element_is_nan@FloatNDArray@@QEBA_NXZ"]
    pub fn FloatNDArray_any_element_is_nan(this: *const FloatNDArray) -> bool;
}
extern "C" {
    #[link_name = "?any_element_is_inf_or_nan@FloatNDArray@@QEBA_NXZ"]
    pub fn FloatNDArray_any_element_is_inf_or_nan(this: *const FloatNDArray)
     -> bool;
}
extern "C" {
    #[link_name = "?any_element_not_one_or_zero@FloatNDArray@@QEBA_NXZ"]
    pub fn FloatNDArray_any_element_not_one_or_zero(this: *const FloatNDArray)
     -> bool;
}
extern "C" {
    #[link_name = "?all_elements_are_zero@FloatNDArray@@QEBA_NXZ"]
    pub fn FloatNDArray_all_elements_are_zero(this: *const FloatNDArray)
     -> bool;
}
extern "C" {
    #[link_name =
          "?all_elements_are_int_or_inf_or_nan@FloatNDArray@@QEBA_NXZ"]
    pub fn FloatNDArray_all_elements_are_int_or_inf_or_nan(this:
                                                               *const FloatNDArray)
     -> bool;
}
extern "C" {
    #[link_name = "?all_integers@FloatNDArray@@QEBA_NAEAM0@Z"]
    pub fn FloatNDArray_all_integers(this: *const FloatNDArray,
                                     max_val: *mut f32, min_val: *mut f32)
     -> bool;
}
extern "C" {
    #[link_name = "?all_integers@FloatNDArray@@QEBA_NXZ"]
    pub fn FloatNDArray_all_integers1(this: *const FloatNDArray) -> bool;
}
extern "C" {
    #[link_name = "?too_large_for_float@FloatNDArray@@QEBA_NXZ"]
    pub fn FloatNDArray_too_large_for_float(this: *const FloatNDArray)
     -> bool;
}
extern "C" {
    #[link_name = "?all@FloatNDArray@@QEBA?AVboolNDArray@@H@Z"]
    pub fn FloatNDArray_all(this: *const FloatNDArray,
                            dim: ::std::os::raw::c_int) -> boolNDArray;
}
extern "C" {
    #[link_name = "?any@FloatNDArray@@QEBA?AVboolNDArray@@H@Z"]
    pub fn FloatNDArray_any(this: *const FloatNDArray,
                            dim: ::std::os::raw::c_int) -> boolNDArray;
}
extern "C" {
    #[link_name = "?cumprod@FloatNDArray@@QEBA?AV1@H@Z"]
    pub fn FloatNDArray_cumprod(this: *const FloatNDArray,
                                dim: ::std::os::raw::c_int) -> FloatNDArray;
}
extern "C" {
    #[link_name = "?cumsum@FloatNDArray@@QEBA?AV1@H@Z"]
    pub fn FloatNDArray_cumsum(this: *const FloatNDArray,
                               dim: ::std::os::raw::c_int) -> FloatNDArray;
}
extern "C" {
    #[link_name = "?prod@FloatNDArray@@QEBA?AV1@H@Z"]
    pub fn FloatNDArray_prod(this: *const FloatNDArray,
                             dim: ::std::os::raw::c_int) -> FloatNDArray;
}
extern "C" {
    #[link_name = "?dprod@FloatNDArray@@QEBA?AVNDArray@@H@Z"]
    pub fn FloatNDArray_dprod(this: *const FloatNDArray,
                              dim: ::std::os::raw::c_int) -> NDArray;
}
extern "C" {
    #[link_name = "?sum@FloatNDArray@@QEBA?AV1@H@Z"]
    pub fn FloatNDArray_sum(this: *const FloatNDArray,
                            dim: ::std::os::raw::c_int) -> FloatNDArray;
}
extern "C" {
    #[link_name = "?dsum@FloatNDArray@@QEBA?AVNDArray@@H@Z"]
    pub fn FloatNDArray_dsum(this: *const FloatNDArray,
                             dim: ::std::os::raw::c_int) -> NDArray;
}
extern "C" {
    #[link_name = "?sumsq@FloatNDArray@@QEBA?AV1@H@Z"]
    pub fn FloatNDArray_sumsq(this: *const FloatNDArray,
                              dim: ::std::os::raw::c_int) -> FloatNDArray;
}
extern "C" {
    #[link_name = "?concat@FloatNDArray@@QEAA?AV1@AEBV1@AEBV?$Array@H@@@Z"]
    pub fn FloatNDArray_concat(this: *mut FloatNDArray,
                               rb: *const FloatNDArray,
                               ra_idx: *const Array<::std::os::raw::c_int>)
     -> FloatNDArray;
}
extern "C" {
    #[link_name =
          "?concat@FloatNDArray@@QEAA?AVFloatComplexNDArray@@AEBV2@AEBV?$Array@H@@@Z"]
    pub fn FloatNDArray_concat1(this: *mut FloatNDArray,
                                rb: *const FloatComplexNDArray,
                                ra_idx: *const Array<::std::os::raw::c_int>)
     -> FloatComplexNDArray;
}
extern "C" {
    #[link_name =
          "?concat@FloatNDArray@@QEAA?AVcharNDArray@@AEBV2@AEBV?$Array@H@@@Z"]
    pub fn FloatNDArray_concat2(this: *mut FloatNDArray,
                                rb: *const charNDArray,
                                ra_idx: *const Array<::std::os::raw::c_int>)
     -> charNDArray;
}
extern "C" {
    #[link_name = "?max@FloatNDArray@@QEBA?AV1@H@Z"]
    pub fn FloatNDArray_max(this: *const FloatNDArray,
                            dim: ::std::os::raw::c_int) -> FloatNDArray;
}
extern "C" {
    #[link_name = "?max@FloatNDArray@@QEBA?AV1@AEAV?$Array@H@@H@Z"]
    pub fn FloatNDArray_max1(this: *const FloatNDArray,
                             index: *mut Array<::std::os::raw::c_int>,
                             dim: ::std::os::raw::c_int) -> FloatNDArray;
}
extern "C" {
    #[link_name = "?min@FloatNDArray@@QEBA?AV1@H@Z"]
    pub fn FloatNDArray_min(this: *const FloatNDArray,
                            dim: ::std::os::raw::c_int) -> FloatNDArray;
}
extern "C" {
    #[link_name = "?min@FloatNDArray@@QEBA?AV1@AEAV?$Array@H@@H@Z"]
    pub fn FloatNDArray_min1(this: *const FloatNDArray,
                             index: *mut Array<::std::os::raw::c_int>,
                             dim: ::std::os::raw::c_int) -> FloatNDArray;
}
extern "C" {
    #[link_name = "?cummax@FloatNDArray@@QEBA?AV1@H@Z"]
    pub fn FloatNDArray_cummax(this: *const FloatNDArray,
                               dim: ::std::os::raw::c_int) -> FloatNDArray;
}
extern "C" {
    #[link_name = "?cummax@FloatNDArray@@QEBA?AV1@AEAV?$Array@H@@H@Z"]
    pub fn FloatNDArray_cummax1(this: *const FloatNDArray,
                                index: *mut Array<::std::os::raw::c_int>,
                                dim: ::std::os::raw::c_int) -> FloatNDArray;
}
extern "C" {
    #[link_name = "?cummin@FloatNDArray@@QEBA?AV1@H@Z"]
    pub fn FloatNDArray_cummin(this: *const FloatNDArray,
                               dim: ::std::os::raw::c_int) -> FloatNDArray;
}
extern "C" {
    #[link_name = "?cummin@FloatNDArray@@QEBA?AV1@AEAV?$Array@H@@H@Z"]
    pub fn FloatNDArray_cummin1(this: *const FloatNDArray,
                                index: *mut Array<::std::os::raw::c_int>,
                                dim: ::std::os::raw::c_int) -> FloatNDArray;
}
extern "C" {
    #[link_name = "?diff@FloatNDArray@@QEBA?AV1@HH@Z"]
    pub fn FloatNDArray_diff(this: *const FloatNDArray,
                             order: octave_idx_type,
                             dim: ::std::os::raw::c_int) -> FloatNDArray;
}
extern "C" {
    #[link_name = "?insert@FloatNDArray@@QEAAAEAV1@AEBV1@HH@Z"]
    pub fn FloatNDArray_insert(this: *mut FloatNDArray,
                               a: *const FloatNDArray, r: octave_idx_type,
                               c: octave_idx_type) -> *mut FloatNDArray;
}
extern "C" {
    #[link_name = "?insert@FloatNDArray@@QEAAAEAV1@AEBV1@AEBV?$Array@H@@@Z"]
    pub fn FloatNDArray_insert1(this: *mut FloatNDArray,
                                a: *const FloatNDArray,
                                ra_idx: *const Array<::std::os::raw::c_int>)
     -> *mut FloatNDArray;
}
extern "C" {
    #[link_name = "?abs@FloatNDArray@@QEBA?AV1@XZ"]
    pub fn FloatNDArray_abs(this: *const FloatNDArray) -> FloatNDArray;
}
extern "C" {
    #[link_name = "?isnan@FloatNDArray@@QEBA?AVboolNDArray@@XZ"]
    pub fn FloatNDArray_isnan(this: *const FloatNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name = "?isinf@FloatNDArray@@QEBA?AVboolNDArray@@XZ"]
    pub fn FloatNDArray_isinf(this: *const FloatNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name = "?isfinite@FloatNDArray@@QEBA?AVboolNDArray@@XZ"]
    pub fn FloatNDArray_isfinite(this: *const FloatNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name = "?fourier@FloatNDArray@@QEBA?AVFloatComplexNDArray@@H@Z"]
    pub fn FloatNDArray_fourier(this: *const FloatNDArray,
                                dim: ::std::os::raw::c_int)
     -> FloatComplexNDArray;
}
extern "C" {
    #[link_name = "?ifourier@FloatNDArray@@QEBA?AVFloatComplexNDArray@@H@Z"]
    pub fn FloatNDArray_ifourier(this: *const FloatNDArray,
                                 dim: ::std::os::raw::c_int)
     -> FloatComplexNDArray;
}
extern "C" {
    #[link_name = "?fourier2d@FloatNDArray@@QEBA?AVFloatComplexNDArray@@XZ"]
    pub fn FloatNDArray_fourier2d(this: *const FloatNDArray)
     -> FloatComplexNDArray;
}
extern "C" {
    #[link_name = "?ifourier2d@FloatNDArray@@QEBA?AVFloatComplexNDArray@@XZ"]
    pub fn FloatNDArray_ifourier2d(this: *const FloatNDArray)
     -> FloatComplexNDArray;
}
extern "C" {
    #[link_name = "?fourierNd@FloatNDArray@@QEBA?AVFloatComplexNDArray@@XZ"]
    pub fn FloatNDArray_fourierNd(this: *const FloatNDArray)
     -> FloatComplexNDArray;
}
extern "C" {
    #[link_name = "?ifourierNd@FloatNDArray@@QEBA?AVFloatComplexNDArray@@XZ"]
    pub fn FloatNDArray_ifourierNd(this: *const FloatNDArray)
     -> FloatComplexNDArray;
}
extern "C" {
    #[link_name =
          "?increment_index@FloatNDArray@@SAXAEAV?$Array@H@@AEBVdim_vector@@H@Z"]
    pub fn FloatNDArray_increment_index(ra_idx:
                                            *mut Array<::std::os::raw::c_int>,
                                        dimensions: *const dim_vector,
                                        start_dimension:
                                            ::std::os::raw::c_int);
}
extern "C" {
    #[link_name =
          "?compute_index@FloatNDArray@@SAHAEAV?$Array@H@@AEBVdim_vector@@@Z"]
    pub fn FloatNDArray_compute_index(ra_idx:
                                          *mut Array<::std::os::raw::c_int>,
                                      dimensions: *const dim_vector)
     -> octave_idx_type;
}
extern "C" {
    #[link_name = "?diag@FloatNDArray@@QEBA?AV1@H@Z"]
    pub fn FloatNDArray_diag(this: *const FloatNDArray, k: octave_idx_type)
     -> FloatNDArray;
}
extern "C" {
    #[link_name = "?diag@FloatNDArray@@QEBA?AV1@HH@Z"]
    pub fn FloatNDArray_diag1(this: *const FloatNDArray, m: octave_idx_type,
                              n: octave_idx_type) -> FloatNDArray;
}
extern "C" {
    #[link_name = "??0FloatNDArray@@QEAA@AEBVcharNDArray@@@Z"]
    pub fn FloatNDArray_FloatNDArray(this: *mut FloatNDArray,
                                     arg1: *const charNDArray);
}
impl FloatNDArray {
    #[inline]
    pub unsafe fn any_element_is_negative(&self, arg1: bool) -> bool {
        FloatNDArray_any_element_is_negative(self, arg1)
    }
    #[inline]
    pub unsafe fn any_element_is_positive(&self, arg1: bool) -> bool {
        FloatNDArray_any_element_is_positive(self, arg1)
    }
    #[inline]
    pub unsafe fn any_element_is_nan(&self) -> bool {
        FloatNDArray_any_element_is_nan(self)
    }
    #[inline]
    pub unsafe fn any_element_is_inf_or_nan(&self) -> bool {
        FloatNDArray_any_element_is_inf_or_nan(self)
    }
    #[inline]
    pub unsafe fn any_element_not_one_or_zero(&self) -> bool {
        FloatNDArray_any_element_not_one_or_zero(self)
    }
    #[inline]
    pub unsafe fn all_elements_are_zero(&self) -> bool {
        FloatNDArray_all_elements_are_zero(self)
    }
    #[inline]
    pub unsafe fn all_elements_are_int_or_inf_or_nan(&self) -> bool {
        FloatNDArray_all_elements_are_int_or_inf_or_nan(self)
    }
    #[inline]
    pub unsafe fn all_integers(&self, max_val: *mut f32, min_val: *mut f32)
     -> bool {
        FloatNDArray_all_integers(self, max_val, min_val)
    }
    #[inline]
    pub unsafe fn all_integers1(&self) -> bool {
        FloatNDArray_all_integers1(self)
    }
    #[inline]
    pub unsafe fn too_large_for_float(&self) -> bool {
        FloatNDArray_too_large_for_float(self)
    }
    #[inline]
    pub unsafe fn all(&self, dim: ::std::os::raw::c_int) -> boolNDArray {
        FloatNDArray_all(self, dim)
    }
    #[inline]
    pub unsafe fn any(&self, dim: ::std::os::raw::c_int) -> boolNDArray {
        FloatNDArray_any(self, dim)
    }
    #[inline]
    pub unsafe fn cumprod(&self, dim: ::std::os::raw::c_int) -> FloatNDArray {
        FloatNDArray_cumprod(self, dim)
    }
    #[inline]
    pub unsafe fn cumsum(&self, dim: ::std::os::raw::c_int) -> FloatNDArray {
        FloatNDArray_cumsum(self, dim)
    }
    #[inline]
    pub unsafe fn prod(&self, dim: ::std::os::raw::c_int) -> FloatNDArray {
        FloatNDArray_prod(self, dim)
    }
    #[inline]
    pub unsafe fn dprod(&self, dim: ::std::os::raw::c_int) -> NDArray {
        FloatNDArray_dprod(self, dim)
    }
    #[inline]
    pub unsafe fn sum(&self, dim: ::std::os::raw::c_int) -> FloatNDArray {
        FloatNDArray_sum(self, dim)
    }
    #[inline]
    pub unsafe fn dsum(&self, dim: ::std::os::raw::c_int) -> NDArray {
        FloatNDArray_dsum(self, dim)
    }
    #[inline]
    pub unsafe fn sumsq(&self, dim: ::std::os::raw::c_int) -> FloatNDArray {
        FloatNDArray_sumsq(self, dim)
    }
    #[inline]
    pub unsafe fn concat(&mut self, rb: *const FloatNDArray,
                         ra_idx: *const Array<::std::os::raw::c_int>)
     -> FloatNDArray {
        FloatNDArray_concat(self, rb, ra_idx)
    }
    #[inline]
    pub unsafe fn concat1(&mut self, rb: *const FloatComplexNDArray,
                          ra_idx: *const Array<::std::os::raw::c_int>)
     -> FloatComplexNDArray {
        FloatNDArray_concat1(self, rb, ra_idx)
    }
    #[inline]
    pub unsafe fn concat2(&mut self, rb: *const charNDArray,
                          ra_idx: *const Array<::std::os::raw::c_int>)
     -> charNDArray {
        FloatNDArray_concat2(self, rb, ra_idx)
    }
    #[inline]
    pub unsafe fn max(&self, dim: ::std::os::raw::c_int) -> FloatNDArray {
        FloatNDArray_max(self, dim)
    }
    #[inline]
    pub unsafe fn max1(&self, index: *mut Array<::std::os::raw::c_int>,
                       dim: ::std::os::raw::c_int) -> FloatNDArray {
        FloatNDArray_max1(self, index, dim)
    }
    #[inline]
    pub unsafe fn min(&self, dim: ::std::os::raw::c_int) -> FloatNDArray {
        FloatNDArray_min(self, dim)
    }
    #[inline]
    pub unsafe fn min1(&self, index: *mut Array<::std::os::raw::c_int>,
                       dim: ::std::os::raw::c_int) -> FloatNDArray {
        FloatNDArray_min1(self, index, dim)
    }
    #[inline]
    pub unsafe fn cummax(&self, dim: ::std::os::raw::c_int) -> FloatNDArray {
        FloatNDArray_cummax(self, dim)
    }
    #[inline]
    pub unsafe fn cummax1(&self, index: *mut Array<::std::os::raw::c_int>,
                          dim: ::std::os::raw::c_int) -> FloatNDArray {
        FloatNDArray_cummax1(self, index, dim)
    }
    #[inline]
    pub unsafe fn cummin(&self, dim: ::std::os::raw::c_int) -> FloatNDArray {
        FloatNDArray_cummin(self, dim)
    }
    #[inline]
    pub unsafe fn cummin1(&self, index: *mut Array<::std::os::raw::c_int>,
                          dim: ::std::os::raw::c_int) -> FloatNDArray {
        FloatNDArray_cummin1(self, index, dim)
    }
    #[inline]
    pub unsafe fn diff(&self, order: octave_idx_type,
                       dim: ::std::os::raw::c_int) -> FloatNDArray {
        FloatNDArray_diff(self, order, dim)
    }
    #[inline]
    pub unsafe fn insert(&mut self, a: *const FloatNDArray,
                         r: octave_idx_type, c: octave_idx_type)
     -> *mut FloatNDArray {
        FloatNDArray_insert(self, a, r, c)
    }
    #[inline]
    pub unsafe fn insert1(&mut self, a: *const FloatNDArray,
                          ra_idx: *const Array<::std::os::raw::c_int>)
     -> *mut FloatNDArray {
        FloatNDArray_insert1(self, a, ra_idx)
    }
    #[inline]
    pub unsafe fn abs(&self) -> FloatNDArray { FloatNDArray_abs(self) }
    #[inline]
    pub unsafe fn isnan(&self) -> boolNDArray { FloatNDArray_isnan(self) }
    #[inline]
    pub unsafe fn isinf(&self) -> boolNDArray { FloatNDArray_isinf(self) }
    #[inline]
    pub unsafe fn isfinite(&self) -> boolNDArray {
        FloatNDArray_isfinite(self)
    }
    #[inline]
    pub unsafe fn fourier(&self, dim: ::std::os::raw::c_int)
     -> FloatComplexNDArray {
        FloatNDArray_fourier(self, dim)
    }
    #[inline]
    pub unsafe fn ifourier(&self, dim: ::std::os::raw::c_int)
     -> FloatComplexNDArray {
        FloatNDArray_ifourier(self, dim)
    }
    #[inline]
    pub unsafe fn fourier2d(&self) -> FloatComplexNDArray {
        FloatNDArray_fourier2d(self)
    }
    #[inline]
    pub unsafe fn ifourier2d(&self) -> FloatComplexNDArray {
        FloatNDArray_ifourier2d(self)
    }
    #[inline]
    pub unsafe fn fourierNd(&self) -> FloatComplexNDArray {
        FloatNDArray_fourierNd(self)
    }
    #[inline]
    pub unsafe fn ifourierNd(&self) -> FloatComplexNDArray {
        FloatNDArray_ifourierNd(self)
    }
    #[inline]
    pub unsafe fn increment_index(ra_idx: *mut Array<::std::os::raw::c_int>,
                                  dimensions: *const dim_vector,
                                  start_dimension: ::std::os::raw::c_int) {
        FloatNDArray_increment_index(ra_idx, dimensions, start_dimension)
    }
    #[inline]
    pub unsafe fn compute_index(ra_idx: *mut Array<::std::os::raw::c_int>,
                                dimensions: *const dim_vector)
     -> octave_idx_type {
        FloatNDArray_compute_index(ra_idx, dimensions)
    }
    #[inline]
    pub unsafe fn diag(&self, k: octave_idx_type) -> FloatNDArray {
        FloatNDArray_diag(self, k)
    }
    #[inline]
    pub unsafe fn diag1(&self, m: octave_idx_type, n: octave_idx_type)
     -> FloatNDArray {
        FloatNDArray_diag1(self, m, n)
    }
    #[inline]
    pub unsafe fn new(arg1: *const charNDArray) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        FloatNDArray_FloatNDArray(&mut __bindgen_tmp, arg1);
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct FloatComplexNDArray {
    pub _base: MArray<std_complex<f32>>,
}
#[test]
fn bindgen_test_layout_FloatComplexNDArray() {
    assert_eq!(::std::mem::size_of::<FloatComplexNDArray>() , 40usize , concat
               ! ( "Size of: " , stringify ! ( FloatComplexNDArray ) ));
    assert_eq! (::std::mem::align_of::<FloatComplexNDArray>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( FloatComplexNDArray ) ));
}
extern "C" {
    #[link_name = "?any_element_is_nan@FloatComplexNDArray@@QEBA_NXZ"]
    pub fn FloatComplexNDArray_any_element_is_nan(this:
                                                      *const FloatComplexNDArray)
     -> bool;
}
extern "C" {
    #[link_name = "?any_element_is_inf_or_nan@FloatComplexNDArray@@QEBA_NXZ"]
    pub fn FloatComplexNDArray_any_element_is_inf_or_nan(this:
                                                             *const FloatComplexNDArray)
     -> bool;
}
extern "C" {
    #[link_name = "?all_elements_are_real@FloatComplexNDArray@@QEBA_NXZ"]
    pub fn FloatComplexNDArray_all_elements_are_real(this:
                                                         *const FloatComplexNDArray)
     -> bool;
}
extern "C" {
    #[link_name = "?all_integers@FloatComplexNDArray@@QEBA_NAEAM0@Z"]
    pub fn FloatComplexNDArray_all_integers(this: *const FloatComplexNDArray,
                                            max_val: *mut f32,
                                            min_val: *mut f32) -> bool;
}
extern "C" {
    #[link_name = "?too_large_for_float@FloatComplexNDArray@@QEBA_NXZ"]
    pub fn FloatComplexNDArray_too_large_for_float(this:
                                                       *const FloatComplexNDArray)
     -> bool;
}
extern "C" {
    #[link_name = "?all@FloatComplexNDArray@@QEBA?AVboolNDArray@@H@Z"]
    pub fn FloatComplexNDArray_all(this: *const FloatComplexNDArray,
                                   dim: ::std::os::raw::c_int) -> boolNDArray;
}
extern "C" {
    #[link_name = "?any@FloatComplexNDArray@@QEBA?AVboolNDArray@@H@Z"]
    pub fn FloatComplexNDArray_any(this: *const FloatComplexNDArray,
                                   dim: ::std::os::raw::c_int) -> boolNDArray;
}
extern "C" {
    #[link_name = "?cumprod@FloatComplexNDArray@@QEBA?AV1@H@Z"]
    pub fn FloatComplexNDArray_cumprod(this: *const FloatComplexNDArray,
                                       dim: ::std::os::raw::c_int)
     -> FloatComplexNDArray;
}
extern "C" {
    #[link_name = "?cumsum@FloatComplexNDArray@@QEBA?AV1@H@Z"]
    pub fn FloatComplexNDArray_cumsum(this: *const FloatComplexNDArray,
                                      dim: ::std::os::raw::c_int)
     -> FloatComplexNDArray;
}
extern "C" {
    #[link_name = "?prod@FloatComplexNDArray@@QEBA?AV1@H@Z"]
    pub fn FloatComplexNDArray_prod(this: *const FloatComplexNDArray,
                                    dim: ::std::os::raw::c_int)
     -> FloatComplexNDArray;
}
extern "C" {
    #[link_name = "?dprod@FloatComplexNDArray@@QEBA?AVComplexNDArray@@H@Z"]
    pub fn FloatComplexNDArray_dprod(this: *const FloatComplexNDArray,
                                     dim: ::std::os::raw::c_int)
     -> ComplexNDArray;
}
extern "C" {
    #[link_name = "?sum@FloatComplexNDArray@@QEBA?AV1@H@Z"]
    pub fn FloatComplexNDArray_sum(this: *const FloatComplexNDArray,
                                   dim: ::std::os::raw::c_int)
     -> FloatComplexNDArray;
}
extern "C" {
    #[link_name = "?dsum@FloatComplexNDArray@@QEBA?AVComplexNDArray@@H@Z"]
    pub fn FloatComplexNDArray_dsum(this: *const FloatComplexNDArray,
                                    dim: ::std::os::raw::c_int)
     -> ComplexNDArray;
}
extern "C" {
    #[link_name = "?sumsq@FloatComplexNDArray@@QEBA?AV1@H@Z"]
    pub fn FloatComplexNDArray_sumsq(this: *const FloatComplexNDArray,
                                     dim: ::std::os::raw::c_int)
     -> FloatComplexNDArray;
}
extern "C" {
    #[link_name =
          "?concat@FloatComplexNDArray@@QEAA?AV1@AEBV1@AEBV?$Array@H@@@Z"]
    pub fn FloatComplexNDArray_concat(this: *mut FloatComplexNDArray,
                                      rb: *const FloatComplexNDArray,
                                      ra_idx:
                                          *const Array<::std::os::raw::c_int>)
     -> FloatComplexNDArray;
}
extern "C" {
    #[link_name =
          "?concat@FloatComplexNDArray@@QEAA?AV1@AEBVFloatNDArray@@AEBV?$Array@H@@@Z"]
    pub fn FloatComplexNDArray_concat1(this: *mut FloatComplexNDArray,
                                       rb: *const FloatNDArray,
                                       ra_idx:
                                           *const Array<::std::os::raw::c_int>)
     -> FloatComplexNDArray;
}
extern "C" {
    #[link_name = "?max@FloatComplexNDArray@@QEBA?AV1@H@Z"]
    pub fn FloatComplexNDArray_max(this: *const FloatComplexNDArray,
                                   dim: ::std::os::raw::c_int)
     -> FloatComplexNDArray;
}
extern "C" {
    #[link_name = "?max@FloatComplexNDArray@@QEBA?AV1@AEAV?$Array@H@@H@Z"]
    pub fn FloatComplexNDArray_max1(this: *const FloatComplexNDArray,
                                    index: *mut Array<::std::os::raw::c_int>,
                                    dim: ::std::os::raw::c_int)
     -> FloatComplexNDArray;
}
extern "C" {
    #[link_name = "?min@FloatComplexNDArray@@QEBA?AV1@H@Z"]
    pub fn FloatComplexNDArray_min(this: *const FloatComplexNDArray,
                                   dim: ::std::os::raw::c_int)
     -> FloatComplexNDArray;
}
extern "C" {
    #[link_name = "?min@FloatComplexNDArray@@QEBA?AV1@AEAV?$Array@H@@H@Z"]
    pub fn FloatComplexNDArray_min1(this: *const FloatComplexNDArray,
                                    index: *mut Array<::std::os::raw::c_int>,
                                    dim: ::std::os::raw::c_int)
     -> FloatComplexNDArray;
}
extern "C" {
    #[link_name = "?cummax@FloatComplexNDArray@@QEBA?AV1@H@Z"]
    pub fn FloatComplexNDArray_cummax(this: *const FloatComplexNDArray,
                                      dim: ::std::os::raw::c_int)
     -> FloatComplexNDArray;
}
extern "C" {
    #[link_name = "?cummax@FloatComplexNDArray@@QEBA?AV1@AEAV?$Array@H@@H@Z"]
    pub fn FloatComplexNDArray_cummax1(this: *const FloatComplexNDArray,
                                       index:
                                           *mut Array<::std::os::raw::c_int>,
                                       dim: ::std::os::raw::c_int)
     -> FloatComplexNDArray;
}
extern "C" {
    #[link_name = "?cummin@FloatComplexNDArray@@QEBA?AV1@H@Z"]
    pub fn FloatComplexNDArray_cummin(this: *const FloatComplexNDArray,
                                      dim: ::std::os::raw::c_int)
     -> FloatComplexNDArray;
}
extern "C" {
    #[link_name = "?cummin@FloatComplexNDArray@@QEBA?AV1@AEAV?$Array@H@@H@Z"]
    pub fn FloatComplexNDArray_cummin1(this: *const FloatComplexNDArray,
                                       index:
                                           *mut Array<::std::os::raw::c_int>,
                                       dim: ::std::os::raw::c_int)
     -> FloatComplexNDArray;
}
extern "C" {
    #[link_name = "?diff@FloatComplexNDArray@@QEBA?AV1@HH@Z"]
    pub fn FloatComplexNDArray_diff(this: *const FloatComplexNDArray,
                                    order: octave_idx_type,
                                    dim: ::std::os::raw::c_int)
     -> FloatComplexNDArray;
}
extern "C" {
    #[link_name = "?insert@FloatComplexNDArray@@QEAAAEAV1@AEBVNDArray@@HH@Z"]
    pub fn FloatComplexNDArray_insert(this: *mut FloatComplexNDArray,
                                      a: *const NDArray, r: octave_idx_type,
                                      c: octave_idx_type)
     -> *mut FloatComplexNDArray;
}
extern "C" {
    #[link_name = "?insert@FloatComplexNDArray@@QEAAAEAV1@AEBV1@HH@Z"]
    pub fn FloatComplexNDArray_insert1(this: *mut FloatComplexNDArray,
                                       a: *const FloatComplexNDArray,
                                       r: octave_idx_type, c: octave_idx_type)
     -> *mut FloatComplexNDArray;
}
extern "C" {
    #[link_name =
          "?insert@FloatComplexNDArray@@QEAAAEAV1@AEBV1@AEBV?$Array@H@@@Z"]
    pub fn FloatComplexNDArray_insert2(this: *mut FloatComplexNDArray,
                                       a: *const FloatComplexNDArray,
                                       ra_idx:
                                           *const Array<::std::os::raw::c_int>)
     -> *mut FloatComplexNDArray;
}
extern "C" {
    #[link_name = "?abs@FloatComplexNDArray@@QEBA?AVFloatNDArray@@XZ"]
    pub fn FloatComplexNDArray_abs(this: *const FloatComplexNDArray)
     -> FloatNDArray;
}
extern "C" {
    #[link_name = "?isnan@FloatComplexNDArray@@QEBA?AVboolNDArray@@XZ"]
    pub fn FloatComplexNDArray_isnan(this: *const FloatComplexNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?isinf@FloatComplexNDArray@@QEBA?AVboolNDArray@@XZ"]
    pub fn FloatComplexNDArray_isinf(this: *const FloatComplexNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?isfinite@FloatComplexNDArray@@QEBA?AVboolNDArray@@XZ"]
    pub fn FloatComplexNDArray_isfinite(this: *const FloatComplexNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?fourier@FloatComplexNDArray@@QEBA?AV1@H@Z"]
    pub fn FloatComplexNDArray_fourier(this: *const FloatComplexNDArray,
                                       dim: ::std::os::raw::c_int)
     -> FloatComplexNDArray;
}
extern "C" {
    #[link_name = "?ifourier@FloatComplexNDArray@@QEBA?AV1@H@Z"]
    pub fn FloatComplexNDArray_ifourier(this: *const FloatComplexNDArray,
                                        dim: ::std::os::raw::c_int)
     -> FloatComplexNDArray;
}
extern "C" {
    #[link_name = "?fourier2d@FloatComplexNDArray@@QEBA?AV1@XZ"]
    pub fn FloatComplexNDArray_fourier2d(this: *const FloatComplexNDArray)
     -> FloatComplexNDArray;
}
extern "C" {
    #[link_name = "?ifourier2d@FloatComplexNDArray@@QEBA?AV1@XZ"]
    pub fn FloatComplexNDArray_ifourier2d(this: *const FloatComplexNDArray)
     -> FloatComplexNDArray;
}
extern "C" {
    #[link_name = "?fourierNd@FloatComplexNDArray@@QEBA?AV1@XZ"]
    pub fn FloatComplexNDArray_fourierNd(this: *const FloatComplexNDArray)
     -> FloatComplexNDArray;
}
extern "C" {
    #[link_name = "?ifourierNd@FloatComplexNDArray@@QEBA?AV1@XZ"]
    pub fn FloatComplexNDArray_ifourierNd(this: *const FloatComplexNDArray)
     -> FloatComplexNDArray;
}
extern "C" {
    #[link_name =
          "?increment_index@FloatComplexNDArray@@SAXAEAV?$Array@H@@AEBVdim_vector@@H@Z"]
    pub fn FloatComplexNDArray_increment_index(ra_idx:
                                                   *mut Array<::std::os::raw::c_int>,
                                               dimensions: *const dim_vector,
                                               start_dimension:
                                                   ::std::os::raw::c_int);
}
extern "C" {
    #[link_name =
          "?compute_index@FloatComplexNDArray@@SAHAEAV?$Array@H@@AEBVdim_vector@@@Z"]
    pub fn FloatComplexNDArray_compute_index(ra_idx:
                                                 *mut Array<::std::os::raw::c_int>,
                                             dimensions: *const dim_vector)
     -> octave_idx_type;
}
extern "C" {
    #[link_name = "?diag@FloatComplexNDArray@@QEBA?AV1@H@Z"]
    pub fn FloatComplexNDArray_diag(this: *const FloatComplexNDArray,
                                    k: octave_idx_type)
     -> FloatComplexNDArray;
}
extern "C" {
    #[link_name = "?diag@FloatComplexNDArray@@QEBA?AV1@HH@Z"]
    pub fn FloatComplexNDArray_diag1(this: *const FloatComplexNDArray,
                                     m: octave_idx_type, n: octave_idx_type)
     -> FloatComplexNDArray;
}
extern "C" {
    #[link_name = "??0FloatComplexNDArray@@QEAA@AEBVcharNDArray@@@Z"]
    pub fn FloatComplexNDArray_FloatComplexNDArray(this:
                                                       *mut FloatComplexNDArray,
                                                   arg1: *const charNDArray);
}
impl FloatComplexNDArray {
    #[inline]
    pub unsafe fn any_element_is_nan(&self) -> bool {
        FloatComplexNDArray_any_element_is_nan(self)
    }
    #[inline]
    pub unsafe fn any_element_is_inf_or_nan(&self) -> bool {
        FloatComplexNDArray_any_element_is_inf_or_nan(self)
    }
    #[inline]
    pub unsafe fn all_elements_are_real(&self) -> bool {
        FloatComplexNDArray_all_elements_are_real(self)
    }
    #[inline]
    pub unsafe fn all_integers(&self, max_val: *mut f32, min_val: *mut f32)
     -> bool {
        FloatComplexNDArray_all_integers(self, max_val, min_val)
    }
    #[inline]
    pub unsafe fn too_large_for_float(&self) -> bool {
        FloatComplexNDArray_too_large_for_float(self)
    }
    #[inline]
    pub unsafe fn all(&self, dim: ::std::os::raw::c_int) -> boolNDArray {
        FloatComplexNDArray_all(self, dim)
    }
    #[inline]
    pub unsafe fn any(&self, dim: ::std::os::raw::c_int) -> boolNDArray {
        FloatComplexNDArray_any(self, dim)
    }
    #[inline]
    pub unsafe fn cumprod(&self, dim: ::std::os::raw::c_int)
     -> FloatComplexNDArray {
        FloatComplexNDArray_cumprod(self, dim)
    }
    #[inline]
    pub unsafe fn cumsum(&self, dim: ::std::os::raw::c_int)
     -> FloatComplexNDArray {
        FloatComplexNDArray_cumsum(self, dim)
    }
    #[inline]
    pub unsafe fn prod(&self, dim: ::std::os::raw::c_int)
     -> FloatComplexNDArray {
        FloatComplexNDArray_prod(self, dim)
    }
    #[inline]
    pub unsafe fn dprod(&self, dim: ::std::os::raw::c_int) -> ComplexNDArray {
        FloatComplexNDArray_dprod(self, dim)
    }
    #[inline]
    pub unsafe fn sum(&self, dim: ::std::os::raw::c_int)
     -> FloatComplexNDArray {
        FloatComplexNDArray_sum(self, dim)
    }
    #[inline]
    pub unsafe fn dsum(&self, dim: ::std::os::raw::c_int) -> ComplexNDArray {
        FloatComplexNDArray_dsum(self, dim)
    }
    #[inline]
    pub unsafe fn sumsq(&self, dim: ::std::os::raw::c_int)
     -> FloatComplexNDArray {
        FloatComplexNDArray_sumsq(self, dim)
    }
    #[inline]
    pub unsafe fn concat(&mut self, rb: *const FloatComplexNDArray,
                         ra_idx: *const Array<::std::os::raw::c_int>)
     -> FloatComplexNDArray {
        FloatComplexNDArray_concat(self, rb, ra_idx)
    }
    #[inline]
    pub unsafe fn concat1(&mut self, rb: *const FloatNDArray,
                          ra_idx: *const Array<::std::os::raw::c_int>)
     -> FloatComplexNDArray {
        FloatComplexNDArray_concat1(self, rb, ra_idx)
    }
    #[inline]
    pub unsafe fn max(&self, dim: ::std::os::raw::c_int)
     -> FloatComplexNDArray {
        FloatComplexNDArray_max(self, dim)
    }
    #[inline]
    pub unsafe fn max1(&self, index: *mut Array<::std::os::raw::c_int>,
                       dim: ::std::os::raw::c_int) -> FloatComplexNDArray {
        FloatComplexNDArray_max1(self, index, dim)
    }
    #[inline]
    pub unsafe fn min(&self, dim: ::std::os::raw::c_int)
     -> FloatComplexNDArray {
        FloatComplexNDArray_min(self, dim)
    }
    #[inline]
    pub unsafe fn min1(&self, index: *mut Array<::std::os::raw::c_int>,
                       dim: ::std::os::raw::c_int) -> FloatComplexNDArray {
        FloatComplexNDArray_min1(self, index, dim)
    }
    #[inline]
    pub unsafe fn cummax(&self, dim: ::std::os::raw::c_int)
     -> FloatComplexNDArray {
        FloatComplexNDArray_cummax(self, dim)
    }
    #[inline]
    pub unsafe fn cummax1(&self, index: *mut Array<::std::os::raw::c_int>,
                          dim: ::std::os::raw::c_int) -> FloatComplexNDArray {
        FloatComplexNDArray_cummax1(self, index, dim)
    }
    #[inline]
    pub unsafe fn cummin(&self, dim: ::std::os::raw::c_int)
     -> FloatComplexNDArray {
        FloatComplexNDArray_cummin(self, dim)
    }
    #[inline]
    pub unsafe fn cummin1(&self, index: *mut Array<::std::os::raw::c_int>,
                          dim: ::std::os::raw::c_int) -> FloatComplexNDArray {
        FloatComplexNDArray_cummin1(self, index, dim)
    }
    #[inline]
    pub unsafe fn diff(&self, order: octave_idx_type,
                       dim: ::std::os::raw::c_int) -> FloatComplexNDArray {
        FloatComplexNDArray_diff(self, order, dim)
    }
    #[inline]
    pub unsafe fn insert(&mut self, a: *const NDArray, r: octave_idx_type,
                         c: octave_idx_type) -> *mut FloatComplexNDArray {
        FloatComplexNDArray_insert(self, a, r, c)
    }
    #[inline]
    pub unsafe fn insert1(&mut self, a: *const FloatComplexNDArray,
                          r: octave_idx_type, c: octave_idx_type)
     -> *mut FloatComplexNDArray {
        FloatComplexNDArray_insert1(self, a, r, c)
    }
    #[inline]
    pub unsafe fn insert2(&mut self, a: *const FloatComplexNDArray,
                          ra_idx: *const Array<::std::os::raw::c_int>)
     -> *mut FloatComplexNDArray {
        FloatComplexNDArray_insert2(self, a, ra_idx)
    }
    #[inline]
    pub unsafe fn abs(&self) -> FloatNDArray { FloatComplexNDArray_abs(self) }
    #[inline]
    pub unsafe fn isnan(&self) -> boolNDArray {
        FloatComplexNDArray_isnan(self)
    }
    #[inline]
    pub unsafe fn isinf(&self) -> boolNDArray {
        FloatComplexNDArray_isinf(self)
    }
    #[inline]
    pub unsafe fn isfinite(&self) -> boolNDArray {
        FloatComplexNDArray_isfinite(self)
    }
    #[inline]
    pub unsafe fn fourier(&self, dim: ::std::os::raw::c_int)
     -> FloatComplexNDArray {
        FloatComplexNDArray_fourier(self, dim)
    }
    #[inline]
    pub unsafe fn ifourier(&self, dim: ::std::os::raw::c_int)
     -> FloatComplexNDArray {
        FloatComplexNDArray_ifourier(self, dim)
    }
    #[inline]
    pub unsafe fn fourier2d(&self) -> FloatComplexNDArray {
        FloatComplexNDArray_fourier2d(self)
    }
    #[inline]
    pub unsafe fn ifourier2d(&self) -> FloatComplexNDArray {
        FloatComplexNDArray_ifourier2d(self)
    }
    #[inline]
    pub unsafe fn fourierNd(&self) -> FloatComplexNDArray {
        FloatComplexNDArray_fourierNd(self)
    }
    #[inline]
    pub unsafe fn ifourierNd(&self) -> FloatComplexNDArray {
        FloatComplexNDArray_ifourierNd(self)
    }
    #[inline]
    pub unsafe fn increment_index(ra_idx: *mut Array<::std::os::raw::c_int>,
                                  dimensions: *const dim_vector,
                                  start_dimension: ::std::os::raw::c_int) {
        FloatComplexNDArray_increment_index(ra_idx, dimensions,
                                            start_dimension)
    }
    #[inline]
    pub unsafe fn compute_index(ra_idx: *mut Array<::std::os::raw::c_int>,
                                dimensions: *const dim_vector)
     -> octave_idx_type {
        FloatComplexNDArray_compute_index(ra_idx, dimensions)
    }
    #[inline]
    pub unsafe fn diag(&self, k: octave_idx_type) -> FloatComplexNDArray {
        FloatComplexNDArray_diag(self, k)
    }
    #[inline]
    pub unsafe fn diag1(&self, m: octave_idx_type, n: octave_idx_type)
     -> FloatComplexNDArray {
        FloatComplexNDArray_diag1(self, m, n)
    }
    #[inline]
    pub unsafe fn new(arg1: *const charNDArray) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        FloatComplexNDArray_FloatComplexNDArray(&mut __bindgen_tmp, arg1);
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct boolNDArray {
    pub _base: Array<bool>,
}
pub type boolNDArray_matrix_type = boolMatrix;
#[test]
fn bindgen_test_layout_boolNDArray() {
    assert_eq!(::std::mem::size_of::<boolNDArray>() , 40usize , concat ! (
               "Size of: " , stringify ! ( boolNDArray ) ));
    assert_eq! (::std::mem::align_of::<boolNDArray>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( boolNDArray ) ));
}
extern "C" {
    #[link_name = "?invert@boolNDArray@@QEAAAEAV1@XZ"]
    pub fn boolNDArray_invert(this: *mut boolNDArray) -> *mut boolNDArray;
}
extern "C" {
    #[link_name = "?all@boolNDArray@@QEBA?AV1@H@Z"]
    pub fn boolNDArray_all(this: *const boolNDArray,
                           dim: ::std::os::raw::c_int) -> boolNDArray;
}
extern "C" {
    #[link_name = "?any@boolNDArray@@QEBA?AV1@H@Z"]
    pub fn boolNDArray_any(this: *const boolNDArray,
                           dim: ::std::os::raw::c_int) -> boolNDArray;
}
extern "C" {
    #[link_name = "?sum@boolNDArray@@QEBA?AVNDArray@@H@Z"]
    pub fn boolNDArray_sum(this: *const boolNDArray,
                           dim: ::std::os::raw::c_int) -> NDArray;
}
extern "C" {
    #[link_name = "?cumsum@boolNDArray@@QEBA?AVNDArray@@H@Z"]
    pub fn boolNDArray_cumsum(this: *const boolNDArray,
                              dim: ::std::os::raw::c_int) -> NDArray;
}
extern "C" {
    #[link_name = "?concat@boolNDArray@@QEAA?AV1@AEBV1@AEBV?$Array@H@@@Z"]
    pub fn boolNDArray_concat(this: *mut boolNDArray, rb: *const boolNDArray,
                              ra_idx: *const Array<::std::os::raw::c_int>)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?insert@boolNDArray@@QEAAAEAV1@AEBV1@HH@Z"]
    pub fn boolNDArray_insert(this: *mut boolNDArray, a: *const boolNDArray,
                              r: octave_idx_type, c: octave_idx_type)
     -> *mut boolNDArray;
}
extern "C" {
    #[link_name = "?insert@boolNDArray@@QEAAAEAV1@AEBV1@AEBV?$Array@H@@@Z"]
    pub fn boolNDArray_insert1(this: *mut boolNDArray, a: *const boolNDArray,
                               ra_idx: *const Array<::std::os::raw::c_int>)
     -> *mut boolNDArray;
}
extern "C" {
    #[link_name =
          "?increment_index@boolNDArray@@SAXAEAV?$Array@H@@AEBVdim_vector@@H@Z"]
    pub fn boolNDArray_increment_index(ra_idx:
                                           *mut Array<::std::os::raw::c_int>,
                                       dimensions: *const dim_vector,
                                       start_dimension:
                                           ::std::os::raw::c_int);
}
extern "C" {
    #[link_name =
          "?compute_index@boolNDArray@@SAHAEAV?$Array@H@@AEBVdim_vector@@@Z"]
    pub fn boolNDArray_compute_index(ra_idx:
                                         *mut Array<::std::os::raw::c_int>,
                                     dimensions: *const dim_vector)
     -> octave_idx_type;
}
extern "C" {
    #[link_name = "?diag@boolNDArray@@QEBA?AV1@H@Z"]
    pub fn boolNDArray_diag(this: *const boolNDArray, k: octave_idx_type)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?diag@boolNDArray@@QEBA?AV1@HH@Z"]
    pub fn boolNDArray_diag1(this: *const boolNDArray, m: octave_idx_type,
                             n: octave_idx_type) -> boolNDArray;
}
impl boolNDArray {
    #[inline]
    pub unsafe fn invert(&mut self) -> *mut boolNDArray {
        boolNDArray_invert(self)
    }
    #[inline]
    pub unsafe fn all(&self, dim: ::std::os::raw::c_int) -> boolNDArray {
        boolNDArray_all(self, dim)
    }
    #[inline]
    pub unsafe fn any(&self, dim: ::std::os::raw::c_int) -> boolNDArray {
        boolNDArray_any(self, dim)
    }
    #[inline]
    pub unsafe fn sum(&self, dim: ::std::os::raw::c_int) -> NDArray {
        boolNDArray_sum(self, dim)
    }
    #[inline]
    pub unsafe fn cumsum(&self, dim: ::std::os::raw::c_int) -> NDArray {
        boolNDArray_cumsum(self, dim)
    }
    #[inline]
    pub unsafe fn concat(&mut self, rb: *const boolNDArray,
                         ra_idx: *const Array<::std::os::raw::c_int>)
     -> boolNDArray {
        boolNDArray_concat(self, rb, ra_idx)
    }
    #[inline]
    pub unsafe fn insert(&mut self, a: *const boolNDArray, r: octave_idx_type,
                         c: octave_idx_type) -> *mut boolNDArray {
        boolNDArray_insert(self, a, r, c)
    }
    #[inline]
    pub unsafe fn insert1(&mut self, a: *const boolNDArray,
                          ra_idx: *const Array<::std::os::raw::c_int>)
     -> *mut boolNDArray {
        boolNDArray_insert1(self, a, ra_idx)
    }
    #[inline]
    pub unsafe fn increment_index(ra_idx: *mut Array<::std::os::raw::c_int>,
                                  dimensions: *const dim_vector,
                                  start_dimension: ::std::os::raw::c_int) {
        boolNDArray_increment_index(ra_idx, dimensions, start_dimension)
    }
    #[inline]
    pub unsafe fn compute_index(ra_idx: *mut Array<::std::os::raw::c_int>,
                                dimensions: *const dim_vector)
     -> octave_idx_type {
        boolNDArray_compute_index(ra_idx, dimensions)
    }
    #[inline]
    pub unsafe fn diag(&self, k: octave_idx_type) -> boolNDArray {
        boolNDArray_diag(self, k)
    }
    #[inline]
    pub unsafe fn diag1(&self, m: octave_idx_type, n: octave_idx_type)
     -> boolNDArray {
        boolNDArray_diag1(self, m, n)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct charNDArray {
    pub _base: Array<::std::os::raw::c_char>,
}
pub type charNDArray_matrix_type = charMatrix;
#[test]
fn bindgen_test_layout_charNDArray() {
    assert_eq!(::std::mem::size_of::<charNDArray>() , 40usize , concat ! (
               "Size of: " , stringify ! ( charNDArray ) ));
    assert_eq! (::std::mem::align_of::<charNDArray>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( charNDArray ) ));
}
extern "C" {
    #[link_name = "?all@charNDArray@@QEBA?AVboolNDArray@@H@Z"]
    pub fn charNDArray_all(this: *const charNDArray,
                           dim: ::std::os::raw::c_int) -> boolNDArray;
}
extern "C" {
    #[link_name = "?any@charNDArray@@QEBA?AVboolNDArray@@H@Z"]
    pub fn charNDArray_any(this: *const charNDArray,
                           dim: ::std::os::raw::c_int) -> boolNDArray;
}
extern "C" {
    #[link_name = "?concat@charNDArray@@QEAA?AV1@AEBV1@AEBV?$Array@H@@@Z"]
    pub fn charNDArray_concat(this: *mut charNDArray, rb: *const charNDArray,
                              ra_idx: *const Array<::std::os::raw::c_int>)
     -> charNDArray;
}
extern "C" {
    #[link_name =
          "?concat@charNDArray@@QEAA?AV1@AEBVNDArray@@AEBV?$Array@H@@@Z"]
    pub fn charNDArray_concat1(this: *mut charNDArray, rb: *const NDArray,
                               ra_idx: *const Array<::std::os::raw::c_int>)
     -> charNDArray;
}
extern "C" {
    #[link_name = "?max@charNDArray@@QEBA?AV1@H@Z"]
    pub fn charNDArray_max(this: *const charNDArray,
                           dim: ::std::os::raw::c_int) -> charNDArray;
}
extern "C" {
    #[link_name = "?max@charNDArray@@QEBA?AV1@AEAV?$Array@H@@H@Z"]
    pub fn charNDArray_max1(this: *const charNDArray,
                            index: *mut Array<::std::os::raw::c_int>,
                            dim: ::std::os::raw::c_int) -> charNDArray;
}
extern "C" {
    #[link_name = "?min@charNDArray@@QEBA?AV1@H@Z"]
    pub fn charNDArray_min(this: *const charNDArray,
                           dim: ::std::os::raw::c_int) -> charNDArray;
}
extern "C" {
    #[link_name = "?min@charNDArray@@QEBA?AV1@AEAV?$Array@H@@H@Z"]
    pub fn charNDArray_min1(this: *const charNDArray,
                            index: *mut Array<::std::os::raw::c_int>,
                            dim: ::std::os::raw::c_int) -> charNDArray;
}
extern "C" {
    #[link_name = "?insert@charNDArray@@QEAAAEAV1@AEBV1@HH@Z"]
    pub fn charNDArray_insert(this: *mut charNDArray, a: *const charNDArray,
                              r: octave_idx_type, c: octave_idx_type)
     -> *mut charNDArray;
}
extern "C" {
    #[link_name = "?insert@charNDArray@@QEAAAEAV1@AEBV1@AEBV?$Array@H@@@Z"]
    pub fn charNDArray_insert1(this: *mut charNDArray, a: *const charNDArray,
                               ra_idx: *const Array<::std::os::raw::c_int>)
     -> *mut charNDArray;
}
extern "C" {
    #[link_name =
          "?increment_index@charNDArray@@SAXAEAV?$Array@H@@AEBVdim_vector@@H@Z"]
    pub fn charNDArray_increment_index(ra_idx:
                                           *mut Array<::std::os::raw::c_int>,
                                       dimensions: *const dim_vector,
                                       start_dimension:
                                           ::std::os::raw::c_int);
}
extern "C" {
    #[link_name =
          "?compute_index@charNDArray@@SAHAEAV?$Array@H@@AEBVdim_vector@@@Z"]
    pub fn charNDArray_compute_index(ra_idx:
                                         *mut Array<::std::os::raw::c_int>,
                                     dimensions: *const dim_vector)
     -> octave_idx_type;
}
extern "C" {
    #[link_name = "?diag@charNDArray@@QEBA?AV1@H@Z"]
    pub fn charNDArray_diag(this: *const charNDArray, k: octave_idx_type)
     -> charNDArray;
}
extern "C" {
    #[link_name = "?diag@charNDArray@@QEBA?AV1@HH@Z"]
    pub fn charNDArray_diag1(this: *const charNDArray, m: octave_idx_type,
                             n: octave_idx_type) -> charNDArray;
}
extern "C" {
    #[link_name = "??0charNDArray@@QEAA@D@Z"]
    pub fn charNDArray_charNDArray(this: *mut charNDArray,
                                   c: ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "??0charNDArray@@QEAA@PEBD@Z"]
    pub fn charNDArray_charNDArray1(this: *mut charNDArray,
                                    s: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name =
          "??0charNDArray@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn charNDArray_charNDArray2(this: *mut charNDArray,
                                    s: *const std_string);
}
extern "C" {
    #[link_name = "??0charNDArray@@QEAA@AEBVstring_vector@@D@Z"]
    pub fn charNDArray_charNDArray3(this: *mut charNDArray,
                                    s: *const string_vector,
                                    fill_value: ::std::os::raw::c_char);
}
impl charNDArray {
    #[inline]
    pub unsafe fn all(&self, dim: ::std::os::raw::c_int) -> boolNDArray {
        charNDArray_all(self, dim)
    }
    #[inline]
    pub unsafe fn any(&self, dim: ::std::os::raw::c_int) -> boolNDArray {
        charNDArray_any(self, dim)
    }
    #[inline]
    pub unsafe fn concat(&mut self, rb: *const charNDArray,
                         ra_idx: *const Array<::std::os::raw::c_int>)
     -> charNDArray {
        charNDArray_concat(self, rb, ra_idx)
    }
    #[inline]
    pub unsafe fn concat1(&mut self, rb: *const NDArray,
                          ra_idx: *const Array<::std::os::raw::c_int>)
     -> charNDArray {
        charNDArray_concat1(self, rb, ra_idx)
    }
    #[inline]
    pub unsafe fn max(&self, dim: ::std::os::raw::c_int) -> charNDArray {
        charNDArray_max(self, dim)
    }
    #[inline]
    pub unsafe fn max1(&self, index: *mut Array<::std::os::raw::c_int>,
                       dim: ::std::os::raw::c_int) -> charNDArray {
        charNDArray_max1(self, index, dim)
    }
    #[inline]
    pub unsafe fn min(&self, dim: ::std::os::raw::c_int) -> charNDArray {
        charNDArray_min(self, dim)
    }
    #[inline]
    pub unsafe fn min1(&self, index: *mut Array<::std::os::raw::c_int>,
                       dim: ::std::os::raw::c_int) -> charNDArray {
        charNDArray_min1(self, index, dim)
    }
    #[inline]
    pub unsafe fn insert(&mut self, a: *const charNDArray, r: octave_idx_type,
                         c: octave_idx_type) -> *mut charNDArray {
        charNDArray_insert(self, a, r, c)
    }
    #[inline]
    pub unsafe fn insert1(&mut self, a: *const charNDArray,
                          ra_idx: *const Array<::std::os::raw::c_int>)
     -> *mut charNDArray {
        charNDArray_insert1(self, a, ra_idx)
    }
    #[inline]
    pub unsafe fn increment_index(ra_idx: *mut Array<::std::os::raw::c_int>,
                                  dimensions: *const dim_vector,
                                  start_dimension: ::std::os::raw::c_int) {
        charNDArray_increment_index(ra_idx, dimensions, start_dimension)
    }
    #[inline]
    pub unsafe fn compute_index(ra_idx: *mut Array<::std::os::raw::c_int>,
                                dimensions: *const dim_vector)
     -> octave_idx_type {
        charNDArray_compute_index(ra_idx, dimensions)
    }
    #[inline]
    pub unsafe fn diag(&self, k: octave_idx_type) -> charNDArray {
        charNDArray_diag(self, k)
    }
    #[inline]
    pub unsafe fn diag1(&self, m: octave_idx_type, n: octave_idx_type)
     -> charNDArray {
        charNDArray_diag1(self, m, n)
    }
    #[inline]
    pub unsafe fn new(c: ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        charNDArray_charNDArray(&mut __bindgen_tmp, c);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(s: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        charNDArray_charNDArray1(&mut __bindgen_tmp, s);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new2(s: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        charNDArray_charNDArray2(&mut __bindgen_tmp, s);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new3(s: *const string_vector,
                       fill_value: ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        charNDArray_charNDArray3(&mut __bindgen_tmp, s, fill_value);
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct ColumnVector {
    pub _base: MArray<f64>,
}
#[test]
fn bindgen_test_layout_ColumnVector() {
    assert_eq!(::std::mem::size_of::<ColumnVector>() , 40usize , concat ! (
               "Size of: " , stringify ! ( ColumnVector ) ));
    assert_eq! (::std::mem::align_of::<ColumnVector>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ColumnVector ) ));
}
extern "C" {
    #[link_name = "?insert@ColumnVector@@QEAAAEAV1@AEBV1@H@Z"]
    pub fn ColumnVector_insert(this: *mut ColumnVector,
                               a: *const ColumnVector, r: octave_idx_type)
     -> *mut ColumnVector;
}
extern "C" {
    #[link_name = "?fill@ColumnVector@@QEAAAEAV1@N@Z"]
    pub fn ColumnVector_fill(this: *mut ColumnVector, val: f64)
     -> *mut ColumnVector;
}
extern "C" {
    #[link_name = "?fill@ColumnVector@@QEAAAEAV1@NHH@Z"]
    pub fn ColumnVector_fill1(this: *mut ColumnVector, val: f64,
                              r1: octave_idx_type, r2: octave_idx_type)
     -> *mut ColumnVector;
}
extern "C" {
    #[link_name = "?stack@ColumnVector@@QEBA?AV1@AEBV1@@Z"]
    pub fn ColumnVector_stack(this: *const ColumnVector,
                              a: *const ColumnVector) -> ColumnVector;
}
extern "C" {
    #[link_name = "?transpose@ColumnVector@@QEBA?AVRowVector@@XZ"]
    pub fn ColumnVector_transpose(this: *const ColumnVector) -> RowVector;
}
extern "C" {
    #[link_name = "?extract@ColumnVector@@QEBA?AV1@HH@Z"]
    pub fn ColumnVector_extract(this: *const ColumnVector,
                                r1: octave_idx_type, r2: octave_idx_type)
     -> ColumnVector;
}
extern "C" {
    #[link_name = "?extract_n@ColumnVector@@QEBA?AV1@HH@Z"]
    pub fn ColumnVector_extract_n(this: *const ColumnVector,
                                  r1: octave_idx_type, n: octave_idx_type)
     -> ColumnVector;
}
extern "C" {
    #[link_name = "?min@ColumnVector@@QEBANXZ"]
    pub fn ColumnVector_min(this: *const ColumnVector) -> f64;
}
extern "C" {
    #[link_name = "?max@ColumnVector@@QEBANXZ"]
    pub fn ColumnVector_max(this: *const ColumnVector) -> f64;
}
extern "C" {
    #[link_name = "?abs@ColumnVector@@QEBA?AV1@XZ"]
    pub fn ColumnVector_abs(this: *const ColumnVector) -> ColumnVector;
}
impl ColumnVector {
    #[inline]
    pub unsafe fn insert(&mut self, a: *const ColumnVector,
                         r: octave_idx_type) -> *mut ColumnVector {
        ColumnVector_insert(self, a, r)
    }
    #[inline]
    pub unsafe fn fill(&mut self, val: f64) -> *mut ColumnVector {
        ColumnVector_fill(self, val)
    }
    #[inline]
    pub unsafe fn fill1(&mut self, val: f64, r1: octave_idx_type,
                        r2: octave_idx_type) -> *mut ColumnVector {
        ColumnVector_fill1(self, val, r1, r2)
    }
    #[inline]
    pub unsafe fn stack(&self, a: *const ColumnVector) -> ColumnVector {
        ColumnVector_stack(self, a)
    }
    #[inline]
    pub unsafe fn transpose(&self) -> RowVector {
        ColumnVector_transpose(self)
    }
    #[inline]
    pub unsafe fn extract(&self, r1: octave_idx_type, r2: octave_idx_type)
     -> ColumnVector {
        ColumnVector_extract(self, r1, r2)
    }
    #[inline]
    pub unsafe fn extract_n(&self, r1: octave_idx_type, n: octave_idx_type)
     -> ColumnVector {
        ColumnVector_extract_n(self, r1, n)
    }
    #[inline]
    pub unsafe fn min(&self) -> f64 { ColumnVector_min(self) }
    #[inline]
    pub unsafe fn max(&self) -> f64 { ColumnVector_max(self) }
    #[inline]
    pub unsafe fn abs(&self) -> ColumnVector { ColumnVector_abs(self) }
}
#[repr(C)]
#[derive(Debug)]
pub struct ComplexColumnVector {
    pub _base: MArray<std_complex<f64>>,
}
#[test]
fn bindgen_test_layout_ComplexColumnVector() {
    assert_eq!(::std::mem::size_of::<ComplexColumnVector>() , 40usize , concat
               ! ( "Size of: " , stringify ! ( ComplexColumnVector ) ));
    assert_eq! (::std::mem::align_of::<ComplexColumnVector>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( ComplexColumnVector ) ));
}
extern "C" {
    #[link_name =
          "?insert@ComplexColumnVector@@QEAAAEAV1@AEBVColumnVector@@H@Z"]
    pub fn ComplexColumnVector_insert(this: *mut ComplexColumnVector,
                                      a: *const ColumnVector,
                                      r: octave_idx_type)
     -> *mut ComplexColumnVector;
}
extern "C" {
    #[link_name = "?insert@ComplexColumnVector@@QEAAAEAV1@AEBV1@H@Z"]
    pub fn ComplexColumnVector_insert1(this: *mut ComplexColumnVector,
                                       a: *const ComplexColumnVector,
                                       r: octave_idx_type)
     -> *mut ComplexColumnVector;
}
extern "C" {
    #[link_name = "?fill@ComplexColumnVector@@QEAAAEAV1@N@Z"]
    pub fn ComplexColumnVector_fill(this: *mut ComplexColumnVector, val: f64)
     -> *mut ComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?fill@ComplexColumnVector@@QEAAAEAV1@AEBU?$complex@N@std@@@Z"]
    pub fn ComplexColumnVector_fill1(this: *mut ComplexColumnVector,
                                     val: *const Complex)
     -> *mut ComplexColumnVector;
}
extern "C" {
    #[link_name = "?fill@ComplexColumnVector@@QEAAAEAV1@NHH@Z"]
    pub fn ComplexColumnVector_fill2(this: *mut ComplexColumnVector, val: f64,
                                     r1: octave_idx_type, r2: octave_idx_type)
     -> *mut ComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?fill@ComplexColumnVector@@QEAAAEAV1@AEBU?$complex@N@std@@HH@Z"]
    pub fn ComplexColumnVector_fill3(this: *mut ComplexColumnVector,
                                     val: *const Complex, r1: octave_idx_type,
                                     r2: octave_idx_type)
     -> *mut ComplexColumnVector;
}
extern "C" {
    #[link_name = "?stack@ComplexColumnVector@@QEBA?AV1@AEBVColumnVector@@@Z"]
    pub fn ComplexColumnVector_stack(this: *const ComplexColumnVector,
                                     a: *const ColumnVector)
     -> ComplexColumnVector;
}
extern "C" {
    #[link_name = "?stack@ComplexColumnVector@@QEBA?AV1@AEBV1@@Z"]
    pub fn ComplexColumnVector_stack1(this: *const ComplexColumnVector,
                                      a: *const ComplexColumnVector)
     -> ComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?hermitian@ComplexColumnVector@@QEBA?AVComplexRowVector@@XZ"]
    pub fn ComplexColumnVector_hermitian(this: *const ComplexColumnVector)
     -> ComplexRowVector;
}
extern "C" {
    #[link_name =
          "?transpose@ComplexColumnVector@@QEBA?AVComplexRowVector@@XZ"]
    pub fn ComplexColumnVector_transpose(this: *const ComplexColumnVector)
     -> ComplexRowVector;
}
extern "C" {
    #[link_name = "?extract@ComplexColumnVector@@QEBA?AV1@HH@Z"]
    pub fn ComplexColumnVector_extract(this: *const ComplexColumnVector,
                                       r1: octave_idx_type,
                                       r2: octave_idx_type)
     -> ComplexColumnVector;
}
extern "C" {
    #[link_name = "?extract_n@ComplexColumnVector@@QEBA?AV1@HH@Z"]
    pub fn ComplexColumnVector_extract_n(this: *const ComplexColumnVector,
                                         r1: octave_idx_type,
                                         n: octave_idx_type)
     -> ComplexColumnVector;
}
extern "C" {
    #[link_name = "?min@ComplexColumnVector@@QEBA?AU?$complex@N@std@@XZ"]
    pub fn ComplexColumnVector_min(this: *const ComplexColumnVector)
     -> Complex;
}
extern "C" {
    #[link_name = "?max@ComplexColumnVector@@QEBA?AU?$complex@N@std@@XZ"]
    pub fn ComplexColumnVector_max(this: *const ComplexColumnVector)
     -> Complex;
}
extern "C" {
    #[link_name = "?abs@ComplexColumnVector@@QEBA?AVColumnVector@@XZ"]
    pub fn ComplexColumnVector_abs(this: *const ComplexColumnVector)
     -> ColumnVector;
}
extern "C" {
    #[link_name = "??0ComplexColumnVector@@QEAA@AEBVColumnVector@@@Z"]
    pub fn ComplexColumnVector_ComplexColumnVector(this:
                                                       *mut ComplexColumnVector,
                                                   a: *const ColumnVector);
}
impl ComplexColumnVector {
    #[inline]
    pub unsafe fn insert(&mut self, a: *const ColumnVector,
                         r: octave_idx_type) -> *mut ComplexColumnVector {
        ComplexColumnVector_insert(self, a, r)
    }
    #[inline]
    pub unsafe fn insert1(&mut self, a: *const ComplexColumnVector,
                          r: octave_idx_type) -> *mut ComplexColumnVector {
        ComplexColumnVector_insert1(self, a, r)
    }
    #[inline]
    pub unsafe fn fill(&mut self, val: f64) -> *mut ComplexColumnVector {
        ComplexColumnVector_fill(self, val)
    }
    #[inline]
    pub unsafe fn fill1(&mut self, val: *const Complex)
     -> *mut ComplexColumnVector {
        ComplexColumnVector_fill1(self, val)
    }
    #[inline]
    pub unsafe fn fill2(&mut self, val: f64, r1: octave_idx_type,
                        r2: octave_idx_type) -> *mut ComplexColumnVector {
        ComplexColumnVector_fill2(self, val, r1, r2)
    }
    #[inline]
    pub unsafe fn fill3(&mut self, val: *const Complex, r1: octave_idx_type,
                        r2: octave_idx_type) -> *mut ComplexColumnVector {
        ComplexColumnVector_fill3(self, val, r1, r2)
    }
    #[inline]
    pub unsafe fn stack(&self, a: *const ColumnVector)
     -> ComplexColumnVector {
        ComplexColumnVector_stack(self, a)
    }
    #[inline]
    pub unsafe fn stack1(&self, a: *const ComplexColumnVector)
     -> ComplexColumnVector {
        ComplexColumnVector_stack1(self, a)
    }
    #[inline]
    pub unsafe fn hermitian(&self) -> ComplexRowVector {
        ComplexColumnVector_hermitian(self)
    }
    #[inline]
    pub unsafe fn transpose(&self) -> ComplexRowVector {
        ComplexColumnVector_transpose(self)
    }
    #[inline]
    pub unsafe fn extract(&self, r1: octave_idx_type, r2: octave_idx_type)
     -> ComplexColumnVector {
        ComplexColumnVector_extract(self, r1, r2)
    }
    #[inline]
    pub unsafe fn extract_n(&self, r1: octave_idx_type, n: octave_idx_type)
     -> ComplexColumnVector {
        ComplexColumnVector_extract_n(self, r1, n)
    }
    #[inline]
    pub unsafe fn min(&self) -> Complex { ComplexColumnVector_min(self) }
    #[inline]
    pub unsafe fn max(&self) -> Complex { ComplexColumnVector_max(self) }
    #[inline]
    pub unsafe fn abs(&self) -> ColumnVector { ComplexColumnVector_abs(self) }
    #[inline]
    pub unsafe fn new(a: *const ColumnVector) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        ComplexColumnVector_ComplexColumnVector(&mut __bindgen_tmp, a);
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct FloatColumnVector {
    pub _base: MArray<f32>,
}
#[test]
fn bindgen_test_layout_FloatColumnVector() {
    assert_eq!(::std::mem::size_of::<FloatColumnVector>() , 40usize , concat !
               ( "Size of: " , stringify ! ( FloatColumnVector ) ));
    assert_eq! (::std::mem::align_of::<FloatColumnVector>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( FloatColumnVector ) ));
}
extern "C" {
    #[link_name = "?insert@FloatColumnVector@@QEAAAEAV1@AEBV1@H@Z"]
    pub fn FloatColumnVector_insert(this: *mut FloatColumnVector,
                                    a: *const FloatColumnVector,
                                    r: octave_idx_type)
     -> *mut FloatColumnVector;
}
extern "C" {
    #[link_name = "?fill@FloatColumnVector@@QEAAAEAV1@M@Z"]
    pub fn FloatColumnVector_fill(this: *mut FloatColumnVector, val: f32)
     -> *mut FloatColumnVector;
}
extern "C" {
    #[link_name = "?fill@FloatColumnVector@@QEAAAEAV1@MHH@Z"]
    pub fn FloatColumnVector_fill1(this: *mut FloatColumnVector, val: f32,
                                   r1: octave_idx_type, r2: octave_idx_type)
     -> *mut FloatColumnVector;
}
extern "C" {
    #[link_name = "?stack@FloatColumnVector@@QEBA?AV1@AEBV1@@Z"]
    pub fn FloatColumnVector_stack(this: *const FloatColumnVector,
                                   a: *const FloatColumnVector)
     -> FloatColumnVector;
}
extern "C" {
    #[link_name = "?transpose@FloatColumnVector@@QEBA?AVFloatRowVector@@XZ"]
    pub fn FloatColumnVector_transpose(this: *const FloatColumnVector)
     -> FloatRowVector;
}
extern "C" {
    #[link_name = "?extract@FloatColumnVector@@QEBA?AV1@HH@Z"]
    pub fn FloatColumnVector_extract(this: *const FloatColumnVector,
                                     r1: octave_idx_type, r2: octave_idx_type)
     -> FloatColumnVector;
}
extern "C" {
    #[link_name = "?extract_n@FloatColumnVector@@QEBA?AV1@HH@Z"]
    pub fn FloatColumnVector_extract_n(this: *const FloatColumnVector,
                                       r1: octave_idx_type,
                                       n: octave_idx_type)
     -> FloatColumnVector;
}
extern "C" {
    #[link_name = "?min@FloatColumnVector@@QEBAMXZ"]
    pub fn FloatColumnVector_min(this: *const FloatColumnVector) -> f32;
}
extern "C" {
    #[link_name = "?max@FloatColumnVector@@QEBAMXZ"]
    pub fn FloatColumnVector_max(this: *const FloatColumnVector) -> f32;
}
extern "C" {
    #[link_name = "?abs@FloatColumnVector@@QEBA?AV1@XZ"]
    pub fn FloatColumnVector_abs(this: *const FloatColumnVector)
     -> FloatColumnVector;
}
impl FloatColumnVector {
    #[inline]
    pub unsafe fn insert(&mut self, a: *const FloatColumnVector,
                         r: octave_idx_type) -> *mut FloatColumnVector {
        FloatColumnVector_insert(self, a, r)
    }
    #[inline]
    pub unsafe fn fill(&mut self, val: f32) -> *mut FloatColumnVector {
        FloatColumnVector_fill(self, val)
    }
    #[inline]
    pub unsafe fn fill1(&mut self, val: f32, r1: octave_idx_type,
                        r2: octave_idx_type) -> *mut FloatColumnVector {
        FloatColumnVector_fill1(self, val, r1, r2)
    }
    #[inline]
    pub unsafe fn stack(&self, a: *const FloatColumnVector)
     -> FloatColumnVector {
        FloatColumnVector_stack(self, a)
    }
    #[inline]
    pub unsafe fn transpose(&self) -> FloatRowVector {
        FloatColumnVector_transpose(self)
    }
    #[inline]
    pub unsafe fn extract(&self, r1: octave_idx_type, r2: octave_idx_type)
     -> FloatColumnVector {
        FloatColumnVector_extract(self, r1, r2)
    }
    #[inline]
    pub unsafe fn extract_n(&self, r1: octave_idx_type, n: octave_idx_type)
     -> FloatColumnVector {
        FloatColumnVector_extract_n(self, r1, n)
    }
    #[inline]
    pub unsafe fn min(&self) -> f32 { FloatColumnVector_min(self) }
    #[inline]
    pub unsafe fn max(&self) -> f32 { FloatColumnVector_max(self) }
    #[inline]
    pub unsafe fn abs(&self) -> FloatColumnVector {
        FloatColumnVector_abs(self)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct FloatComplexColumnVector {
    pub _base: MArray<std_complex<f32>>,
}
#[test]
fn bindgen_test_layout_FloatComplexColumnVector() {
    assert_eq!(::std::mem::size_of::<FloatComplexColumnVector>() , 40usize ,
               concat ! (
               "Size of: " , stringify ! ( FloatComplexColumnVector ) ));
    assert_eq! (::std::mem::align_of::<FloatComplexColumnVector>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( FloatComplexColumnVector ) ));
}
extern "C" {
    #[link_name =
          "?insert@FloatComplexColumnVector@@QEAAAEAV1@AEBVFloatColumnVector@@H@Z"]
    pub fn FloatComplexColumnVector_insert(this:
                                               *mut FloatComplexColumnVector,
                                           a: *const FloatColumnVector,
                                           r: octave_idx_type)
     -> *mut FloatComplexColumnVector;
}
extern "C" {
    #[link_name = "?insert@FloatComplexColumnVector@@QEAAAEAV1@AEBV1@H@Z"]
    pub fn FloatComplexColumnVector_insert1(this:
                                                *mut FloatComplexColumnVector,
                                            a:
                                                *const FloatComplexColumnVector,
                                            r: octave_idx_type)
     -> *mut FloatComplexColumnVector;
}
extern "C" {
    #[link_name = "?fill@FloatComplexColumnVector@@QEAAAEAV1@M@Z"]
    pub fn FloatComplexColumnVector_fill(this: *mut FloatComplexColumnVector,
                                         val: f32)
     -> *mut FloatComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?fill@FloatComplexColumnVector@@QEAAAEAV1@AEBU?$complex@M@std@@@Z"]
    pub fn FloatComplexColumnVector_fill1(this: *mut FloatComplexColumnVector,
                                          val: *const FloatComplex)
     -> *mut FloatComplexColumnVector;
}
extern "C" {
    #[link_name = "?fill@FloatComplexColumnVector@@QEAAAEAV1@MHH@Z"]
    pub fn FloatComplexColumnVector_fill2(this: *mut FloatComplexColumnVector,
                                          val: f32, r1: octave_idx_type,
                                          r2: octave_idx_type)
     -> *mut FloatComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?fill@FloatComplexColumnVector@@QEAAAEAV1@AEBU?$complex@M@std@@HH@Z"]
    pub fn FloatComplexColumnVector_fill3(this: *mut FloatComplexColumnVector,
                                          val: *const FloatComplex,
                                          r1: octave_idx_type,
                                          r2: octave_idx_type)
     -> *mut FloatComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?stack@FloatComplexColumnVector@@QEBA?AV1@AEBVFloatColumnVector@@@Z"]
    pub fn FloatComplexColumnVector_stack(this:
                                              *const FloatComplexColumnVector,
                                          a: *const FloatColumnVector)
     -> FloatComplexColumnVector;
}
extern "C" {
    #[link_name = "?stack@FloatComplexColumnVector@@QEBA?AV1@AEBV1@@Z"]
    pub fn FloatComplexColumnVector_stack1(this:
                                               *const FloatComplexColumnVector,
                                           a: *const FloatComplexColumnVector)
     -> FloatComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?hermitian@FloatComplexColumnVector@@QEBA?AVFloatComplexRowVector@@XZ"]
    pub fn FloatComplexColumnVector_hermitian(this:
                                                  *const FloatComplexColumnVector)
     -> FloatComplexRowVector;
}
extern "C" {
    #[link_name =
          "?transpose@FloatComplexColumnVector@@QEBA?AVFloatComplexRowVector@@XZ"]
    pub fn FloatComplexColumnVector_transpose(this:
                                                  *const FloatComplexColumnVector)
     -> FloatComplexRowVector;
}
extern "C" {
    #[link_name = "?extract@FloatComplexColumnVector@@QEBA?AV1@HH@Z"]
    pub fn FloatComplexColumnVector_extract(this:
                                                *const FloatComplexColumnVector,
                                            r1: octave_idx_type,
                                            r2: octave_idx_type)
     -> FloatComplexColumnVector;
}
extern "C" {
    #[link_name = "?extract_n@FloatComplexColumnVector@@QEBA?AV1@HH@Z"]
    pub fn FloatComplexColumnVector_extract_n(this:
                                                  *const FloatComplexColumnVector,
                                              r1: octave_idx_type,
                                              n: octave_idx_type)
     -> FloatComplexColumnVector;
}
extern "C" {
    #[link_name = "?min@FloatComplexColumnVector@@QEBA?AU?$complex@M@std@@XZ"]
    pub fn FloatComplexColumnVector_min(this: *const FloatComplexColumnVector)
     -> FloatComplex;
}
extern "C" {
    #[link_name = "?max@FloatComplexColumnVector@@QEBA?AU?$complex@M@std@@XZ"]
    pub fn FloatComplexColumnVector_max(this: *const FloatComplexColumnVector)
     -> FloatComplex;
}
extern "C" {
    #[link_name =
          "?abs@FloatComplexColumnVector@@QEBA?AVFloatColumnVector@@XZ"]
    pub fn FloatComplexColumnVector_abs(this: *const FloatComplexColumnVector)
     -> FloatColumnVector;
}
extern "C" {
    #[link_name =
          "??0FloatComplexColumnVector@@QEAA@AEBVFloatColumnVector@@@Z"]
    pub fn FloatComplexColumnVector_FloatComplexColumnVector(this:
                                                                 *mut FloatComplexColumnVector,
                                                             a:
                                                                 *const FloatColumnVector);
}
impl FloatComplexColumnVector {
    #[inline]
    pub unsafe fn insert(&mut self, a: *const FloatColumnVector,
                         r: octave_idx_type)
     -> *mut FloatComplexColumnVector {
        FloatComplexColumnVector_insert(self, a, r)
    }
    #[inline]
    pub unsafe fn insert1(&mut self, a: *const FloatComplexColumnVector,
                          r: octave_idx_type)
     -> *mut FloatComplexColumnVector {
        FloatComplexColumnVector_insert1(self, a, r)
    }
    #[inline]
    pub unsafe fn fill(&mut self, val: f32) -> *mut FloatComplexColumnVector {
        FloatComplexColumnVector_fill(self, val)
    }
    #[inline]
    pub unsafe fn fill1(&mut self, val: *const FloatComplex)
     -> *mut FloatComplexColumnVector {
        FloatComplexColumnVector_fill1(self, val)
    }
    #[inline]
    pub unsafe fn fill2(&mut self, val: f32, r1: octave_idx_type,
                        r2: octave_idx_type)
     -> *mut FloatComplexColumnVector {
        FloatComplexColumnVector_fill2(self, val, r1, r2)
    }
    #[inline]
    pub unsafe fn fill3(&mut self, val: *const FloatComplex,
                        r1: octave_idx_type, r2: octave_idx_type)
     -> *mut FloatComplexColumnVector {
        FloatComplexColumnVector_fill3(self, val, r1, r2)
    }
    #[inline]
    pub unsafe fn stack(&self, a: *const FloatColumnVector)
     -> FloatComplexColumnVector {
        FloatComplexColumnVector_stack(self, a)
    }
    #[inline]
    pub unsafe fn stack1(&self, a: *const FloatComplexColumnVector)
     -> FloatComplexColumnVector {
        FloatComplexColumnVector_stack1(self, a)
    }
    #[inline]
    pub unsafe fn hermitian(&self) -> FloatComplexRowVector {
        FloatComplexColumnVector_hermitian(self)
    }
    #[inline]
    pub unsafe fn transpose(&self) -> FloatComplexRowVector {
        FloatComplexColumnVector_transpose(self)
    }
    #[inline]
    pub unsafe fn extract(&self, r1: octave_idx_type, r2: octave_idx_type)
     -> FloatComplexColumnVector {
        FloatComplexColumnVector_extract(self, r1, r2)
    }
    #[inline]
    pub unsafe fn extract_n(&self, r1: octave_idx_type, n: octave_idx_type)
     -> FloatComplexColumnVector {
        FloatComplexColumnVector_extract_n(self, r1, n)
    }
    #[inline]
    pub unsafe fn min(&self) -> FloatComplex {
        FloatComplexColumnVector_min(self)
    }
    #[inline]
    pub unsafe fn max(&self) -> FloatComplex {
        FloatComplexColumnVector_max(self)
    }
    #[inline]
    pub unsafe fn abs(&self) -> FloatColumnVector {
        FloatComplexColumnVector_abs(self)
    }
    #[inline]
    pub unsafe fn new(a: *const FloatColumnVector) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        FloatComplexColumnVector_FloatComplexColumnVector(&mut __bindgen_tmp,
                                                          a);
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct RowVector {
    pub _base: MArray<f64>,
}
#[test]
fn bindgen_test_layout_RowVector() {
    assert_eq!(::std::mem::size_of::<RowVector>() , 40usize , concat ! (
               "Size of: " , stringify ! ( RowVector ) ));
    assert_eq! (::std::mem::align_of::<RowVector>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( RowVector ) ));
}
extern "C" {
    #[link_name = "?insert@RowVector@@QEAAAEAV1@AEBV1@H@Z"]
    pub fn RowVector_insert(this: *mut RowVector, a: *const RowVector,
                            c: octave_idx_type) -> *mut RowVector;
}
extern "C" {
    #[link_name = "?fill@RowVector@@QEAAAEAV1@N@Z"]
    pub fn RowVector_fill(this: *mut RowVector, val: f64) -> *mut RowVector;
}
extern "C" {
    #[link_name = "?fill@RowVector@@QEAAAEAV1@NHH@Z"]
    pub fn RowVector_fill1(this: *mut RowVector, val: f64,
                           c1: octave_idx_type, c2: octave_idx_type)
     -> *mut RowVector;
}
extern "C" {
    #[link_name = "?append@RowVector@@QEBA?AV1@AEBV1@@Z"]
    pub fn RowVector_append(this: *const RowVector, a: *const RowVector)
     -> RowVector;
}
extern "C" {
    #[link_name = "?transpose@RowVector@@QEBA?AVColumnVector@@XZ"]
    pub fn RowVector_transpose(this: *const RowVector) -> ColumnVector;
}
extern "C" {
    #[link_name = "?extract@RowVector@@QEBA?AV1@HH@Z"]
    pub fn RowVector_extract(this: *const RowVector, c1: octave_idx_type,
                             c2: octave_idx_type) -> RowVector;
}
extern "C" {
    #[link_name = "?extract_n@RowVector@@QEBA?AV1@HH@Z"]
    pub fn RowVector_extract_n(this: *const RowVector, c1: octave_idx_type,
                               n: octave_idx_type) -> RowVector;
}
extern "C" {
    #[link_name = "?min@RowVector@@QEBANXZ"]
    pub fn RowVector_min(this: *const RowVector) -> f64;
}
extern "C" {
    #[link_name = "?max@RowVector@@QEBANXZ"]
    pub fn RowVector_max(this: *const RowVector) -> f64;
}
impl RowVector {
    #[inline]
    pub unsafe fn insert(&mut self, a: *const RowVector, c: octave_idx_type)
     -> *mut RowVector {
        RowVector_insert(self, a, c)
    }
    #[inline]
    pub unsafe fn fill(&mut self, val: f64) -> *mut RowVector {
        RowVector_fill(self, val)
    }
    #[inline]
    pub unsafe fn fill1(&mut self, val: f64, c1: octave_idx_type,
                        c2: octave_idx_type) -> *mut RowVector {
        RowVector_fill1(self, val, c1, c2)
    }
    #[inline]
    pub unsafe fn append(&self, a: *const RowVector) -> RowVector {
        RowVector_append(self, a)
    }
    #[inline]
    pub unsafe fn transpose(&self) -> ColumnVector {
        RowVector_transpose(self)
    }
    #[inline]
    pub unsafe fn extract(&self, c1: octave_idx_type, c2: octave_idx_type)
     -> RowVector {
        RowVector_extract(self, c1, c2)
    }
    #[inline]
    pub unsafe fn extract_n(&self, c1: octave_idx_type, n: octave_idx_type)
     -> RowVector {
        RowVector_extract_n(self, c1, n)
    }
    #[inline]
    pub unsafe fn min(&self) -> f64 { RowVector_min(self) }
    #[inline]
    pub unsafe fn max(&self) -> f64 { RowVector_max(self) }
}
#[repr(C)]
#[derive(Debug)]
pub struct ComplexRowVector {
    pub _base: MArray<std_complex<f64>>,
}
#[test]
fn bindgen_test_layout_ComplexRowVector() {
    assert_eq!(::std::mem::size_of::<ComplexRowVector>() , 40usize , concat !
               ( "Size of: " , stringify ! ( ComplexRowVector ) ));
    assert_eq! (::std::mem::align_of::<ComplexRowVector>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( ComplexRowVector ) ));
}
extern "C" {
    #[link_name = "?insert@ComplexRowVector@@QEAAAEAV1@AEBVRowVector@@H@Z"]
    pub fn ComplexRowVector_insert(this: *mut ComplexRowVector,
                                   a: *const RowVector, c: octave_idx_type)
     -> *mut ComplexRowVector;
}
extern "C" {
    #[link_name = "?insert@ComplexRowVector@@QEAAAEAV1@AEBV1@H@Z"]
    pub fn ComplexRowVector_insert1(this: *mut ComplexRowVector,
                                    a: *const ComplexRowVector,
                                    c: octave_idx_type)
     -> *mut ComplexRowVector;
}
extern "C" {
    #[link_name = "?fill@ComplexRowVector@@QEAAAEAV1@N@Z"]
    pub fn ComplexRowVector_fill(this: *mut ComplexRowVector, val: f64)
     -> *mut ComplexRowVector;
}
extern "C" {
    #[link_name = "?fill@ComplexRowVector@@QEAAAEAV1@AEBU?$complex@N@std@@@Z"]
    pub fn ComplexRowVector_fill1(this: *mut ComplexRowVector,
                                  val: *const Complex)
     -> *mut ComplexRowVector;
}
extern "C" {
    #[link_name = "?fill@ComplexRowVector@@QEAAAEAV1@NHH@Z"]
    pub fn ComplexRowVector_fill2(this: *mut ComplexRowVector, val: f64,
                                  c1: octave_idx_type, c2: octave_idx_type)
     -> *mut ComplexRowVector;
}
extern "C" {
    #[link_name =
          "?fill@ComplexRowVector@@QEAAAEAV1@AEBU?$complex@N@std@@HH@Z"]
    pub fn ComplexRowVector_fill3(this: *mut ComplexRowVector,
                                  val: *const Complex, c1: octave_idx_type,
                                  c2: octave_idx_type)
     -> *mut ComplexRowVector;
}
extern "C" {
    #[link_name = "?append@ComplexRowVector@@QEBA?AV1@AEBVRowVector@@@Z"]
    pub fn ComplexRowVector_append(this: *const ComplexRowVector,
                                   a: *const RowVector) -> ComplexRowVector;
}
extern "C" {
    #[link_name = "?append@ComplexRowVector@@QEBA?AV1@AEBV1@@Z"]
    pub fn ComplexRowVector_append1(this: *const ComplexRowVector,
                                    a: *const ComplexRowVector)
     -> ComplexRowVector;
}
extern "C" {
    #[link_name =
          "?hermitian@ComplexRowVector@@QEBA?AVComplexColumnVector@@XZ"]
    pub fn ComplexRowVector_hermitian(this: *const ComplexRowVector)
     -> ComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?transpose@ComplexRowVector@@QEBA?AVComplexColumnVector@@XZ"]
    pub fn ComplexRowVector_transpose(this: *const ComplexRowVector)
     -> ComplexColumnVector;
}
extern "C" {
    #[link_name = "?extract@ComplexRowVector@@QEBA?AV1@HH@Z"]
    pub fn ComplexRowVector_extract(this: *const ComplexRowVector,
                                    c1: octave_idx_type, c2: octave_idx_type)
     -> ComplexRowVector;
}
extern "C" {
    #[link_name = "?extract_n@ComplexRowVector@@QEBA?AV1@HH@Z"]
    pub fn ComplexRowVector_extract_n(this: *const ComplexRowVector,
                                      c1: octave_idx_type, n: octave_idx_type)
     -> ComplexRowVector;
}
extern "C" {
    #[link_name = "?min@ComplexRowVector@@QEBA?AU?$complex@N@std@@XZ"]
    pub fn ComplexRowVector_min(this: *const ComplexRowVector) -> Complex;
}
extern "C" {
    #[link_name = "?max@ComplexRowVector@@QEBA?AU?$complex@N@std@@XZ"]
    pub fn ComplexRowVector_max(this: *const ComplexRowVector) -> Complex;
}
impl ComplexRowVector {
    #[inline]
    pub unsafe fn insert(&mut self, a: *const RowVector, c: octave_idx_type)
     -> *mut ComplexRowVector {
        ComplexRowVector_insert(self, a, c)
    }
    #[inline]
    pub unsafe fn insert1(&mut self, a: *const ComplexRowVector,
                          c: octave_idx_type) -> *mut ComplexRowVector {
        ComplexRowVector_insert1(self, a, c)
    }
    #[inline]
    pub unsafe fn fill(&mut self, val: f64) -> *mut ComplexRowVector {
        ComplexRowVector_fill(self, val)
    }
    #[inline]
    pub unsafe fn fill1(&mut self, val: *const Complex)
     -> *mut ComplexRowVector {
        ComplexRowVector_fill1(self, val)
    }
    #[inline]
    pub unsafe fn fill2(&mut self, val: f64, c1: octave_idx_type,
                        c2: octave_idx_type) -> *mut ComplexRowVector {
        ComplexRowVector_fill2(self, val, c1, c2)
    }
    #[inline]
    pub unsafe fn fill3(&mut self, val: *const Complex, c1: octave_idx_type,
                        c2: octave_idx_type) -> *mut ComplexRowVector {
        ComplexRowVector_fill3(self, val, c1, c2)
    }
    #[inline]
    pub unsafe fn append(&self, a: *const RowVector) -> ComplexRowVector {
        ComplexRowVector_append(self, a)
    }
    #[inline]
    pub unsafe fn append1(&self, a: *const ComplexRowVector)
     -> ComplexRowVector {
        ComplexRowVector_append1(self, a)
    }
    #[inline]
    pub unsafe fn hermitian(&self) -> ComplexColumnVector {
        ComplexRowVector_hermitian(self)
    }
    #[inline]
    pub unsafe fn transpose(&self) -> ComplexColumnVector {
        ComplexRowVector_transpose(self)
    }
    #[inline]
    pub unsafe fn extract(&self, c1: octave_idx_type, c2: octave_idx_type)
     -> ComplexRowVector {
        ComplexRowVector_extract(self, c1, c2)
    }
    #[inline]
    pub unsafe fn extract_n(&self, c1: octave_idx_type, n: octave_idx_type)
     -> ComplexRowVector {
        ComplexRowVector_extract_n(self, c1, n)
    }
    #[inline]
    pub unsafe fn min(&self) -> Complex { ComplexRowVector_min(self) }
    #[inline]
    pub unsafe fn max(&self) -> Complex { ComplexRowVector_max(self) }
}
#[repr(C)]
#[derive(Debug)]
pub struct FloatRowVector {
    pub _base: MArray<f32>,
}
#[test]
fn bindgen_test_layout_FloatRowVector() {
    assert_eq!(::std::mem::size_of::<FloatRowVector>() , 40usize , concat ! (
               "Size of: " , stringify ! ( FloatRowVector ) ));
    assert_eq! (::std::mem::align_of::<FloatRowVector>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( FloatRowVector ) ));
}
extern "C" {
    #[link_name = "?insert@FloatRowVector@@QEAAAEAV1@AEBV1@H@Z"]
    pub fn FloatRowVector_insert(this: *mut FloatRowVector,
                                 a: *const FloatRowVector, c: octave_idx_type)
     -> *mut FloatRowVector;
}
extern "C" {
    #[link_name = "?fill@FloatRowVector@@QEAAAEAV1@M@Z"]
    pub fn FloatRowVector_fill(this: *mut FloatRowVector, val: f32)
     -> *mut FloatRowVector;
}
extern "C" {
    #[link_name = "?fill@FloatRowVector@@QEAAAEAV1@MHH@Z"]
    pub fn FloatRowVector_fill1(this: *mut FloatRowVector, val: f32,
                                c1: octave_idx_type, c2: octave_idx_type)
     -> *mut FloatRowVector;
}
extern "C" {
    #[link_name = "?append@FloatRowVector@@QEBA?AV1@AEBV1@@Z"]
    pub fn FloatRowVector_append(this: *const FloatRowVector,
                                 a: *const FloatRowVector) -> FloatRowVector;
}
extern "C" {
    #[link_name = "?transpose@FloatRowVector@@QEBA?AVFloatColumnVector@@XZ"]
    pub fn FloatRowVector_transpose(this: *const FloatRowVector)
     -> FloatColumnVector;
}
extern "C" {
    #[link_name = "?extract@FloatRowVector@@QEBA?AV1@HH@Z"]
    pub fn FloatRowVector_extract(this: *const FloatRowVector,
                                  c1: octave_idx_type, c2: octave_idx_type)
     -> FloatRowVector;
}
extern "C" {
    #[link_name = "?extract_n@FloatRowVector@@QEBA?AV1@HH@Z"]
    pub fn FloatRowVector_extract_n(this: *const FloatRowVector,
                                    c1: octave_idx_type, n: octave_idx_type)
     -> FloatRowVector;
}
extern "C" {
    #[link_name = "?min@FloatRowVector@@QEBAMXZ"]
    pub fn FloatRowVector_min(this: *const FloatRowVector) -> f32;
}
extern "C" {
    #[link_name = "?max@FloatRowVector@@QEBAMXZ"]
    pub fn FloatRowVector_max(this: *const FloatRowVector) -> f32;
}
impl FloatRowVector {
    #[inline]
    pub unsafe fn insert(&mut self, a: *const FloatRowVector,
                         c: octave_idx_type) -> *mut FloatRowVector {
        FloatRowVector_insert(self, a, c)
    }
    #[inline]
    pub unsafe fn fill(&mut self, val: f32) -> *mut FloatRowVector {
        FloatRowVector_fill(self, val)
    }
    #[inline]
    pub unsafe fn fill1(&mut self, val: f32, c1: octave_idx_type,
                        c2: octave_idx_type) -> *mut FloatRowVector {
        FloatRowVector_fill1(self, val, c1, c2)
    }
    #[inline]
    pub unsafe fn append(&self, a: *const FloatRowVector) -> FloatRowVector {
        FloatRowVector_append(self, a)
    }
    #[inline]
    pub unsafe fn transpose(&self) -> FloatColumnVector {
        FloatRowVector_transpose(self)
    }
    #[inline]
    pub unsafe fn extract(&self, c1: octave_idx_type, c2: octave_idx_type)
     -> FloatRowVector {
        FloatRowVector_extract(self, c1, c2)
    }
    #[inline]
    pub unsafe fn extract_n(&self, c1: octave_idx_type, n: octave_idx_type)
     -> FloatRowVector {
        FloatRowVector_extract_n(self, c1, n)
    }
    #[inline]
    pub unsafe fn min(&self) -> f32 { FloatRowVector_min(self) }
    #[inline]
    pub unsafe fn max(&self) -> f32 { FloatRowVector_max(self) }
}
#[repr(C)]
#[derive(Debug)]
pub struct FloatComplexRowVector {
    pub _base: MArray<std_complex<f32>>,
}
#[test]
fn bindgen_test_layout_FloatComplexRowVector() {
    assert_eq!(::std::mem::size_of::<FloatComplexRowVector>() , 40usize ,
               concat ! ( "Size of: " , stringify ! ( FloatComplexRowVector )
               ));
    assert_eq! (::std::mem::align_of::<FloatComplexRowVector>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( FloatComplexRowVector ) ));
}
extern "C" {
    #[link_name =
          "?insert@FloatComplexRowVector@@QEAAAEAV1@AEBVFloatRowVector@@H@Z"]
    pub fn FloatComplexRowVector_insert(this: *mut FloatComplexRowVector,
                                        a: *const FloatRowVector,
                                        c: octave_idx_type)
     -> *mut FloatComplexRowVector;
}
extern "C" {
    #[link_name = "?insert@FloatComplexRowVector@@QEAAAEAV1@AEBV1@H@Z"]
    pub fn FloatComplexRowVector_insert1(this: *mut FloatComplexRowVector,
                                         a: *const FloatComplexRowVector,
                                         c: octave_idx_type)
     -> *mut FloatComplexRowVector;
}
extern "C" {
    #[link_name = "?fill@FloatComplexRowVector@@QEAAAEAV1@M@Z"]
    pub fn FloatComplexRowVector_fill(this: *mut FloatComplexRowVector,
                                      val: f32) -> *mut FloatComplexRowVector;
}
extern "C" {
    #[link_name =
          "?fill@FloatComplexRowVector@@QEAAAEAV1@AEBU?$complex@M@std@@@Z"]
    pub fn FloatComplexRowVector_fill1(this: *mut FloatComplexRowVector,
                                       val: *const FloatComplex)
     -> *mut FloatComplexRowVector;
}
extern "C" {
    #[link_name = "?fill@FloatComplexRowVector@@QEAAAEAV1@MHH@Z"]
    pub fn FloatComplexRowVector_fill2(this: *mut FloatComplexRowVector,
                                       val: f32, c1: octave_idx_type,
                                       c2: octave_idx_type)
     -> *mut FloatComplexRowVector;
}
extern "C" {
    #[link_name =
          "?fill@FloatComplexRowVector@@QEAAAEAV1@AEBU?$complex@M@std@@HH@Z"]
    pub fn FloatComplexRowVector_fill3(this: *mut FloatComplexRowVector,
                                       val: *const FloatComplex,
                                       c1: octave_idx_type,
                                       c2: octave_idx_type)
     -> *mut FloatComplexRowVector;
}
extern "C" {
    #[link_name =
          "?append@FloatComplexRowVector@@QEBA?AV1@AEBVFloatRowVector@@@Z"]
    pub fn FloatComplexRowVector_append(this: *const FloatComplexRowVector,
                                        a: *const FloatRowVector)
     -> FloatComplexRowVector;
}
extern "C" {
    #[link_name = "?append@FloatComplexRowVector@@QEBA?AV1@AEBV1@@Z"]
    pub fn FloatComplexRowVector_append1(this: *const FloatComplexRowVector,
                                         a: *const FloatComplexRowVector)
     -> FloatComplexRowVector;
}
extern "C" {
    #[link_name =
          "?hermitian@FloatComplexRowVector@@QEBA?AVFloatComplexColumnVector@@XZ"]
    pub fn FloatComplexRowVector_hermitian(this: *const FloatComplexRowVector)
     -> FloatComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?transpose@FloatComplexRowVector@@QEBA?AVFloatComplexColumnVector@@XZ"]
    pub fn FloatComplexRowVector_transpose(this: *const FloatComplexRowVector)
     -> FloatComplexColumnVector;
}
extern "C" {
    #[link_name = "?extract@FloatComplexRowVector@@QEBA?AV1@HH@Z"]
    pub fn FloatComplexRowVector_extract(this: *const FloatComplexRowVector,
                                         c1: octave_idx_type,
                                         c2: octave_idx_type)
     -> FloatComplexRowVector;
}
extern "C" {
    #[link_name = "?extract_n@FloatComplexRowVector@@QEBA?AV1@HH@Z"]
    pub fn FloatComplexRowVector_extract_n(this: *const FloatComplexRowVector,
                                           c1: octave_idx_type,
                                           n: octave_idx_type)
     -> FloatComplexRowVector;
}
extern "C" {
    #[link_name = "?min@FloatComplexRowVector@@QEBA?AU?$complex@M@std@@XZ"]
    pub fn FloatComplexRowVector_min(this: *const FloatComplexRowVector)
     -> FloatComplex;
}
extern "C" {
    #[link_name = "?max@FloatComplexRowVector@@QEBA?AU?$complex@M@std@@XZ"]
    pub fn FloatComplexRowVector_max(this: *const FloatComplexRowVector)
     -> FloatComplex;
}
impl FloatComplexRowVector {
    #[inline]
    pub unsafe fn insert(&mut self, a: *const FloatRowVector,
                         c: octave_idx_type) -> *mut FloatComplexRowVector {
        FloatComplexRowVector_insert(self, a, c)
    }
    #[inline]
    pub unsafe fn insert1(&mut self, a: *const FloatComplexRowVector,
                          c: octave_idx_type) -> *mut FloatComplexRowVector {
        FloatComplexRowVector_insert1(self, a, c)
    }
    #[inline]
    pub unsafe fn fill(&mut self, val: f32) -> *mut FloatComplexRowVector {
        FloatComplexRowVector_fill(self, val)
    }
    #[inline]
    pub unsafe fn fill1(&mut self, val: *const FloatComplex)
     -> *mut FloatComplexRowVector {
        FloatComplexRowVector_fill1(self, val)
    }
    #[inline]
    pub unsafe fn fill2(&mut self, val: f32, c1: octave_idx_type,
                        c2: octave_idx_type) -> *mut FloatComplexRowVector {
        FloatComplexRowVector_fill2(self, val, c1, c2)
    }
    #[inline]
    pub unsafe fn fill3(&mut self, val: *const FloatComplex,
                        c1: octave_idx_type, c2: octave_idx_type)
     -> *mut FloatComplexRowVector {
        FloatComplexRowVector_fill3(self, val, c1, c2)
    }
    #[inline]
    pub unsafe fn append(&self, a: *const FloatRowVector)
     -> FloatComplexRowVector {
        FloatComplexRowVector_append(self, a)
    }
    #[inline]
    pub unsafe fn append1(&self, a: *const FloatComplexRowVector)
     -> FloatComplexRowVector {
        FloatComplexRowVector_append1(self, a)
    }
    #[inline]
    pub unsafe fn hermitian(&self) -> FloatComplexColumnVector {
        FloatComplexRowVector_hermitian(self)
    }
    #[inline]
    pub unsafe fn transpose(&self) -> FloatComplexColumnVector {
        FloatComplexRowVector_transpose(self)
    }
    #[inline]
    pub unsafe fn extract(&self, c1: octave_idx_type, c2: octave_idx_type)
     -> FloatComplexRowVector {
        FloatComplexRowVector_extract(self, c1, c2)
    }
    #[inline]
    pub unsafe fn extract_n(&self, c1: octave_idx_type, n: octave_idx_type)
     -> FloatComplexRowVector {
        FloatComplexRowVector_extract_n(self, c1, n)
    }
    #[inline]
    pub unsafe fn min(&self) -> FloatComplex {
        FloatComplexRowVector_min(self)
    }
    #[inline]
    pub unsafe fn max(&self) -> FloatComplex {
        FloatComplexRowVector_max(self)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct DiagMatrix {
    pub _base: MDiagArray2<f64>,
}
#[test]
fn bindgen_test_layout_DiagMatrix() {
    assert_eq!(::std::mem::size_of::<DiagMatrix>() , 48usize , concat ! (
               "Size of: " , stringify ! ( DiagMatrix ) ));
    assert_eq! (::std::mem::align_of::<DiagMatrix>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( DiagMatrix ) ));
}
extern "C" {
    #[link_name = "?fill@DiagMatrix@@QEAAAEAV1@N@Z"]
    pub fn DiagMatrix_fill(this: *mut DiagMatrix, val: f64)
     -> *mut DiagMatrix;
}
extern "C" {
    #[link_name = "?fill@DiagMatrix@@QEAAAEAV1@NHH@Z"]
    pub fn DiagMatrix_fill1(this: *mut DiagMatrix, val: f64,
                            beg: octave_idx_type, end: octave_idx_type)
     -> *mut DiagMatrix;
}
extern "C" {
    #[link_name = "?fill@DiagMatrix@@QEAAAEAV1@AEBVColumnVector@@@Z"]
    pub fn DiagMatrix_fill2(this: *mut DiagMatrix, a: *const ColumnVector)
     -> *mut DiagMatrix;
}
extern "C" {
    #[link_name = "?fill@DiagMatrix@@QEAAAEAV1@AEBVRowVector@@@Z"]
    pub fn DiagMatrix_fill3(this: *mut DiagMatrix, a: *const RowVector)
     -> *mut DiagMatrix;
}
extern "C" {
    #[link_name = "?fill@DiagMatrix@@QEAAAEAV1@AEBVColumnVector@@H@Z"]
    pub fn DiagMatrix_fill4(this: *mut DiagMatrix, a: *const ColumnVector,
                            beg: octave_idx_type) -> *mut DiagMatrix;
}
extern "C" {
    #[link_name = "?fill@DiagMatrix@@QEAAAEAV1@AEBVRowVector@@H@Z"]
    pub fn DiagMatrix_fill5(this: *mut DiagMatrix, a: *const RowVector,
                            beg: octave_idx_type) -> *mut DiagMatrix;
}
extern "C" {
    #[link_name = "?abs@DiagMatrix@@QEBA?AV1@XZ"]
    pub fn DiagMatrix_abs(this: *const DiagMatrix) -> DiagMatrix;
}
extern "C" {
    #[link_name = "?extract@DiagMatrix@@QEBA?AVMatrix@@HHHH@Z"]
    pub fn DiagMatrix_extract(this: *const DiagMatrix, r1: octave_idx_type,
                              c1: octave_idx_type, r2: octave_idx_type,
                              c2: octave_idx_type) -> Matrix;
}
extern "C" {
    #[link_name = "?row@DiagMatrix@@QEBA?AVRowVector@@H@Z"]
    pub fn DiagMatrix_row(this: *const DiagMatrix, i: octave_idx_type)
     -> RowVector;
}
extern "C" {
    #[link_name = "?row@DiagMatrix@@QEBA?AVRowVector@@PEAD@Z"]
    pub fn DiagMatrix_row1(this: *const DiagMatrix,
                           s: *mut ::std::os::raw::c_char) -> RowVector;
}
extern "C" {
    #[link_name = "?column@DiagMatrix@@QEBA?AVColumnVector@@H@Z"]
    pub fn DiagMatrix_column(this: *const DiagMatrix, i: octave_idx_type)
     -> ColumnVector;
}
extern "C" {
    #[link_name = "?column@DiagMatrix@@QEBA?AVColumnVector@@PEAD@Z"]
    pub fn DiagMatrix_column1(this: *const DiagMatrix,
                              s: *mut ::std::os::raw::c_char) -> ColumnVector;
}
extern "C" {
    #[link_name = "?inverse@DiagMatrix@@QEBA?AV1@XZ"]
    pub fn DiagMatrix_inverse(this: *const DiagMatrix) -> DiagMatrix;
}
extern "C" {
    #[link_name = "?inverse@DiagMatrix@@QEBA?AV1@AEAH@Z"]
    pub fn DiagMatrix_inverse1(this: *const DiagMatrix,
                               info: *mut octave_idx_type) -> DiagMatrix;
}
extern "C" {
    #[link_name = "?pseudo_inverse@DiagMatrix@@QEBA?AV1@N@Z"]
    pub fn DiagMatrix_pseudo_inverse(this: *const DiagMatrix, tol: f64)
     -> DiagMatrix;
}
extern "C" {
    #[link_name = "?determinant@DiagMatrix@@QEBA?AV?$base_det@N@@XZ"]
    pub fn DiagMatrix_determinant(this: *const DiagMatrix) -> DET;
}
extern "C" {
    #[link_name = "?rcond@DiagMatrix@@QEBANXZ"]
    pub fn DiagMatrix_rcond(this: *const DiagMatrix) -> f64;
}
impl DiagMatrix {
    #[inline]
    pub unsafe fn fill(&mut self, val: f64) -> *mut DiagMatrix {
        DiagMatrix_fill(self, val)
    }
    #[inline]
    pub unsafe fn fill1(&mut self, val: f64, beg: octave_idx_type,
                        end: octave_idx_type) -> *mut DiagMatrix {
        DiagMatrix_fill1(self, val, beg, end)
    }
    #[inline]
    pub unsafe fn fill2(&mut self, a: *const ColumnVector)
     -> *mut DiagMatrix {
        DiagMatrix_fill2(self, a)
    }
    #[inline]
    pub unsafe fn fill3(&mut self, a: *const RowVector) -> *mut DiagMatrix {
        DiagMatrix_fill3(self, a)
    }
    #[inline]
    pub unsafe fn fill4(&mut self, a: *const ColumnVector,
                        beg: octave_idx_type) -> *mut DiagMatrix {
        DiagMatrix_fill4(self, a, beg)
    }
    #[inline]
    pub unsafe fn fill5(&mut self, a: *const RowVector, beg: octave_idx_type)
     -> *mut DiagMatrix {
        DiagMatrix_fill5(self, a, beg)
    }
    #[inline]
    pub unsafe fn abs(&self) -> DiagMatrix { DiagMatrix_abs(self) }
    #[inline]
    pub unsafe fn extract(&self, r1: octave_idx_type, c1: octave_idx_type,
                          r2: octave_idx_type, c2: octave_idx_type)
     -> Matrix {
        DiagMatrix_extract(self, r1, c1, r2, c2)
    }
    #[inline]
    pub unsafe fn row(&self, i: octave_idx_type) -> RowVector {
        DiagMatrix_row(self, i)
    }
    #[inline]
    pub unsafe fn row1(&self, s: *mut ::std::os::raw::c_char) -> RowVector {
        DiagMatrix_row1(self, s)
    }
    #[inline]
    pub unsafe fn column(&self, i: octave_idx_type) -> ColumnVector {
        DiagMatrix_column(self, i)
    }
    #[inline]
    pub unsafe fn column1(&self, s: *mut ::std::os::raw::c_char)
     -> ColumnVector {
        DiagMatrix_column1(self, s)
    }
    #[inline]
    pub unsafe fn inverse(&self) -> DiagMatrix { DiagMatrix_inverse(self) }
    #[inline]
    pub unsafe fn inverse1(&self, info: *mut octave_idx_type) -> DiagMatrix {
        DiagMatrix_inverse1(self, info)
    }
    #[inline]
    pub unsafe fn pseudo_inverse(&self, tol: f64) -> DiagMatrix {
        DiagMatrix_pseudo_inverse(self, tol)
    }
    #[inline]
    pub unsafe fn determinant(&self) -> DET { DiagMatrix_determinant(self) }
    #[inline]
    pub unsafe fn rcond(&self) -> f64 { DiagMatrix_rcond(self) }
}
#[repr(C)]
#[derive(Debug)]
pub struct ComplexDiagMatrix {
    pub _base: MDiagArray2<std_complex<f64>>,
}
#[test]
fn bindgen_test_layout_ComplexDiagMatrix() {
    assert_eq!(::std::mem::size_of::<ComplexDiagMatrix>() , 48usize , concat !
               ( "Size of: " , stringify ! ( ComplexDiagMatrix ) ));
    assert_eq! (::std::mem::align_of::<ComplexDiagMatrix>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( ComplexDiagMatrix ) ));
}
extern "C" {
    #[link_name = "?fill@ComplexDiagMatrix@@QEAAAEAV1@N@Z"]
    pub fn ComplexDiagMatrix_fill(this: *mut ComplexDiagMatrix, val: f64)
     -> *mut ComplexDiagMatrix;
}
extern "C" {
    #[link_name =
          "?fill@ComplexDiagMatrix@@QEAAAEAV1@AEBU?$complex@N@std@@@Z"]
    pub fn ComplexDiagMatrix_fill1(this: *mut ComplexDiagMatrix,
                                   val: *const Complex)
     -> *mut ComplexDiagMatrix;
}
extern "C" {
    #[link_name = "?fill@ComplexDiagMatrix@@QEAAAEAV1@NHH@Z"]
    pub fn ComplexDiagMatrix_fill2(this: *mut ComplexDiagMatrix, val: f64,
                                   beg: octave_idx_type, end: octave_idx_type)
     -> *mut ComplexDiagMatrix;
}
extern "C" {
    #[link_name =
          "?fill@ComplexDiagMatrix@@QEAAAEAV1@AEBU?$complex@N@std@@HH@Z"]
    pub fn ComplexDiagMatrix_fill3(this: *mut ComplexDiagMatrix,
                                   val: *const Complex, beg: octave_idx_type,
                                   end: octave_idx_type)
     -> *mut ComplexDiagMatrix;
}
extern "C" {
    #[link_name = "?fill@ComplexDiagMatrix@@QEAAAEAV1@AEBVColumnVector@@@Z"]
    pub fn ComplexDiagMatrix_fill4(this: *mut ComplexDiagMatrix,
                                   a: *const ColumnVector)
     -> *mut ComplexDiagMatrix;
}
extern "C" {
    #[link_name =
          "?fill@ComplexDiagMatrix@@QEAAAEAV1@AEBVComplexColumnVector@@@Z"]
    pub fn ComplexDiagMatrix_fill5(this: *mut ComplexDiagMatrix,
                                   a: *const ComplexColumnVector)
     -> *mut ComplexDiagMatrix;
}
extern "C" {
    #[link_name = "?fill@ComplexDiagMatrix@@QEAAAEAV1@AEBVRowVector@@@Z"]
    pub fn ComplexDiagMatrix_fill6(this: *mut ComplexDiagMatrix,
                                   a: *const RowVector)
     -> *mut ComplexDiagMatrix;
}
extern "C" {
    #[link_name =
          "?fill@ComplexDiagMatrix@@QEAAAEAV1@AEBVComplexRowVector@@@Z"]
    pub fn ComplexDiagMatrix_fill7(this: *mut ComplexDiagMatrix,
                                   a: *const ComplexRowVector)
     -> *mut ComplexDiagMatrix;
}
extern "C" {
    #[link_name = "?fill@ComplexDiagMatrix@@QEAAAEAV1@AEBVColumnVector@@H@Z"]
    pub fn ComplexDiagMatrix_fill8(this: *mut ComplexDiagMatrix,
                                   a: *const ColumnVector,
                                   beg: octave_idx_type)
     -> *mut ComplexDiagMatrix;
}
extern "C" {
    #[link_name =
          "?fill@ComplexDiagMatrix@@QEAAAEAV1@AEBVComplexColumnVector@@H@Z"]
    pub fn ComplexDiagMatrix_fill9(this: *mut ComplexDiagMatrix,
                                   a: *const ComplexColumnVector,
                                   beg: octave_idx_type)
     -> *mut ComplexDiagMatrix;
}
extern "C" {
    #[link_name = "?fill@ComplexDiagMatrix@@QEAAAEAV1@AEBVRowVector@@H@Z"]
    pub fn ComplexDiagMatrix_fill10(this: *mut ComplexDiagMatrix,
                                    a: *const RowVector, beg: octave_idx_type)
     -> *mut ComplexDiagMatrix;
}
extern "C" {
    #[link_name =
          "?fill@ComplexDiagMatrix@@QEAAAEAV1@AEBVComplexRowVector@@H@Z"]
    pub fn ComplexDiagMatrix_fill11(this: *mut ComplexDiagMatrix,
                                    a: *const ComplexRowVector,
                                    beg: octave_idx_type)
     -> *mut ComplexDiagMatrix;
}
extern "C" {
    #[link_name = "?abs@ComplexDiagMatrix@@QEBA?AVDiagMatrix@@XZ"]
    pub fn ComplexDiagMatrix_abs(this: *const ComplexDiagMatrix)
     -> DiagMatrix;
}
extern "C" {
    #[link_name = "?extract@ComplexDiagMatrix@@QEBA?AVComplexMatrix@@HHHH@Z"]
    pub fn ComplexDiagMatrix_extract(this: *const ComplexDiagMatrix,
                                     r1: octave_idx_type, c1: octave_idx_type,
                                     r2: octave_idx_type, c2: octave_idx_type)
     -> ComplexMatrix;
}
extern "C" {
    #[link_name = "?row@ComplexDiagMatrix@@QEBA?AVComplexRowVector@@H@Z"]
    pub fn ComplexDiagMatrix_row(this: *const ComplexDiagMatrix,
                                 i: octave_idx_type) -> ComplexRowVector;
}
extern "C" {
    #[link_name = "?row@ComplexDiagMatrix@@QEBA?AVComplexRowVector@@PEAD@Z"]
    pub fn ComplexDiagMatrix_row1(this: *const ComplexDiagMatrix,
                                  s: *mut ::std::os::raw::c_char)
     -> ComplexRowVector;
}
extern "C" {
    #[link_name =
          "?column@ComplexDiagMatrix@@QEBA?AVComplexColumnVector@@H@Z"]
    pub fn ComplexDiagMatrix_column(this: *const ComplexDiagMatrix,
                                    i: octave_idx_type)
     -> ComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?column@ComplexDiagMatrix@@QEBA?AVComplexColumnVector@@PEAD@Z"]
    pub fn ComplexDiagMatrix_column1(this: *const ComplexDiagMatrix,
                                     s: *mut ::std::os::raw::c_char)
     -> ComplexColumnVector;
}
extern "C" {
    #[link_name = "?inverse@ComplexDiagMatrix@@QEBA?AV1@AEAH@Z"]
    pub fn ComplexDiagMatrix_inverse(this: *const ComplexDiagMatrix,
                                     info: *mut octave_idx_type)
     -> ComplexDiagMatrix;
}
extern "C" {
    #[link_name = "?inverse@ComplexDiagMatrix@@QEBA?AV1@XZ"]
    pub fn ComplexDiagMatrix_inverse1(this: *const ComplexDiagMatrix)
     -> ComplexDiagMatrix;
}
extern "C" {
    #[link_name = "?pseudo_inverse@ComplexDiagMatrix@@QEBA?AV1@N@Z"]
    pub fn ComplexDiagMatrix_pseudo_inverse(this: *const ComplexDiagMatrix,
                                            tol: f64) -> ComplexDiagMatrix;
}
extern "C" {
    #[link_name = "?all_elements_are_real@ComplexDiagMatrix@@QEBA_NXZ"]
    pub fn ComplexDiagMatrix_all_elements_are_real(this:
                                                       *const ComplexDiagMatrix)
     -> bool;
}
extern "C" {
    #[link_name =
          "?determinant@ComplexDiagMatrix@@QEBA?AV?$base_det@U?$complex@N@std@@@@XZ"]
    pub fn ComplexDiagMatrix_determinant(this: *const ComplexDiagMatrix)
     -> ComplexDET;
}
extern "C" {
    #[link_name = "?rcond@ComplexDiagMatrix@@QEBANXZ"]
    pub fn ComplexDiagMatrix_rcond(this: *const ComplexDiagMatrix) -> f64;
}
extern "C" {
    #[link_name = "??0ComplexDiagMatrix@@QEAA@AEBVDiagMatrix@@@Z"]
    pub fn ComplexDiagMatrix_ComplexDiagMatrix(this: *mut ComplexDiagMatrix,
                                               a: *const DiagMatrix);
}
impl ComplexDiagMatrix {
    #[inline]
    pub unsafe fn fill(&mut self, val: f64) -> *mut ComplexDiagMatrix {
        ComplexDiagMatrix_fill(self, val)
    }
    #[inline]
    pub unsafe fn fill1(&mut self, val: *const Complex)
     -> *mut ComplexDiagMatrix {
        ComplexDiagMatrix_fill1(self, val)
    }
    #[inline]
    pub unsafe fn fill2(&mut self, val: f64, beg: octave_idx_type,
                        end: octave_idx_type) -> *mut ComplexDiagMatrix {
        ComplexDiagMatrix_fill2(self, val, beg, end)
    }
    #[inline]
    pub unsafe fn fill3(&mut self, val: *const Complex, beg: octave_idx_type,
                        end: octave_idx_type) -> *mut ComplexDiagMatrix {
        ComplexDiagMatrix_fill3(self, val, beg, end)
    }
    #[inline]
    pub unsafe fn fill4(&mut self, a: *const ColumnVector)
     -> *mut ComplexDiagMatrix {
        ComplexDiagMatrix_fill4(self, a)
    }
    #[inline]
    pub unsafe fn fill5(&mut self, a: *const ComplexColumnVector)
     -> *mut ComplexDiagMatrix {
        ComplexDiagMatrix_fill5(self, a)
    }
    #[inline]
    pub unsafe fn fill6(&mut self, a: *const RowVector)
     -> *mut ComplexDiagMatrix {
        ComplexDiagMatrix_fill6(self, a)
    }
    #[inline]
    pub unsafe fn fill7(&mut self, a: *const ComplexRowVector)
     -> *mut ComplexDiagMatrix {
        ComplexDiagMatrix_fill7(self, a)
    }
    #[inline]
    pub unsafe fn fill8(&mut self, a: *const ColumnVector,
                        beg: octave_idx_type) -> *mut ComplexDiagMatrix {
        ComplexDiagMatrix_fill8(self, a, beg)
    }
    #[inline]
    pub unsafe fn fill9(&mut self, a: *const ComplexColumnVector,
                        beg: octave_idx_type) -> *mut ComplexDiagMatrix {
        ComplexDiagMatrix_fill9(self, a, beg)
    }
    #[inline]
    pub unsafe fn fill10(&mut self, a: *const RowVector, beg: octave_idx_type)
     -> *mut ComplexDiagMatrix {
        ComplexDiagMatrix_fill10(self, a, beg)
    }
    #[inline]
    pub unsafe fn fill11(&mut self, a: *const ComplexRowVector,
                         beg: octave_idx_type) -> *mut ComplexDiagMatrix {
        ComplexDiagMatrix_fill11(self, a, beg)
    }
    #[inline]
    pub unsafe fn abs(&self) -> DiagMatrix { ComplexDiagMatrix_abs(self) }
    #[inline]
    pub unsafe fn extract(&self, r1: octave_idx_type, c1: octave_idx_type,
                          r2: octave_idx_type, c2: octave_idx_type)
     -> ComplexMatrix {
        ComplexDiagMatrix_extract(self, r1, c1, r2, c2)
    }
    #[inline]
    pub unsafe fn row(&self, i: octave_idx_type) -> ComplexRowVector {
        ComplexDiagMatrix_row(self, i)
    }
    #[inline]
    pub unsafe fn row1(&self, s: *mut ::std::os::raw::c_char)
     -> ComplexRowVector {
        ComplexDiagMatrix_row1(self, s)
    }
    #[inline]
    pub unsafe fn column(&self, i: octave_idx_type) -> ComplexColumnVector {
        ComplexDiagMatrix_column(self, i)
    }
    #[inline]
    pub unsafe fn column1(&self, s: *mut ::std::os::raw::c_char)
     -> ComplexColumnVector {
        ComplexDiagMatrix_column1(self, s)
    }
    #[inline]
    pub unsafe fn inverse(&self, info: *mut octave_idx_type)
     -> ComplexDiagMatrix {
        ComplexDiagMatrix_inverse(self, info)
    }
    #[inline]
    pub unsafe fn inverse1(&self) -> ComplexDiagMatrix {
        ComplexDiagMatrix_inverse1(self)
    }
    #[inline]
    pub unsafe fn pseudo_inverse(&self, tol: f64) -> ComplexDiagMatrix {
        ComplexDiagMatrix_pseudo_inverse(self, tol)
    }
    #[inline]
    pub unsafe fn all_elements_are_real(&self) -> bool {
        ComplexDiagMatrix_all_elements_are_real(self)
    }
    #[inline]
    pub unsafe fn determinant(&self) -> ComplexDET {
        ComplexDiagMatrix_determinant(self)
    }
    #[inline]
    pub unsafe fn rcond(&self) -> f64 { ComplexDiagMatrix_rcond(self) }
    #[inline]
    pub unsafe fn new(a: *const DiagMatrix) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        ComplexDiagMatrix_ComplexDiagMatrix(&mut __bindgen_tmp, a);
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct FloatDiagMatrix {
    pub _base: MDiagArray2<f32>,
}
#[test]
fn bindgen_test_layout_FloatDiagMatrix() {
    assert_eq!(::std::mem::size_of::<FloatDiagMatrix>() , 48usize , concat ! (
               "Size of: " , stringify ! ( FloatDiagMatrix ) ));
    assert_eq! (::std::mem::align_of::<FloatDiagMatrix>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( FloatDiagMatrix ) ));
}
extern "C" {
    #[link_name = "?fill@FloatDiagMatrix@@QEAAAEAV1@M@Z"]
    pub fn FloatDiagMatrix_fill(this: *mut FloatDiagMatrix, val: f32)
     -> *mut FloatDiagMatrix;
}
extern "C" {
    #[link_name = "?fill@FloatDiagMatrix@@QEAAAEAV1@MHH@Z"]
    pub fn FloatDiagMatrix_fill1(this: *mut FloatDiagMatrix, val: f32,
                                 beg: octave_idx_type, end: octave_idx_type)
     -> *mut FloatDiagMatrix;
}
extern "C" {
    #[link_name =
          "?fill@FloatDiagMatrix@@QEAAAEAV1@AEBVFloatColumnVector@@@Z"]
    pub fn FloatDiagMatrix_fill2(this: *mut FloatDiagMatrix,
                                 a: *const FloatColumnVector)
     -> *mut FloatDiagMatrix;
}
extern "C" {
    #[link_name = "?fill@FloatDiagMatrix@@QEAAAEAV1@AEBVFloatRowVector@@@Z"]
    pub fn FloatDiagMatrix_fill3(this: *mut FloatDiagMatrix,
                                 a: *const FloatRowVector)
     -> *mut FloatDiagMatrix;
}
extern "C" {
    #[link_name =
          "?fill@FloatDiagMatrix@@QEAAAEAV1@AEBVFloatColumnVector@@H@Z"]
    pub fn FloatDiagMatrix_fill4(this: *mut FloatDiagMatrix,
                                 a: *const FloatColumnVector,
                                 beg: octave_idx_type)
     -> *mut FloatDiagMatrix;
}
extern "C" {
    #[link_name = "?fill@FloatDiagMatrix@@QEAAAEAV1@AEBVFloatRowVector@@H@Z"]
    pub fn FloatDiagMatrix_fill5(this: *mut FloatDiagMatrix,
                                 a: *const FloatRowVector,
                                 beg: octave_idx_type)
     -> *mut FloatDiagMatrix;
}
extern "C" {
    #[link_name = "?abs@FloatDiagMatrix@@QEBA?AV1@XZ"]
    pub fn FloatDiagMatrix_abs(this: *const FloatDiagMatrix)
     -> FloatDiagMatrix;
}
extern "C" {
    #[link_name = "?extract@FloatDiagMatrix@@QEBA?AVFloatMatrix@@HHHH@Z"]
    pub fn FloatDiagMatrix_extract(this: *const FloatDiagMatrix,
                                   r1: octave_idx_type, c1: octave_idx_type,
                                   r2: octave_idx_type, c2: octave_idx_type)
     -> FloatMatrix;
}
extern "C" {
    #[link_name = "?row@FloatDiagMatrix@@QEBA?AVFloatRowVector@@H@Z"]
    pub fn FloatDiagMatrix_row(this: *const FloatDiagMatrix,
                               i: octave_idx_type) -> FloatRowVector;
}
extern "C" {
    #[link_name = "?row@FloatDiagMatrix@@QEBA?AVFloatRowVector@@PEAD@Z"]
    pub fn FloatDiagMatrix_row1(this: *const FloatDiagMatrix,
                                s: *mut ::std::os::raw::c_char)
     -> FloatRowVector;
}
extern "C" {
    #[link_name = "?column@FloatDiagMatrix@@QEBA?AVFloatColumnVector@@H@Z"]
    pub fn FloatDiagMatrix_column(this: *const FloatDiagMatrix,
                                  i: octave_idx_type) -> FloatColumnVector;
}
extern "C" {
    #[link_name = "?column@FloatDiagMatrix@@QEBA?AVFloatColumnVector@@PEAD@Z"]
    pub fn FloatDiagMatrix_column1(this: *const FloatDiagMatrix,
                                   s: *mut ::std::os::raw::c_char)
     -> FloatColumnVector;
}
extern "C" {
    #[link_name = "?inverse@FloatDiagMatrix@@QEBA?AV1@XZ"]
    pub fn FloatDiagMatrix_inverse(this: *const FloatDiagMatrix)
     -> FloatDiagMatrix;
}
extern "C" {
    #[link_name = "?inverse@FloatDiagMatrix@@QEBA?AV1@AEAH@Z"]
    pub fn FloatDiagMatrix_inverse1(this: *const FloatDiagMatrix,
                                    info: *mut octave_idx_type)
     -> FloatDiagMatrix;
}
extern "C" {
    #[link_name = "?pseudo_inverse@FloatDiagMatrix@@QEBA?AV1@M@Z"]
    pub fn FloatDiagMatrix_pseudo_inverse(this: *const FloatDiagMatrix,
                                          tol: f32) -> FloatDiagMatrix;
}
extern "C" {
    #[link_name = "?determinant@FloatDiagMatrix@@QEBA?AV?$base_det@M@@XZ"]
    pub fn FloatDiagMatrix_determinant(this: *const FloatDiagMatrix)
     -> FloatDET;
}
extern "C" {
    #[link_name = "?rcond@FloatDiagMatrix@@QEBAMXZ"]
    pub fn FloatDiagMatrix_rcond(this: *const FloatDiagMatrix) -> f32;
}
impl FloatDiagMatrix {
    #[inline]
    pub unsafe fn fill(&mut self, val: f32) -> *mut FloatDiagMatrix {
        FloatDiagMatrix_fill(self, val)
    }
    #[inline]
    pub unsafe fn fill1(&mut self, val: f32, beg: octave_idx_type,
                        end: octave_idx_type) -> *mut FloatDiagMatrix {
        FloatDiagMatrix_fill1(self, val, beg, end)
    }
    #[inline]
    pub unsafe fn fill2(&mut self, a: *const FloatColumnVector)
     -> *mut FloatDiagMatrix {
        FloatDiagMatrix_fill2(self, a)
    }
    #[inline]
    pub unsafe fn fill3(&mut self, a: *const FloatRowVector)
     -> *mut FloatDiagMatrix {
        FloatDiagMatrix_fill3(self, a)
    }
    #[inline]
    pub unsafe fn fill4(&mut self, a: *const FloatColumnVector,
                        beg: octave_idx_type) -> *mut FloatDiagMatrix {
        FloatDiagMatrix_fill4(self, a, beg)
    }
    #[inline]
    pub unsafe fn fill5(&mut self, a: *const FloatRowVector,
                        beg: octave_idx_type) -> *mut FloatDiagMatrix {
        FloatDiagMatrix_fill5(self, a, beg)
    }
    #[inline]
    pub unsafe fn abs(&self) -> FloatDiagMatrix { FloatDiagMatrix_abs(self) }
    #[inline]
    pub unsafe fn extract(&self, r1: octave_idx_type, c1: octave_idx_type,
                          r2: octave_idx_type, c2: octave_idx_type)
     -> FloatMatrix {
        FloatDiagMatrix_extract(self, r1, c1, r2, c2)
    }
    #[inline]
    pub unsafe fn row(&self, i: octave_idx_type) -> FloatRowVector {
        FloatDiagMatrix_row(self, i)
    }
    #[inline]
    pub unsafe fn row1(&self, s: *mut ::std::os::raw::c_char)
     -> FloatRowVector {
        FloatDiagMatrix_row1(self, s)
    }
    #[inline]
    pub unsafe fn column(&self, i: octave_idx_type) -> FloatColumnVector {
        FloatDiagMatrix_column(self, i)
    }
    #[inline]
    pub unsafe fn column1(&self, s: *mut ::std::os::raw::c_char)
     -> FloatColumnVector {
        FloatDiagMatrix_column1(self, s)
    }
    #[inline]
    pub unsafe fn inverse(&self) -> FloatDiagMatrix {
        FloatDiagMatrix_inverse(self)
    }
    #[inline]
    pub unsafe fn inverse1(&self, info: *mut octave_idx_type)
     -> FloatDiagMatrix {
        FloatDiagMatrix_inverse1(self, info)
    }
    #[inline]
    pub unsafe fn pseudo_inverse(&self, tol: f32) -> FloatDiagMatrix {
        FloatDiagMatrix_pseudo_inverse(self, tol)
    }
    #[inline]
    pub unsafe fn determinant(&self) -> FloatDET {
        FloatDiagMatrix_determinant(self)
    }
    #[inline]
    pub unsafe fn rcond(&self) -> f32 { FloatDiagMatrix_rcond(self) }
}
#[repr(C)]
#[derive(Debug)]
pub struct FloatComplexDiagMatrix {
    pub _base: MDiagArray2<std_complex<f32>>,
}
#[test]
fn bindgen_test_layout_FloatComplexDiagMatrix() {
    assert_eq!(::std::mem::size_of::<FloatComplexDiagMatrix>() , 48usize ,
               concat ! ( "Size of: " , stringify ! ( FloatComplexDiagMatrix )
               ));
    assert_eq! (::std::mem::align_of::<FloatComplexDiagMatrix>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( FloatComplexDiagMatrix ) ));
}
extern "C" {
    #[link_name = "?fill@FloatComplexDiagMatrix@@QEAAAEAV1@M@Z"]
    pub fn FloatComplexDiagMatrix_fill(this: *mut FloatComplexDiagMatrix,
                                       val: f32)
     -> *mut FloatComplexDiagMatrix;
}
extern "C" {
    #[link_name =
          "?fill@FloatComplexDiagMatrix@@QEAAAEAV1@AEBU?$complex@M@std@@@Z"]
    pub fn FloatComplexDiagMatrix_fill1(this: *mut FloatComplexDiagMatrix,
                                        val: *const FloatComplex)
     -> *mut FloatComplexDiagMatrix;
}
extern "C" {
    #[link_name = "?fill@FloatComplexDiagMatrix@@QEAAAEAV1@MHH@Z"]
    pub fn FloatComplexDiagMatrix_fill2(this: *mut FloatComplexDiagMatrix,
                                        val: f32, beg: octave_idx_type,
                                        end: octave_idx_type)
     -> *mut FloatComplexDiagMatrix;
}
extern "C" {
    #[link_name =
          "?fill@FloatComplexDiagMatrix@@QEAAAEAV1@AEBU?$complex@M@std@@HH@Z"]
    pub fn FloatComplexDiagMatrix_fill3(this: *mut FloatComplexDiagMatrix,
                                        val: *const FloatComplex,
                                        beg: octave_idx_type,
                                        end: octave_idx_type)
     -> *mut FloatComplexDiagMatrix;
}
extern "C" {
    #[link_name =
          "?fill@FloatComplexDiagMatrix@@QEAAAEAV1@AEBVFloatColumnVector@@@Z"]
    pub fn FloatComplexDiagMatrix_fill4(this: *mut FloatComplexDiagMatrix,
                                        a: *const FloatColumnVector)
     -> *mut FloatComplexDiagMatrix;
}
extern "C" {
    #[link_name =
          "?fill@FloatComplexDiagMatrix@@QEAAAEAV1@AEBVFloatComplexColumnVector@@@Z"]
    pub fn FloatComplexDiagMatrix_fill5(this: *mut FloatComplexDiagMatrix,
                                        a: *const FloatComplexColumnVector)
     -> *mut FloatComplexDiagMatrix;
}
extern "C" {
    #[link_name =
          "?fill@FloatComplexDiagMatrix@@QEAAAEAV1@AEBVFloatRowVector@@@Z"]
    pub fn FloatComplexDiagMatrix_fill6(this: *mut FloatComplexDiagMatrix,
                                        a: *const FloatRowVector)
     -> *mut FloatComplexDiagMatrix;
}
extern "C" {
    #[link_name =
          "?fill@FloatComplexDiagMatrix@@QEAAAEAV1@AEBVFloatComplexRowVector@@@Z"]
    pub fn FloatComplexDiagMatrix_fill7(this: *mut FloatComplexDiagMatrix,
                                        a: *const FloatComplexRowVector)
     -> *mut FloatComplexDiagMatrix;
}
extern "C" {
    #[link_name =
          "?fill@FloatComplexDiagMatrix@@QEAAAEAV1@AEBVFloatColumnVector@@H@Z"]
    pub fn FloatComplexDiagMatrix_fill8(this: *mut FloatComplexDiagMatrix,
                                        a: *const FloatColumnVector,
                                        beg: octave_idx_type)
     -> *mut FloatComplexDiagMatrix;
}
extern "C" {
    #[link_name =
          "?fill@FloatComplexDiagMatrix@@QEAAAEAV1@AEBVFloatComplexColumnVector@@H@Z"]
    pub fn FloatComplexDiagMatrix_fill9(this: *mut FloatComplexDiagMatrix,
                                        a: *const FloatComplexColumnVector,
                                        beg: octave_idx_type)
     -> *mut FloatComplexDiagMatrix;
}
extern "C" {
    #[link_name =
          "?fill@FloatComplexDiagMatrix@@QEAAAEAV1@AEBVFloatRowVector@@H@Z"]
    pub fn FloatComplexDiagMatrix_fill10(this: *mut FloatComplexDiagMatrix,
                                         a: *const FloatRowVector,
                                         beg: octave_idx_type)
     -> *mut FloatComplexDiagMatrix;
}
extern "C" {
    #[link_name =
          "?fill@FloatComplexDiagMatrix@@QEAAAEAV1@AEBVFloatComplexRowVector@@H@Z"]
    pub fn FloatComplexDiagMatrix_fill11(this: *mut FloatComplexDiagMatrix,
                                         a: *const FloatComplexRowVector,
                                         beg: octave_idx_type)
     -> *mut FloatComplexDiagMatrix;
}
extern "C" {
    #[link_name = "?abs@FloatComplexDiagMatrix@@QEBA?AVFloatDiagMatrix@@XZ"]
    pub fn FloatComplexDiagMatrix_abs(this: *const FloatComplexDiagMatrix)
     -> FloatDiagMatrix;
}
extern "C" {
    #[link_name =
          "?extract@FloatComplexDiagMatrix@@QEBA?AVFloatComplexMatrix@@HHHH@Z"]
    pub fn FloatComplexDiagMatrix_extract(this: *const FloatComplexDiagMatrix,
                                          r1: octave_idx_type,
                                          c1: octave_idx_type,
                                          r2: octave_idx_type,
                                          c2: octave_idx_type)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name =
          "?row@FloatComplexDiagMatrix@@QEBA?AVFloatComplexRowVector@@H@Z"]
    pub fn FloatComplexDiagMatrix_row(this: *const FloatComplexDiagMatrix,
                                      i: octave_idx_type)
     -> FloatComplexRowVector;
}
extern "C" {
    #[link_name =
          "?row@FloatComplexDiagMatrix@@QEBA?AVFloatComplexRowVector@@PEAD@Z"]
    pub fn FloatComplexDiagMatrix_row1(this: *const FloatComplexDiagMatrix,
                                       s: *mut ::std::os::raw::c_char)
     -> FloatComplexRowVector;
}
extern "C" {
    #[link_name =
          "?column@FloatComplexDiagMatrix@@QEBA?AVFloatComplexColumnVector@@H@Z"]
    pub fn FloatComplexDiagMatrix_column(this: *const FloatComplexDiagMatrix,
                                         i: octave_idx_type)
     -> FloatComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?column@FloatComplexDiagMatrix@@QEBA?AVFloatComplexColumnVector@@PEAD@Z"]
    pub fn FloatComplexDiagMatrix_column1(this: *const FloatComplexDiagMatrix,
                                          s: *mut ::std::os::raw::c_char)
     -> FloatComplexColumnVector;
}
extern "C" {
    #[link_name = "?inverse@FloatComplexDiagMatrix@@QEBA?AV1@AEAH@Z"]
    pub fn FloatComplexDiagMatrix_inverse(this: *const FloatComplexDiagMatrix,
                                          info: *mut octave_idx_type)
     -> FloatComplexDiagMatrix;
}
extern "C" {
    #[link_name = "?inverse@FloatComplexDiagMatrix@@QEBA?AV1@XZ"]
    pub fn FloatComplexDiagMatrix_inverse1(this:
                                               *const FloatComplexDiagMatrix)
     -> FloatComplexDiagMatrix;
}
extern "C" {
    #[link_name = "?pseudo_inverse@FloatComplexDiagMatrix@@QEBA?AV1@M@Z"]
    pub fn FloatComplexDiagMatrix_pseudo_inverse(this:
                                                     *const FloatComplexDiagMatrix,
                                                 tol: f32)
     -> FloatComplexDiagMatrix;
}
extern "C" {
    #[link_name = "?all_elements_are_real@FloatComplexDiagMatrix@@QEBA_NXZ"]
    pub fn FloatComplexDiagMatrix_all_elements_are_real(this:
                                                            *const FloatComplexDiagMatrix)
     -> bool;
}
extern "C" {
    #[link_name =
          "?determinant@FloatComplexDiagMatrix@@QEBA?AV?$base_det@U?$complex@M@std@@@@XZ"]
    pub fn FloatComplexDiagMatrix_determinant(this:
                                                  *const FloatComplexDiagMatrix)
     -> FloatComplexDET;
}
extern "C" {
    #[link_name = "?rcond@FloatComplexDiagMatrix@@QEBAMXZ"]
    pub fn FloatComplexDiagMatrix_rcond(this: *const FloatComplexDiagMatrix)
     -> f32;
}
extern "C" {
    #[link_name = "??0FloatComplexDiagMatrix@@QEAA@AEBVFloatDiagMatrix@@@Z"]
    pub fn FloatComplexDiagMatrix_FloatComplexDiagMatrix(this:
                                                             *mut FloatComplexDiagMatrix,
                                                         a:
                                                             *const FloatDiagMatrix);
}
impl FloatComplexDiagMatrix {
    #[inline]
    pub unsafe fn fill(&mut self, val: f32) -> *mut FloatComplexDiagMatrix {
        FloatComplexDiagMatrix_fill(self, val)
    }
    #[inline]
    pub unsafe fn fill1(&mut self, val: *const FloatComplex)
     -> *mut FloatComplexDiagMatrix {
        FloatComplexDiagMatrix_fill1(self, val)
    }
    #[inline]
    pub unsafe fn fill2(&mut self, val: f32, beg: octave_idx_type,
                        end: octave_idx_type) -> *mut FloatComplexDiagMatrix {
        FloatComplexDiagMatrix_fill2(self, val, beg, end)
    }
    #[inline]
    pub unsafe fn fill3(&mut self, val: *const FloatComplex,
                        beg: octave_idx_type, end: octave_idx_type)
     -> *mut FloatComplexDiagMatrix {
        FloatComplexDiagMatrix_fill3(self, val, beg, end)
    }
    #[inline]
    pub unsafe fn fill4(&mut self, a: *const FloatColumnVector)
     -> *mut FloatComplexDiagMatrix {
        FloatComplexDiagMatrix_fill4(self, a)
    }
    #[inline]
    pub unsafe fn fill5(&mut self, a: *const FloatComplexColumnVector)
     -> *mut FloatComplexDiagMatrix {
        FloatComplexDiagMatrix_fill5(self, a)
    }
    #[inline]
    pub unsafe fn fill6(&mut self, a: *const FloatRowVector)
     -> *mut FloatComplexDiagMatrix {
        FloatComplexDiagMatrix_fill6(self, a)
    }
    #[inline]
    pub unsafe fn fill7(&mut self, a: *const FloatComplexRowVector)
     -> *mut FloatComplexDiagMatrix {
        FloatComplexDiagMatrix_fill7(self, a)
    }
    #[inline]
    pub unsafe fn fill8(&mut self, a: *const FloatColumnVector,
                        beg: octave_idx_type) -> *mut FloatComplexDiagMatrix {
        FloatComplexDiagMatrix_fill8(self, a, beg)
    }
    #[inline]
    pub unsafe fn fill9(&mut self, a: *const FloatComplexColumnVector,
                        beg: octave_idx_type) -> *mut FloatComplexDiagMatrix {
        FloatComplexDiagMatrix_fill9(self, a, beg)
    }
    #[inline]
    pub unsafe fn fill10(&mut self, a: *const FloatRowVector,
                         beg: octave_idx_type)
     -> *mut FloatComplexDiagMatrix {
        FloatComplexDiagMatrix_fill10(self, a, beg)
    }
    #[inline]
    pub unsafe fn fill11(&mut self, a: *const FloatComplexRowVector,
                         beg: octave_idx_type)
     -> *mut FloatComplexDiagMatrix {
        FloatComplexDiagMatrix_fill11(self, a, beg)
    }
    #[inline]
    pub unsafe fn abs(&self) -> FloatDiagMatrix {
        FloatComplexDiagMatrix_abs(self)
    }
    #[inline]
    pub unsafe fn extract(&self, r1: octave_idx_type, c1: octave_idx_type,
                          r2: octave_idx_type, c2: octave_idx_type)
     -> FloatComplexMatrix {
        FloatComplexDiagMatrix_extract(self, r1, c1, r2, c2)
    }
    #[inline]
    pub unsafe fn row(&self, i: octave_idx_type) -> FloatComplexRowVector {
        FloatComplexDiagMatrix_row(self, i)
    }
    #[inline]
    pub unsafe fn row1(&self, s: *mut ::std::os::raw::c_char)
     -> FloatComplexRowVector {
        FloatComplexDiagMatrix_row1(self, s)
    }
    #[inline]
    pub unsafe fn column(&self, i: octave_idx_type)
     -> FloatComplexColumnVector {
        FloatComplexDiagMatrix_column(self, i)
    }
    #[inline]
    pub unsafe fn column1(&self, s: *mut ::std::os::raw::c_char)
     -> FloatComplexColumnVector {
        FloatComplexDiagMatrix_column1(self, s)
    }
    #[inline]
    pub unsafe fn inverse(&self, info: *mut octave_idx_type)
     -> FloatComplexDiagMatrix {
        FloatComplexDiagMatrix_inverse(self, info)
    }
    #[inline]
    pub unsafe fn inverse1(&self) -> FloatComplexDiagMatrix {
        FloatComplexDiagMatrix_inverse1(self)
    }
    #[inline]
    pub unsafe fn pseudo_inverse(&self, tol: f32) -> FloatComplexDiagMatrix {
        FloatComplexDiagMatrix_pseudo_inverse(self, tol)
    }
    #[inline]
    pub unsafe fn all_elements_are_real(&self) -> bool {
        FloatComplexDiagMatrix_all_elements_are_real(self)
    }
    #[inline]
    pub unsafe fn determinant(&self) -> FloatComplexDET {
        FloatComplexDiagMatrix_determinant(self)
    }
    #[inline]
    pub unsafe fn rcond(&self) -> f32 { FloatComplexDiagMatrix_rcond(self) }
    #[inline]
    pub unsafe fn new(a: *const FloatDiagMatrix) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        FloatComplexDiagMatrix_FloatComplexDiagMatrix(&mut __bindgen_tmp, a);
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aepbalance {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gepbalance {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct chol {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug)]
pub struct EIG {
    pub lambda: ComplexColumnVector,
    pub v: ComplexMatrix,
    pub w: ComplexMatrix,
}
#[test]
fn bindgen_test_layout_EIG() {
    assert_eq!(::std::mem::size_of::<EIG>() , 120usize , concat ! (
               "Size of: " , stringify ! ( EIG ) ));
    assert_eq! (::std::mem::align_of::<EIG>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( EIG ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EIG ) ) . lambda as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EIG ) , "::" ,
                stringify ! ( lambda ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EIG ) ) . v as * const _ as usize } ,
                40usize , concat ! (
                "Alignment of field: " , stringify ! ( EIG ) , "::" ,
                stringify ! ( v ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EIG ) ) . w as * const _ as usize } ,
                80usize , concat ! (
                "Alignment of field: " , stringify ! ( EIG ) , "::" ,
                stringify ! ( w ) ));
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hess {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct schur {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct svd {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lu {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qr {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qrp {
    pub _address: u8,
}
pub type b_d_Mapper =
    ::std::option::Option<unsafe extern "C" fn(arg1: f64) -> bool>;
pub type b_c_Mapper =
    ::std::option::Option<unsafe extern "C" fn(arg1: *const Complex) -> bool>;
pub type d_d_Mapper =
    ::std::option::Option<unsafe extern "C" fn(arg1: f64) -> f64>;
pub type d_c_Mapper =
    ::std::option::Option<unsafe extern "C" fn(arg1: *const Complex) -> f64>;
pub type c_c_Mapper =
    ::std::option::Option<unsafe extern "C" fn(arg1: *const Complex)
                              -> Complex>;
pub type b_f_Mapper =
    ::std::option::Option<unsafe extern "C" fn(arg1: f32) -> bool>;
pub type b_fc_Mapper =
    ::std::option::Option<unsafe extern "C" fn(arg1: *const FloatComplex)
                              -> bool>;
pub type f_f_Mapper =
    ::std::option::Option<unsafe extern "C" fn(arg1: f32) -> f32>;
pub type f_fc_Mapper =
    ::std::option::Option<unsafe extern "C" fn(arg1: *const FloatComplex)
                              -> f32>;
pub type fc_fc_Mapper =
    ::std::option::Option<unsafe extern "C" fn(arg1: *const FloatComplex)
                              -> FloatComplex>;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum blas_trans_type {
    blas_no_trans = 78,
    blas_trans = 84,
    blas_conj_trans = 67,
}
extern "C" {
    #[link_name = "?mx_el_and@@YA?AVboolNDArray@@AEBV1@0@Z"]
    pub fn mx_el_and(arg1: *const boolNDArray, arg2: *const boolNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_or@@YA?AVboolNDArray@@AEBV1@0@Z"]
    pub fn mx_el_or(arg1: *const boolNDArray, arg2: *const boolNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_and_not@@YA?AVboolNDArray@@AEBV1@0@Z"]
    pub fn mx_el_and_not(arg1: *const boolNDArray, arg2: *const boolNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_or_not@@YA?AVboolNDArray@@AEBV1@0@Z"]
    pub fn mx_el_or_not(arg1: *const boolNDArray, arg2: *const boolNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_not_and@@YA?AVboolNDArray@@AEBV1@0@Z"]
    pub fn mx_el_not_and(arg1: *const boolNDArray, arg2: *const boolNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_not_or@@YA?AVboolNDArray@@AEBV1@0@Z"]
    pub fn mx_el_not_or(arg1: *const boolNDArray, arg2: *const boolNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_lt@@YA?AVboolNDArray@@AEBV1@0@Z"]
    pub fn mx_el_lt(arg1: *const boolNDArray, arg2: *const boolNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_le@@YA?AVboolNDArray@@AEBV1@0@Z"]
    pub fn mx_el_le(arg1: *const boolNDArray, arg2: *const boolNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_ge@@YA?AVboolNDArray@@AEBV1@0@Z"]
    pub fn mx_el_ge(arg1: *const boolNDArray, arg2: *const boolNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_gt@@YA?AVboolNDArray@@AEBV1@0@Z"]
    pub fn mx_el_gt(arg1: *const boolNDArray, arg2: *const boolNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_eq@@YA?AVboolNDArray@@AEBV1@0@Z"]
    pub fn mx_el_eq(arg1: *const boolNDArray, arg2: *const boolNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_ne@@YA?AVboolNDArray@@AEBV1@0@Z"]
    pub fn mx_el_ne(arg1: *const boolNDArray, arg2: *const boolNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_and@@YA?AVboolNDArray@@AEBV1@AEB_N@Z"]
    pub fn mx_el_and1(arg1: *const boolNDArray, arg2: *const bool)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_or@@YA?AVboolNDArray@@AEBV1@AEB_N@Z"]
    pub fn mx_el_or1(arg1: *const boolNDArray, arg2: *const bool)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_not_and@@YA?AVboolNDArray@@AEBV1@AEB_N@Z"]
    pub fn mx_el_not_and1(arg1: *const boolNDArray, arg2: *const bool)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_not_or@@YA?AVboolNDArray@@AEBV1@AEB_N@Z"]
    pub fn mx_el_not_or1(arg1: *const boolNDArray, arg2: *const bool)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_lt@@YA?AVboolNDArray@@AEBV1@AEB_N@Z"]
    pub fn mx_el_lt1(arg1: *const boolNDArray, arg2: *const bool)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_le@@YA?AVboolNDArray@@AEBV1@AEB_N@Z"]
    pub fn mx_el_le1(arg1: *const boolNDArray, arg2: *const bool)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_ge@@YA?AVboolNDArray@@AEBV1@AEB_N@Z"]
    pub fn mx_el_ge1(arg1: *const boolNDArray, arg2: *const bool)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_gt@@YA?AVboolNDArray@@AEBV1@AEB_N@Z"]
    pub fn mx_el_gt1(arg1: *const boolNDArray, arg2: *const bool)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_eq@@YA?AVboolNDArray@@AEBV1@AEB_N@Z"]
    pub fn mx_el_eq1(arg1: *const boolNDArray, arg2: *const bool)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_ne@@YA?AVboolNDArray@@AEBV1@AEB_N@Z"]
    pub fn mx_el_ne1(arg1: *const boolNDArray, arg2: *const bool)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_and@@YA?AVboolNDArray@@AEB_NAEBV1@@Z"]
    pub fn mx_el_and2(arg1: *const bool, arg2: *const boolNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_or@@YA?AVboolNDArray@@AEB_NAEBV1@@Z"]
    pub fn mx_el_or2(arg1: *const bool, arg2: *const boolNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_and_not@@YA?AVboolNDArray@@AEB_NAEBV1@@Z"]
    pub fn mx_el_and_not1(arg1: *const bool, arg2: *const boolNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_or_not@@YA?AVboolNDArray@@AEB_NAEBV1@@Z"]
    pub fn mx_el_or_not1(arg1: *const bool, arg2: *const boolNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_lt@@YA?AVboolNDArray@@AEB_NAEBV1@@Z"]
    pub fn mx_el_lt2(arg1: *const bool, arg2: *const boolNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_le@@YA?AVboolNDArray@@AEB_NAEBV1@@Z"]
    pub fn mx_el_le2(arg1: *const bool, arg2: *const boolNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_ge@@YA?AVboolNDArray@@AEB_NAEBV1@@Z"]
    pub fn mx_el_ge2(arg1: *const bool, arg2: *const boolNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_gt@@YA?AVboolNDArray@@AEB_NAEBV1@@Z"]
    pub fn mx_el_gt2(arg1: *const bool, arg2: *const boolNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_eq@@YA?AVboolNDArray@@AEB_NAEBV1@@Z"]
    pub fn mx_el_eq2(arg1: *const bool, arg2: *const boolNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_ne@@YA?AVboolNDArray@@AEB_NAEBV1@@Z"]
    pub fn mx_el_ne2(arg1: *const bool, arg2: *const boolNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_and_assign@@YAAEAVboolNDArray@@AEAV1@AEBV1@@Z"]
    pub fn mx_el_and_assign(m: *mut boolNDArray, a: *const boolNDArray)
     -> *mut boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_or_assign@@YAAEAVboolNDArray@@AEAV1@AEBV1@@Z"]
    pub fn mx_el_or_assign(m: *mut boolNDArray, a: *const boolNDArray)
     -> *mut boolNDArray;
}
extern "C" {
    #[link_name = "?bsxfun_and@@YA?AVboolNDArray@@AEBV1@0@Z"]
    pub fn bsxfun_and(arg1: *const boolNDArray, arg2: *const boolNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?bsxfun_or@@YA?AVboolNDArray@@AEBV1@0@Z"]
    pub fn bsxfun_or(arg1: *const boolNDArray, arg2: *const boolNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_and@@YA?AVboolMatrix@@AEBV1@0@Z"]
    pub fn mx_el_and3(arg1: *const boolMatrix, arg2: *const boolMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_or@@YA?AVboolMatrix@@AEBV1@0@Z"]
    pub fn mx_el_or3(arg1: *const boolMatrix, arg2: *const boolMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_and@@YA?AVboolMatrix@@AEBV1@AEB_N@Z"]
    pub fn mx_el_and4(arg1: *const boolMatrix, arg2: *const bool)
     -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_or@@YA?AVboolMatrix@@AEBV1@AEB_N@Z"]
    pub fn mx_el_or4(arg1: *const boolMatrix, arg2: *const bool)
     -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_and@@YA?AVboolMatrix@@AEB_NAEBV1@@Z"]
    pub fn mx_el_and5(arg1: *const bool, arg2: *const boolMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_or@@YA?AVboolMatrix@@AEB_NAEBV1@@Z"]
    pub fn mx_el_or5(arg1: *const bool, arg2: *const boolMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_lt@@YA?AVboolMatrix@@AEBV1@0@Z"]
    pub fn mx_el_lt3(arg1: *const boolMatrix, arg2: *const boolMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_le@@YA?AVboolMatrix@@AEBV1@0@Z"]
    pub fn mx_el_le3(arg1: *const boolMatrix, arg2: *const boolMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_ge@@YA?AVboolMatrix@@AEBV1@0@Z"]
    pub fn mx_el_ge3(arg1: *const boolMatrix, arg2: *const boolMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_gt@@YA?AVboolMatrix@@AEBV1@0@Z"]
    pub fn mx_el_gt3(arg1: *const boolMatrix, arg2: *const boolMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_eq@@YA?AVboolMatrix@@AEBV1@0@Z"]
    pub fn mx_el_eq3(arg1: *const boolMatrix, arg2: *const boolMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_ne@@YA?AVboolMatrix@@AEBV1@0@Z"]
    pub fn mx_el_ne3(arg1: *const boolMatrix, arg2: *const boolMatrix)
     -> boolMatrix;
}
#[repr(C)]
#[derive(Debug)]
pub struct string_vector {
    pub _base: Array<std_basic_string<::std::os::raw::c_char, std_allocator>>,
}
#[test]
fn bindgen_test_layout_string_vector() {
    assert_eq!(::std::mem::size_of::<string_vector>() , 40usize , concat ! (
               "Size of: " , stringify ! ( string_vector ) ));
    assert_eq! (::std::mem::align_of::<string_vector>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( string_vector ) ));
}
extern "C" {
    #[link_name = "?sort@string_vector@@QEAAAEAV1@_N@Z"]
    pub fn string_vector_sort(this: *mut string_vector, make_uniq: bool)
     -> *mut string_vector;
}
extern "C" {
    #[link_name = "?uniq@string_vector@@QEAAAEAV1@XZ"]
    pub fn string_vector_uniq(this: *mut string_vector) -> *mut string_vector;
}
extern "C" {
    #[link_name =
          "?append@string_vector@@QEAAAEAV1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn string_vector_append(this: *mut string_vector,
                                s: *const std_string) -> *mut string_vector;
}
extern "C" {
    #[link_name = "?append@string_vector@@QEAAAEAV1@AEBV1@@Z"]
    pub fn string_vector_append1(this: *mut string_vector,
                                 sv: *const string_vector)
     -> *mut string_vector;
}
extern "C" {
    #[link_name =
          "?join@string_vector@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV23@@Z"]
    pub fn string_vector_join(this: *const string_vector,
                              sep: *const std_string) -> std_string;
}
extern "C" {
    #[link_name = "?c_str_vec@string_vector@@QEBAPEAPEADXZ"]
    pub fn string_vector_c_str_vec(this: *const string_vector)
     -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name =
          "?std_list@string_vector@@QEBA?AV?$list@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ"]
    pub fn string_vector_std_list(this: *const string_vector) -> std_list;
}
extern "C" {
    #[link_name = "?delete_c_str_vec@string_vector@@SAXPEBQEBD@Z"]
    pub fn string_vector_delete_c_str_vec(arg1:
                                              *const *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name =
          "?list_in_columns@string_vector@@QEBAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV23@HAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z"]
    pub fn string_vector_list_in_columns(this: *const string_vector,
                                         arg1: *mut std_ostream,
                                         width: ::std::os::raw::c_int,
                                         prefix: *const std_string)
     -> *mut std_ostream;
}
extern "C" {
    #[link_name = "??0string_vector@@QEAA@PEBQEBD@Z"]
    pub fn string_vector_string_vector(this: *mut string_vector,
                                       s:
                                           *const *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "??0string_vector@@QEAA@PEBQEBDH@Z"]
    pub fn string_vector_string_vector1(this: *mut string_vector,
                                        s:
                                            *const *const ::std::os::raw::c_char,
                                        n: octave_idx_type);
}
impl string_vector {
    #[inline]
    pub unsafe fn sort(&mut self, make_uniq: bool) -> *mut string_vector {
        string_vector_sort(self, make_uniq)
    }
    #[inline]
    pub unsafe fn uniq(&mut self) -> *mut string_vector {
        string_vector_uniq(self)
    }
    #[inline]
    pub unsafe fn append(&mut self, s: *const std_string)
     -> *mut string_vector {
        string_vector_append(self, s)
    }
    #[inline]
    pub unsafe fn append1(&mut self, sv: *const string_vector)
     -> *mut string_vector {
        string_vector_append1(self, sv)
    }
    #[inline]
    pub unsafe fn join(&self, sep: *const std_string) -> std_string {
        string_vector_join(self, sep)
    }
    #[inline]
    pub unsafe fn c_str_vec(&self) -> *mut *mut ::std::os::raw::c_char {
        string_vector_c_str_vec(self)
    }
    #[inline]
    pub unsafe fn std_list(&self) -> std_list { string_vector_std_list(self) }
    #[inline]
    pub unsafe fn delete_c_str_vec(arg1:
                                       *const *const ::std::os::raw::c_char) {
        string_vector_delete_c_str_vec(arg1)
    }
    #[inline]
    pub unsafe fn list_in_columns(&self, arg1: *mut std_ostream,
                                  width: ::std::os::raw::c_int,
                                  prefix: *const std_string)
     -> *mut std_ostream {
        string_vector_list_in_columns(self, arg1, width, prefix)
    }
    #[inline]
    pub unsafe fn new(s: *const *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        string_vector_string_vector(&mut __bindgen_tmp, s);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(s: *const *const ::std::os::raw::c_char,
                       n: octave_idx_type) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        string_vector_string_vector1(&mut __bindgen_tmp, s, n);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "?min@@YA?AVcharNDArray@@DAEBV1@@Z"]
    pub fn min(d: ::std::os::raw::c_char, m: *const charNDArray)
     -> charNDArray;
}
extern "C" {
    #[link_name = "?min@@YA?AVcharNDArray@@AEBV1@D@Z"]
    pub fn min1(m: *const charNDArray, d: ::std::os::raw::c_char)
     -> charNDArray;
}
extern "C" {
    #[link_name = "?min@@YA?AVcharNDArray@@AEBV1@0@Z"]
    pub fn min2(a: *const charNDArray, b: *const charNDArray) -> charNDArray;
}
extern "C" {
    #[link_name = "?max@@YA?AVcharNDArray@@DAEBV1@@Z"]
    pub fn max(d: ::std::os::raw::c_char, m: *const charNDArray)
     -> charNDArray;
}
extern "C" {
    #[link_name = "?max@@YA?AVcharNDArray@@AEBV1@D@Z"]
    pub fn max1(m: *const charNDArray, d: ::std::os::raw::c_char)
     -> charNDArray;
}
extern "C" {
    #[link_name = "?max@@YA?AVcharNDArray@@AEBV1@0@Z"]
    pub fn max2(a: *const charNDArray, b: *const charNDArray) -> charNDArray;
}
extern "C" {
    #[link_name = "?mx_el_lt@@YA?AVboolNDArray@@AEBVcharNDArray@@AEBD@Z"]
    pub fn mx_el_lt4(arg1: *const charNDArray,
                     arg2: *const ::std::os::raw::c_char) -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_le@@YA?AVboolNDArray@@AEBVcharNDArray@@AEBD@Z"]
    pub fn mx_el_le4(arg1: *const charNDArray,
                     arg2: *const ::std::os::raw::c_char) -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_ge@@YA?AVboolNDArray@@AEBVcharNDArray@@AEBD@Z"]
    pub fn mx_el_ge4(arg1: *const charNDArray,
                     arg2: *const ::std::os::raw::c_char) -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_gt@@YA?AVboolNDArray@@AEBVcharNDArray@@AEBD@Z"]
    pub fn mx_el_gt4(arg1: *const charNDArray,
                     arg2: *const ::std::os::raw::c_char) -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_eq@@YA?AVboolNDArray@@AEBVcharNDArray@@AEBD@Z"]
    pub fn mx_el_eq4(arg1: *const charNDArray,
                     arg2: *const ::std::os::raw::c_char) -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_ne@@YA?AVboolNDArray@@AEBVcharNDArray@@AEBD@Z"]
    pub fn mx_el_ne4(arg1: *const charNDArray,
                     arg2: *const ::std::os::raw::c_char) -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_and@@YA?AVboolNDArray@@AEBVcharNDArray@@AEBD@Z"]
    pub fn mx_el_and6(arg1: *const charNDArray,
                      arg2: *const ::std::os::raw::c_char) -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_or@@YA?AVboolNDArray@@AEBVcharNDArray@@AEBD@Z"]
    pub fn mx_el_or6(arg1: *const charNDArray,
                     arg2: *const ::std::os::raw::c_char) -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_not_and@@YA?AVboolNDArray@@AEBVcharNDArray@@AEBD@Z"]
    pub fn mx_el_not_and2(arg1: *const charNDArray,
                          arg2: *const ::std::os::raw::c_char) -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_not_or@@YA?AVboolNDArray@@AEBVcharNDArray@@AEBD@Z"]
    pub fn mx_el_not_or2(arg1: *const charNDArray,
                         arg2: *const ::std::os::raw::c_char) -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_lt@@YA?AVboolNDArray@@AEBDAEBVcharNDArray@@@Z"]
    pub fn mx_el_lt5(arg1: *const ::std::os::raw::c_char,
                     arg2: *const charNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_le@@YA?AVboolNDArray@@AEBDAEBVcharNDArray@@@Z"]
    pub fn mx_el_le5(arg1: *const ::std::os::raw::c_char,
                     arg2: *const charNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_ge@@YA?AVboolNDArray@@AEBDAEBVcharNDArray@@@Z"]
    pub fn mx_el_ge5(arg1: *const ::std::os::raw::c_char,
                     arg2: *const charNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_gt@@YA?AVboolNDArray@@AEBDAEBVcharNDArray@@@Z"]
    pub fn mx_el_gt5(arg1: *const ::std::os::raw::c_char,
                     arg2: *const charNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_eq@@YA?AVboolNDArray@@AEBDAEBVcharNDArray@@@Z"]
    pub fn mx_el_eq5(arg1: *const ::std::os::raw::c_char,
                     arg2: *const charNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_ne@@YA?AVboolNDArray@@AEBDAEBVcharNDArray@@@Z"]
    pub fn mx_el_ne5(arg1: *const ::std::os::raw::c_char,
                     arg2: *const charNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_and@@YA?AVboolNDArray@@AEBDAEBVcharNDArray@@@Z"]
    pub fn mx_el_and7(arg1: *const ::std::os::raw::c_char,
                      arg2: *const charNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_or@@YA?AVboolNDArray@@AEBDAEBVcharNDArray@@@Z"]
    pub fn mx_el_or7(arg1: *const ::std::os::raw::c_char,
                     arg2: *const charNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_and_not@@YA?AVboolNDArray@@AEBDAEBVcharNDArray@@@Z"]
    pub fn mx_el_and_not2(arg1: *const ::std::os::raw::c_char,
                          arg2: *const charNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_or_not@@YA?AVboolNDArray@@AEBDAEBVcharNDArray@@@Z"]
    pub fn mx_el_or_not2(arg1: *const ::std::os::raw::c_char,
                         arg2: *const charNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_lt@@YA?AVboolNDArray@@AEBVcharNDArray@@0@Z"]
    pub fn mx_el_lt6(arg1: *const charNDArray, arg2: *const charNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_le@@YA?AVboolNDArray@@AEBVcharNDArray@@0@Z"]
    pub fn mx_el_le6(arg1: *const charNDArray, arg2: *const charNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_ge@@YA?AVboolNDArray@@AEBVcharNDArray@@0@Z"]
    pub fn mx_el_ge6(arg1: *const charNDArray, arg2: *const charNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_gt@@YA?AVboolNDArray@@AEBVcharNDArray@@0@Z"]
    pub fn mx_el_gt6(arg1: *const charNDArray, arg2: *const charNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_eq@@YA?AVboolNDArray@@AEBVcharNDArray@@0@Z"]
    pub fn mx_el_eq6(arg1: *const charNDArray, arg2: *const charNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_ne@@YA?AVboolNDArray@@AEBVcharNDArray@@0@Z"]
    pub fn mx_el_ne6(arg1: *const charNDArray, arg2: *const charNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_and@@YA?AVboolNDArray@@AEBVcharNDArray@@0@Z"]
    pub fn mx_el_and8(arg1: *const charNDArray, arg2: *const charNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_or@@YA?AVboolNDArray@@AEBVcharNDArray@@0@Z"]
    pub fn mx_el_or8(arg1: *const charNDArray, arg2: *const charNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_and_not@@YA?AVboolNDArray@@AEBVcharNDArray@@0@Z"]
    pub fn mx_el_and_not3(arg1: *const charNDArray, arg2: *const charNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_or_not@@YA?AVboolNDArray@@AEBVcharNDArray@@0@Z"]
    pub fn mx_el_or_not3(arg1: *const charNDArray, arg2: *const charNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_not_and@@YA?AVboolNDArray@@AEBVcharNDArray@@0@Z"]
    pub fn mx_el_not_and3(arg1: *const charNDArray, arg2: *const charNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_not_or@@YA?AVboolNDArray@@AEBVcharNDArray@@0@Z"]
    pub fn mx_el_not_or3(arg1: *const charNDArray, arg2: *const charNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?bsxfun_eq@@YA?AVboolNDArray@@AEBVcharNDArray@@0@Z"]
    pub fn bsxfun_eq(arg1: *const charNDArray, arg2: *const charNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?bsxfun_ne@@YA?AVboolNDArray@@AEBVcharNDArray@@0@Z"]
    pub fn bsxfun_ne(arg1: *const charNDArray, arg2: *const charNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?bsxfun_lt@@YA?AVboolNDArray@@AEBVcharNDArray@@0@Z"]
    pub fn bsxfun_lt(arg1: *const charNDArray, arg2: *const charNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?bsxfun_le@@YA?AVboolNDArray@@AEBVcharNDArray@@0@Z"]
    pub fn bsxfun_le(arg1: *const charNDArray, arg2: *const charNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?bsxfun_gt@@YA?AVboolNDArray@@AEBVcharNDArray@@0@Z"]
    pub fn bsxfun_gt(arg1: *const charNDArray, arg2: *const charNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?bsxfun_ge@@YA?AVboolNDArray@@AEBVcharNDArray@@0@Z"]
    pub fn bsxfun_ge(arg1: *const charNDArray, arg2: *const charNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_lt@@YA?AVboolMatrix@@AEBVcharMatrix@@AEBD@Z"]
    pub fn mx_el_lt7(arg1: *const charMatrix,
                     arg2: *const ::std::os::raw::c_char) -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_le@@YA?AVboolMatrix@@AEBVcharMatrix@@AEBD@Z"]
    pub fn mx_el_le7(arg1: *const charMatrix,
                     arg2: *const ::std::os::raw::c_char) -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_ge@@YA?AVboolMatrix@@AEBVcharMatrix@@AEBD@Z"]
    pub fn mx_el_ge7(arg1: *const charMatrix,
                     arg2: *const ::std::os::raw::c_char) -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_gt@@YA?AVboolMatrix@@AEBVcharMatrix@@AEBD@Z"]
    pub fn mx_el_gt7(arg1: *const charMatrix,
                     arg2: *const ::std::os::raw::c_char) -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_eq@@YA?AVboolMatrix@@AEBVcharMatrix@@AEBD@Z"]
    pub fn mx_el_eq7(arg1: *const charMatrix,
                     arg2: *const ::std::os::raw::c_char) -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_ne@@YA?AVboolMatrix@@AEBVcharMatrix@@AEBD@Z"]
    pub fn mx_el_ne7(arg1: *const charMatrix,
                     arg2: *const ::std::os::raw::c_char) -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_and@@YA?AVboolMatrix@@AEBVcharMatrix@@AEBD@Z"]
    pub fn mx_el_and9(arg1: *const charMatrix,
                      arg2: *const ::std::os::raw::c_char) -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_or@@YA?AVboolMatrix@@AEBVcharMatrix@@AEBD@Z"]
    pub fn mx_el_or9(arg1: *const charMatrix,
                     arg2: *const ::std::os::raw::c_char) -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_lt@@YA?AVboolMatrix@@AEBDAEBVcharMatrix@@@Z"]
    pub fn mx_el_lt8(arg1: *const ::std::os::raw::c_char,
                     arg2: *const charMatrix) -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_le@@YA?AVboolMatrix@@AEBDAEBVcharMatrix@@@Z"]
    pub fn mx_el_le8(arg1: *const ::std::os::raw::c_char,
                     arg2: *const charMatrix) -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_ge@@YA?AVboolMatrix@@AEBDAEBVcharMatrix@@@Z"]
    pub fn mx_el_ge8(arg1: *const ::std::os::raw::c_char,
                     arg2: *const charMatrix) -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_gt@@YA?AVboolMatrix@@AEBDAEBVcharMatrix@@@Z"]
    pub fn mx_el_gt8(arg1: *const ::std::os::raw::c_char,
                     arg2: *const charMatrix) -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_eq@@YA?AVboolMatrix@@AEBDAEBVcharMatrix@@@Z"]
    pub fn mx_el_eq8(arg1: *const ::std::os::raw::c_char,
                     arg2: *const charMatrix) -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_ne@@YA?AVboolMatrix@@AEBDAEBVcharMatrix@@@Z"]
    pub fn mx_el_ne8(arg1: *const ::std::os::raw::c_char,
                     arg2: *const charMatrix) -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_and@@YA?AVboolMatrix@@AEBDAEBVcharMatrix@@@Z"]
    pub fn mx_el_and10(arg1: *const ::std::os::raw::c_char,
                       arg2: *const charMatrix) -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_or@@YA?AVboolMatrix@@AEBDAEBVcharMatrix@@@Z"]
    pub fn mx_el_or10(arg1: *const ::std::os::raw::c_char,
                      arg2: *const charMatrix) -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_lt@@YA?AVboolMatrix@@AEBVcharMatrix@@0@Z"]
    pub fn mx_el_lt9(arg1: *const charMatrix, arg2: *const charMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_le@@YA?AVboolMatrix@@AEBVcharMatrix@@0@Z"]
    pub fn mx_el_le9(arg1: *const charMatrix, arg2: *const charMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_ge@@YA?AVboolMatrix@@AEBVcharMatrix@@0@Z"]
    pub fn mx_el_ge9(arg1: *const charMatrix, arg2: *const charMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_gt@@YA?AVboolMatrix@@AEBVcharMatrix@@0@Z"]
    pub fn mx_el_gt9(arg1: *const charMatrix, arg2: *const charMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_eq@@YA?AVboolMatrix@@AEBVcharMatrix@@0@Z"]
    pub fn mx_el_eq9(arg1: *const charMatrix, arg2: *const charMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_ne@@YA?AVboolMatrix@@AEBVcharMatrix@@0@Z"]
    pub fn mx_el_ne9(arg1: *const charMatrix, arg2: *const charMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_and@@YA?AVboolMatrix@@AEBVcharMatrix@@0@Z"]
    pub fn mx_el_and11(arg1: *const charMatrix, arg2: *const charMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_or@@YA?AVboolMatrix@@AEBVcharMatrix@@0@Z"]
    pub fn mx_el_or11(arg1: *const charMatrix, arg2: *const charMatrix)
     -> boolMatrix;
}
#[repr(C)]
#[derive(Debug)]
pub struct intNDArray<T> {
    pub _base: MArray<T>,
}
extern "C" {
    #[link_name = "?real@@YA?AVNDArray@@AEBVComplexNDArray@@@Z"]
    pub fn real(a: *const ComplexNDArray) -> NDArray;
}
extern "C" {
    #[link_name = "?imag@@YA?AVNDArray@@AEBVComplexNDArray@@@Z"]
    pub fn imag(a: *const ComplexNDArray) -> NDArray;
}
extern "C" {
    #[link_name = "?min@@YA?AVNDArray@@NAEBV1@@Z"]
    pub fn min3(d: f64, m: *const NDArray) -> NDArray;
}
extern "C" {
    #[link_name = "?min@@YA?AVNDArray@@AEBV1@N@Z"]
    pub fn min4(m: *const NDArray, d: f64) -> NDArray;
}
extern "C" {
    #[link_name = "?min@@YA?AVNDArray@@AEBV1@0@Z"]
    pub fn min5(a: *const NDArray, b: *const NDArray) -> NDArray;
}
extern "C" {
    #[link_name = "?max@@YA?AVNDArray@@NAEBV1@@Z"]
    pub fn max3(d: f64, m: *const NDArray) -> NDArray;
}
extern "C" {
    #[link_name = "?max@@YA?AVNDArray@@AEBV1@N@Z"]
    pub fn max4(m: *const NDArray, d: f64) -> NDArray;
}
extern "C" {
    #[link_name = "?max@@YA?AVNDArray@@AEBV1@0@Z"]
    pub fn max5(a: *const NDArray, b: *const NDArray) -> NDArray;
}
extern "C" {
    #[link_name = "?mx_el_lt@@YA?AVboolNDArray@@AEBVNDArray@@AEBN@Z"]
    pub fn mx_el_lt10(arg1: *const NDArray, arg2: *const f64) -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_le@@YA?AVboolNDArray@@AEBVNDArray@@AEBN@Z"]
    pub fn mx_el_le10(arg1: *const NDArray, arg2: *const f64) -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_ge@@YA?AVboolNDArray@@AEBVNDArray@@AEBN@Z"]
    pub fn mx_el_ge10(arg1: *const NDArray, arg2: *const f64) -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_gt@@YA?AVboolNDArray@@AEBVNDArray@@AEBN@Z"]
    pub fn mx_el_gt10(arg1: *const NDArray, arg2: *const f64) -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_eq@@YA?AVboolNDArray@@AEBVNDArray@@AEBN@Z"]
    pub fn mx_el_eq10(arg1: *const NDArray, arg2: *const f64) -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_ne@@YA?AVboolNDArray@@AEBVNDArray@@AEBN@Z"]
    pub fn mx_el_ne10(arg1: *const NDArray, arg2: *const f64) -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_and@@YA?AVboolNDArray@@AEBVNDArray@@AEBN@Z"]
    pub fn mx_el_and12(arg1: *const NDArray, arg2: *const f64) -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_or@@YA?AVboolNDArray@@AEBVNDArray@@AEBN@Z"]
    pub fn mx_el_or12(arg1: *const NDArray, arg2: *const f64) -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_not_and@@YA?AVboolNDArray@@AEBVNDArray@@AEBN@Z"]
    pub fn mx_el_not_and4(arg1: *const NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_not_or@@YA?AVboolNDArray@@AEBVNDArray@@AEBN@Z"]
    pub fn mx_el_not_or4(arg1: *const NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_lt@@YA?AVboolNDArray@@AEBNAEBVNDArray@@@Z"]
    pub fn mx_el_lt11(arg1: *const f64, arg2: *const NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_le@@YA?AVboolNDArray@@AEBNAEBVNDArray@@@Z"]
    pub fn mx_el_le11(arg1: *const f64, arg2: *const NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_ge@@YA?AVboolNDArray@@AEBNAEBVNDArray@@@Z"]
    pub fn mx_el_ge11(arg1: *const f64, arg2: *const NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_gt@@YA?AVboolNDArray@@AEBNAEBVNDArray@@@Z"]
    pub fn mx_el_gt11(arg1: *const f64, arg2: *const NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_eq@@YA?AVboolNDArray@@AEBNAEBVNDArray@@@Z"]
    pub fn mx_el_eq11(arg1: *const f64, arg2: *const NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_ne@@YA?AVboolNDArray@@AEBNAEBVNDArray@@@Z"]
    pub fn mx_el_ne11(arg1: *const f64, arg2: *const NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_and@@YA?AVboolNDArray@@AEBNAEBVNDArray@@@Z"]
    pub fn mx_el_and13(arg1: *const f64, arg2: *const NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_or@@YA?AVboolNDArray@@AEBNAEBVNDArray@@@Z"]
    pub fn mx_el_or13(arg1: *const f64, arg2: *const NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_and_not@@YA?AVboolNDArray@@AEBNAEBVNDArray@@@Z"]
    pub fn mx_el_and_not4(arg1: *const f64, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_or_not@@YA?AVboolNDArray@@AEBNAEBVNDArray@@@Z"]
    pub fn mx_el_or_not4(arg1: *const f64, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_lt@@YA?AVboolNDArray@@AEBVNDArray@@0@Z"]
    pub fn mx_el_lt12(arg1: *const NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_le@@YA?AVboolNDArray@@AEBVNDArray@@0@Z"]
    pub fn mx_el_le12(arg1: *const NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_ge@@YA?AVboolNDArray@@AEBVNDArray@@0@Z"]
    pub fn mx_el_ge12(arg1: *const NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_gt@@YA?AVboolNDArray@@AEBVNDArray@@0@Z"]
    pub fn mx_el_gt12(arg1: *const NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_eq@@YA?AVboolNDArray@@AEBVNDArray@@0@Z"]
    pub fn mx_el_eq12(arg1: *const NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_ne@@YA?AVboolNDArray@@AEBVNDArray@@0@Z"]
    pub fn mx_el_ne12(arg1: *const NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_and@@YA?AVboolNDArray@@AEBVNDArray@@0@Z"]
    pub fn mx_el_and14(arg1: *const NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_or@@YA?AVboolNDArray@@AEBVNDArray@@0@Z"]
    pub fn mx_el_or14(arg1: *const NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_and_not@@YA?AVboolNDArray@@AEBVNDArray@@0@Z"]
    pub fn mx_el_and_not5(arg1: *const NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_or_not@@YA?AVboolNDArray@@AEBVNDArray@@0@Z"]
    pub fn mx_el_or_not5(arg1: *const NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_not_and@@YA?AVboolNDArray@@AEBVNDArray@@0@Z"]
    pub fn mx_el_not_and5(arg1: *const NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_not_or@@YA?AVboolNDArray@@AEBVNDArray@@0@Z"]
    pub fn mx_el_not_or5(arg1: *const NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?bsxfun_add@@YA?AVNDArray@@AEBV1@0@Z"]
    pub fn bsxfun_add(arg1: *const NDArray, arg2: *const NDArray) -> NDArray;
}
extern "C" {
    #[link_name = "?bsxfun_sub@@YA?AVNDArray@@AEBV1@0@Z"]
    pub fn bsxfun_sub(arg1: *const NDArray, arg2: *const NDArray) -> NDArray;
}
extern "C" {
    #[link_name = "?bsxfun_mul@@YA?AVNDArray@@AEBV1@0@Z"]
    pub fn bsxfun_mul(arg1: *const NDArray, arg2: *const NDArray) -> NDArray;
}
extern "C" {
    #[link_name = "?bsxfun_div@@YA?AVNDArray@@AEBV1@0@Z"]
    pub fn bsxfun_div(arg1: *const NDArray, arg2: *const NDArray) -> NDArray;
}
extern "C" {
    #[link_name = "?bsxfun_pow@@YA?AVNDArray@@AEBV1@0@Z"]
    pub fn bsxfun_pow(arg1: *const NDArray, arg2: *const NDArray) -> NDArray;
}
extern "C" {
    #[link_name = "?bsxfun_min@@YA?AVNDArray@@AEBV1@0@Z"]
    pub fn bsxfun_min(arg1: *const NDArray, arg2: *const NDArray) -> NDArray;
}
extern "C" {
    #[link_name = "?bsxfun_max@@YA?AVNDArray@@AEBV1@0@Z"]
    pub fn bsxfun_max(arg1: *const NDArray, arg2: *const NDArray) -> NDArray;
}
extern "C" {
    #[link_name = "?bsxfun_eq@@YA?AVboolNDArray@@AEBVNDArray@@0@Z"]
    pub fn bsxfun_eq1(arg1: *const NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?bsxfun_ne@@YA?AVboolNDArray@@AEBVNDArray@@0@Z"]
    pub fn bsxfun_ne1(arg1: *const NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?bsxfun_lt@@YA?AVboolNDArray@@AEBVNDArray@@0@Z"]
    pub fn bsxfun_lt1(arg1: *const NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?bsxfun_le@@YA?AVboolNDArray@@AEBVNDArray@@0@Z"]
    pub fn bsxfun_le1(arg1: *const NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?bsxfun_gt@@YA?AVboolNDArray@@AEBVNDArray@@0@Z"]
    pub fn bsxfun_gt1(arg1: *const NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?bsxfun_ge@@YA?AVboolNDArray@@AEBVNDArray@@0@Z"]
    pub fn bsxfun_ge1(arg1: *const NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?bsxfun_pow@@YA?AVComplexNDArray@@AEBV1@AEBVNDArray@@@Z"]
    pub fn bsxfun_pow1(arg1: *const ComplexNDArray, arg2: *const NDArray)
     -> ComplexNDArray;
}
extern "C" {
    #[link_name = "?bsxfun_pow@@YA?AVComplexNDArray@@AEBVNDArray@@AEBV1@@Z"]
    pub fn bsxfun_pow2(arg1: *const NDArray, arg2: *const ComplexNDArray)
     -> ComplexNDArray;
}
#[repr(C)]
#[derive(Debug)]
pub struct DiagArray2<T> {
    pub _base: Array<T>,
    pub d1: octave_idx_type,
    pub d2: octave_idx_type,
}
#[repr(C)]
#[derive(Debug)]
pub struct MDiagArray2<T> {
    pub _base: DiagArray2<T>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct base_det<T> {
    pub c2: T,
    pub e2: ::std::os::raw::c_int,
}
pub type DET = base_det<f64>;
pub type FloatDET = base_det<f32>;
pub type ComplexDET = base_det<std_complex<f64>>;
pub type FloatComplexDET = base_det<std_complex<f32>>;
extern "C" {
    #[link_name = "?real@@YA?AVMatrix@@AEBVComplexMatrix@@@Z"]
    pub fn real1(a: *const ComplexMatrix) -> Matrix;
}
extern "C" {
    #[link_name = "?imag@@YA?AVMatrix@@AEBVComplexMatrix@@@Z"]
    pub fn imag1(a: *const ComplexMatrix) -> Matrix;
}
extern "C" {
    #[link_name = "?Givens@@YA?AVMatrix@@NN@Z"]
    pub fn Givens(arg1: f64, arg2: f64) -> Matrix;
}
extern "C" {
    #[link_name = "?Sylvester@@YA?AVMatrix@@AEBV1@00@Z"]
    pub fn Sylvester(arg1: *const Matrix, arg2: *const Matrix,
                     arg3: *const Matrix) -> Matrix;
}
extern "C" {
    #[link_name = "?xgemm@@YA?AVMatrix@@AEBV1@0W4blas_trans_type@@1@Z"]
    pub fn xgemm(a: *const Matrix, b: *const Matrix, transa: blas_trans_type,
                 transb: blas_trans_type) -> Matrix;
}
extern "C" {
    #[link_name = "?min@@YA?AVMatrix@@NAEBV1@@Z"]
    pub fn min6(d: f64, m: *const Matrix) -> Matrix;
}
extern "C" {
    #[link_name = "?min@@YA?AVMatrix@@AEBV1@N@Z"]
    pub fn min7(m: *const Matrix, d: f64) -> Matrix;
}
extern "C" {
    #[link_name = "?min@@YA?AVMatrix@@AEBV1@0@Z"]
    pub fn min8(a: *const Matrix, b: *const Matrix) -> Matrix;
}
extern "C" {
    #[link_name = "?max@@YA?AVMatrix@@NAEBV1@@Z"]
    pub fn max6(d: f64, m: *const Matrix) -> Matrix;
}
extern "C" {
    #[link_name = "?max@@YA?AVMatrix@@AEBV1@N@Z"]
    pub fn max7(m: *const Matrix, d: f64) -> Matrix;
}
extern "C" {
    #[link_name = "?max@@YA?AVMatrix@@AEBV1@0@Z"]
    pub fn max8(a: *const Matrix, b: *const Matrix) -> Matrix;
}
extern "C" {
    #[link_name = "?linspace@@YA?AVMatrix@@AEBVColumnVector@@0H@Z"]
    pub fn linspace(x1: *const ColumnVector, x2: *const ColumnVector,
                    n: octave_idx_type) -> Matrix;
}
extern "C" {
    #[link_name = "?mx_el_lt@@YA?AVboolMatrix@@AEBVMatrix@@AEBN@Z"]
    pub fn mx_el_lt13(arg1: *const Matrix, arg2: *const f64) -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_le@@YA?AVboolMatrix@@AEBVMatrix@@AEBN@Z"]
    pub fn mx_el_le13(arg1: *const Matrix, arg2: *const f64) -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_ge@@YA?AVboolMatrix@@AEBVMatrix@@AEBN@Z"]
    pub fn mx_el_ge13(arg1: *const Matrix, arg2: *const f64) -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_gt@@YA?AVboolMatrix@@AEBVMatrix@@AEBN@Z"]
    pub fn mx_el_gt13(arg1: *const Matrix, arg2: *const f64) -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_eq@@YA?AVboolMatrix@@AEBVMatrix@@AEBN@Z"]
    pub fn mx_el_eq13(arg1: *const Matrix, arg2: *const f64) -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_ne@@YA?AVboolMatrix@@AEBVMatrix@@AEBN@Z"]
    pub fn mx_el_ne13(arg1: *const Matrix, arg2: *const f64) -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_and@@YA?AVboolMatrix@@AEBVMatrix@@AEBN@Z"]
    pub fn mx_el_and15(arg1: *const Matrix, arg2: *const f64) -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_or@@YA?AVboolMatrix@@AEBVMatrix@@AEBN@Z"]
    pub fn mx_el_or15(arg1: *const Matrix, arg2: *const f64) -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_lt@@YA?AVboolMatrix@@AEBNAEBVMatrix@@@Z"]
    pub fn mx_el_lt14(arg1: *const f64, arg2: *const Matrix) -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_le@@YA?AVboolMatrix@@AEBNAEBVMatrix@@@Z"]
    pub fn mx_el_le14(arg1: *const f64, arg2: *const Matrix) -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_ge@@YA?AVboolMatrix@@AEBNAEBVMatrix@@@Z"]
    pub fn mx_el_ge14(arg1: *const f64, arg2: *const Matrix) -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_gt@@YA?AVboolMatrix@@AEBNAEBVMatrix@@@Z"]
    pub fn mx_el_gt14(arg1: *const f64, arg2: *const Matrix) -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_eq@@YA?AVboolMatrix@@AEBNAEBVMatrix@@@Z"]
    pub fn mx_el_eq14(arg1: *const f64, arg2: *const Matrix) -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_ne@@YA?AVboolMatrix@@AEBNAEBVMatrix@@@Z"]
    pub fn mx_el_ne14(arg1: *const f64, arg2: *const Matrix) -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_and@@YA?AVboolMatrix@@AEBNAEBVMatrix@@@Z"]
    pub fn mx_el_and16(arg1: *const f64, arg2: *const Matrix) -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_or@@YA?AVboolMatrix@@AEBNAEBVMatrix@@@Z"]
    pub fn mx_el_or16(arg1: *const f64, arg2: *const Matrix) -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_lt@@YA?AVboolMatrix@@AEBVMatrix@@0@Z"]
    pub fn mx_el_lt15(arg1: *const Matrix, arg2: *const Matrix) -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_le@@YA?AVboolMatrix@@AEBVMatrix@@0@Z"]
    pub fn mx_el_le15(arg1: *const Matrix, arg2: *const Matrix) -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_ge@@YA?AVboolMatrix@@AEBVMatrix@@0@Z"]
    pub fn mx_el_ge15(arg1: *const Matrix, arg2: *const Matrix) -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_gt@@YA?AVboolMatrix@@AEBVMatrix@@0@Z"]
    pub fn mx_el_gt15(arg1: *const Matrix, arg2: *const Matrix) -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_eq@@YA?AVboolMatrix@@AEBVMatrix@@0@Z"]
    pub fn mx_el_eq15(arg1: *const Matrix, arg2: *const Matrix) -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_ne@@YA?AVboolMatrix@@AEBVMatrix@@0@Z"]
    pub fn mx_el_ne15(arg1: *const Matrix, arg2: *const Matrix) -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_and@@YA?AVboolMatrix@@AEBVMatrix@@0@Z"]
    pub fn mx_el_and17(arg1: *const Matrix, arg2: *const Matrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_or@@YA?AVboolMatrix@@AEBVMatrix@@0@Z"]
    pub fn mx_el_or17(arg1: *const Matrix, arg2: *const Matrix) -> boolMatrix;
}
extern "C" {
    #[link_name = "?conj@@YA?AVComplexNDArray@@AEBV1@@Z"]
    pub fn conj(a: *const ComplexNDArray) -> ComplexNDArray;
}
extern "C" {
    #[link_name = "?min@@YA?AVComplexNDArray@@U?$complex@N@std@@AEBV1@@Z"]
    pub fn min9(d: Complex, m: *const ComplexNDArray) -> ComplexNDArray;
}
extern "C" {
    #[link_name = "?min@@YA?AVComplexNDArray@@AEBV1@U?$complex@N@std@@@Z"]
    pub fn min10(m: *const ComplexNDArray, d: Complex) -> ComplexNDArray;
}
extern "C" {
    #[link_name = "?min@@YA?AVComplexNDArray@@AEBV1@0@Z"]
    pub fn min11(a: *const ComplexNDArray, b: *const ComplexNDArray)
     -> ComplexNDArray;
}
extern "C" {
    #[link_name = "?max@@YA?AVComplexNDArray@@U?$complex@N@std@@AEBV1@@Z"]
    pub fn max9(d: Complex, m: *const ComplexNDArray) -> ComplexNDArray;
}
extern "C" {
    #[link_name = "?max@@YA?AVComplexNDArray@@AEBV1@U?$complex@N@std@@@Z"]
    pub fn max10(m: *const ComplexNDArray, d: Complex) -> ComplexNDArray;
}
extern "C" {
    #[link_name = "?max@@YA?AVComplexNDArray@@AEBV1@0@Z"]
    pub fn max11(a: *const ComplexNDArray, b: *const ComplexNDArray)
     -> ComplexNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBVComplexNDArray@@AEBU?$complex@N@std@@@Z"]
    pub fn mx_el_lt16(arg1: *const ComplexNDArray, arg2: *const Complex)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBVComplexNDArray@@AEBU?$complex@N@std@@@Z"]
    pub fn mx_el_le16(arg1: *const ComplexNDArray, arg2: *const Complex)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBVComplexNDArray@@AEBU?$complex@N@std@@@Z"]
    pub fn mx_el_ge16(arg1: *const ComplexNDArray, arg2: *const Complex)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBVComplexNDArray@@AEBU?$complex@N@std@@@Z"]
    pub fn mx_el_gt16(arg1: *const ComplexNDArray, arg2: *const Complex)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBVComplexNDArray@@AEBU?$complex@N@std@@@Z"]
    pub fn mx_el_eq16(arg1: *const ComplexNDArray, arg2: *const Complex)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBVComplexNDArray@@AEBU?$complex@N@std@@@Z"]
    pub fn mx_el_ne16(arg1: *const ComplexNDArray, arg2: *const Complex)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBVComplexNDArray@@AEBU?$complex@N@std@@@Z"]
    pub fn mx_el_and18(arg1: *const ComplexNDArray, arg2: *const Complex)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBVComplexNDArray@@AEBU?$complex@N@std@@@Z"]
    pub fn mx_el_or18(arg1: *const ComplexNDArray, arg2: *const Complex)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBVComplexNDArray@@AEBU?$complex@N@std@@@Z"]
    pub fn mx_el_not_and6(arg1: *const ComplexNDArray, arg2: *const Complex)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBVComplexNDArray@@AEBU?$complex@N@std@@@Z"]
    pub fn mx_el_not_or6(arg1: *const ComplexNDArray, arg2: *const Complex)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBU?$complex@N@std@@AEBVComplexNDArray@@@Z"]
    pub fn mx_el_lt17(arg1: *const Complex, arg2: *const ComplexNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBU?$complex@N@std@@AEBVComplexNDArray@@@Z"]
    pub fn mx_el_le17(arg1: *const Complex, arg2: *const ComplexNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBU?$complex@N@std@@AEBVComplexNDArray@@@Z"]
    pub fn mx_el_ge17(arg1: *const Complex, arg2: *const ComplexNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBU?$complex@N@std@@AEBVComplexNDArray@@@Z"]
    pub fn mx_el_gt17(arg1: *const Complex, arg2: *const ComplexNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBU?$complex@N@std@@AEBVComplexNDArray@@@Z"]
    pub fn mx_el_eq17(arg1: *const Complex, arg2: *const ComplexNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBU?$complex@N@std@@AEBVComplexNDArray@@@Z"]
    pub fn mx_el_ne17(arg1: *const Complex, arg2: *const ComplexNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBU?$complex@N@std@@AEBVComplexNDArray@@@Z"]
    pub fn mx_el_and19(arg1: *const Complex, arg2: *const ComplexNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBU?$complex@N@std@@AEBVComplexNDArray@@@Z"]
    pub fn mx_el_or19(arg1: *const Complex, arg2: *const ComplexNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBU?$complex@N@std@@AEBVComplexNDArray@@@Z"]
    pub fn mx_el_and_not6(arg1: *const Complex, arg2: *const ComplexNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBU?$complex@N@std@@AEBVComplexNDArray@@@Z"]
    pub fn mx_el_or_not6(arg1: *const Complex, arg2: *const ComplexNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_lt@@YA?AVboolNDArray@@AEBVComplexNDArray@@0@Z"]
    pub fn mx_el_lt18(arg1: *const ComplexNDArray,
                      arg2: *const ComplexNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_le@@YA?AVboolNDArray@@AEBVComplexNDArray@@0@Z"]
    pub fn mx_el_le18(arg1: *const ComplexNDArray,
                      arg2: *const ComplexNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_ge@@YA?AVboolNDArray@@AEBVComplexNDArray@@0@Z"]
    pub fn mx_el_ge18(arg1: *const ComplexNDArray,
                      arg2: *const ComplexNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_gt@@YA?AVboolNDArray@@AEBVComplexNDArray@@0@Z"]
    pub fn mx_el_gt18(arg1: *const ComplexNDArray,
                      arg2: *const ComplexNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_eq@@YA?AVboolNDArray@@AEBVComplexNDArray@@0@Z"]
    pub fn mx_el_eq18(arg1: *const ComplexNDArray,
                      arg2: *const ComplexNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_ne@@YA?AVboolNDArray@@AEBVComplexNDArray@@0@Z"]
    pub fn mx_el_ne18(arg1: *const ComplexNDArray,
                      arg2: *const ComplexNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_and@@YA?AVboolNDArray@@AEBVComplexNDArray@@0@Z"]
    pub fn mx_el_and20(arg1: *const ComplexNDArray,
                       arg2: *const ComplexNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_or@@YA?AVboolNDArray@@AEBVComplexNDArray@@0@Z"]
    pub fn mx_el_or20(arg1: *const ComplexNDArray,
                      arg2: *const ComplexNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_and_not@@YA?AVboolNDArray@@AEBVComplexNDArray@@0@Z"]
    pub fn mx_el_and_not7(arg1: *const ComplexNDArray,
                          arg2: *const ComplexNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_or_not@@YA?AVboolNDArray@@AEBVComplexNDArray@@0@Z"]
    pub fn mx_el_or_not7(arg1: *const ComplexNDArray,
                         arg2: *const ComplexNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_not_and@@YA?AVboolNDArray@@AEBVComplexNDArray@@0@Z"]
    pub fn mx_el_not_and7(arg1: *const ComplexNDArray,
                          arg2: *const ComplexNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_not_or@@YA?AVboolNDArray@@AEBVComplexNDArray@@0@Z"]
    pub fn mx_el_not_or7(arg1: *const ComplexNDArray,
                         arg2: *const ComplexNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name = "?bsxfun_add@@YA?AVComplexNDArray@@AEBV1@0@Z"]
    pub fn bsxfun_add1(arg1: *const ComplexNDArray,
                       arg2: *const ComplexNDArray) -> ComplexNDArray;
}
extern "C" {
    #[link_name = "?bsxfun_sub@@YA?AVComplexNDArray@@AEBV1@0@Z"]
    pub fn bsxfun_sub1(arg1: *const ComplexNDArray,
                       arg2: *const ComplexNDArray) -> ComplexNDArray;
}
extern "C" {
    #[link_name = "?bsxfun_mul@@YA?AVComplexNDArray@@AEBV1@0@Z"]
    pub fn bsxfun_mul1(arg1: *const ComplexNDArray,
                       arg2: *const ComplexNDArray) -> ComplexNDArray;
}
extern "C" {
    #[link_name = "?bsxfun_div@@YA?AVComplexNDArray@@AEBV1@0@Z"]
    pub fn bsxfun_div1(arg1: *const ComplexNDArray,
                       arg2: *const ComplexNDArray) -> ComplexNDArray;
}
extern "C" {
    #[link_name = "?bsxfun_pow@@YA?AVComplexNDArray@@AEBV1@0@Z"]
    pub fn bsxfun_pow3(arg1: *const ComplexNDArray,
                       arg2: *const ComplexNDArray) -> ComplexNDArray;
}
extern "C" {
    #[link_name = "?bsxfun_min@@YA?AVComplexNDArray@@AEBV1@0@Z"]
    pub fn bsxfun_min1(arg1: *const ComplexNDArray,
                       arg2: *const ComplexNDArray) -> ComplexNDArray;
}
extern "C" {
    #[link_name = "?bsxfun_max@@YA?AVComplexNDArray@@AEBV1@0@Z"]
    pub fn bsxfun_max1(arg1: *const ComplexNDArray,
                       arg2: *const ComplexNDArray) -> ComplexNDArray;
}
extern "C" {
    #[link_name = "?bsxfun_eq@@YA?AVboolNDArray@@AEBVComplexNDArray@@0@Z"]
    pub fn bsxfun_eq2(arg1: *const ComplexNDArray,
                      arg2: *const ComplexNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name = "?bsxfun_ne@@YA?AVboolNDArray@@AEBVComplexNDArray@@0@Z"]
    pub fn bsxfun_ne2(arg1: *const ComplexNDArray,
                      arg2: *const ComplexNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name = "?bsxfun_lt@@YA?AVboolNDArray@@AEBVComplexNDArray@@0@Z"]
    pub fn bsxfun_lt2(arg1: *const ComplexNDArray,
                      arg2: *const ComplexNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name = "?bsxfun_le@@YA?AVboolNDArray@@AEBVComplexNDArray@@0@Z"]
    pub fn bsxfun_le2(arg1: *const ComplexNDArray,
                      arg2: *const ComplexNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name = "?bsxfun_gt@@YA?AVboolNDArray@@AEBVComplexNDArray@@0@Z"]
    pub fn bsxfun_gt2(arg1: *const ComplexNDArray,
                      arg2: *const ComplexNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name = "?bsxfun_ge@@YA?AVboolNDArray@@AEBVComplexNDArray@@0@Z"]
    pub fn bsxfun_ge2(arg1: *const ComplexNDArray,
                      arg2: *const ComplexNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name = "?conj@@YA?AVComplexMatrix@@AEBV1@@Z"]
    pub fn conj1(a: *const ComplexMatrix) -> ComplexMatrix;
}
extern "C" {
    #[link_name = "?Givens@@YA?AVComplexMatrix@@AEBU?$complex@N@std@@0@Z"]
    pub fn Givens1(arg1: *const Complex, arg2: *const Complex)
     -> ComplexMatrix;
}
extern "C" {
    #[link_name = "?Sylvester@@YA?AVComplexMatrix@@AEBV1@00@Z"]
    pub fn Sylvester1(arg1: *const ComplexMatrix, arg2: *const ComplexMatrix,
                      arg3: *const ComplexMatrix) -> ComplexMatrix;
}
extern "C" {
    #[link_name = "?xgemm@@YA?AVComplexMatrix@@AEBV1@0W4blas_trans_type@@1@Z"]
    pub fn xgemm1(a: *const ComplexMatrix, b: *const ComplexMatrix,
                  transa: blas_trans_type, transb: blas_trans_type)
     -> ComplexMatrix;
}
extern "C" {
    #[link_name = "?min@@YA?AVComplexMatrix@@AEBU?$complex@N@std@@AEBV1@@Z"]
    pub fn min12(c: *const Complex, m: *const ComplexMatrix) -> ComplexMatrix;
}
extern "C" {
    #[link_name = "?min@@YA?AVComplexMatrix@@AEBV1@AEBU?$complex@N@std@@@Z"]
    pub fn min13(m: *const ComplexMatrix, c: *const Complex) -> ComplexMatrix;
}
extern "C" {
    #[link_name = "?min@@YA?AVComplexMatrix@@AEBV1@0@Z"]
    pub fn min14(a: *const ComplexMatrix, b: *const ComplexMatrix)
     -> ComplexMatrix;
}
extern "C" {
    #[link_name = "?max@@YA?AVComplexMatrix@@AEBU?$complex@N@std@@AEBV1@@Z"]
    pub fn max12(c: *const Complex, m: *const ComplexMatrix) -> ComplexMatrix;
}
extern "C" {
    #[link_name = "?max@@YA?AVComplexMatrix@@AEBV1@AEBU?$complex@N@std@@@Z"]
    pub fn max13(m: *const ComplexMatrix, c: *const Complex) -> ComplexMatrix;
}
extern "C" {
    #[link_name = "?max@@YA?AVComplexMatrix@@AEBV1@0@Z"]
    pub fn max14(a: *const ComplexMatrix, b: *const ComplexMatrix)
     -> ComplexMatrix;
}
extern "C" {
    #[link_name =
          "?linspace@@YA?AVComplexMatrix@@AEBVComplexColumnVector@@0H@Z"]
    pub fn linspace1(x1: *const ComplexColumnVector,
                     x2: *const ComplexColumnVector, n: octave_idx_type)
     -> ComplexMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolMatrix@@AEBVComplexMatrix@@AEBU?$complex@N@std@@@Z"]
    pub fn mx_el_lt19(arg1: *const ComplexMatrix, arg2: *const Complex)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolMatrix@@AEBVComplexMatrix@@AEBU?$complex@N@std@@@Z"]
    pub fn mx_el_le19(arg1: *const ComplexMatrix, arg2: *const Complex)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolMatrix@@AEBVComplexMatrix@@AEBU?$complex@N@std@@@Z"]
    pub fn mx_el_ge19(arg1: *const ComplexMatrix, arg2: *const Complex)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolMatrix@@AEBVComplexMatrix@@AEBU?$complex@N@std@@@Z"]
    pub fn mx_el_gt19(arg1: *const ComplexMatrix, arg2: *const Complex)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolMatrix@@AEBVComplexMatrix@@AEBU?$complex@N@std@@@Z"]
    pub fn mx_el_eq19(arg1: *const ComplexMatrix, arg2: *const Complex)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolMatrix@@AEBVComplexMatrix@@AEBU?$complex@N@std@@@Z"]
    pub fn mx_el_ne19(arg1: *const ComplexMatrix, arg2: *const Complex)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolMatrix@@AEBVComplexMatrix@@AEBU?$complex@N@std@@@Z"]
    pub fn mx_el_and21(arg1: *const ComplexMatrix, arg2: *const Complex)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolMatrix@@AEBVComplexMatrix@@AEBU?$complex@N@std@@@Z"]
    pub fn mx_el_or21(arg1: *const ComplexMatrix, arg2: *const Complex)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolMatrix@@AEBU?$complex@N@std@@AEBVComplexMatrix@@@Z"]
    pub fn mx_el_lt20(arg1: *const Complex, arg2: *const ComplexMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolMatrix@@AEBU?$complex@N@std@@AEBVComplexMatrix@@@Z"]
    pub fn mx_el_le20(arg1: *const Complex, arg2: *const ComplexMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolMatrix@@AEBU?$complex@N@std@@AEBVComplexMatrix@@@Z"]
    pub fn mx_el_ge20(arg1: *const Complex, arg2: *const ComplexMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolMatrix@@AEBU?$complex@N@std@@AEBVComplexMatrix@@@Z"]
    pub fn mx_el_gt20(arg1: *const Complex, arg2: *const ComplexMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolMatrix@@AEBU?$complex@N@std@@AEBVComplexMatrix@@@Z"]
    pub fn mx_el_eq20(arg1: *const Complex, arg2: *const ComplexMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolMatrix@@AEBU?$complex@N@std@@AEBVComplexMatrix@@@Z"]
    pub fn mx_el_ne20(arg1: *const Complex, arg2: *const ComplexMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolMatrix@@AEBU?$complex@N@std@@AEBVComplexMatrix@@@Z"]
    pub fn mx_el_and22(arg1: *const Complex, arg2: *const ComplexMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolMatrix@@AEBU?$complex@N@std@@AEBVComplexMatrix@@@Z"]
    pub fn mx_el_or22(arg1: *const Complex, arg2: *const ComplexMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_lt@@YA?AVboolMatrix@@AEBVComplexMatrix@@0@Z"]
    pub fn mx_el_lt21(arg1: *const ComplexMatrix, arg2: *const ComplexMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_le@@YA?AVboolMatrix@@AEBVComplexMatrix@@0@Z"]
    pub fn mx_el_le21(arg1: *const ComplexMatrix, arg2: *const ComplexMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_ge@@YA?AVboolMatrix@@AEBVComplexMatrix@@0@Z"]
    pub fn mx_el_ge21(arg1: *const ComplexMatrix, arg2: *const ComplexMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_gt@@YA?AVboolMatrix@@AEBVComplexMatrix@@0@Z"]
    pub fn mx_el_gt21(arg1: *const ComplexMatrix, arg2: *const ComplexMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_eq@@YA?AVboolMatrix@@AEBVComplexMatrix@@0@Z"]
    pub fn mx_el_eq21(arg1: *const ComplexMatrix, arg2: *const ComplexMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_ne@@YA?AVboolMatrix@@AEBVComplexMatrix@@0@Z"]
    pub fn mx_el_ne21(arg1: *const ComplexMatrix, arg2: *const ComplexMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_and@@YA?AVboolMatrix@@AEBVComplexMatrix@@0@Z"]
    pub fn mx_el_and23(arg1: *const ComplexMatrix, arg2: *const ComplexMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_or@@YA?AVboolMatrix@@AEBVComplexMatrix@@0@Z"]
    pub fn mx_el_or23(arg1: *const ComplexMatrix, arg2: *const ComplexMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name = "?real@@YA?AVFloatNDArray@@AEBVFloatComplexNDArray@@@Z"]
    pub fn real2(a: *const FloatComplexNDArray) -> FloatNDArray;
}
extern "C" {
    #[link_name = "?imag@@YA?AVFloatNDArray@@AEBVFloatComplexNDArray@@@Z"]
    pub fn imag2(a: *const FloatComplexNDArray) -> FloatNDArray;
}
extern "C" {
    #[link_name = "?min@@YA?AVFloatNDArray@@MAEBV1@@Z"]
    pub fn min15(d: f32, m: *const FloatNDArray) -> FloatNDArray;
}
extern "C" {
    #[link_name = "?min@@YA?AVFloatNDArray@@AEBV1@M@Z"]
    pub fn min16(m: *const FloatNDArray, d: f32) -> FloatNDArray;
}
extern "C" {
    #[link_name = "?min@@YA?AVFloatNDArray@@AEBV1@0@Z"]
    pub fn min17(a: *const FloatNDArray, b: *const FloatNDArray)
     -> FloatNDArray;
}
extern "C" {
    #[link_name = "?max@@YA?AVFloatNDArray@@MAEBV1@@Z"]
    pub fn max15(d: f32, m: *const FloatNDArray) -> FloatNDArray;
}
extern "C" {
    #[link_name = "?max@@YA?AVFloatNDArray@@AEBV1@M@Z"]
    pub fn max16(m: *const FloatNDArray, d: f32) -> FloatNDArray;
}
extern "C" {
    #[link_name = "?max@@YA?AVFloatNDArray@@AEBV1@0@Z"]
    pub fn max17(a: *const FloatNDArray, b: *const FloatNDArray)
     -> FloatNDArray;
}
extern "C" {
    #[link_name = "?mx_el_lt@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBM@Z"]
    pub fn mx_el_lt22(arg1: *const FloatNDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_le@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBM@Z"]
    pub fn mx_el_le22(arg1: *const FloatNDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_ge@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBM@Z"]
    pub fn mx_el_ge22(arg1: *const FloatNDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_gt@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBM@Z"]
    pub fn mx_el_gt22(arg1: *const FloatNDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_eq@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBM@Z"]
    pub fn mx_el_eq22(arg1: *const FloatNDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_ne@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBM@Z"]
    pub fn mx_el_ne22(arg1: *const FloatNDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_and@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBM@Z"]
    pub fn mx_el_and24(arg1: *const FloatNDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_or@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBM@Z"]
    pub fn mx_el_or24(arg1: *const FloatNDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBM@Z"]
    pub fn mx_el_not_and8(arg1: *const FloatNDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_not_or@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBM@Z"]
    pub fn mx_el_not_or8(arg1: *const FloatNDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_lt@@YA?AVboolNDArray@@AEBMAEBVFloatNDArray@@@Z"]
    pub fn mx_el_lt23(arg1: *const f32, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_le@@YA?AVboolNDArray@@AEBMAEBVFloatNDArray@@@Z"]
    pub fn mx_el_le23(arg1: *const f32, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_ge@@YA?AVboolNDArray@@AEBMAEBVFloatNDArray@@@Z"]
    pub fn mx_el_ge23(arg1: *const f32, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_gt@@YA?AVboolNDArray@@AEBMAEBVFloatNDArray@@@Z"]
    pub fn mx_el_gt23(arg1: *const f32, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_eq@@YA?AVboolNDArray@@AEBMAEBVFloatNDArray@@@Z"]
    pub fn mx_el_eq23(arg1: *const f32, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_ne@@YA?AVboolNDArray@@AEBMAEBVFloatNDArray@@@Z"]
    pub fn mx_el_ne23(arg1: *const f32, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_and@@YA?AVboolNDArray@@AEBMAEBVFloatNDArray@@@Z"]
    pub fn mx_el_and25(arg1: *const f32, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_or@@YA?AVboolNDArray@@AEBMAEBVFloatNDArray@@@Z"]
    pub fn mx_el_or25(arg1: *const f32, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBMAEBVFloatNDArray@@@Z"]
    pub fn mx_el_and_not8(arg1: *const f32, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_or_not@@YA?AVboolNDArray@@AEBMAEBVFloatNDArray@@@Z"]
    pub fn mx_el_or_not8(arg1: *const f32, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_lt@@YA?AVboolNDArray@@AEBVFloatNDArray@@0@Z"]
    pub fn mx_el_lt24(arg1: *const FloatNDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_le@@YA?AVboolNDArray@@AEBVFloatNDArray@@0@Z"]
    pub fn mx_el_le24(arg1: *const FloatNDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_ge@@YA?AVboolNDArray@@AEBVFloatNDArray@@0@Z"]
    pub fn mx_el_ge24(arg1: *const FloatNDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_gt@@YA?AVboolNDArray@@AEBVFloatNDArray@@0@Z"]
    pub fn mx_el_gt24(arg1: *const FloatNDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_eq@@YA?AVboolNDArray@@AEBVFloatNDArray@@0@Z"]
    pub fn mx_el_eq24(arg1: *const FloatNDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_ne@@YA?AVboolNDArray@@AEBVFloatNDArray@@0@Z"]
    pub fn mx_el_ne24(arg1: *const FloatNDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_and@@YA?AVboolNDArray@@AEBVFloatNDArray@@0@Z"]
    pub fn mx_el_and26(arg1: *const FloatNDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_or@@YA?AVboolNDArray@@AEBVFloatNDArray@@0@Z"]
    pub fn mx_el_or26(arg1: *const FloatNDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_and_not@@YA?AVboolNDArray@@AEBVFloatNDArray@@0@Z"]
    pub fn mx_el_and_not9(arg1: *const FloatNDArray,
                          arg2: *const FloatNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_or_not@@YA?AVboolNDArray@@AEBVFloatNDArray@@0@Z"]
    pub fn mx_el_or_not9(arg1: *const FloatNDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_not_and@@YA?AVboolNDArray@@AEBVFloatNDArray@@0@Z"]
    pub fn mx_el_not_and9(arg1: *const FloatNDArray,
                          arg2: *const FloatNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_not_or@@YA?AVboolNDArray@@AEBVFloatNDArray@@0@Z"]
    pub fn mx_el_not_or9(arg1: *const FloatNDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?bsxfun_add@@YA?AVFloatNDArray@@AEBV1@0@Z"]
    pub fn bsxfun_add2(arg1: *const FloatNDArray, arg2: *const FloatNDArray)
     -> FloatNDArray;
}
extern "C" {
    #[link_name = "?bsxfun_sub@@YA?AVFloatNDArray@@AEBV1@0@Z"]
    pub fn bsxfun_sub2(arg1: *const FloatNDArray, arg2: *const FloatNDArray)
     -> FloatNDArray;
}
extern "C" {
    #[link_name = "?bsxfun_mul@@YA?AVFloatNDArray@@AEBV1@0@Z"]
    pub fn bsxfun_mul2(arg1: *const FloatNDArray, arg2: *const FloatNDArray)
     -> FloatNDArray;
}
extern "C" {
    #[link_name = "?bsxfun_div@@YA?AVFloatNDArray@@AEBV1@0@Z"]
    pub fn bsxfun_div2(arg1: *const FloatNDArray, arg2: *const FloatNDArray)
     -> FloatNDArray;
}
extern "C" {
    #[link_name = "?bsxfun_pow@@YA?AVFloatNDArray@@AEBV1@0@Z"]
    pub fn bsxfun_pow4(arg1: *const FloatNDArray, arg2: *const FloatNDArray)
     -> FloatNDArray;
}
extern "C" {
    #[link_name = "?bsxfun_min@@YA?AVFloatNDArray@@AEBV1@0@Z"]
    pub fn bsxfun_min2(arg1: *const FloatNDArray, arg2: *const FloatNDArray)
     -> FloatNDArray;
}
extern "C" {
    #[link_name = "?bsxfun_max@@YA?AVFloatNDArray@@AEBV1@0@Z"]
    pub fn bsxfun_max2(arg1: *const FloatNDArray, arg2: *const FloatNDArray)
     -> FloatNDArray;
}
extern "C" {
    #[link_name = "?bsxfun_eq@@YA?AVboolNDArray@@AEBVFloatNDArray@@0@Z"]
    pub fn bsxfun_eq3(arg1: *const FloatNDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?bsxfun_ne@@YA?AVboolNDArray@@AEBVFloatNDArray@@0@Z"]
    pub fn bsxfun_ne3(arg1: *const FloatNDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?bsxfun_lt@@YA?AVboolNDArray@@AEBVFloatNDArray@@0@Z"]
    pub fn bsxfun_lt3(arg1: *const FloatNDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?bsxfun_le@@YA?AVboolNDArray@@AEBVFloatNDArray@@0@Z"]
    pub fn bsxfun_le3(arg1: *const FloatNDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?bsxfun_gt@@YA?AVboolNDArray@@AEBVFloatNDArray@@0@Z"]
    pub fn bsxfun_gt3(arg1: *const FloatNDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?bsxfun_ge@@YA?AVboolNDArray@@AEBVFloatNDArray@@0@Z"]
    pub fn bsxfun_ge3(arg1: *const FloatNDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_pow@@YA?AVFloatComplexNDArray@@AEBV1@AEBVFloatNDArray@@@Z"]
    pub fn bsxfun_pow5(arg1: *const FloatComplexNDArray,
                       arg2: *const FloatNDArray) -> FloatComplexNDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_pow@@YA?AVFloatComplexNDArray@@AEBVFloatNDArray@@AEBV1@@Z"]
    pub fn bsxfun_pow6(arg1: *const FloatNDArray,
                       arg2: *const FloatComplexNDArray)
     -> FloatComplexNDArray;
}
extern "C" {
    #[link_name = "?real@@YA?AVFloatMatrix@@AEBVFloatComplexMatrix@@@Z"]
    pub fn real3(a: *const FloatComplexMatrix) -> FloatMatrix;
}
extern "C" {
    #[link_name = "?imag@@YA?AVFloatMatrix@@AEBVFloatComplexMatrix@@@Z"]
    pub fn imag3(a: *const FloatComplexMatrix) -> FloatMatrix;
}
extern "C" {
    #[link_name = "?Givens@@YA?AVFloatMatrix@@MM@Z"]
    pub fn Givens2(arg1: f32, arg2: f32) -> FloatMatrix;
}
extern "C" {
    #[link_name = "?Sylvester@@YA?AVFloatMatrix@@AEBV1@00@Z"]
    pub fn Sylvester2(arg1: *const FloatMatrix, arg2: *const FloatMatrix,
                      arg3: *const FloatMatrix) -> FloatMatrix;
}
extern "C" {
    #[link_name = "?xgemm@@YA?AVFloatMatrix@@AEBV1@0W4blas_trans_type@@1@Z"]
    pub fn xgemm2(a: *const FloatMatrix, b: *const FloatMatrix,
                  transa: blas_trans_type, transb: blas_trans_type)
     -> FloatMatrix;
}
extern "C" {
    #[link_name = "?min@@YA?AVFloatMatrix@@MAEBV1@@Z"]
    pub fn min18(d: f32, m: *const FloatMatrix) -> FloatMatrix;
}
extern "C" {
    #[link_name = "?min@@YA?AVFloatMatrix@@AEBV1@M@Z"]
    pub fn min19(m: *const FloatMatrix, d: f32) -> FloatMatrix;
}
extern "C" {
    #[link_name = "?min@@YA?AVFloatMatrix@@AEBV1@0@Z"]
    pub fn min20(a: *const FloatMatrix, b: *const FloatMatrix) -> FloatMatrix;
}
extern "C" {
    #[link_name = "?max@@YA?AVFloatMatrix@@MAEBV1@@Z"]
    pub fn max18(d: f32, m: *const FloatMatrix) -> FloatMatrix;
}
extern "C" {
    #[link_name = "?max@@YA?AVFloatMatrix@@AEBV1@M@Z"]
    pub fn max19(m: *const FloatMatrix, d: f32) -> FloatMatrix;
}
extern "C" {
    #[link_name = "?max@@YA?AVFloatMatrix@@AEBV1@0@Z"]
    pub fn max20(a: *const FloatMatrix, b: *const FloatMatrix) -> FloatMatrix;
}
extern "C" {
    #[link_name = "?linspace@@YA?AVFloatMatrix@@AEBVFloatColumnVector@@0H@Z"]
    pub fn linspace2(x1: *const FloatColumnVector,
                     x2: *const FloatColumnVector, n: octave_idx_type)
     -> FloatMatrix;
}
extern "C" {
    #[link_name = "?mx_el_lt@@YA?AVboolMatrix@@AEBVFloatMatrix@@AEBM@Z"]
    pub fn mx_el_lt25(arg1: *const FloatMatrix, arg2: *const f32)
     -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_le@@YA?AVboolMatrix@@AEBVFloatMatrix@@AEBM@Z"]
    pub fn mx_el_le25(arg1: *const FloatMatrix, arg2: *const f32)
     -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_ge@@YA?AVboolMatrix@@AEBVFloatMatrix@@AEBM@Z"]
    pub fn mx_el_ge25(arg1: *const FloatMatrix, arg2: *const f32)
     -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_gt@@YA?AVboolMatrix@@AEBVFloatMatrix@@AEBM@Z"]
    pub fn mx_el_gt25(arg1: *const FloatMatrix, arg2: *const f32)
     -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_eq@@YA?AVboolMatrix@@AEBVFloatMatrix@@AEBM@Z"]
    pub fn mx_el_eq25(arg1: *const FloatMatrix, arg2: *const f32)
     -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_ne@@YA?AVboolMatrix@@AEBVFloatMatrix@@AEBM@Z"]
    pub fn mx_el_ne25(arg1: *const FloatMatrix, arg2: *const f32)
     -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_and@@YA?AVboolMatrix@@AEBVFloatMatrix@@AEBM@Z"]
    pub fn mx_el_and27(arg1: *const FloatMatrix, arg2: *const f32)
     -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_or@@YA?AVboolMatrix@@AEBVFloatMatrix@@AEBM@Z"]
    pub fn mx_el_or27(arg1: *const FloatMatrix, arg2: *const f32)
     -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_lt@@YA?AVboolMatrix@@AEBMAEBVFloatMatrix@@@Z"]
    pub fn mx_el_lt26(arg1: *const f32, arg2: *const FloatMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_le@@YA?AVboolMatrix@@AEBMAEBVFloatMatrix@@@Z"]
    pub fn mx_el_le26(arg1: *const f32, arg2: *const FloatMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_ge@@YA?AVboolMatrix@@AEBMAEBVFloatMatrix@@@Z"]
    pub fn mx_el_ge26(arg1: *const f32, arg2: *const FloatMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_gt@@YA?AVboolMatrix@@AEBMAEBVFloatMatrix@@@Z"]
    pub fn mx_el_gt26(arg1: *const f32, arg2: *const FloatMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_eq@@YA?AVboolMatrix@@AEBMAEBVFloatMatrix@@@Z"]
    pub fn mx_el_eq26(arg1: *const f32, arg2: *const FloatMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_ne@@YA?AVboolMatrix@@AEBMAEBVFloatMatrix@@@Z"]
    pub fn mx_el_ne26(arg1: *const f32, arg2: *const FloatMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_and@@YA?AVboolMatrix@@AEBMAEBVFloatMatrix@@@Z"]
    pub fn mx_el_and28(arg1: *const f32, arg2: *const FloatMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_or@@YA?AVboolMatrix@@AEBMAEBVFloatMatrix@@@Z"]
    pub fn mx_el_or28(arg1: *const f32, arg2: *const FloatMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_lt@@YA?AVboolMatrix@@AEBVFloatMatrix@@0@Z"]
    pub fn mx_el_lt27(arg1: *const FloatMatrix, arg2: *const FloatMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_le@@YA?AVboolMatrix@@AEBVFloatMatrix@@0@Z"]
    pub fn mx_el_le27(arg1: *const FloatMatrix, arg2: *const FloatMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_ge@@YA?AVboolMatrix@@AEBVFloatMatrix@@0@Z"]
    pub fn mx_el_ge27(arg1: *const FloatMatrix, arg2: *const FloatMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_gt@@YA?AVboolMatrix@@AEBVFloatMatrix@@0@Z"]
    pub fn mx_el_gt27(arg1: *const FloatMatrix, arg2: *const FloatMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_eq@@YA?AVboolMatrix@@AEBVFloatMatrix@@0@Z"]
    pub fn mx_el_eq27(arg1: *const FloatMatrix, arg2: *const FloatMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_ne@@YA?AVboolMatrix@@AEBVFloatMatrix@@0@Z"]
    pub fn mx_el_ne27(arg1: *const FloatMatrix, arg2: *const FloatMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_and@@YA?AVboolMatrix@@AEBVFloatMatrix@@0@Z"]
    pub fn mx_el_and29(arg1: *const FloatMatrix, arg2: *const FloatMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_or@@YA?AVboolMatrix@@AEBVFloatMatrix@@0@Z"]
    pub fn mx_el_or29(arg1: *const FloatMatrix, arg2: *const FloatMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name = "?conj@@YA?AVFloatComplexNDArray@@AEBV1@@Z"]
    pub fn conj2(a: *const FloatComplexNDArray) -> FloatComplexNDArray;
}
extern "C" {
    #[link_name =
          "?min@@YA?AVFloatComplexNDArray@@U?$complex@M@std@@AEBV1@@Z"]
    pub fn min21(d: FloatComplex, m: *const FloatComplexNDArray)
     -> FloatComplexNDArray;
}
extern "C" {
    #[link_name =
          "?min@@YA?AVFloatComplexNDArray@@AEBV1@U?$complex@M@std@@@Z"]
    pub fn min22(m: *const FloatComplexNDArray, d: FloatComplex)
     -> FloatComplexNDArray;
}
extern "C" {
    #[link_name = "?min@@YA?AVFloatComplexNDArray@@AEBV1@0@Z"]
    pub fn min23(a: *const FloatComplexNDArray, b: *const FloatComplexNDArray)
     -> FloatComplexNDArray;
}
extern "C" {
    #[link_name =
          "?max@@YA?AVFloatComplexNDArray@@U?$complex@M@std@@AEBV1@@Z"]
    pub fn max21(d: FloatComplex, m: *const FloatComplexNDArray)
     -> FloatComplexNDArray;
}
extern "C" {
    #[link_name =
          "?max@@YA?AVFloatComplexNDArray@@AEBV1@U?$complex@M@std@@@Z"]
    pub fn max22(m: *const FloatComplexNDArray, d: FloatComplex)
     -> FloatComplexNDArray;
}
extern "C" {
    #[link_name = "?max@@YA?AVFloatComplexNDArray@@AEBV1@0@Z"]
    pub fn max23(a: *const FloatComplexNDArray, b: *const FloatComplexNDArray)
     -> FloatComplexNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBVFloatComplexNDArray@@AEBU?$complex@M@std@@@Z"]
    pub fn mx_el_lt28(arg1: *const FloatComplexNDArray,
                      arg2: *const FloatComplex) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBVFloatComplexNDArray@@AEBU?$complex@M@std@@@Z"]
    pub fn mx_el_le28(arg1: *const FloatComplexNDArray,
                      arg2: *const FloatComplex) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBVFloatComplexNDArray@@AEBU?$complex@M@std@@@Z"]
    pub fn mx_el_ge28(arg1: *const FloatComplexNDArray,
                      arg2: *const FloatComplex) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBVFloatComplexNDArray@@AEBU?$complex@M@std@@@Z"]
    pub fn mx_el_gt28(arg1: *const FloatComplexNDArray,
                      arg2: *const FloatComplex) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBVFloatComplexNDArray@@AEBU?$complex@M@std@@@Z"]
    pub fn mx_el_eq28(arg1: *const FloatComplexNDArray,
                      arg2: *const FloatComplex) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBVFloatComplexNDArray@@AEBU?$complex@M@std@@@Z"]
    pub fn mx_el_ne28(arg1: *const FloatComplexNDArray,
                      arg2: *const FloatComplex) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBVFloatComplexNDArray@@AEBU?$complex@M@std@@@Z"]
    pub fn mx_el_and30(arg1: *const FloatComplexNDArray,
                       arg2: *const FloatComplex) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBVFloatComplexNDArray@@AEBU?$complex@M@std@@@Z"]
    pub fn mx_el_or30(arg1: *const FloatComplexNDArray,
                      arg2: *const FloatComplex) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBVFloatComplexNDArray@@AEBU?$complex@M@std@@@Z"]
    pub fn mx_el_not_and10(arg1: *const FloatComplexNDArray,
                           arg2: *const FloatComplex) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBVFloatComplexNDArray@@AEBU?$complex@M@std@@@Z"]
    pub fn mx_el_not_or10(arg1: *const FloatComplexNDArray,
                          arg2: *const FloatComplex) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBU?$complex@M@std@@AEBVFloatComplexNDArray@@@Z"]
    pub fn mx_el_lt29(arg1: *const FloatComplex,
                      arg2: *const FloatComplexNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBU?$complex@M@std@@AEBVFloatComplexNDArray@@@Z"]
    pub fn mx_el_le29(arg1: *const FloatComplex,
                      arg2: *const FloatComplexNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBU?$complex@M@std@@AEBVFloatComplexNDArray@@@Z"]
    pub fn mx_el_ge29(arg1: *const FloatComplex,
                      arg2: *const FloatComplexNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBU?$complex@M@std@@AEBVFloatComplexNDArray@@@Z"]
    pub fn mx_el_gt29(arg1: *const FloatComplex,
                      arg2: *const FloatComplexNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBU?$complex@M@std@@AEBVFloatComplexNDArray@@@Z"]
    pub fn mx_el_eq29(arg1: *const FloatComplex,
                      arg2: *const FloatComplexNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBU?$complex@M@std@@AEBVFloatComplexNDArray@@@Z"]
    pub fn mx_el_ne29(arg1: *const FloatComplex,
                      arg2: *const FloatComplexNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBU?$complex@M@std@@AEBVFloatComplexNDArray@@@Z"]
    pub fn mx_el_and31(arg1: *const FloatComplex,
                       arg2: *const FloatComplexNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBU?$complex@M@std@@AEBVFloatComplexNDArray@@@Z"]
    pub fn mx_el_or31(arg1: *const FloatComplex,
                      arg2: *const FloatComplexNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBU?$complex@M@std@@AEBVFloatComplexNDArray@@@Z"]
    pub fn mx_el_and_not10(arg1: *const FloatComplex,
                           arg2: *const FloatComplexNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBU?$complex@M@std@@AEBVFloatComplexNDArray@@@Z"]
    pub fn mx_el_or_not10(arg1: *const FloatComplex,
                          arg2: *const FloatComplexNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_lt@@YA?AVboolNDArray@@AEBVFloatComplexNDArray@@0@Z"]
    pub fn mx_el_lt30(arg1: *const FloatComplexNDArray,
                      arg2: *const FloatComplexNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_le@@YA?AVboolNDArray@@AEBVFloatComplexNDArray@@0@Z"]
    pub fn mx_el_le30(arg1: *const FloatComplexNDArray,
                      arg2: *const FloatComplexNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_ge@@YA?AVboolNDArray@@AEBVFloatComplexNDArray@@0@Z"]
    pub fn mx_el_ge30(arg1: *const FloatComplexNDArray,
                      arg2: *const FloatComplexNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_gt@@YA?AVboolNDArray@@AEBVFloatComplexNDArray@@0@Z"]
    pub fn mx_el_gt30(arg1: *const FloatComplexNDArray,
                      arg2: *const FloatComplexNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_eq@@YA?AVboolNDArray@@AEBVFloatComplexNDArray@@0@Z"]
    pub fn mx_el_eq30(arg1: *const FloatComplexNDArray,
                      arg2: *const FloatComplexNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_ne@@YA?AVboolNDArray@@AEBVFloatComplexNDArray@@0@Z"]
    pub fn mx_el_ne30(arg1: *const FloatComplexNDArray,
                      arg2: *const FloatComplexNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBVFloatComplexNDArray@@0@Z"]
    pub fn mx_el_and32(arg1: *const FloatComplexNDArray,
                       arg2: *const FloatComplexNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_or@@YA?AVboolNDArray@@AEBVFloatComplexNDArray@@0@Z"]
    pub fn mx_el_or32(arg1: *const FloatComplexNDArray,
                      arg2: *const FloatComplexNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBVFloatComplexNDArray@@0@Z"]
    pub fn mx_el_and_not11(arg1: *const FloatComplexNDArray,
                           arg2: *const FloatComplexNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBVFloatComplexNDArray@@0@Z"]
    pub fn mx_el_or_not11(arg1: *const FloatComplexNDArray,
                          arg2: *const FloatComplexNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBVFloatComplexNDArray@@0@Z"]
    pub fn mx_el_not_and11(arg1: *const FloatComplexNDArray,
                           arg2: *const FloatComplexNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBVFloatComplexNDArray@@0@Z"]
    pub fn mx_el_not_or11(arg1: *const FloatComplexNDArray,
                          arg2: *const FloatComplexNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name = "?bsxfun_add@@YA?AVFloatComplexNDArray@@AEBV1@0@Z"]
    pub fn bsxfun_add3(arg1: *const FloatComplexNDArray,
                       arg2: *const FloatComplexNDArray)
     -> FloatComplexNDArray;
}
extern "C" {
    #[link_name = "?bsxfun_sub@@YA?AVFloatComplexNDArray@@AEBV1@0@Z"]
    pub fn bsxfun_sub3(arg1: *const FloatComplexNDArray,
                       arg2: *const FloatComplexNDArray)
     -> FloatComplexNDArray;
}
extern "C" {
    #[link_name = "?bsxfun_mul@@YA?AVFloatComplexNDArray@@AEBV1@0@Z"]
    pub fn bsxfun_mul3(arg1: *const FloatComplexNDArray,
                       arg2: *const FloatComplexNDArray)
     -> FloatComplexNDArray;
}
extern "C" {
    #[link_name = "?bsxfun_div@@YA?AVFloatComplexNDArray@@AEBV1@0@Z"]
    pub fn bsxfun_div3(arg1: *const FloatComplexNDArray,
                       arg2: *const FloatComplexNDArray)
     -> FloatComplexNDArray;
}
extern "C" {
    #[link_name = "?bsxfun_pow@@YA?AVFloatComplexNDArray@@AEBV1@0@Z"]
    pub fn bsxfun_pow7(arg1: *const FloatComplexNDArray,
                       arg2: *const FloatComplexNDArray)
     -> FloatComplexNDArray;
}
extern "C" {
    #[link_name = "?bsxfun_min@@YA?AVFloatComplexNDArray@@AEBV1@0@Z"]
    pub fn bsxfun_min3(arg1: *const FloatComplexNDArray,
                       arg2: *const FloatComplexNDArray)
     -> FloatComplexNDArray;
}
extern "C" {
    #[link_name = "?bsxfun_max@@YA?AVFloatComplexNDArray@@AEBV1@0@Z"]
    pub fn bsxfun_max3(arg1: *const FloatComplexNDArray,
                       arg2: *const FloatComplexNDArray)
     -> FloatComplexNDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_eq@@YA?AVboolNDArray@@AEBVFloatComplexNDArray@@0@Z"]
    pub fn bsxfun_eq4(arg1: *const FloatComplexNDArray,
                      arg2: *const FloatComplexNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_ne@@YA?AVboolNDArray@@AEBVFloatComplexNDArray@@0@Z"]
    pub fn bsxfun_ne4(arg1: *const FloatComplexNDArray,
                      arg2: *const FloatComplexNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_lt@@YA?AVboolNDArray@@AEBVFloatComplexNDArray@@0@Z"]
    pub fn bsxfun_lt4(arg1: *const FloatComplexNDArray,
                      arg2: *const FloatComplexNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_le@@YA?AVboolNDArray@@AEBVFloatComplexNDArray@@0@Z"]
    pub fn bsxfun_le4(arg1: *const FloatComplexNDArray,
                      arg2: *const FloatComplexNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_gt@@YA?AVboolNDArray@@AEBVFloatComplexNDArray@@0@Z"]
    pub fn bsxfun_gt4(arg1: *const FloatComplexNDArray,
                      arg2: *const FloatComplexNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_ge@@YA?AVboolNDArray@@AEBVFloatComplexNDArray@@0@Z"]
    pub fn bsxfun_ge4(arg1: *const FloatComplexNDArray,
                      arg2: *const FloatComplexNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name = "?conj@@YA?AVFloatComplexMatrix@@AEBV1@@Z"]
    pub fn conj3(a: *const FloatComplexMatrix) -> FloatComplexMatrix;
}
extern "C" {
    #[link_name =
          "?Givens@@YA?AVFloatComplexMatrix@@AEBU?$complex@M@std@@0@Z"]
    pub fn Givens3(arg1: *const FloatComplex, arg2: *const FloatComplex)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name = "?Sylvester@@YA?AVFloatComplexMatrix@@AEBV1@00@Z"]
    pub fn Sylvester3(arg1: *const FloatComplexMatrix,
                      arg2: *const FloatComplexMatrix,
                      arg3: *const FloatComplexMatrix) -> FloatComplexMatrix;
}
extern "C" {
    #[link_name =
          "?xgemm@@YA?AVFloatComplexMatrix@@AEBV1@0W4blas_trans_type@@1@Z"]
    pub fn xgemm3(a: *const FloatComplexMatrix, b: *const FloatComplexMatrix,
                  transa: blas_trans_type, transb: blas_trans_type)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name =
          "?min@@YA?AVFloatComplexMatrix@@AEBU?$complex@M@std@@AEBV1@@Z"]
    pub fn min24(c: *const FloatComplex, m: *const FloatComplexMatrix)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name =
          "?min@@YA?AVFloatComplexMatrix@@AEBV1@AEBU?$complex@M@std@@@Z"]
    pub fn min25(m: *const FloatComplexMatrix, c: *const FloatComplex)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name = "?min@@YA?AVFloatComplexMatrix@@AEBV1@0@Z"]
    pub fn min26(a: *const FloatComplexMatrix, b: *const FloatComplexMatrix)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name =
          "?max@@YA?AVFloatComplexMatrix@@AEBU?$complex@M@std@@AEBV1@@Z"]
    pub fn max24(c: *const FloatComplex, m: *const FloatComplexMatrix)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name =
          "?max@@YA?AVFloatComplexMatrix@@AEBV1@AEBU?$complex@M@std@@@Z"]
    pub fn max25(m: *const FloatComplexMatrix, c: *const FloatComplex)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name = "?max@@YA?AVFloatComplexMatrix@@AEBV1@0@Z"]
    pub fn max26(a: *const FloatComplexMatrix, b: *const FloatComplexMatrix)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name =
          "?linspace@@YA?AVFloatComplexMatrix@@AEBVFloatComplexColumnVector@@0H@Z"]
    pub fn linspace3(x1: *const FloatComplexColumnVector,
                     x2: *const FloatComplexColumnVector, n: octave_idx_type)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolMatrix@@AEBVFloatComplexMatrix@@AEBU?$complex@M@std@@@Z"]
    pub fn mx_el_lt31(arg1: *const FloatComplexMatrix,
                      arg2: *const FloatComplex) -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolMatrix@@AEBVFloatComplexMatrix@@AEBU?$complex@M@std@@@Z"]
    pub fn mx_el_le31(arg1: *const FloatComplexMatrix,
                      arg2: *const FloatComplex) -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolMatrix@@AEBVFloatComplexMatrix@@AEBU?$complex@M@std@@@Z"]
    pub fn mx_el_ge31(arg1: *const FloatComplexMatrix,
                      arg2: *const FloatComplex) -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolMatrix@@AEBVFloatComplexMatrix@@AEBU?$complex@M@std@@@Z"]
    pub fn mx_el_gt31(arg1: *const FloatComplexMatrix,
                      arg2: *const FloatComplex) -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolMatrix@@AEBVFloatComplexMatrix@@AEBU?$complex@M@std@@@Z"]
    pub fn mx_el_eq31(arg1: *const FloatComplexMatrix,
                      arg2: *const FloatComplex) -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolMatrix@@AEBVFloatComplexMatrix@@AEBU?$complex@M@std@@@Z"]
    pub fn mx_el_ne31(arg1: *const FloatComplexMatrix,
                      arg2: *const FloatComplex) -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolMatrix@@AEBVFloatComplexMatrix@@AEBU?$complex@M@std@@@Z"]
    pub fn mx_el_and33(arg1: *const FloatComplexMatrix,
                       arg2: *const FloatComplex) -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolMatrix@@AEBVFloatComplexMatrix@@AEBU?$complex@M@std@@@Z"]
    pub fn mx_el_or33(arg1: *const FloatComplexMatrix,
                      arg2: *const FloatComplex) -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolMatrix@@AEBU?$complex@M@std@@AEBVFloatComplexMatrix@@@Z"]
    pub fn mx_el_lt32(arg1: *const FloatComplex,
                      arg2: *const FloatComplexMatrix) -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolMatrix@@AEBU?$complex@M@std@@AEBVFloatComplexMatrix@@@Z"]
    pub fn mx_el_le32(arg1: *const FloatComplex,
                      arg2: *const FloatComplexMatrix) -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolMatrix@@AEBU?$complex@M@std@@AEBVFloatComplexMatrix@@@Z"]
    pub fn mx_el_ge32(arg1: *const FloatComplex,
                      arg2: *const FloatComplexMatrix) -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolMatrix@@AEBU?$complex@M@std@@AEBVFloatComplexMatrix@@@Z"]
    pub fn mx_el_gt32(arg1: *const FloatComplex,
                      arg2: *const FloatComplexMatrix) -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolMatrix@@AEBU?$complex@M@std@@AEBVFloatComplexMatrix@@@Z"]
    pub fn mx_el_eq32(arg1: *const FloatComplex,
                      arg2: *const FloatComplexMatrix) -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolMatrix@@AEBU?$complex@M@std@@AEBVFloatComplexMatrix@@@Z"]
    pub fn mx_el_ne32(arg1: *const FloatComplex,
                      arg2: *const FloatComplexMatrix) -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolMatrix@@AEBU?$complex@M@std@@AEBVFloatComplexMatrix@@@Z"]
    pub fn mx_el_and34(arg1: *const FloatComplex,
                       arg2: *const FloatComplexMatrix) -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolMatrix@@AEBU?$complex@M@std@@AEBVFloatComplexMatrix@@@Z"]
    pub fn mx_el_or34(arg1: *const FloatComplex,
                      arg2: *const FloatComplexMatrix) -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_lt@@YA?AVboolMatrix@@AEBVFloatComplexMatrix@@0@Z"]
    pub fn mx_el_lt33(arg1: *const FloatComplexMatrix,
                      arg2: *const FloatComplexMatrix) -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_le@@YA?AVboolMatrix@@AEBVFloatComplexMatrix@@0@Z"]
    pub fn mx_el_le33(arg1: *const FloatComplexMatrix,
                      arg2: *const FloatComplexMatrix) -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_ge@@YA?AVboolMatrix@@AEBVFloatComplexMatrix@@0@Z"]
    pub fn mx_el_ge33(arg1: *const FloatComplexMatrix,
                      arg2: *const FloatComplexMatrix) -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_gt@@YA?AVboolMatrix@@AEBVFloatComplexMatrix@@0@Z"]
    pub fn mx_el_gt33(arg1: *const FloatComplexMatrix,
                      arg2: *const FloatComplexMatrix) -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_eq@@YA?AVboolMatrix@@AEBVFloatComplexMatrix@@0@Z"]
    pub fn mx_el_eq33(arg1: *const FloatComplexMatrix,
                      arg2: *const FloatComplexMatrix) -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_ne@@YA?AVboolMatrix@@AEBVFloatComplexMatrix@@0@Z"]
    pub fn mx_el_ne33(arg1: *const FloatComplexMatrix,
                      arg2: *const FloatComplexMatrix) -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_and@@YA?AVboolMatrix@@AEBVFloatComplexMatrix@@0@Z"]
    pub fn mx_el_and35(arg1: *const FloatComplexMatrix,
                       arg2: *const FloatComplexMatrix) -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_or@@YA?AVboolMatrix@@AEBVFloatComplexMatrix@@0@Z"]
    pub fn mx_el_or35(arg1: *const FloatComplexMatrix,
                      arg2: *const FloatComplexMatrix) -> boolMatrix;
}
extern "C" {
    #[link_name = "?real@@YA?AVColumnVector@@AEBVComplexColumnVector@@@Z"]
    pub fn real4(a: *const ComplexColumnVector) -> ColumnVector;
}
extern "C" {
    #[link_name = "?imag@@YA?AVColumnVector@@AEBVComplexColumnVector@@@Z"]
    pub fn imag4(a: *const ComplexColumnVector) -> ColumnVector;
}
extern "C" {
    #[link_name =
          "?real@@YA?AVFloatColumnVector@@AEBVFloatComplexColumnVector@@@Z"]
    pub fn real5(a: *const FloatComplexColumnVector) -> FloatColumnVector;
}
extern "C" {
    #[link_name =
          "?imag@@YA?AVFloatColumnVector@@AEBVFloatComplexColumnVector@@@Z"]
    pub fn imag5(a: *const FloatComplexColumnVector) -> FloatColumnVector;
}
extern "C" {
    #[link_name = "?linspace@@YA?AVRowVector@@NNH@Z"]
    pub fn linspace4(x1: f64, x2: f64, n: octave_idx_type) -> RowVector;
}
extern "C" {
    #[link_name =
          "?linspace@@YA?AVComplexRowVector@@AEBU?$complex@N@std@@0H@Z"]
    pub fn linspace5(x1: *const Complex, x2: *const Complex,
                     n: octave_idx_type) -> ComplexRowVector;
}
extern "C" {
    #[link_name = "?linspace@@YA?AVFloatRowVector@@MMH@Z"]
    pub fn linspace6(x1: f32, x2: f32, n: octave_idx_type) -> FloatRowVector;
}
extern "C" {
    #[link_name =
          "?linspace@@YA?AVFloatComplexRowVector@@AEBU?$complex@M@std@@0H@Z"]
    pub fn linspace7(x1: *const FloatComplex, x2: *const FloatComplex,
                     n: octave_idx_type) -> FloatComplexRowVector;
}
extern "C" {
    #[link_name = "?real@@YA?AVDiagMatrix@@AEBVComplexDiagMatrix@@@Z"]
    pub fn real6(a: *const ComplexDiagMatrix) -> DiagMatrix;
}
extern "C" {
    #[link_name = "?imag@@YA?AVDiagMatrix@@AEBVComplexDiagMatrix@@@Z"]
    pub fn imag6(a: *const ComplexDiagMatrix) -> DiagMatrix;
}
extern "C" {
    #[link_name = "?conj@@YA?AVComplexDiagMatrix@@AEBV1@@Z"]
    pub fn conj4(a: *const ComplexDiagMatrix) -> ComplexDiagMatrix;
}
extern "C" {
    #[link_name =
          "?real@@YA?AVFloatDiagMatrix@@AEBVFloatComplexDiagMatrix@@@Z"]
    pub fn real7(a: *const FloatComplexDiagMatrix) -> FloatDiagMatrix;
}
extern "C" {
    #[link_name =
          "?imag@@YA?AVFloatDiagMatrix@@AEBVFloatComplexDiagMatrix@@@Z"]
    pub fn imag7(a: *const FloatComplexDiagMatrix) -> FloatDiagMatrix;
}
extern "C" {
    #[link_name = "?conj@@YA?AVFloatComplexDiagMatrix@@AEBV1@@Z"]
    pub fn conj5(a: *const FloatComplexDiagMatrix) -> FloatComplexDiagMatrix;
}
#[repr(C)]
#[derive(Debug)]
pub struct SparseBoolMatrix {
    pub _base: Sparse<bool>,
}
pub type SparseBoolMatrix_dense_matrix_type = boolMatrix;
#[test]
fn bindgen_test_layout_SparseBoolMatrix() {
    assert_eq!(::std::mem::size_of::<SparseBoolMatrix>() , 24usize , concat !
               ( "Size of: " , stringify ! ( SparseBoolMatrix ) ));
    assert_eq! (::std::mem::align_of::<SparseBoolMatrix>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( SparseBoolMatrix ) ));
}
extern "C" {
    #[link_name = "?insert@SparseBoolMatrix@@QEAAAEAV1@AEBV1@HH@Z"]
    pub fn SparseBoolMatrix_insert(this: *mut SparseBoolMatrix,
                                   a: *const SparseBoolMatrix,
                                   r: octave_idx_type, c: octave_idx_type)
     -> *mut SparseBoolMatrix;
}
extern "C" {
    #[link_name =
          "?insert@SparseBoolMatrix@@QEAAAEAV1@AEBV1@AEBV?$Array@H@@@Z"]
    pub fn SparseBoolMatrix_insert1(this: *mut SparseBoolMatrix,
                                    a: *const SparseBoolMatrix,
                                    indx: *const Array<::std::os::raw::c_int>)
     -> *mut SparseBoolMatrix;
}
extern "C" {
    #[link_name =
          "?concat@SparseBoolMatrix@@QEAA?AV1@AEBV1@AEBV?$Array@H@@@Z"]
    pub fn SparseBoolMatrix_concat(this: *mut SparseBoolMatrix,
                                   rb: *const SparseBoolMatrix,
                                   ra_idx:
                                       *const Array<::std::os::raw::c_int>)
     -> SparseBoolMatrix;
}
extern "C" {
    #[link_name = "?diag@SparseBoolMatrix@@QEBA?AV1@H@Z"]
    pub fn SparseBoolMatrix_diag(this: *const SparseBoolMatrix,
                                 k: octave_idx_type) -> SparseBoolMatrix;
}
extern "C" {
    #[link_name = "?matrix_value@SparseBoolMatrix@@QEBA?AVboolMatrix@@XZ"]
    pub fn SparseBoolMatrix_matrix_value(this: *const SparseBoolMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name = "?squeeze@SparseBoolMatrix@@QEBA?AV1@XZ"]
    pub fn SparseBoolMatrix_squeeze(this: *const SparseBoolMatrix)
     -> SparseBoolMatrix;
}
extern "C" {
    #[link_name = "?index@SparseBoolMatrix@@QEBA?AV1@AEBVidx_vector@@_N@Z"]
    pub fn SparseBoolMatrix_index(this: *const SparseBoolMatrix,
                                  i: *const idx_vector, resize_ok: bool)
     -> SparseBoolMatrix;
}
extern "C" {
    #[link_name = "?index@SparseBoolMatrix@@QEBA?AV1@AEBVidx_vector@@0_N@Z"]
    pub fn SparseBoolMatrix_index1(this: *const SparseBoolMatrix,
                                   i: *const idx_vector, j: *const idx_vector,
                                   resize_ok: bool) -> SparseBoolMatrix;
}
extern "C" {
    #[link_name = "?reshape@SparseBoolMatrix@@QEBA?AV1@AEBVdim_vector@@@Z"]
    pub fn SparseBoolMatrix_reshape(this: *const SparseBoolMatrix,
                                    new_dims: *const dim_vector)
     -> SparseBoolMatrix;
}
extern "C" {
    #[link_name = "?permute@SparseBoolMatrix@@QEBA?AV1@AEBV?$Array@H@@_N@Z"]
    pub fn SparseBoolMatrix_permute(this: *const SparseBoolMatrix,
                                    vec: *const Array<::std::os::raw::c_int>,
                                    inv: bool) -> SparseBoolMatrix;
}
extern "C" {
    #[link_name = "?ipermute@SparseBoolMatrix@@QEBA?AV1@AEBV?$Array@H@@@Z"]
    pub fn SparseBoolMatrix_ipermute(this: *const SparseBoolMatrix,
                                     vec: *const Array<::std::os::raw::c_int>)
     -> SparseBoolMatrix;
}
extern "C" {
    #[link_name = "?all@SparseBoolMatrix@@QEBA?AV1@H@Z"]
    pub fn SparseBoolMatrix_all(this: *const SparseBoolMatrix,
                                dim: ::std::os::raw::c_int)
     -> SparseBoolMatrix;
}
extern "C" {
    #[link_name = "?any@SparseBoolMatrix@@QEBA?AV1@H@Z"]
    pub fn SparseBoolMatrix_any(this: *const SparseBoolMatrix,
                                dim: ::std::os::raw::c_int)
     -> SparseBoolMatrix;
}
extern "C" {
    #[link_name = "?sum@SparseBoolMatrix@@QEBA?AVSparseMatrix@@H@Z"]
    pub fn SparseBoolMatrix_sum(this: *const SparseBoolMatrix,
                                dim: ::std::os::raw::c_int) -> SparseMatrix;
}
impl SparseBoolMatrix {
    #[inline]
    pub unsafe fn insert(&mut self, a: *const SparseBoolMatrix,
                         r: octave_idx_type, c: octave_idx_type)
     -> *mut SparseBoolMatrix {
        SparseBoolMatrix_insert(self, a, r, c)
    }
    #[inline]
    pub unsafe fn insert1(&mut self, a: *const SparseBoolMatrix,
                          indx: *const Array<::std::os::raw::c_int>)
     -> *mut SparseBoolMatrix {
        SparseBoolMatrix_insert1(self, a, indx)
    }
    #[inline]
    pub unsafe fn concat(&mut self, rb: *const SparseBoolMatrix,
                         ra_idx: *const Array<::std::os::raw::c_int>)
     -> SparseBoolMatrix {
        SparseBoolMatrix_concat(self, rb, ra_idx)
    }
    #[inline]
    pub unsafe fn diag(&self, k: octave_idx_type) -> SparseBoolMatrix {
        SparseBoolMatrix_diag(self, k)
    }
    #[inline]
    pub unsafe fn matrix_value(&self) -> boolMatrix {
        SparseBoolMatrix_matrix_value(self)
    }
    #[inline]
    pub unsafe fn squeeze(&self) -> SparseBoolMatrix {
        SparseBoolMatrix_squeeze(self)
    }
    #[inline]
    pub unsafe fn index(&self, i: *const idx_vector, resize_ok: bool)
     -> SparseBoolMatrix {
        SparseBoolMatrix_index(self, i, resize_ok)
    }
    #[inline]
    pub unsafe fn index1(&self, i: *const idx_vector, j: *const idx_vector,
                         resize_ok: bool) -> SparseBoolMatrix {
        SparseBoolMatrix_index1(self, i, j, resize_ok)
    }
    #[inline]
    pub unsafe fn reshape(&self, new_dims: *const dim_vector)
     -> SparseBoolMatrix {
        SparseBoolMatrix_reshape(self, new_dims)
    }
    #[inline]
    pub unsafe fn permute(&self, vec: *const Array<::std::os::raw::c_int>,
                          inv: bool) -> SparseBoolMatrix {
        SparseBoolMatrix_permute(self, vec, inv)
    }
    #[inline]
    pub unsafe fn ipermute(&self, vec: *const Array<::std::os::raw::c_int>)
     -> SparseBoolMatrix {
        SparseBoolMatrix_ipermute(self, vec)
    }
    #[inline]
    pub unsafe fn all(&self, dim: ::std::os::raw::c_int) -> SparseBoolMatrix {
        SparseBoolMatrix_all(self, dim)
    }
    #[inline]
    pub unsafe fn any(&self, dim: ::std::os::raw::c_int) -> SparseBoolMatrix {
        SparseBoolMatrix_any(self, dim)
    }
    #[inline]
    pub unsafe fn sum(&self, dim: ::std::os::raw::c_int) -> SparseMatrix {
        SparseBoolMatrix_sum(self, dim)
    }
}
extern "C" {
    #[link_name = "?mx_el_eq@@YA?AVSparseBoolMatrix@@AEBV1@AEB_N@Z"]
    pub fn mx_el_eq34(arg1: *const SparseBoolMatrix, arg2: *const bool)
     -> SparseBoolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_ne@@YA?AVSparseBoolMatrix@@AEBV1@AEB_N@Z"]
    pub fn mx_el_ne34(arg1: *const SparseBoolMatrix, arg2: *const bool)
     -> SparseBoolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_and@@YA?AVSparseBoolMatrix@@AEBV1@AEB_N@Z"]
    pub fn mx_el_and36(arg1: *const SparseBoolMatrix, arg2: *const bool)
     -> SparseBoolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_or@@YA?AVSparseBoolMatrix@@AEBV1@AEB_N@Z"]
    pub fn mx_el_or36(arg1: *const SparseBoolMatrix, arg2: *const bool)
     -> SparseBoolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_eq@@YA?AVSparseBoolMatrix@@AEB_NAEBV1@@Z"]
    pub fn mx_el_eq35(arg1: *const bool, arg2: *const SparseBoolMatrix)
     -> SparseBoolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_ne@@YA?AVSparseBoolMatrix@@AEB_NAEBV1@@Z"]
    pub fn mx_el_ne35(arg1: *const bool, arg2: *const SparseBoolMatrix)
     -> SparseBoolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_and@@YA?AVSparseBoolMatrix@@AEB_NAEBV1@@Z"]
    pub fn mx_el_and37(arg1: *const bool, arg2: *const SparseBoolMatrix)
     -> SparseBoolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_or@@YA?AVSparseBoolMatrix@@AEB_NAEBV1@@Z"]
    pub fn mx_el_or37(arg1: *const bool, arg2: *const SparseBoolMatrix)
     -> SparseBoolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_eq@@YA?AVSparseBoolMatrix@@AEBV1@0@Z"]
    pub fn mx_el_eq36(arg1: *const SparseBoolMatrix,
                      arg2: *const SparseBoolMatrix) -> SparseBoolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_ne@@YA?AVSparseBoolMatrix@@AEBV1@0@Z"]
    pub fn mx_el_ne36(arg1: *const SparseBoolMatrix,
                      arg2: *const SparseBoolMatrix) -> SparseBoolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_and@@YA?AVSparseBoolMatrix@@AEBV1@0@Z"]
    pub fn mx_el_and38(arg1: *const SparseBoolMatrix,
                       arg2: *const SparseBoolMatrix) -> SparseBoolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_or@@YA?AVSparseBoolMatrix@@AEBV1@0@Z"]
    pub fn mx_el_or38(arg1: *const SparseBoolMatrix,
                      arg2: *const SparseBoolMatrix) -> SparseBoolMatrix;
}
extern "C" {
    #[link_name = "?real@@YA?AVSparseMatrix@@AEBVSparseComplexMatrix@@@Z"]
    pub fn real8(a: *const SparseComplexMatrix) -> SparseMatrix;
}
extern "C" {
    #[link_name = "?imag@@YA?AVSparseMatrix@@AEBVSparseComplexMatrix@@@Z"]
    pub fn imag8(a: *const SparseComplexMatrix) -> SparseMatrix;
}
extern "C" {
    #[link_name = "?mul_trans@@YA?AVMatrix@@AEBV1@AEBVSparseMatrix@@@Z"]
    pub fn mul_trans(a: *const Matrix, b: *const SparseMatrix) -> Matrix;
}
extern "C" {
    #[link_name = "?trans_mul@@YA?AVMatrix@@AEBVSparseMatrix@@AEBV1@@Z"]
    pub fn trans_mul(a: *const SparseMatrix, b: *const Matrix) -> Matrix;
}
extern "C" {
    #[link_name = "?min@@YA?AVSparseMatrix@@NAEBV1@@Z"]
    pub fn min27(d: f64, m: *const SparseMatrix) -> SparseMatrix;
}
extern "C" {
    #[link_name = "?min@@YA?AVSparseMatrix@@AEBV1@N@Z"]
    pub fn min28(m: *const SparseMatrix, d: f64) -> SparseMatrix;
}
extern "C" {
    #[link_name = "?min@@YA?AVSparseMatrix@@AEBV1@0@Z"]
    pub fn min29(a: *const SparseMatrix, b: *const SparseMatrix)
     -> SparseMatrix;
}
extern "C" {
    #[link_name = "?max@@YA?AVSparseMatrix@@NAEBV1@@Z"]
    pub fn max27(d: f64, m: *const SparseMatrix) -> SparseMatrix;
}
extern "C" {
    #[link_name = "?max@@YA?AVSparseMatrix@@AEBV1@N@Z"]
    pub fn max28(m: *const SparseMatrix, d: f64) -> SparseMatrix;
}
extern "C" {
    #[link_name = "?max@@YA?AVSparseMatrix@@AEBV1@0@Z"]
    pub fn max29(a: *const SparseMatrix, b: *const SparseMatrix)
     -> SparseMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVSparseBoolMatrix@@AEBVSparseMatrix@@AEBN@Z"]
    pub fn mx_el_lt34(arg1: *const SparseMatrix, arg2: *const f64)
     -> SparseBoolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVSparseBoolMatrix@@AEBVSparseMatrix@@AEBN@Z"]
    pub fn mx_el_le34(arg1: *const SparseMatrix, arg2: *const f64)
     -> SparseBoolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVSparseBoolMatrix@@AEBVSparseMatrix@@AEBN@Z"]
    pub fn mx_el_ge34(arg1: *const SparseMatrix, arg2: *const f64)
     -> SparseBoolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVSparseBoolMatrix@@AEBVSparseMatrix@@AEBN@Z"]
    pub fn mx_el_gt34(arg1: *const SparseMatrix, arg2: *const f64)
     -> SparseBoolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVSparseBoolMatrix@@AEBVSparseMatrix@@AEBN@Z"]
    pub fn mx_el_eq37(arg1: *const SparseMatrix, arg2: *const f64)
     -> SparseBoolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVSparseBoolMatrix@@AEBVSparseMatrix@@AEBN@Z"]
    pub fn mx_el_ne37(arg1: *const SparseMatrix, arg2: *const f64)
     -> SparseBoolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVSparseBoolMatrix@@AEBVSparseMatrix@@AEBN@Z"]
    pub fn mx_el_and39(arg1: *const SparseMatrix, arg2: *const f64)
     -> SparseBoolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVSparseBoolMatrix@@AEBVSparseMatrix@@AEBN@Z"]
    pub fn mx_el_or39(arg1: *const SparseMatrix, arg2: *const f64)
     -> SparseBoolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVSparseBoolMatrix@@AEBNAEBVSparseMatrix@@@Z"]
    pub fn mx_el_lt35(arg1: *const f64, arg2: *const SparseMatrix)
     -> SparseBoolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVSparseBoolMatrix@@AEBNAEBVSparseMatrix@@@Z"]
    pub fn mx_el_le35(arg1: *const f64, arg2: *const SparseMatrix)
     -> SparseBoolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVSparseBoolMatrix@@AEBNAEBVSparseMatrix@@@Z"]
    pub fn mx_el_ge35(arg1: *const f64, arg2: *const SparseMatrix)
     -> SparseBoolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVSparseBoolMatrix@@AEBNAEBVSparseMatrix@@@Z"]
    pub fn mx_el_gt35(arg1: *const f64, arg2: *const SparseMatrix)
     -> SparseBoolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVSparseBoolMatrix@@AEBNAEBVSparseMatrix@@@Z"]
    pub fn mx_el_eq38(arg1: *const f64, arg2: *const SparseMatrix)
     -> SparseBoolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVSparseBoolMatrix@@AEBNAEBVSparseMatrix@@@Z"]
    pub fn mx_el_ne38(arg1: *const f64, arg2: *const SparseMatrix)
     -> SparseBoolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVSparseBoolMatrix@@AEBNAEBVSparseMatrix@@@Z"]
    pub fn mx_el_and40(arg1: *const f64, arg2: *const SparseMatrix)
     -> SparseBoolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVSparseBoolMatrix@@AEBNAEBVSparseMatrix@@@Z"]
    pub fn mx_el_or40(arg1: *const f64, arg2: *const SparseMatrix)
     -> SparseBoolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_lt@@YA?AVSparseBoolMatrix@@AEBVSparseMatrix@@0@Z"]
    pub fn mx_el_lt36(arg1: *const SparseMatrix, arg2: *const SparseMatrix)
     -> SparseBoolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_le@@YA?AVSparseBoolMatrix@@AEBVSparseMatrix@@0@Z"]
    pub fn mx_el_le36(arg1: *const SparseMatrix, arg2: *const SparseMatrix)
     -> SparseBoolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_ge@@YA?AVSparseBoolMatrix@@AEBVSparseMatrix@@0@Z"]
    pub fn mx_el_ge36(arg1: *const SparseMatrix, arg2: *const SparseMatrix)
     -> SparseBoolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_gt@@YA?AVSparseBoolMatrix@@AEBVSparseMatrix@@0@Z"]
    pub fn mx_el_gt36(arg1: *const SparseMatrix, arg2: *const SparseMatrix)
     -> SparseBoolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_eq@@YA?AVSparseBoolMatrix@@AEBVSparseMatrix@@0@Z"]
    pub fn mx_el_eq39(arg1: *const SparseMatrix, arg2: *const SparseMatrix)
     -> SparseBoolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_ne@@YA?AVSparseBoolMatrix@@AEBVSparseMatrix@@0@Z"]
    pub fn mx_el_ne39(arg1: *const SparseMatrix, arg2: *const SparseMatrix)
     -> SparseBoolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_and@@YA?AVSparseBoolMatrix@@AEBVSparseMatrix@@0@Z"]
    pub fn mx_el_and41(arg1: *const SparseMatrix, arg2: *const SparseMatrix)
     -> SparseBoolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_or@@YA?AVSparseBoolMatrix@@AEBVSparseMatrix@@0@Z"]
    pub fn mx_el_or41(arg1: *const SparseMatrix, arg2: *const SparseMatrix)
     -> SparseBoolMatrix;
}
extern "C" {
    #[link_name =
          "?mul_trans@@YA?AVComplexMatrix@@AEBV1@AEBVSparseComplexMatrix@@@Z"]
    pub fn mul_trans1(arg1: *const ComplexMatrix,
                      arg2: *const SparseComplexMatrix) -> ComplexMatrix;
}
extern "C" {
    #[link_name =
          "?mul_herm@@YA?AVComplexMatrix@@AEBV1@AEBVSparseComplexMatrix@@@Z"]
    pub fn mul_herm(arg1: *const ComplexMatrix,
                    arg2: *const SparseComplexMatrix) -> ComplexMatrix;
}
extern "C" {
    #[link_name =
          "?trans_mul@@YA?AVComplexMatrix@@AEBVSparseComplexMatrix@@AEBV1@@Z"]
    pub fn trans_mul1(arg1: *const SparseComplexMatrix,
                      arg2: *const ComplexMatrix) -> ComplexMatrix;
}
extern "C" {
    #[link_name =
          "?herm_mul@@YA?AVComplexMatrix@@AEBVSparseComplexMatrix@@AEBV1@@Z"]
    pub fn herm_mul(arg1: *const SparseComplexMatrix,
                    arg2: *const ComplexMatrix) -> ComplexMatrix;
}
extern "C" {
    #[link_name =
          "?min@@YA?AVSparseComplexMatrix@@AEBU?$complex@N@std@@AEBV1@@Z"]
    pub fn min30(c: *const Complex, m: *const SparseComplexMatrix)
     -> SparseComplexMatrix;
}
extern "C" {
    #[link_name =
          "?min@@YA?AVSparseComplexMatrix@@AEBV1@AEBU?$complex@N@std@@@Z"]
    pub fn min31(m: *const SparseComplexMatrix, c: *const Complex)
     -> SparseComplexMatrix;
}
extern "C" {
    #[link_name = "?min@@YA?AVSparseComplexMatrix@@AEBV1@0@Z"]
    pub fn min32(a: *const SparseComplexMatrix, b: *const SparseComplexMatrix)
     -> SparseComplexMatrix;
}
extern "C" {
    #[link_name =
          "?max@@YA?AVSparseComplexMatrix@@AEBU?$complex@N@std@@AEBV1@@Z"]
    pub fn max30(c: *const Complex, m: *const SparseComplexMatrix)
     -> SparseComplexMatrix;
}
extern "C" {
    #[link_name =
          "?max@@YA?AVSparseComplexMatrix@@AEBV1@AEBU?$complex@N@std@@@Z"]
    pub fn max31(m: *const SparseComplexMatrix, c: *const Complex)
     -> SparseComplexMatrix;
}
extern "C" {
    #[link_name = "?max@@YA?AVSparseComplexMatrix@@AEBV1@0@Z"]
    pub fn max32(a: *const SparseComplexMatrix, b: *const SparseComplexMatrix)
     -> SparseComplexMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVSparseBoolMatrix@@AEBVSparseComplexMatrix@@AEBU?$complex@N@std@@@Z"]
    pub fn mx_el_lt37(arg1: *const SparseComplexMatrix, arg2: *const Complex)
     -> SparseBoolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVSparseBoolMatrix@@AEBVSparseComplexMatrix@@AEBU?$complex@N@std@@@Z"]
    pub fn mx_el_le37(arg1: *const SparseComplexMatrix, arg2: *const Complex)
     -> SparseBoolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVSparseBoolMatrix@@AEBVSparseComplexMatrix@@AEBU?$complex@N@std@@@Z"]
    pub fn mx_el_ge37(arg1: *const SparseComplexMatrix, arg2: *const Complex)
     -> SparseBoolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVSparseBoolMatrix@@AEBVSparseComplexMatrix@@AEBU?$complex@N@std@@@Z"]
    pub fn mx_el_gt37(arg1: *const SparseComplexMatrix, arg2: *const Complex)
     -> SparseBoolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVSparseBoolMatrix@@AEBVSparseComplexMatrix@@AEBU?$complex@N@std@@@Z"]
    pub fn mx_el_eq40(arg1: *const SparseComplexMatrix, arg2: *const Complex)
     -> SparseBoolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVSparseBoolMatrix@@AEBVSparseComplexMatrix@@AEBU?$complex@N@std@@@Z"]
    pub fn mx_el_ne40(arg1: *const SparseComplexMatrix, arg2: *const Complex)
     -> SparseBoolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVSparseBoolMatrix@@AEBVSparseComplexMatrix@@AEBU?$complex@N@std@@@Z"]
    pub fn mx_el_and42(arg1: *const SparseComplexMatrix, arg2: *const Complex)
     -> SparseBoolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVSparseBoolMatrix@@AEBVSparseComplexMatrix@@AEBU?$complex@N@std@@@Z"]
    pub fn mx_el_or42(arg1: *const SparseComplexMatrix, arg2: *const Complex)
     -> SparseBoolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVSparseBoolMatrix@@AEBU?$complex@N@std@@AEBVSparseComplexMatrix@@@Z"]
    pub fn mx_el_lt38(arg1: *const Complex, arg2: *const SparseComplexMatrix)
     -> SparseBoolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVSparseBoolMatrix@@AEBU?$complex@N@std@@AEBVSparseComplexMatrix@@@Z"]
    pub fn mx_el_le38(arg1: *const Complex, arg2: *const SparseComplexMatrix)
     -> SparseBoolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVSparseBoolMatrix@@AEBU?$complex@N@std@@AEBVSparseComplexMatrix@@@Z"]
    pub fn mx_el_ge38(arg1: *const Complex, arg2: *const SparseComplexMatrix)
     -> SparseBoolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVSparseBoolMatrix@@AEBU?$complex@N@std@@AEBVSparseComplexMatrix@@@Z"]
    pub fn mx_el_gt38(arg1: *const Complex, arg2: *const SparseComplexMatrix)
     -> SparseBoolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVSparseBoolMatrix@@AEBU?$complex@N@std@@AEBVSparseComplexMatrix@@@Z"]
    pub fn mx_el_eq41(arg1: *const Complex, arg2: *const SparseComplexMatrix)
     -> SparseBoolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVSparseBoolMatrix@@AEBU?$complex@N@std@@AEBVSparseComplexMatrix@@@Z"]
    pub fn mx_el_ne41(arg1: *const Complex, arg2: *const SparseComplexMatrix)
     -> SparseBoolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVSparseBoolMatrix@@AEBU?$complex@N@std@@AEBVSparseComplexMatrix@@@Z"]
    pub fn mx_el_and43(arg1: *const Complex, arg2: *const SparseComplexMatrix)
     -> SparseBoolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVSparseBoolMatrix@@AEBU?$complex@N@std@@AEBVSparseComplexMatrix@@@Z"]
    pub fn mx_el_or43(arg1: *const Complex, arg2: *const SparseComplexMatrix)
     -> SparseBoolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVSparseBoolMatrix@@AEBVSparseComplexMatrix@@0@Z"]
    pub fn mx_el_lt39(arg1: *const SparseComplexMatrix,
                      arg2: *const SparseComplexMatrix) -> SparseBoolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVSparseBoolMatrix@@AEBVSparseComplexMatrix@@0@Z"]
    pub fn mx_el_le39(arg1: *const SparseComplexMatrix,
                      arg2: *const SparseComplexMatrix) -> SparseBoolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVSparseBoolMatrix@@AEBVSparseComplexMatrix@@0@Z"]
    pub fn mx_el_ge39(arg1: *const SparseComplexMatrix,
                      arg2: *const SparseComplexMatrix) -> SparseBoolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVSparseBoolMatrix@@AEBVSparseComplexMatrix@@0@Z"]
    pub fn mx_el_gt39(arg1: *const SparseComplexMatrix,
                      arg2: *const SparseComplexMatrix) -> SparseBoolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVSparseBoolMatrix@@AEBVSparseComplexMatrix@@0@Z"]
    pub fn mx_el_eq42(arg1: *const SparseComplexMatrix,
                      arg2: *const SparseComplexMatrix) -> SparseBoolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVSparseBoolMatrix@@AEBVSparseComplexMatrix@@0@Z"]
    pub fn mx_el_ne42(arg1: *const SparseComplexMatrix,
                      arg2: *const SparseComplexMatrix) -> SparseBoolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVSparseBoolMatrix@@AEBVSparseComplexMatrix@@0@Z"]
    pub fn mx_el_and44(arg1: *const SparseComplexMatrix,
                       arg2: *const SparseComplexMatrix) -> SparseBoolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVSparseBoolMatrix@@AEBVSparseComplexMatrix@@0@Z"]
    pub fn mx_el_or44(arg1: *const SparseComplexMatrix,
                      arg2: *const SparseComplexMatrix) -> SparseBoolMatrix;
}
pub type int8NDArray = intNDArray<octave_int<::std::os::raw::c_schar>>;
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_lt40(arg1: *const int8NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_le40(arg1: *const int8NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_ge40(arg1: *const int8NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_gt40(arg1: *const int8NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_eq43(arg1: *const int8NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_ne43(arg1: *const int8NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_and45(arg1: *const int8NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_or45(arg1: *const int8NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_not_and12(arg1: *const int8NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_not_or12(arg1: *const int8NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_lt41(arg1: *const octave_int8, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_le41(arg1: *const octave_int8, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_ge41(arg1: *const octave_int8, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_gt41(arg1: *const octave_int8, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_eq44(arg1: *const octave_int8, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_ne44(arg1: *const octave_int8, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_and46(arg1: *const octave_int8, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_or46(arg1: *const octave_int8, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_and_not12(arg1: *const octave_int8, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_or_not12(arg1: *const octave_int8, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@0@Z"]
    pub fn mx_el_lt42(arg1: *const int8NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@0@Z"]
    pub fn mx_el_le42(arg1: *const int8NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@0@Z"]
    pub fn mx_el_ge42(arg1: *const int8NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@0@Z"]
    pub fn mx_el_gt42(arg1: *const int8NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@0@Z"]
    pub fn mx_el_eq45(arg1: *const int8NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@0@Z"]
    pub fn mx_el_ne45(arg1: *const int8NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@0@Z"]
    pub fn mx_el_and47(arg1: *const int8NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@0@Z"]
    pub fn mx_el_or47(arg1: *const int8NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@0@Z"]
    pub fn mx_el_and_not13(arg1: *const int8NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@0@Z"]
    pub fn mx_el_or_not13(arg1: *const int8NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@0@Z"]
    pub fn mx_el_not_and13(arg1: *const int8NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@0@Z"]
    pub fn mx_el_not_or13(arg1: *const int8NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?min@@YA?AV?$intNDArray@V?$octave_int@C@@@@V?$octave_int@C@@AEBV1@@Z"]
    pub fn min33(d: octave_int8, m: *const int8NDArray) -> int8NDArray;
}
extern "C" {
    #[link_name =
          "?min@@YA?AV?$intNDArray@V?$octave_int@C@@@@AEBV1@V?$octave_int@C@@@Z"]
    pub fn min34(m: *const int8NDArray, d: octave_int8) -> int8NDArray;
}
extern "C" {
    #[link_name = "?min@@YA?AV?$intNDArray@V?$octave_int@C@@@@AEBV1@0@Z"]
    pub fn min35(a: *const int8NDArray, b: *const int8NDArray) -> int8NDArray;
}
extern "C" {
    #[link_name =
          "?max@@YA?AV?$intNDArray@V?$octave_int@C@@@@V?$octave_int@C@@AEBV1@@Z"]
    pub fn max33(d: octave_int8, m: *const int8NDArray) -> int8NDArray;
}
extern "C" {
    #[link_name =
          "?max@@YA?AV?$intNDArray@V?$octave_int@C@@@@AEBV1@V?$octave_int@C@@@Z"]
    pub fn max34(m: *const int8NDArray, d: octave_int8) -> int8NDArray;
}
extern "C" {
    #[link_name = "?max@@YA?AV?$intNDArray@V?$octave_int@C@@@@AEBV1@0@Z"]
    pub fn max35(a: *const int8NDArray, b: *const int8NDArray) -> int8NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_add@@YA?AV?$intNDArray@V?$octave_int@C@@@@AEBV1@0@Z"]
    pub fn bsxfun_add4(arg1: *const int8NDArray, arg2: *const int8NDArray)
     -> int8NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_sub@@YA?AV?$intNDArray@V?$octave_int@C@@@@AEBV1@0@Z"]
    pub fn bsxfun_sub4(arg1: *const int8NDArray, arg2: *const int8NDArray)
     -> int8NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_mul@@YA?AV?$intNDArray@V?$octave_int@C@@@@AEBV1@0@Z"]
    pub fn bsxfun_mul4(arg1: *const int8NDArray, arg2: *const int8NDArray)
     -> int8NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_div@@YA?AV?$intNDArray@V?$octave_int@C@@@@AEBV1@0@Z"]
    pub fn bsxfun_div4(arg1: *const int8NDArray, arg2: *const int8NDArray)
     -> int8NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_pow@@YA?AV?$intNDArray@V?$octave_int@C@@@@AEBV1@0@Z"]
    pub fn bsxfun_pow8(arg1: *const int8NDArray, arg2: *const int8NDArray)
     -> int8NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_min@@YA?AV?$intNDArray@V?$octave_int@C@@@@AEBV1@0@Z"]
    pub fn bsxfun_min4(arg1: *const int8NDArray, arg2: *const int8NDArray)
     -> int8NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_max@@YA?AV?$intNDArray@V?$octave_int@C@@@@AEBV1@0@Z"]
    pub fn bsxfun_max4(arg1: *const int8NDArray, arg2: *const int8NDArray)
     -> int8NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_pow@@YA?AV?$intNDArray@V?$octave_int@C@@@@AEBV1@AEBVNDArray@@@Z"]
    pub fn bsxfun_pow9(arg1: *const int8NDArray, arg2: *const NDArray)
     -> int8NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_pow@@YA?AV?$intNDArray@V?$octave_int@C@@@@AEBV1@AEBVFloatNDArray@@@Z"]
    pub fn bsxfun_pow10(arg1: *const int8NDArray, arg2: *const FloatNDArray)
     -> int8NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_pow@@YA?AV?$intNDArray@V?$octave_int@C@@@@AEBVNDArray@@AEBV1@@Z"]
    pub fn bsxfun_pow11(arg1: *const NDArray, arg2: *const int8NDArray)
     -> int8NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_pow@@YA?AV?$intNDArray@V?$octave_int@C@@@@AEBVFloatNDArray@@AEBV1@@Z"]
    pub fn bsxfun_pow12(arg1: *const FloatNDArray, arg2: *const int8NDArray)
     -> int8NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@0@Z"]
    pub fn bsxfun_eq5(arg1: *const int8NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@0@Z"]
    pub fn bsxfun_ne5(arg1: *const int8NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@0@Z"]
    pub fn bsxfun_lt5(arg1: *const int8NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@0@Z"]
    pub fn bsxfun_le5(arg1: *const int8NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@0@Z"]
    pub fn bsxfun_gt5(arg1: *const int8NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@0@Z"]
    pub fn bsxfun_ge5(arg1: *const int8NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
pub type int16NDArray = intNDArray<octave_int<::std::os::raw::c_short>>;
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_lt43(arg1: *const int16NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_le43(arg1: *const int16NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_ge43(arg1: *const int16NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_gt43(arg1: *const int16NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_eq46(arg1: *const int16NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_ne46(arg1: *const int16NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_and48(arg1: *const int16NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_or48(arg1: *const int16NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_not_and14(arg1: *const int16NDArray,
                           arg2: *const octave_int16) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_not_or14(arg1: *const int16NDArray,
                          arg2: *const octave_int16) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_lt44(arg1: *const octave_int16, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_le44(arg1: *const octave_int16, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_ge44(arg1: *const octave_int16, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_gt44(arg1: *const octave_int16, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_eq47(arg1: *const octave_int16, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_ne47(arg1: *const octave_int16, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_and49(arg1: *const octave_int16, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_or49(arg1: *const octave_int16, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_and_not14(arg1: *const octave_int16,
                           arg2: *const int16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_or_not14(arg1: *const octave_int16,
                          arg2: *const int16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@0@Z"]
    pub fn mx_el_lt45(arg1: *const int16NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@0@Z"]
    pub fn mx_el_le45(arg1: *const int16NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@0@Z"]
    pub fn mx_el_ge45(arg1: *const int16NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@0@Z"]
    pub fn mx_el_gt45(arg1: *const int16NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@0@Z"]
    pub fn mx_el_eq48(arg1: *const int16NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@0@Z"]
    pub fn mx_el_ne48(arg1: *const int16NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@0@Z"]
    pub fn mx_el_and50(arg1: *const int16NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@0@Z"]
    pub fn mx_el_or50(arg1: *const int16NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@0@Z"]
    pub fn mx_el_and_not15(arg1: *const int16NDArray,
                           arg2: *const int16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@0@Z"]
    pub fn mx_el_or_not15(arg1: *const int16NDArray,
                          arg2: *const int16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@0@Z"]
    pub fn mx_el_not_and15(arg1: *const int16NDArray,
                           arg2: *const int16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@0@Z"]
    pub fn mx_el_not_or15(arg1: *const int16NDArray,
                          arg2: *const int16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?min@@YA?AV?$intNDArray@V?$octave_int@F@@@@V?$octave_int@F@@AEBV1@@Z"]
    pub fn min36(d: octave_int16, m: *const int16NDArray) -> int16NDArray;
}
extern "C" {
    #[link_name =
          "?min@@YA?AV?$intNDArray@V?$octave_int@F@@@@AEBV1@V?$octave_int@F@@@Z"]
    pub fn min37(m: *const int16NDArray, d: octave_int16) -> int16NDArray;
}
extern "C" {
    #[link_name = "?min@@YA?AV?$intNDArray@V?$octave_int@F@@@@AEBV1@0@Z"]
    pub fn min38(a: *const int16NDArray, b: *const int16NDArray)
     -> int16NDArray;
}
extern "C" {
    #[link_name =
          "?max@@YA?AV?$intNDArray@V?$octave_int@F@@@@V?$octave_int@F@@AEBV1@@Z"]
    pub fn max36(d: octave_int16, m: *const int16NDArray) -> int16NDArray;
}
extern "C" {
    #[link_name =
          "?max@@YA?AV?$intNDArray@V?$octave_int@F@@@@AEBV1@V?$octave_int@F@@@Z"]
    pub fn max37(m: *const int16NDArray, d: octave_int16) -> int16NDArray;
}
extern "C" {
    #[link_name = "?max@@YA?AV?$intNDArray@V?$octave_int@F@@@@AEBV1@0@Z"]
    pub fn max38(a: *const int16NDArray, b: *const int16NDArray)
     -> int16NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_add@@YA?AV?$intNDArray@V?$octave_int@F@@@@AEBV1@0@Z"]
    pub fn bsxfun_add5(arg1: *const int16NDArray, arg2: *const int16NDArray)
     -> int16NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_sub@@YA?AV?$intNDArray@V?$octave_int@F@@@@AEBV1@0@Z"]
    pub fn bsxfun_sub5(arg1: *const int16NDArray, arg2: *const int16NDArray)
     -> int16NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_mul@@YA?AV?$intNDArray@V?$octave_int@F@@@@AEBV1@0@Z"]
    pub fn bsxfun_mul5(arg1: *const int16NDArray, arg2: *const int16NDArray)
     -> int16NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_div@@YA?AV?$intNDArray@V?$octave_int@F@@@@AEBV1@0@Z"]
    pub fn bsxfun_div5(arg1: *const int16NDArray, arg2: *const int16NDArray)
     -> int16NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_pow@@YA?AV?$intNDArray@V?$octave_int@F@@@@AEBV1@0@Z"]
    pub fn bsxfun_pow13(arg1: *const int16NDArray, arg2: *const int16NDArray)
     -> int16NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_min@@YA?AV?$intNDArray@V?$octave_int@F@@@@AEBV1@0@Z"]
    pub fn bsxfun_min5(arg1: *const int16NDArray, arg2: *const int16NDArray)
     -> int16NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_max@@YA?AV?$intNDArray@V?$octave_int@F@@@@AEBV1@0@Z"]
    pub fn bsxfun_max5(arg1: *const int16NDArray, arg2: *const int16NDArray)
     -> int16NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_pow@@YA?AV?$intNDArray@V?$octave_int@F@@@@AEBV1@AEBVNDArray@@@Z"]
    pub fn bsxfun_pow14(arg1: *const int16NDArray, arg2: *const NDArray)
     -> int16NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_pow@@YA?AV?$intNDArray@V?$octave_int@F@@@@AEBV1@AEBVFloatNDArray@@@Z"]
    pub fn bsxfun_pow15(arg1: *const int16NDArray, arg2: *const FloatNDArray)
     -> int16NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_pow@@YA?AV?$intNDArray@V?$octave_int@F@@@@AEBVNDArray@@AEBV1@@Z"]
    pub fn bsxfun_pow16(arg1: *const NDArray, arg2: *const int16NDArray)
     -> int16NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_pow@@YA?AV?$intNDArray@V?$octave_int@F@@@@AEBVFloatNDArray@@AEBV1@@Z"]
    pub fn bsxfun_pow17(arg1: *const FloatNDArray, arg2: *const int16NDArray)
     -> int16NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@0@Z"]
    pub fn bsxfun_eq6(arg1: *const int16NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@0@Z"]
    pub fn bsxfun_ne6(arg1: *const int16NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@0@Z"]
    pub fn bsxfun_lt6(arg1: *const int16NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@0@Z"]
    pub fn bsxfun_le6(arg1: *const int16NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@0@Z"]
    pub fn bsxfun_gt6(arg1: *const int16NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@0@Z"]
    pub fn bsxfun_ge6(arg1: *const int16NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
pub type int32NDArray = intNDArray<octave_int<::std::os::raw::c_int>>;
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_lt46(arg1: *const int32NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_le46(arg1: *const int32NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_ge46(arg1: *const int32NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_gt46(arg1: *const int32NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_eq49(arg1: *const int32NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_ne49(arg1: *const int32NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_and51(arg1: *const int32NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_or51(arg1: *const int32NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_not_and16(arg1: *const int32NDArray,
                           arg2: *const octave_int32) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_not_or16(arg1: *const int32NDArray,
                          arg2: *const octave_int32) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_lt47(arg1: *const octave_int32, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_le47(arg1: *const octave_int32, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_ge47(arg1: *const octave_int32, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_gt47(arg1: *const octave_int32, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_eq50(arg1: *const octave_int32, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_ne50(arg1: *const octave_int32, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_and52(arg1: *const octave_int32, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_or52(arg1: *const octave_int32, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_and_not16(arg1: *const octave_int32,
                           arg2: *const int32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_or_not16(arg1: *const octave_int32,
                          arg2: *const int32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@0@Z"]
    pub fn mx_el_lt48(arg1: *const int32NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@0@Z"]
    pub fn mx_el_le48(arg1: *const int32NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@0@Z"]
    pub fn mx_el_ge48(arg1: *const int32NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@0@Z"]
    pub fn mx_el_gt48(arg1: *const int32NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@0@Z"]
    pub fn mx_el_eq51(arg1: *const int32NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@0@Z"]
    pub fn mx_el_ne51(arg1: *const int32NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@0@Z"]
    pub fn mx_el_and53(arg1: *const int32NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@0@Z"]
    pub fn mx_el_or53(arg1: *const int32NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@0@Z"]
    pub fn mx_el_and_not17(arg1: *const int32NDArray,
                           arg2: *const int32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@0@Z"]
    pub fn mx_el_or_not17(arg1: *const int32NDArray,
                          arg2: *const int32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@0@Z"]
    pub fn mx_el_not_and17(arg1: *const int32NDArray,
                           arg2: *const int32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@0@Z"]
    pub fn mx_el_not_or17(arg1: *const int32NDArray,
                          arg2: *const int32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?min@@YA?AV?$intNDArray@V?$octave_int@H@@@@V?$octave_int@H@@AEBV1@@Z"]
    pub fn min39(d: octave_int32, m: *const int32NDArray) -> int32NDArray;
}
extern "C" {
    #[link_name =
          "?min@@YA?AV?$intNDArray@V?$octave_int@H@@@@AEBV1@V?$octave_int@H@@@Z"]
    pub fn min40(m: *const int32NDArray, d: octave_int32) -> int32NDArray;
}
extern "C" {
    #[link_name = "?min@@YA?AV?$intNDArray@V?$octave_int@H@@@@AEBV1@0@Z"]
    pub fn min41(a: *const int32NDArray, b: *const int32NDArray)
     -> int32NDArray;
}
extern "C" {
    #[link_name =
          "?max@@YA?AV?$intNDArray@V?$octave_int@H@@@@V?$octave_int@H@@AEBV1@@Z"]
    pub fn max39(d: octave_int32, m: *const int32NDArray) -> int32NDArray;
}
extern "C" {
    #[link_name =
          "?max@@YA?AV?$intNDArray@V?$octave_int@H@@@@AEBV1@V?$octave_int@H@@@Z"]
    pub fn max40(m: *const int32NDArray, d: octave_int32) -> int32NDArray;
}
extern "C" {
    #[link_name = "?max@@YA?AV?$intNDArray@V?$octave_int@H@@@@AEBV1@0@Z"]
    pub fn max41(a: *const int32NDArray, b: *const int32NDArray)
     -> int32NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_add@@YA?AV?$intNDArray@V?$octave_int@H@@@@AEBV1@0@Z"]
    pub fn bsxfun_add6(arg1: *const int32NDArray, arg2: *const int32NDArray)
     -> int32NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_sub@@YA?AV?$intNDArray@V?$octave_int@H@@@@AEBV1@0@Z"]
    pub fn bsxfun_sub6(arg1: *const int32NDArray, arg2: *const int32NDArray)
     -> int32NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_mul@@YA?AV?$intNDArray@V?$octave_int@H@@@@AEBV1@0@Z"]
    pub fn bsxfun_mul6(arg1: *const int32NDArray, arg2: *const int32NDArray)
     -> int32NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_div@@YA?AV?$intNDArray@V?$octave_int@H@@@@AEBV1@0@Z"]
    pub fn bsxfun_div6(arg1: *const int32NDArray, arg2: *const int32NDArray)
     -> int32NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_pow@@YA?AV?$intNDArray@V?$octave_int@H@@@@AEBV1@0@Z"]
    pub fn bsxfun_pow18(arg1: *const int32NDArray, arg2: *const int32NDArray)
     -> int32NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_min@@YA?AV?$intNDArray@V?$octave_int@H@@@@AEBV1@0@Z"]
    pub fn bsxfun_min6(arg1: *const int32NDArray, arg2: *const int32NDArray)
     -> int32NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_max@@YA?AV?$intNDArray@V?$octave_int@H@@@@AEBV1@0@Z"]
    pub fn bsxfun_max6(arg1: *const int32NDArray, arg2: *const int32NDArray)
     -> int32NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_pow@@YA?AV?$intNDArray@V?$octave_int@H@@@@AEBV1@AEBVNDArray@@@Z"]
    pub fn bsxfun_pow19(arg1: *const int32NDArray, arg2: *const NDArray)
     -> int32NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_pow@@YA?AV?$intNDArray@V?$octave_int@H@@@@AEBV1@AEBVFloatNDArray@@@Z"]
    pub fn bsxfun_pow20(arg1: *const int32NDArray, arg2: *const FloatNDArray)
     -> int32NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_pow@@YA?AV?$intNDArray@V?$octave_int@H@@@@AEBVNDArray@@AEBV1@@Z"]
    pub fn bsxfun_pow21(arg1: *const NDArray, arg2: *const int32NDArray)
     -> int32NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_pow@@YA?AV?$intNDArray@V?$octave_int@H@@@@AEBVFloatNDArray@@AEBV1@@Z"]
    pub fn bsxfun_pow22(arg1: *const FloatNDArray, arg2: *const int32NDArray)
     -> int32NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@0@Z"]
    pub fn bsxfun_eq7(arg1: *const int32NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@0@Z"]
    pub fn bsxfun_ne7(arg1: *const int32NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@0@Z"]
    pub fn bsxfun_lt7(arg1: *const int32NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@0@Z"]
    pub fn bsxfun_le7(arg1: *const int32NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@0@Z"]
    pub fn bsxfun_gt7(arg1: *const int32NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@0@Z"]
    pub fn bsxfun_ge7(arg1: *const int32NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
pub type int64NDArray = intNDArray<octave_int<::std::os::raw::c_longlong>>;
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_lt49(arg1: *const int64NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_le49(arg1: *const int64NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_ge49(arg1: *const int64NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_gt49(arg1: *const int64NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_eq52(arg1: *const int64NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_ne52(arg1: *const int64NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_and54(arg1: *const int64NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_or54(arg1: *const int64NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_not_and18(arg1: *const int64NDArray,
                           arg2: *const octave_int64) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_not_or18(arg1: *const int64NDArray,
                          arg2: *const octave_int64) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_lt50(arg1: *const octave_int64, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_le50(arg1: *const octave_int64, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_ge50(arg1: *const octave_int64, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_gt50(arg1: *const octave_int64, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_eq53(arg1: *const octave_int64, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_ne53(arg1: *const octave_int64, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_and55(arg1: *const octave_int64, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_or55(arg1: *const octave_int64, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_and_not18(arg1: *const octave_int64,
                           arg2: *const int64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_or_not18(arg1: *const octave_int64,
                          arg2: *const int64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@0@Z"]
    pub fn mx_el_lt51(arg1: *const int64NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@0@Z"]
    pub fn mx_el_le51(arg1: *const int64NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@0@Z"]
    pub fn mx_el_ge51(arg1: *const int64NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@0@Z"]
    pub fn mx_el_gt51(arg1: *const int64NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@0@Z"]
    pub fn mx_el_eq54(arg1: *const int64NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@0@Z"]
    pub fn mx_el_ne54(arg1: *const int64NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@0@Z"]
    pub fn mx_el_and56(arg1: *const int64NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@0@Z"]
    pub fn mx_el_or56(arg1: *const int64NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@0@Z"]
    pub fn mx_el_and_not19(arg1: *const int64NDArray,
                           arg2: *const int64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@0@Z"]
    pub fn mx_el_or_not19(arg1: *const int64NDArray,
                          arg2: *const int64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@0@Z"]
    pub fn mx_el_not_and19(arg1: *const int64NDArray,
                           arg2: *const int64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@0@Z"]
    pub fn mx_el_not_or19(arg1: *const int64NDArray,
                          arg2: *const int64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?min@@YA?AV?$intNDArray@V?$octave_int@_J@@@@V?$octave_int@_J@@AEBV1@@Z"]
    pub fn min42(d: octave_int64, m: *const int64NDArray) -> int64NDArray;
}
extern "C" {
    #[link_name =
          "?min@@YA?AV?$intNDArray@V?$octave_int@_J@@@@AEBV1@V?$octave_int@_J@@@Z"]
    pub fn min43(m: *const int64NDArray, d: octave_int64) -> int64NDArray;
}
extern "C" {
    #[link_name = "?min@@YA?AV?$intNDArray@V?$octave_int@_J@@@@AEBV1@0@Z"]
    pub fn min44(a: *const int64NDArray, b: *const int64NDArray)
     -> int64NDArray;
}
extern "C" {
    #[link_name =
          "?max@@YA?AV?$intNDArray@V?$octave_int@_J@@@@V?$octave_int@_J@@AEBV1@@Z"]
    pub fn max42(d: octave_int64, m: *const int64NDArray) -> int64NDArray;
}
extern "C" {
    #[link_name =
          "?max@@YA?AV?$intNDArray@V?$octave_int@_J@@@@AEBV1@V?$octave_int@_J@@@Z"]
    pub fn max43(m: *const int64NDArray, d: octave_int64) -> int64NDArray;
}
extern "C" {
    #[link_name = "?max@@YA?AV?$intNDArray@V?$octave_int@_J@@@@AEBV1@0@Z"]
    pub fn max44(a: *const int64NDArray, b: *const int64NDArray)
     -> int64NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_add@@YA?AV?$intNDArray@V?$octave_int@_J@@@@AEBV1@0@Z"]
    pub fn bsxfun_add7(arg1: *const int64NDArray, arg2: *const int64NDArray)
     -> int64NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_sub@@YA?AV?$intNDArray@V?$octave_int@_J@@@@AEBV1@0@Z"]
    pub fn bsxfun_sub7(arg1: *const int64NDArray, arg2: *const int64NDArray)
     -> int64NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_mul@@YA?AV?$intNDArray@V?$octave_int@_J@@@@AEBV1@0@Z"]
    pub fn bsxfun_mul7(arg1: *const int64NDArray, arg2: *const int64NDArray)
     -> int64NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_div@@YA?AV?$intNDArray@V?$octave_int@_J@@@@AEBV1@0@Z"]
    pub fn bsxfun_div7(arg1: *const int64NDArray, arg2: *const int64NDArray)
     -> int64NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_pow@@YA?AV?$intNDArray@V?$octave_int@_J@@@@AEBV1@0@Z"]
    pub fn bsxfun_pow23(arg1: *const int64NDArray, arg2: *const int64NDArray)
     -> int64NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_min@@YA?AV?$intNDArray@V?$octave_int@_J@@@@AEBV1@0@Z"]
    pub fn bsxfun_min7(arg1: *const int64NDArray, arg2: *const int64NDArray)
     -> int64NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_max@@YA?AV?$intNDArray@V?$octave_int@_J@@@@AEBV1@0@Z"]
    pub fn bsxfun_max7(arg1: *const int64NDArray, arg2: *const int64NDArray)
     -> int64NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_pow@@YA?AV?$intNDArray@V?$octave_int@_J@@@@AEBV1@AEBVNDArray@@@Z"]
    pub fn bsxfun_pow24(arg1: *const int64NDArray, arg2: *const NDArray)
     -> int64NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_pow@@YA?AV?$intNDArray@V?$octave_int@_J@@@@AEBV1@AEBVFloatNDArray@@@Z"]
    pub fn bsxfun_pow25(arg1: *const int64NDArray, arg2: *const FloatNDArray)
     -> int64NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_pow@@YA?AV?$intNDArray@V?$octave_int@_J@@@@AEBVNDArray@@AEBV1@@Z"]
    pub fn bsxfun_pow26(arg1: *const NDArray, arg2: *const int64NDArray)
     -> int64NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_pow@@YA?AV?$intNDArray@V?$octave_int@_J@@@@AEBVFloatNDArray@@AEBV1@@Z"]
    pub fn bsxfun_pow27(arg1: *const FloatNDArray, arg2: *const int64NDArray)
     -> int64NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@0@Z"]
    pub fn bsxfun_eq8(arg1: *const int64NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@0@Z"]
    pub fn bsxfun_ne8(arg1: *const int64NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@0@Z"]
    pub fn bsxfun_lt8(arg1: *const int64NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@0@Z"]
    pub fn bsxfun_le8(arg1: *const int64NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@0@Z"]
    pub fn bsxfun_gt8(arg1: *const int64NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@0@Z"]
    pub fn bsxfun_ge8(arg1: *const int64NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
pub type uint8NDArray = intNDArray<octave_int<::std::os::raw::c_uchar>>;
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_lt52(arg1: *const uint8NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_le52(arg1: *const uint8NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_ge52(arg1: *const uint8NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_gt52(arg1: *const uint8NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_eq55(arg1: *const uint8NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_ne55(arg1: *const uint8NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_and57(arg1: *const uint8NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_or57(arg1: *const uint8NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_not_and20(arg1: *const uint8NDArray,
                           arg2: *const octave_uint8) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_not_or20(arg1: *const uint8NDArray,
                          arg2: *const octave_uint8) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_lt53(arg1: *const octave_uint8, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_le53(arg1: *const octave_uint8, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_ge53(arg1: *const octave_uint8, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_gt53(arg1: *const octave_uint8, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_eq56(arg1: *const octave_uint8, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_ne56(arg1: *const octave_uint8, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_and58(arg1: *const octave_uint8, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_or58(arg1: *const octave_uint8, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_and_not20(arg1: *const octave_uint8,
                           arg2: *const uint8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_or_not20(arg1: *const octave_uint8,
                          arg2: *const uint8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@0@Z"]
    pub fn mx_el_lt54(arg1: *const uint8NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@0@Z"]
    pub fn mx_el_le54(arg1: *const uint8NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@0@Z"]
    pub fn mx_el_ge54(arg1: *const uint8NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@0@Z"]
    pub fn mx_el_gt54(arg1: *const uint8NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@0@Z"]
    pub fn mx_el_eq57(arg1: *const uint8NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@0@Z"]
    pub fn mx_el_ne57(arg1: *const uint8NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@0@Z"]
    pub fn mx_el_and59(arg1: *const uint8NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@0@Z"]
    pub fn mx_el_or59(arg1: *const uint8NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@0@Z"]
    pub fn mx_el_and_not21(arg1: *const uint8NDArray,
                           arg2: *const uint8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@0@Z"]
    pub fn mx_el_or_not21(arg1: *const uint8NDArray,
                          arg2: *const uint8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@0@Z"]
    pub fn mx_el_not_and21(arg1: *const uint8NDArray,
                           arg2: *const uint8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@0@Z"]
    pub fn mx_el_not_or21(arg1: *const uint8NDArray,
                          arg2: *const uint8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?min@@YA?AV?$intNDArray@V?$octave_int@E@@@@V?$octave_int@E@@AEBV1@@Z"]
    pub fn min45(d: octave_uint8, m: *const uint8NDArray) -> uint8NDArray;
}
extern "C" {
    #[link_name =
          "?min@@YA?AV?$intNDArray@V?$octave_int@E@@@@AEBV1@V?$octave_int@E@@@Z"]
    pub fn min46(m: *const uint8NDArray, d: octave_uint8) -> uint8NDArray;
}
extern "C" {
    #[link_name = "?min@@YA?AV?$intNDArray@V?$octave_int@E@@@@AEBV1@0@Z"]
    pub fn min47(a: *const uint8NDArray, b: *const uint8NDArray)
     -> uint8NDArray;
}
extern "C" {
    #[link_name =
          "?max@@YA?AV?$intNDArray@V?$octave_int@E@@@@V?$octave_int@E@@AEBV1@@Z"]
    pub fn max45(d: octave_uint8, m: *const uint8NDArray) -> uint8NDArray;
}
extern "C" {
    #[link_name =
          "?max@@YA?AV?$intNDArray@V?$octave_int@E@@@@AEBV1@V?$octave_int@E@@@Z"]
    pub fn max46(m: *const uint8NDArray, d: octave_uint8) -> uint8NDArray;
}
extern "C" {
    #[link_name = "?max@@YA?AV?$intNDArray@V?$octave_int@E@@@@AEBV1@0@Z"]
    pub fn max47(a: *const uint8NDArray, b: *const uint8NDArray)
     -> uint8NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_add@@YA?AV?$intNDArray@V?$octave_int@E@@@@AEBV1@0@Z"]
    pub fn bsxfun_add8(arg1: *const uint8NDArray, arg2: *const uint8NDArray)
     -> uint8NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_sub@@YA?AV?$intNDArray@V?$octave_int@E@@@@AEBV1@0@Z"]
    pub fn bsxfun_sub8(arg1: *const uint8NDArray, arg2: *const uint8NDArray)
     -> uint8NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_mul@@YA?AV?$intNDArray@V?$octave_int@E@@@@AEBV1@0@Z"]
    pub fn bsxfun_mul8(arg1: *const uint8NDArray, arg2: *const uint8NDArray)
     -> uint8NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_div@@YA?AV?$intNDArray@V?$octave_int@E@@@@AEBV1@0@Z"]
    pub fn bsxfun_div8(arg1: *const uint8NDArray, arg2: *const uint8NDArray)
     -> uint8NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_pow@@YA?AV?$intNDArray@V?$octave_int@E@@@@AEBV1@0@Z"]
    pub fn bsxfun_pow28(arg1: *const uint8NDArray, arg2: *const uint8NDArray)
     -> uint8NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_min@@YA?AV?$intNDArray@V?$octave_int@E@@@@AEBV1@0@Z"]
    pub fn bsxfun_min8(arg1: *const uint8NDArray, arg2: *const uint8NDArray)
     -> uint8NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_max@@YA?AV?$intNDArray@V?$octave_int@E@@@@AEBV1@0@Z"]
    pub fn bsxfun_max8(arg1: *const uint8NDArray, arg2: *const uint8NDArray)
     -> uint8NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_pow@@YA?AV?$intNDArray@V?$octave_int@E@@@@AEBV1@AEBVNDArray@@@Z"]
    pub fn bsxfun_pow29(arg1: *const uint8NDArray, arg2: *const NDArray)
     -> uint8NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_pow@@YA?AV?$intNDArray@V?$octave_int@E@@@@AEBV1@AEBVFloatNDArray@@@Z"]
    pub fn bsxfun_pow30(arg1: *const uint8NDArray, arg2: *const FloatNDArray)
     -> uint8NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_pow@@YA?AV?$intNDArray@V?$octave_int@E@@@@AEBVNDArray@@AEBV1@@Z"]
    pub fn bsxfun_pow31(arg1: *const NDArray, arg2: *const uint8NDArray)
     -> uint8NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_pow@@YA?AV?$intNDArray@V?$octave_int@E@@@@AEBVFloatNDArray@@AEBV1@@Z"]
    pub fn bsxfun_pow32(arg1: *const FloatNDArray, arg2: *const uint8NDArray)
     -> uint8NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@0@Z"]
    pub fn bsxfun_eq9(arg1: *const uint8NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@0@Z"]
    pub fn bsxfun_ne9(arg1: *const uint8NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@0@Z"]
    pub fn bsxfun_lt9(arg1: *const uint8NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@0@Z"]
    pub fn bsxfun_le9(arg1: *const uint8NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@0@Z"]
    pub fn bsxfun_gt9(arg1: *const uint8NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@0@Z"]
    pub fn bsxfun_ge9(arg1: *const uint8NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
pub type uint16NDArray = intNDArray<octave_int<::std::os::raw::c_ushort>>;
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_lt55(arg1: *const uint16NDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_le55(arg1: *const uint16NDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_ge55(arg1: *const uint16NDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_gt55(arg1: *const uint16NDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_eq58(arg1: *const uint16NDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_ne58(arg1: *const uint16NDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_and60(arg1: *const uint16NDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_or60(arg1: *const uint16NDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_not_and22(arg1: *const uint16NDArray,
                           arg2: *const octave_uint16) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_not_or22(arg1: *const uint16NDArray,
                          arg2: *const octave_uint16) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_lt56(arg1: *const octave_uint16, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_le56(arg1: *const octave_uint16, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_ge56(arg1: *const octave_uint16, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_gt56(arg1: *const octave_uint16, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_eq59(arg1: *const octave_uint16, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_ne59(arg1: *const octave_uint16, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_and61(arg1: *const octave_uint16, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_or61(arg1: *const octave_uint16, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_and_not22(arg1: *const octave_uint16,
                           arg2: *const uint16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_or_not22(arg1: *const octave_uint16,
                          arg2: *const uint16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@0@Z"]
    pub fn mx_el_lt57(arg1: *const uint16NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@0@Z"]
    pub fn mx_el_le57(arg1: *const uint16NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@0@Z"]
    pub fn mx_el_ge57(arg1: *const uint16NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@0@Z"]
    pub fn mx_el_gt57(arg1: *const uint16NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@0@Z"]
    pub fn mx_el_eq60(arg1: *const uint16NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@0@Z"]
    pub fn mx_el_ne60(arg1: *const uint16NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@0@Z"]
    pub fn mx_el_and62(arg1: *const uint16NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@0@Z"]
    pub fn mx_el_or62(arg1: *const uint16NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@0@Z"]
    pub fn mx_el_and_not23(arg1: *const uint16NDArray,
                           arg2: *const uint16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@0@Z"]
    pub fn mx_el_or_not23(arg1: *const uint16NDArray,
                          arg2: *const uint16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@0@Z"]
    pub fn mx_el_not_and23(arg1: *const uint16NDArray,
                           arg2: *const uint16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@0@Z"]
    pub fn mx_el_not_or23(arg1: *const uint16NDArray,
                          arg2: *const uint16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?min@@YA?AV?$intNDArray@V?$octave_int@G@@@@V?$octave_int@G@@AEBV1@@Z"]
    pub fn min48(d: octave_uint16, m: *const uint16NDArray) -> uint16NDArray;
}
extern "C" {
    #[link_name =
          "?min@@YA?AV?$intNDArray@V?$octave_int@G@@@@AEBV1@V?$octave_int@G@@@Z"]
    pub fn min49(m: *const uint16NDArray, d: octave_uint16) -> uint16NDArray;
}
extern "C" {
    #[link_name = "?min@@YA?AV?$intNDArray@V?$octave_int@G@@@@AEBV1@0@Z"]
    pub fn min50(a: *const uint16NDArray, b: *const uint16NDArray)
     -> uint16NDArray;
}
extern "C" {
    #[link_name =
          "?max@@YA?AV?$intNDArray@V?$octave_int@G@@@@V?$octave_int@G@@AEBV1@@Z"]
    pub fn max48(d: octave_uint16, m: *const uint16NDArray) -> uint16NDArray;
}
extern "C" {
    #[link_name =
          "?max@@YA?AV?$intNDArray@V?$octave_int@G@@@@AEBV1@V?$octave_int@G@@@Z"]
    pub fn max49(m: *const uint16NDArray, d: octave_uint16) -> uint16NDArray;
}
extern "C" {
    #[link_name = "?max@@YA?AV?$intNDArray@V?$octave_int@G@@@@AEBV1@0@Z"]
    pub fn max50(a: *const uint16NDArray, b: *const uint16NDArray)
     -> uint16NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_add@@YA?AV?$intNDArray@V?$octave_int@G@@@@AEBV1@0@Z"]
    pub fn bsxfun_add9(arg1: *const uint16NDArray, arg2: *const uint16NDArray)
     -> uint16NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_sub@@YA?AV?$intNDArray@V?$octave_int@G@@@@AEBV1@0@Z"]
    pub fn bsxfun_sub9(arg1: *const uint16NDArray, arg2: *const uint16NDArray)
     -> uint16NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_mul@@YA?AV?$intNDArray@V?$octave_int@G@@@@AEBV1@0@Z"]
    pub fn bsxfun_mul9(arg1: *const uint16NDArray, arg2: *const uint16NDArray)
     -> uint16NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_div@@YA?AV?$intNDArray@V?$octave_int@G@@@@AEBV1@0@Z"]
    pub fn bsxfun_div9(arg1: *const uint16NDArray, arg2: *const uint16NDArray)
     -> uint16NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_pow@@YA?AV?$intNDArray@V?$octave_int@G@@@@AEBV1@0@Z"]
    pub fn bsxfun_pow33(arg1: *const uint16NDArray,
                        arg2: *const uint16NDArray) -> uint16NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_min@@YA?AV?$intNDArray@V?$octave_int@G@@@@AEBV1@0@Z"]
    pub fn bsxfun_min9(arg1: *const uint16NDArray, arg2: *const uint16NDArray)
     -> uint16NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_max@@YA?AV?$intNDArray@V?$octave_int@G@@@@AEBV1@0@Z"]
    pub fn bsxfun_max9(arg1: *const uint16NDArray, arg2: *const uint16NDArray)
     -> uint16NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_pow@@YA?AV?$intNDArray@V?$octave_int@G@@@@AEBV1@AEBVNDArray@@@Z"]
    pub fn bsxfun_pow34(arg1: *const uint16NDArray, arg2: *const NDArray)
     -> uint16NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_pow@@YA?AV?$intNDArray@V?$octave_int@G@@@@AEBV1@AEBVFloatNDArray@@@Z"]
    pub fn bsxfun_pow35(arg1: *const uint16NDArray, arg2: *const FloatNDArray)
     -> uint16NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_pow@@YA?AV?$intNDArray@V?$octave_int@G@@@@AEBVNDArray@@AEBV1@@Z"]
    pub fn bsxfun_pow36(arg1: *const NDArray, arg2: *const uint16NDArray)
     -> uint16NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_pow@@YA?AV?$intNDArray@V?$octave_int@G@@@@AEBVFloatNDArray@@AEBV1@@Z"]
    pub fn bsxfun_pow37(arg1: *const FloatNDArray, arg2: *const uint16NDArray)
     -> uint16NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@0@Z"]
    pub fn bsxfun_eq10(arg1: *const uint16NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@0@Z"]
    pub fn bsxfun_ne10(arg1: *const uint16NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@0@Z"]
    pub fn bsxfun_lt10(arg1: *const uint16NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@0@Z"]
    pub fn bsxfun_le10(arg1: *const uint16NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@0@Z"]
    pub fn bsxfun_gt10(arg1: *const uint16NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@0@Z"]
    pub fn bsxfun_ge10(arg1: *const uint16NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
pub type uint32NDArray = intNDArray<octave_int<::std::os::raw::c_uint>>;
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_lt58(arg1: *const uint32NDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_le58(arg1: *const uint32NDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_ge58(arg1: *const uint32NDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_gt58(arg1: *const uint32NDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_eq61(arg1: *const uint32NDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_ne61(arg1: *const uint32NDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_and63(arg1: *const uint32NDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_or63(arg1: *const uint32NDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_not_and24(arg1: *const uint32NDArray,
                           arg2: *const octave_uint32) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_not_or24(arg1: *const uint32NDArray,
                          arg2: *const octave_uint32) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_lt59(arg1: *const octave_uint32, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_le59(arg1: *const octave_uint32, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_ge59(arg1: *const octave_uint32, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_gt59(arg1: *const octave_uint32, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_eq62(arg1: *const octave_uint32, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_ne62(arg1: *const octave_uint32, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_and64(arg1: *const octave_uint32, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_or64(arg1: *const octave_uint32, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_and_not24(arg1: *const octave_uint32,
                           arg2: *const uint32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_or_not24(arg1: *const octave_uint32,
                          arg2: *const uint32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@0@Z"]
    pub fn mx_el_lt60(arg1: *const uint32NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@0@Z"]
    pub fn mx_el_le60(arg1: *const uint32NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@0@Z"]
    pub fn mx_el_ge60(arg1: *const uint32NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@0@Z"]
    pub fn mx_el_gt60(arg1: *const uint32NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@0@Z"]
    pub fn mx_el_eq63(arg1: *const uint32NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@0@Z"]
    pub fn mx_el_ne63(arg1: *const uint32NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@0@Z"]
    pub fn mx_el_and65(arg1: *const uint32NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@0@Z"]
    pub fn mx_el_or65(arg1: *const uint32NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@0@Z"]
    pub fn mx_el_and_not25(arg1: *const uint32NDArray,
                           arg2: *const uint32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@0@Z"]
    pub fn mx_el_or_not25(arg1: *const uint32NDArray,
                          arg2: *const uint32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@0@Z"]
    pub fn mx_el_not_and25(arg1: *const uint32NDArray,
                           arg2: *const uint32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@0@Z"]
    pub fn mx_el_not_or25(arg1: *const uint32NDArray,
                          arg2: *const uint32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?min@@YA?AV?$intNDArray@V?$octave_int@I@@@@V?$octave_int@I@@AEBV1@@Z"]
    pub fn min51(d: octave_uint32, m: *const uint32NDArray) -> uint32NDArray;
}
extern "C" {
    #[link_name =
          "?min@@YA?AV?$intNDArray@V?$octave_int@I@@@@AEBV1@V?$octave_int@I@@@Z"]
    pub fn min52(m: *const uint32NDArray, d: octave_uint32) -> uint32NDArray;
}
extern "C" {
    #[link_name = "?min@@YA?AV?$intNDArray@V?$octave_int@I@@@@AEBV1@0@Z"]
    pub fn min53(a: *const uint32NDArray, b: *const uint32NDArray)
     -> uint32NDArray;
}
extern "C" {
    #[link_name =
          "?max@@YA?AV?$intNDArray@V?$octave_int@I@@@@V?$octave_int@I@@AEBV1@@Z"]
    pub fn max51(d: octave_uint32, m: *const uint32NDArray) -> uint32NDArray;
}
extern "C" {
    #[link_name =
          "?max@@YA?AV?$intNDArray@V?$octave_int@I@@@@AEBV1@V?$octave_int@I@@@Z"]
    pub fn max52(m: *const uint32NDArray, d: octave_uint32) -> uint32NDArray;
}
extern "C" {
    #[link_name = "?max@@YA?AV?$intNDArray@V?$octave_int@I@@@@AEBV1@0@Z"]
    pub fn max53(a: *const uint32NDArray, b: *const uint32NDArray)
     -> uint32NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_add@@YA?AV?$intNDArray@V?$octave_int@I@@@@AEBV1@0@Z"]
    pub fn bsxfun_add10(arg1: *const uint32NDArray,
                        arg2: *const uint32NDArray) -> uint32NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_sub@@YA?AV?$intNDArray@V?$octave_int@I@@@@AEBV1@0@Z"]
    pub fn bsxfun_sub10(arg1: *const uint32NDArray,
                        arg2: *const uint32NDArray) -> uint32NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_mul@@YA?AV?$intNDArray@V?$octave_int@I@@@@AEBV1@0@Z"]
    pub fn bsxfun_mul10(arg1: *const uint32NDArray,
                        arg2: *const uint32NDArray) -> uint32NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_div@@YA?AV?$intNDArray@V?$octave_int@I@@@@AEBV1@0@Z"]
    pub fn bsxfun_div10(arg1: *const uint32NDArray,
                        arg2: *const uint32NDArray) -> uint32NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_pow@@YA?AV?$intNDArray@V?$octave_int@I@@@@AEBV1@0@Z"]
    pub fn bsxfun_pow38(arg1: *const uint32NDArray,
                        arg2: *const uint32NDArray) -> uint32NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_min@@YA?AV?$intNDArray@V?$octave_int@I@@@@AEBV1@0@Z"]
    pub fn bsxfun_min10(arg1: *const uint32NDArray,
                        arg2: *const uint32NDArray) -> uint32NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_max@@YA?AV?$intNDArray@V?$octave_int@I@@@@AEBV1@0@Z"]
    pub fn bsxfun_max10(arg1: *const uint32NDArray,
                        arg2: *const uint32NDArray) -> uint32NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_pow@@YA?AV?$intNDArray@V?$octave_int@I@@@@AEBV1@AEBVNDArray@@@Z"]
    pub fn bsxfun_pow39(arg1: *const uint32NDArray, arg2: *const NDArray)
     -> uint32NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_pow@@YA?AV?$intNDArray@V?$octave_int@I@@@@AEBV1@AEBVFloatNDArray@@@Z"]
    pub fn bsxfun_pow40(arg1: *const uint32NDArray, arg2: *const FloatNDArray)
     -> uint32NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_pow@@YA?AV?$intNDArray@V?$octave_int@I@@@@AEBVNDArray@@AEBV1@@Z"]
    pub fn bsxfun_pow41(arg1: *const NDArray, arg2: *const uint32NDArray)
     -> uint32NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_pow@@YA?AV?$intNDArray@V?$octave_int@I@@@@AEBVFloatNDArray@@AEBV1@@Z"]
    pub fn bsxfun_pow42(arg1: *const FloatNDArray, arg2: *const uint32NDArray)
     -> uint32NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@0@Z"]
    pub fn bsxfun_eq11(arg1: *const uint32NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@0@Z"]
    pub fn bsxfun_ne11(arg1: *const uint32NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@0@Z"]
    pub fn bsxfun_lt11(arg1: *const uint32NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@0@Z"]
    pub fn bsxfun_le11(arg1: *const uint32NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@0@Z"]
    pub fn bsxfun_gt11(arg1: *const uint32NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@0@Z"]
    pub fn bsxfun_ge11(arg1: *const uint32NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
pub type uint64NDArray = intNDArray<octave_int<::std::os::raw::c_ulonglong>>;
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_lt61(arg1: *const uint64NDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_le61(arg1: *const uint64NDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_ge61(arg1: *const uint64NDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_gt61(arg1: *const uint64NDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_eq64(arg1: *const uint64NDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_ne64(arg1: *const uint64NDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_and66(arg1: *const uint64NDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_or66(arg1: *const uint64NDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_not_and26(arg1: *const uint64NDArray,
                           arg2: *const octave_uint64) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_not_or26(arg1: *const uint64NDArray,
                          arg2: *const octave_uint64) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_lt62(arg1: *const octave_uint64, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_le62(arg1: *const octave_uint64, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_ge62(arg1: *const octave_uint64, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_gt62(arg1: *const octave_uint64, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_eq65(arg1: *const octave_uint64, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_ne65(arg1: *const octave_uint64, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_and67(arg1: *const octave_uint64, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_or67(arg1: *const octave_uint64, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_and_not26(arg1: *const octave_uint64,
                           arg2: *const uint64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_or_not26(arg1: *const octave_uint64,
                          arg2: *const uint64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@0@Z"]
    pub fn mx_el_lt63(arg1: *const uint64NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@0@Z"]
    pub fn mx_el_le63(arg1: *const uint64NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@0@Z"]
    pub fn mx_el_ge63(arg1: *const uint64NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@0@Z"]
    pub fn mx_el_gt63(arg1: *const uint64NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@0@Z"]
    pub fn mx_el_eq66(arg1: *const uint64NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@0@Z"]
    pub fn mx_el_ne66(arg1: *const uint64NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@0@Z"]
    pub fn mx_el_and68(arg1: *const uint64NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@0@Z"]
    pub fn mx_el_or68(arg1: *const uint64NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@0@Z"]
    pub fn mx_el_and_not27(arg1: *const uint64NDArray,
                           arg2: *const uint64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@0@Z"]
    pub fn mx_el_or_not27(arg1: *const uint64NDArray,
                          arg2: *const uint64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@0@Z"]
    pub fn mx_el_not_and27(arg1: *const uint64NDArray,
                           arg2: *const uint64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@0@Z"]
    pub fn mx_el_not_or27(arg1: *const uint64NDArray,
                          arg2: *const uint64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?min@@YA?AV?$intNDArray@V?$octave_int@_K@@@@V?$octave_int@_K@@AEBV1@@Z"]
    pub fn min54(d: octave_uint64, m: *const uint64NDArray) -> uint64NDArray;
}
extern "C" {
    #[link_name =
          "?min@@YA?AV?$intNDArray@V?$octave_int@_K@@@@AEBV1@V?$octave_int@_K@@@Z"]
    pub fn min55(m: *const uint64NDArray, d: octave_uint64) -> uint64NDArray;
}
extern "C" {
    #[link_name = "?min@@YA?AV?$intNDArray@V?$octave_int@_K@@@@AEBV1@0@Z"]
    pub fn min56(a: *const uint64NDArray, b: *const uint64NDArray)
     -> uint64NDArray;
}
extern "C" {
    #[link_name =
          "?max@@YA?AV?$intNDArray@V?$octave_int@_K@@@@V?$octave_int@_K@@AEBV1@@Z"]
    pub fn max54(d: octave_uint64, m: *const uint64NDArray) -> uint64NDArray;
}
extern "C" {
    #[link_name =
          "?max@@YA?AV?$intNDArray@V?$octave_int@_K@@@@AEBV1@V?$octave_int@_K@@@Z"]
    pub fn max55(m: *const uint64NDArray, d: octave_uint64) -> uint64NDArray;
}
extern "C" {
    #[link_name = "?max@@YA?AV?$intNDArray@V?$octave_int@_K@@@@AEBV1@0@Z"]
    pub fn max56(a: *const uint64NDArray, b: *const uint64NDArray)
     -> uint64NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_add@@YA?AV?$intNDArray@V?$octave_int@_K@@@@AEBV1@0@Z"]
    pub fn bsxfun_add11(arg1: *const uint64NDArray,
                        arg2: *const uint64NDArray) -> uint64NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_sub@@YA?AV?$intNDArray@V?$octave_int@_K@@@@AEBV1@0@Z"]
    pub fn bsxfun_sub11(arg1: *const uint64NDArray,
                        arg2: *const uint64NDArray) -> uint64NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_mul@@YA?AV?$intNDArray@V?$octave_int@_K@@@@AEBV1@0@Z"]
    pub fn bsxfun_mul11(arg1: *const uint64NDArray,
                        arg2: *const uint64NDArray) -> uint64NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_div@@YA?AV?$intNDArray@V?$octave_int@_K@@@@AEBV1@0@Z"]
    pub fn bsxfun_div11(arg1: *const uint64NDArray,
                        arg2: *const uint64NDArray) -> uint64NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_pow@@YA?AV?$intNDArray@V?$octave_int@_K@@@@AEBV1@0@Z"]
    pub fn bsxfun_pow43(arg1: *const uint64NDArray,
                        arg2: *const uint64NDArray) -> uint64NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_min@@YA?AV?$intNDArray@V?$octave_int@_K@@@@AEBV1@0@Z"]
    pub fn bsxfun_min11(arg1: *const uint64NDArray,
                        arg2: *const uint64NDArray) -> uint64NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_max@@YA?AV?$intNDArray@V?$octave_int@_K@@@@AEBV1@0@Z"]
    pub fn bsxfun_max11(arg1: *const uint64NDArray,
                        arg2: *const uint64NDArray) -> uint64NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_pow@@YA?AV?$intNDArray@V?$octave_int@_K@@@@AEBV1@AEBVNDArray@@@Z"]
    pub fn bsxfun_pow44(arg1: *const uint64NDArray, arg2: *const NDArray)
     -> uint64NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_pow@@YA?AV?$intNDArray@V?$octave_int@_K@@@@AEBV1@AEBVFloatNDArray@@@Z"]
    pub fn bsxfun_pow45(arg1: *const uint64NDArray, arg2: *const FloatNDArray)
     -> uint64NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_pow@@YA?AV?$intNDArray@V?$octave_int@_K@@@@AEBVNDArray@@AEBV1@@Z"]
    pub fn bsxfun_pow46(arg1: *const NDArray, arg2: *const uint64NDArray)
     -> uint64NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_pow@@YA?AV?$intNDArray@V?$octave_int@_K@@@@AEBVFloatNDArray@@AEBV1@@Z"]
    pub fn bsxfun_pow47(arg1: *const FloatNDArray, arg2: *const uint64NDArray)
     -> uint64NDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@0@Z"]
    pub fn bsxfun_eq12(arg1: *const uint64NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@0@Z"]
    pub fn bsxfun_ne12(arg1: *const uint64NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@0@Z"]
    pub fn bsxfun_lt12(arg1: *const uint64NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@0@Z"]
    pub fn bsxfun_le12(arg1: *const uint64NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@0@Z"]
    pub fn bsxfun_gt12(arg1: *const uint64NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?bsxfun_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@0@Z"]
    pub fn bsxfun_ge12(arg1: *const uint64NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?product@@YA?AVComplexDiagMatrix@@AEBV1@AEBVDiagMatrix@@@Z"]
    pub fn product(arg1: *const ComplexDiagMatrix, arg2: *const DiagMatrix)
     -> ComplexDiagMatrix;
}
extern "C" {
    #[link_name =
          "?product@@YA?AVComplexDiagMatrix@@AEBVDiagMatrix@@AEBV1@@Z"]
    pub fn product1(arg1: *const DiagMatrix, arg2: *const ComplexDiagMatrix)
     -> ComplexDiagMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolMatrix@@AEBU?$complex@N@std@@AEBVMatrix@@@Z"]
    pub fn mx_el_lt64(arg1: *const Complex, arg2: *const Matrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolMatrix@@AEBU?$complex@N@std@@AEBVMatrix@@@Z"]
    pub fn mx_el_le64(arg1: *const Complex, arg2: *const Matrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolMatrix@@AEBU?$complex@N@std@@AEBVMatrix@@@Z"]
    pub fn mx_el_ge64(arg1: *const Complex, arg2: *const Matrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolMatrix@@AEBU?$complex@N@std@@AEBVMatrix@@@Z"]
    pub fn mx_el_gt64(arg1: *const Complex, arg2: *const Matrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolMatrix@@AEBU?$complex@N@std@@AEBVMatrix@@@Z"]
    pub fn mx_el_eq67(arg1: *const Complex, arg2: *const Matrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolMatrix@@AEBU?$complex@N@std@@AEBVMatrix@@@Z"]
    pub fn mx_el_ne67(arg1: *const Complex, arg2: *const Matrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolMatrix@@AEBU?$complex@N@std@@AEBVMatrix@@@Z"]
    pub fn mx_el_and69(arg1: *const Complex, arg2: *const Matrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolMatrix@@AEBU?$complex@N@std@@AEBVMatrix@@@Z"]
    pub fn mx_el_or69(arg1: *const Complex, arg2: *const Matrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBU?$complex@N@std@@AEBVNDArray@@@Z"]
    pub fn mx_el_lt65(arg1: *const Complex, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBU?$complex@N@std@@AEBVNDArray@@@Z"]
    pub fn mx_el_le65(arg1: *const Complex, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBU?$complex@N@std@@AEBVNDArray@@@Z"]
    pub fn mx_el_ge65(arg1: *const Complex, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBU?$complex@N@std@@AEBVNDArray@@@Z"]
    pub fn mx_el_gt65(arg1: *const Complex, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBU?$complex@N@std@@AEBVNDArray@@@Z"]
    pub fn mx_el_eq68(arg1: *const Complex, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBU?$complex@N@std@@AEBVNDArray@@@Z"]
    pub fn mx_el_ne68(arg1: *const Complex, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBU?$complex@N@std@@AEBVNDArray@@@Z"]
    pub fn mx_el_and70(arg1: *const Complex, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBU?$complex@N@std@@AEBVNDArray@@@Z"]
    pub fn mx_el_or70(arg1: *const Complex, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBU?$complex@N@std@@AEBVNDArray@@@Z"]
    pub fn mx_el_and_not28(arg1: *const Complex, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBU?$complex@N@std@@AEBVNDArray@@@Z"]
    pub fn mx_el_or_not28(arg1: *const Complex, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?product@@YA?AVComplexMatrix@@AEBV1@AEBVMatrix@@@Z"]
    pub fn product2(arg1: *const ComplexMatrix, arg2: *const Matrix)
     -> ComplexMatrix;
}
extern "C" {
    #[link_name = "?quotient@@YA?AVComplexMatrix@@AEBV1@AEBVMatrix@@@Z"]
    pub fn quotient(arg1: *const ComplexMatrix, arg2: *const Matrix)
     -> ComplexMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolMatrix@@AEBVComplexMatrix@@AEBVMatrix@@@Z"]
    pub fn mx_el_lt66(arg1: *const ComplexMatrix, arg2: *const Matrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolMatrix@@AEBVComplexMatrix@@AEBVMatrix@@@Z"]
    pub fn mx_el_le66(arg1: *const ComplexMatrix, arg2: *const Matrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolMatrix@@AEBVComplexMatrix@@AEBVMatrix@@@Z"]
    pub fn mx_el_ge66(arg1: *const ComplexMatrix, arg2: *const Matrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolMatrix@@AEBVComplexMatrix@@AEBVMatrix@@@Z"]
    pub fn mx_el_gt66(arg1: *const ComplexMatrix, arg2: *const Matrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolMatrix@@AEBVComplexMatrix@@AEBVMatrix@@@Z"]
    pub fn mx_el_eq69(arg1: *const ComplexMatrix, arg2: *const Matrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolMatrix@@AEBVComplexMatrix@@AEBVMatrix@@@Z"]
    pub fn mx_el_ne69(arg1: *const ComplexMatrix, arg2: *const Matrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolMatrix@@AEBVComplexMatrix@@AEBVMatrix@@@Z"]
    pub fn mx_el_and71(arg1: *const ComplexMatrix, arg2: *const Matrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolMatrix@@AEBVComplexMatrix@@AEBVMatrix@@@Z"]
    pub fn mx_el_or71(arg1: *const ComplexMatrix, arg2: *const Matrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name = "?product@@YA?AVComplexNDArray@@AEBV1@AEBVNDArray@@@Z"]
    pub fn product3(arg1: *const ComplexNDArray, arg2: *const NDArray)
     -> ComplexNDArray;
}
extern "C" {
    #[link_name = "?quotient@@YA?AVComplexNDArray@@AEBV1@AEBVNDArray@@@Z"]
    pub fn quotient1(arg1: *const ComplexNDArray, arg2: *const NDArray)
     -> ComplexNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBVComplexNDArray@@AEBVNDArray@@@Z"]
    pub fn mx_el_lt67(arg1: *const ComplexNDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBVComplexNDArray@@AEBVNDArray@@@Z"]
    pub fn mx_el_le67(arg1: *const ComplexNDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBVComplexNDArray@@AEBVNDArray@@@Z"]
    pub fn mx_el_ge67(arg1: *const ComplexNDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBVComplexNDArray@@AEBVNDArray@@@Z"]
    pub fn mx_el_gt67(arg1: *const ComplexNDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBVComplexNDArray@@AEBVNDArray@@@Z"]
    pub fn mx_el_eq70(arg1: *const ComplexNDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBVComplexNDArray@@AEBVNDArray@@@Z"]
    pub fn mx_el_ne70(arg1: *const ComplexNDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBVComplexNDArray@@AEBVNDArray@@@Z"]
    pub fn mx_el_and72(arg1: *const ComplexNDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBVComplexNDArray@@AEBVNDArray@@@Z"]
    pub fn mx_el_or72(arg1: *const ComplexNDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBVComplexNDArray@@AEBVNDArray@@@Z"]
    pub fn mx_el_and_not29(arg1: *const ComplexNDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBVComplexNDArray@@AEBVNDArray@@@Z"]
    pub fn mx_el_or_not29(arg1: *const ComplexNDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBVComplexNDArray@@AEBVNDArray@@@Z"]
    pub fn mx_el_not_and28(arg1: *const ComplexNDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBVComplexNDArray@@AEBVNDArray@@@Z"]
    pub fn mx_el_not_or28(arg1: *const ComplexNDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_lt@@YA?AVboolMatrix@@AEBVComplexMatrix@@AEBN@Z"]
    pub fn mx_el_lt68(arg1: *const ComplexMatrix, arg2: *const f64)
     -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_le@@YA?AVboolMatrix@@AEBVComplexMatrix@@AEBN@Z"]
    pub fn mx_el_le68(arg1: *const ComplexMatrix, arg2: *const f64)
     -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_ge@@YA?AVboolMatrix@@AEBVComplexMatrix@@AEBN@Z"]
    pub fn mx_el_ge68(arg1: *const ComplexMatrix, arg2: *const f64)
     -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_gt@@YA?AVboolMatrix@@AEBVComplexMatrix@@AEBN@Z"]
    pub fn mx_el_gt68(arg1: *const ComplexMatrix, arg2: *const f64)
     -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_eq@@YA?AVboolMatrix@@AEBVComplexMatrix@@AEBN@Z"]
    pub fn mx_el_eq71(arg1: *const ComplexMatrix, arg2: *const f64)
     -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_ne@@YA?AVboolMatrix@@AEBVComplexMatrix@@AEBN@Z"]
    pub fn mx_el_ne71(arg1: *const ComplexMatrix, arg2: *const f64)
     -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_and@@YA?AVboolMatrix@@AEBVComplexMatrix@@AEBN@Z"]
    pub fn mx_el_and73(arg1: *const ComplexMatrix, arg2: *const f64)
     -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_or@@YA?AVboolMatrix@@AEBVComplexMatrix@@AEBN@Z"]
    pub fn mx_el_or73(arg1: *const ComplexMatrix, arg2: *const f64)
     -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_lt@@YA?AVboolNDArray@@AEBVComplexNDArray@@AEBN@Z"]
    pub fn mx_el_lt69(arg1: *const ComplexNDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_le@@YA?AVboolNDArray@@AEBVComplexNDArray@@AEBN@Z"]
    pub fn mx_el_le69(arg1: *const ComplexNDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_ge@@YA?AVboolNDArray@@AEBVComplexNDArray@@AEBN@Z"]
    pub fn mx_el_ge69(arg1: *const ComplexNDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_gt@@YA?AVboolNDArray@@AEBVComplexNDArray@@AEBN@Z"]
    pub fn mx_el_gt69(arg1: *const ComplexNDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_eq@@YA?AVboolNDArray@@AEBVComplexNDArray@@AEBN@Z"]
    pub fn mx_el_eq72(arg1: *const ComplexNDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_ne@@YA?AVboolNDArray@@AEBVComplexNDArray@@AEBN@Z"]
    pub fn mx_el_ne72(arg1: *const ComplexNDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_and@@YA?AVboolNDArray@@AEBVComplexNDArray@@AEBN@Z"]
    pub fn mx_el_and74(arg1: *const ComplexNDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_or@@YA?AVboolNDArray@@AEBVComplexNDArray@@AEBN@Z"]
    pub fn mx_el_or74(arg1: *const ComplexNDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBVComplexNDArray@@AEBN@Z"]
    pub fn mx_el_not_and29(arg1: *const ComplexNDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBVComplexNDArray@@AEBN@Z"]
    pub fn mx_el_not_or29(arg1: *const ComplexNDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolMatrix@@AEBVMatrix@@AEBU?$complex@N@std@@@Z"]
    pub fn mx_el_lt70(arg1: *const Matrix, arg2: *const Complex)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolMatrix@@AEBVMatrix@@AEBU?$complex@N@std@@@Z"]
    pub fn mx_el_le70(arg1: *const Matrix, arg2: *const Complex)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolMatrix@@AEBVMatrix@@AEBU?$complex@N@std@@@Z"]
    pub fn mx_el_ge70(arg1: *const Matrix, arg2: *const Complex)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolMatrix@@AEBVMatrix@@AEBU?$complex@N@std@@@Z"]
    pub fn mx_el_gt70(arg1: *const Matrix, arg2: *const Complex)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolMatrix@@AEBVMatrix@@AEBU?$complex@N@std@@@Z"]
    pub fn mx_el_eq73(arg1: *const Matrix, arg2: *const Complex)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolMatrix@@AEBVMatrix@@AEBU?$complex@N@std@@@Z"]
    pub fn mx_el_ne73(arg1: *const Matrix, arg2: *const Complex)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolMatrix@@AEBVMatrix@@AEBU?$complex@N@std@@@Z"]
    pub fn mx_el_and75(arg1: *const Matrix, arg2: *const Complex)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolMatrix@@AEBVMatrix@@AEBU?$complex@N@std@@@Z"]
    pub fn mx_el_or75(arg1: *const Matrix, arg2: *const Complex)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBVNDArray@@AEBU?$complex@N@std@@@Z"]
    pub fn mx_el_lt71(arg1: *const NDArray, arg2: *const Complex)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBVNDArray@@AEBU?$complex@N@std@@@Z"]
    pub fn mx_el_le71(arg1: *const NDArray, arg2: *const Complex)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBVNDArray@@AEBU?$complex@N@std@@@Z"]
    pub fn mx_el_ge71(arg1: *const NDArray, arg2: *const Complex)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBVNDArray@@AEBU?$complex@N@std@@@Z"]
    pub fn mx_el_gt71(arg1: *const NDArray, arg2: *const Complex)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBVNDArray@@AEBU?$complex@N@std@@@Z"]
    pub fn mx_el_eq74(arg1: *const NDArray, arg2: *const Complex)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBVNDArray@@AEBU?$complex@N@std@@@Z"]
    pub fn mx_el_ne74(arg1: *const NDArray, arg2: *const Complex)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBVNDArray@@AEBU?$complex@N@std@@@Z"]
    pub fn mx_el_and76(arg1: *const NDArray, arg2: *const Complex)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBVNDArray@@AEBU?$complex@N@std@@@Z"]
    pub fn mx_el_or76(arg1: *const NDArray, arg2: *const Complex)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBVNDArray@@AEBU?$complex@N@std@@@Z"]
    pub fn mx_el_not_and30(arg1: *const NDArray, arg2: *const Complex)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBVNDArray@@AEBU?$complex@N@std@@@Z"]
    pub fn mx_el_not_or30(arg1: *const NDArray, arg2: *const Complex)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?product@@YA?AVComplexMatrix@@AEBVMatrix@@AEBV1@@Z"]
    pub fn product4(arg1: *const Matrix, arg2: *const ComplexMatrix)
     -> ComplexMatrix;
}
extern "C" {
    #[link_name = "?quotient@@YA?AVComplexMatrix@@AEBVMatrix@@AEBV1@@Z"]
    pub fn quotient2(arg1: *const Matrix, arg2: *const ComplexMatrix)
     -> ComplexMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolMatrix@@AEBVMatrix@@AEBVComplexMatrix@@@Z"]
    pub fn mx_el_lt72(arg1: *const Matrix, arg2: *const ComplexMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolMatrix@@AEBVMatrix@@AEBVComplexMatrix@@@Z"]
    pub fn mx_el_le72(arg1: *const Matrix, arg2: *const ComplexMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolMatrix@@AEBVMatrix@@AEBVComplexMatrix@@@Z"]
    pub fn mx_el_ge72(arg1: *const Matrix, arg2: *const ComplexMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolMatrix@@AEBVMatrix@@AEBVComplexMatrix@@@Z"]
    pub fn mx_el_gt72(arg1: *const Matrix, arg2: *const ComplexMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolMatrix@@AEBVMatrix@@AEBVComplexMatrix@@@Z"]
    pub fn mx_el_eq75(arg1: *const Matrix, arg2: *const ComplexMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolMatrix@@AEBVMatrix@@AEBVComplexMatrix@@@Z"]
    pub fn mx_el_ne75(arg1: *const Matrix, arg2: *const ComplexMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolMatrix@@AEBVMatrix@@AEBVComplexMatrix@@@Z"]
    pub fn mx_el_and77(arg1: *const Matrix, arg2: *const ComplexMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolMatrix@@AEBVMatrix@@AEBVComplexMatrix@@@Z"]
    pub fn mx_el_or77(arg1: *const Matrix, arg2: *const ComplexMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name = "?product@@YA?AVComplexNDArray@@AEBVNDArray@@AEBV1@@Z"]
    pub fn product5(arg1: *const NDArray, arg2: *const ComplexNDArray)
     -> ComplexNDArray;
}
extern "C" {
    #[link_name = "?quotient@@YA?AVComplexNDArray@@AEBVNDArray@@AEBV1@@Z"]
    pub fn quotient3(arg1: *const NDArray, arg2: *const ComplexNDArray)
     -> ComplexNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBVNDArray@@AEBVComplexNDArray@@@Z"]
    pub fn mx_el_lt73(arg1: *const NDArray, arg2: *const ComplexNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBVNDArray@@AEBVComplexNDArray@@@Z"]
    pub fn mx_el_le73(arg1: *const NDArray, arg2: *const ComplexNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBVNDArray@@AEBVComplexNDArray@@@Z"]
    pub fn mx_el_ge73(arg1: *const NDArray, arg2: *const ComplexNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBVNDArray@@AEBVComplexNDArray@@@Z"]
    pub fn mx_el_gt73(arg1: *const NDArray, arg2: *const ComplexNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBVNDArray@@AEBVComplexNDArray@@@Z"]
    pub fn mx_el_eq76(arg1: *const NDArray, arg2: *const ComplexNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBVNDArray@@AEBVComplexNDArray@@@Z"]
    pub fn mx_el_ne76(arg1: *const NDArray, arg2: *const ComplexNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBVNDArray@@AEBVComplexNDArray@@@Z"]
    pub fn mx_el_and78(arg1: *const NDArray, arg2: *const ComplexNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBVNDArray@@AEBVComplexNDArray@@@Z"]
    pub fn mx_el_or78(arg1: *const NDArray, arg2: *const ComplexNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBVNDArray@@AEBVComplexNDArray@@@Z"]
    pub fn mx_el_and_not30(arg1: *const NDArray, arg2: *const ComplexNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBVNDArray@@AEBVComplexNDArray@@@Z"]
    pub fn mx_el_or_not30(arg1: *const NDArray, arg2: *const ComplexNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBVNDArray@@AEBVComplexNDArray@@@Z"]
    pub fn mx_el_not_and31(arg1: *const NDArray, arg2: *const ComplexNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBVNDArray@@AEBVComplexNDArray@@@Z"]
    pub fn mx_el_not_or31(arg1: *const NDArray, arg2: *const ComplexNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_lt@@YA?AVboolMatrix@@AEBNAEBVComplexMatrix@@@Z"]
    pub fn mx_el_lt74(arg1: *const f64, arg2: *const ComplexMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_le@@YA?AVboolMatrix@@AEBNAEBVComplexMatrix@@@Z"]
    pub fn mx_el_le74(arg1: *const f64, arg2: *const ComplexMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_ge@@YA?AVboolMatrix@@AEBNAEBVComplexMatrix@@@Z"]
    pub fn mx_el_ge74(arg1: *const f64, arg2: *const ComplexMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_gt@@YA?AVboolMatrix@@AEBNAEBVComplexMatrix@@@Z"]
    pub fn mx_el_gt74(arg1: *const f64, arg2: *const ComplexMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_eq@@YA?AVboolMatrix@@AEBNAEBVComplexMatrix@@@Z"]
    pub fn mx_el_eq77(arg1: *const f64, arg2: *const ComplexMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_ne@@YA?AVboolMatrix@@AEBNAEBVComplexMatrix@@@Z"]
    pub fn mx_el_ne77(arg1: *const f64, arg2: *const ComplexMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_and@@YA?AVboolMatrix@@AEBNAEBVComplexMatrix@@@Z"]
    pub fn mx_el_and79(arg1: *const f64, arg2: *const ComplexMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_or@@YA?AVboolMatrix@@AEBNAEBVComplexMatrix@@@Z"]
    pub fn mx_el_or79(arg1: *const f64, arg2: *const ComplexMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name = "?mx_el_lt@@YA?AVboolNDArray@@AEBNAEBVComplexNDArray@@@Z"]
    pub fn mx_el_lt75(arg1: *const f64, arg2: *const ComplexNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_le@@YA?AVboolNDArray@@AEBNAEBVComplexNDArray@@@Z"]
    pub fn mx_el_le75(arg1: *const f64, arg2: *const ComplexNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_ge@@YA?AVboolNDArray@@AEBNAEBVComplexNDArray@@@Z"]
    pub fn mx_el_ge75(arg1: *const f64, arg2: *const ComplexNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_gt@@YA?AVboolNDArray@@AEBNAEBVComplexNDArray@@@Z"]
    pub fn mx_el_gt75(arg1: *const f64, arg2: *const ComplexNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_eq@@YA?AVboolNDArray@@AEBNAEBVComplexNDArray@@@Z"]
    pub fn mx_el_eq78(arg1: *const f64, arg2: *const ComplexNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_ne@@YA?AVboolNDArray@@AEBNAEBVComplexNDArray@@@Z"]
    pub fn mx_el_ne78(arg1: *const f64, arg2: *const ComplexNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_and@@YA?AVboolNDArray@@AEBNAEBVComplexNDArray@@@Z"]
    pub fn mx_el_and80(arg1: *const f64, arg2: *const ComplexNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name = "?mx_el_or@@YA?AVboolNDArray@@AEBNAEBVComplexNDArray@@@Z"]
    pub fn mx_el_or80(arg1: *const f64, arg2: *const ComplexNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBNAEBVComplexNDArray@@@Z"]
    pub fn mx_el_and_not31(arg1: *const f64, arg2: *const ComplexNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBNAEBVComplexNDArray@@@Z"]
    pub fn mx_el_or_not31(arg1: *const f64, arg2: *const ComplexNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?product@@YA?AVFloatComplexDiagMatrix@@AEBV1@AEBVFloatDiagMatrix@@@Z"]
    pub fn product6(arg1: *const FloatComplexDiagMatrix,
                    arg2: *const FloatDiagMatrix) -> FloatComplexDiagMatrix;
}
extern "C" {
    #[link_name =
          "?product@@YA?AVFloatComplexDiagMatrix@@AEBVFloatDiagMatrix@@AEBV1@@Z"]
    pub fn product7(arg1: *const FloatDiagMatrix,
                    arg2: *const FloatComplexDiagMatrix)
     -> FloatComplexDiagMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolMatrix@@AEBU?$complex@M@std@@AEBVFloatMatrix@@@Z"]
    pub fn mx_el_lt76(arg1: *const FloatComplex, arg2: *const FloatMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolMatrix@@AEBU?$complex@M@std@@AEBVFloatMatrix@@@Z"]
    pub fn mx_el_le76(arg1: *const FloatComplex, arg2: *const FloatMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolMatrix@@AEBU?$complex@M@std@@AEBVFloatMatrix@@@Z"]
    pub fn mx_el_ge76(arg1: *const FloatComplex, arg2: *const FloatMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolMatrix@@AEBU?$complex@M@std@@AEBVFloatMatrix@@@Z"]
    pub fn mx_el_gt76(arg1: *const FloatComplex, arg2: *const FloatMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolMatrix@@AEBU?$complex@M@std@@AEBVFloatMatrix@@@Z"]
    pub fn mx_el_eq79(arg1: *const FloatComplex, arg2: *const FloatMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolMatrix@@AEBU?$complex@M@std@@AEBVFloatMatrix@@@Z"]
    pub fn mx_el_ne79(arg1: *const FloatComplex, arg2: *const FloatMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolMatrix@@AEBU?$complex@M@std@@AEBVFloatMatrix@@@Z"]
    pub fn mx_el_and81(arg1: *const FloatComplex, arg2: *const FloatMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolMatrix@@AEBU?$complex@M@std@@AEBVFloatMatrix@@@Z"]
    pub fn mx_el_or81(arg1: *const FloatComplex, arg2: *const FloatMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBU?$complex@M@std@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_lt77(arg1: *const FloatComplex, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBU?$complex@M@std@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_le77(arg1: *const FloatComplex, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBU?$complex@M@std@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_ge77(arg1: *const FloatComplex, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBU?$complex@M@std@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_gt77(arg1: *const FloatComplex, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBU?$complex@M@std@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_eq80(arg1: *const FloatComplex, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBU?$complex@M@std@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_ne80(arg1: *const FloatComplex, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBU?$complex@M@std@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_and82(arg1: *const FloatComplex, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBU?$complex@M@std@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_or82(arg1: *const FloatComplex, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBU?$complex@M@std@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_and_not32(arg1: *const FloatComplex,
                           arg2: *const FloatNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBU?$complex@M@std@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_or_not32(arg1: *const FloatComplex,
                          arg2: *const FloatNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?product@@YA?AVFloatComplexMatrix@@AEBV1@AEBVFloatMatrix@@@Z"]
    pub fn product8(arg1: *const FloatComplexMatrix, arg2: *const FloatMatrix)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name =
          "?quotient@@YA?AVFloatComplexMatrix@@AEBV1@AEBVFloatMatrix@@@Z"]
    pub fn quotient4(arg1: *const FloatComplexMatrix,
                     arg2: *const FloatMatrix) -> FloatComplexMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolMatrix@@AEBVFloatComplexMatrix@@AEBVFloatMatrix@@@Z"]
    pub fn mx_el_lt78(arg1: *const FloatComplexMatrix,
                      arg2: *const FloatMatrix) -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolMatrix@@AEBVFloatComplexMatrix@@AEBVFloatMatrix@@@Z"]
    pub fn mx_el_le78(arg1: *const FloatComplexMatrix,
                      arg2: *const FloatMatrix) -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolMatrix@@AEBVFloatComplexMatrix@@AEBVFloatMatrix@@@Z"]
    pub fn mx_el_ge78(arg1: *const FloatComplexMatrix,
                      arg2: *const FloatMatrix) -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolMatrix@@AEBVFloatComplexMatrix@@AEBVFloatMatrix@@@Z"]
    pub fn mx_el_gt78(arg1: *const FloatComplexMatrix,
                      arg2: *const FloatMatrix) -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolMatrix@@AEBVFloatComplexMatrix@@AEBVFloatMatrix@@@Z"]
    pub fn mx_el_eq81(arg1: *const FloatComplexMatrix,
                      arg2: *const FloatMatrix) -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolMatrix@@AEBVFloatComplexMatrix@@AEBVFloatMatrix@@@Z"]
    pub fn mx_el_ne81(arg1: *const FloatComplexMatrix,
                      arg2: *const FloatMatrix) -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolMatrix@@AEBVFloatComplexMatrix@@AEBVFloatMatrix@@@Z"]
    pub fn mx_el_and83(arg1: *const FloatComplexMatrix,
                       arg2: *const FloatMatrix) -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolMatrix@@AEBVFloatComplexMatrix@@AEBVFloatMatrix@@@Z"]
    pub fn mx_el_or83(arg1: *const FloatComplexMatrix,
                      arg2: *const FloatMatrix) -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?product@@YA?AVFloatComplexNDArray@@AEBV1@AEBVFloatNDArray@@@Z"]
    pub fn product9(arg1: *const FloatComplexNDArray,
                    arg2: *const FloatNDArray) -> FloatComplexNDArray;
}
extern "C" {
    #[link_name =
          "?quotient@@YA?AVFloatComplexNDArray@@AEBV1@AEBVFloatNDArray@@@Z"]
    pub fn quotient5(arg1: *const FloatComplexNDArray,
                     arg2: *const FloatNDArray) -> FloatComplexNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBVFloatComplexNDArray@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_lt79(arg1: *const FloatComplexNDArray,
                      arg2: *const FloatNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBVFloatComplexNDArray@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_le79(arg1: *const FloatComplexNDArray,
                      arg2: *const FloatNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBVFloatComplexNDArray@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_ge79(arg1: *const FloatComplexNDArray,
                      arg2: *const FloatNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBVFloatComplexNDArray@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_gt79(arg1: *const FloatComplexNDArray,
                      arg2: *const FloatNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBVFloatComplexNDArray@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_eq82(arg1: *const FloatComplexNDArray,
                      arg2: *const FloatNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBVFloatComplexNDArray@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_ne82(arg1: *const FloatComplexNDArray,
                      arg2: *const FloatNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBVFloatComplexNDArray@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_and84(arg1: *const FloatComplexNDArray,
                       arg2: *const FloatNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBVFloatComplexNDArray@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_or84(arg1: *const FloatComplexNDArray,
                      arg2: *const FloatNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBVFloatComplexNDArray@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_and_not33(arg1: *const FloatComplexNDArray,
                           arg2: *const FloatNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBVFloatComplexNDArray@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_or_not33(arg1: *const FloatComplexNDArray,
                          arg2: *const FloatNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBVFloatComplexNDArray@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_not_and32(arg1: *const FloatComplexNDArray,
                           arg2: *const FloatNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBVFloatComplexNDArray@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_not_or32(arg1: *const FloatComplexNDArray,
                          arg2: *const FloatNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolMatrix@@AEBVFloatComplexMatrix@@AEBM@Z"]
    pub fn mx_el_lt80(arg1: *const FloatComplexMatrix, arg2: *const f32)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolMatrix@@AEBVFloatComplexMatrix@@AEBM@Z"]
    pub fn mx_el_le80(arg1: *const FloatComplexMatrix, arg2: *const f32)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolMatrix@@AEBVFloatComplexMatrix@@AEBM@Z"]
    pub fn mx_el_ge80(arg1: *const FloatComplexMatrix, arg2: *const f32)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolMatrix@@AEBVFloatComplexMatrix@@AEBM@Z"]
    pub fn mx_el_gt80(arg1: *const FloatComplexMatrix, arg2: *const f32)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolMatrix@@AEBVFloatComplexMatrix@@AEBM@Z"]
    pub fn mx_el_eq83(arg1: *const FloatComplexMatrix, arg2: *const f32)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolMatrix@@AEBVFloatComplexMatrix@@AEBM@Z"]
    pub fn mx_el_ne83(arg1: *const FloatComplexMatrix, arg2: *const f32)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolMatrix@@AEBVFloatComplexMatrix@@AEBM@Z"]
    pub fn mx_el_and85(arg1: *const FloatComplexMatrix, arg2: *const f32)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolMatrix@@AEBVFloatComplexMatrix@@AEBM@Z"]
    pub fn mx_el_or85(arg1: *const FloatComplexMatrix, arg2: *const f32)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBVFloatComplexNDArray@@AEBM@Z"]
    pub fn mx_el_lt81(arg1: *const FloatComplexNDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBVFloatComplexNDArray@@AEBM@Z"]
    pub fn mx_el_le81(arg1: *const FloatComplexNDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBVFloatComplexNDArray@@AEBM@Z"]
    pub fn mx_el_ge81(arg1: *const FloatComplexNDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBVFloatComplexNDArray@@AEBM@Z"]
    pub fn mx_el_gt81(arg1: *const FloatComplexNDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBVFloatComplexNDArray@@AEBM@Z"]
    pub fn mx_el_eq84(arg1: *const FloatComplexNDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBVFloatComplexNDArray@@AEBM@Z"]
    pub fn mx_el_ne84(arg1: *const FloatComplexNDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBVFloatComplexNDArray@@AEBM@Z"]
    pub fn mx_el_and86(arg1: *const FloatComplexNDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBVFloatComplexNDArray@@AEBM@Z"]
    pub fn mx_el_or86(arg1: *const FloatComplexNDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBVFloatComplexNDArray@@AEBM@Z"]
    pub fn mx_el_not_and33(arg1: *const FloatComplexNDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBVFloatComplexNDArray@@AEBM@Z"]
    pub fn mx_el_not_or33(arg1: *const FloatComplexNDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolMatrix@@AEBVFloatMatrix@@AEBU?$complex@M@std@@@Z"]
    pub fn mx_el_lt82(arg1: *const FloatMatrix, arg2: *const FloatComplex)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolMatrix@@AEBVFloatMatrix@@AEBU?$complex@M@std@@@Z"]
    pub fn mx_el_le82(arg1: *const FloatMatrix, arg2: *const FloatComplex)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolMatrix@@AEBVFloatMatrix@@AEBU?$complex@M@std@@@Z"]
    pub fn mx_el_ge82(arg1: *const FloatMatrix, arg2: *const FloatComplex)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolMatrix@@AEBVFloatMatrix@@AEBU?$complex@M@std@@@Z"]
    pub fn mx_el_gt82(arg1: *const FloatMatrix, arg2: *const FloatComplex)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolMatrix@@AEBVFloatMatrix@@AEBU?$complex@M@std@@@Z"]
    pub fn mx_el_eq85(arg1: *const FloatMatrix, arg2: *const FloatComplex)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolMatrix@@AEBVFloatMatrix@@AEBU?$complex@M@std@@@Z"]
    pub fn mx_el_ne85(arg1: *const FloatMatrix, arg2: *const FloatComplex)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolMatrix@@AEBVFloatMatrix@@AEBU?$complex@M@std@@@Z"]
    pub fn mx_el_and87(arg1: *const FloatMatrix, arg2: *const FloatComplex)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolMatrix@@AEBVFloatMatrix@@AEBU?$complex@M@std@@@Z"]
    pub fn mx_el_or87(arg1: *const FloatMatrix, arg2: *const FloatComplex)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBU?$complex@M@std@@@Z"]
    pub fn mx_el_lt83(arg1: *const FloatNDArray, arg2: *const FloatComplex)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBU?$complex@M@std@@@Z"]
    pub fn mx_el_le83(arg1: *const FloatNDArray, arg2: *const FloatComplex)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBU?$complex@M@std@@@Z"]
    pub fn mx_el_ge83(arg1: *const FloatNDArray, arg2: *const FloatComplex)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBU?$complex@M@std@@@Z"]
    pub fn mx_el_gt83(arg1: *const FloatNDArray, arg2: *const FloatComplex)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBU?$complex@M@std@@@Z"]
    pub fn mx_el_eq86(arg1: *const FloatNDArray, arg2: *const FloatComplex)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBU?$complex@M@std@@@Z"]
    pub fn mx_el_ne86(arg1: *const FloatNDArray, arg2: *const FloatComplex)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBU?$complex@M@std@@@Z"]
    pub fn mx_el_and88(arg1: *const FloatNDArray, arg2: *const FloatComplex)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBU?$complex@M@std@@@Z"]
    pub fn mx_el_or88(arg1: *const FloatNDArray, arg2: *const FloatComplex)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBU?$complex@M@std@@@Z"]
    pub fn mx_el_not_and34(arg1: *const FloatNDArray,
                           arg2: *const FloatComplex) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBU?$complex@M@std@@@Z"]
    pub fn mx_el_not_or34(arg1: *const FloatNDArray,
                          arg2: *const FloatComplex) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?product@@YA?AVFloatComplexMatrix@@AEBVFloatMatrix@@AEBV1@@Z"]
    pub fn product10(arg1: *const FloatMatrix,
                     arg2: *const FloatComplexMatrix) -> FloatComplexMatrix;
}
extern "C" {
    #[link_name =
          "?quotient@@YA?AVFloatComplexMatrix@@AEBVFloatMatrix@@AEBV1@@Z"]
    pub fn quotient6(arg1: *const FloatMatrix,
                     arg2: *const FloatComplexMatrix) -> FloatComplexMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolMatrix@@AEBVFloatMatrix@@AEBVFloatComplexMatrix@@@Z"]
    pub fn mx_el_lt84(arg1: *const FloatMatrix,
                      arg2: *const FloatComplexMatrix) -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolMatrix@@AEBVFloatMatrix@@AEBVFloatComplexMatrix@@@Z"]
    pub fn mx_el_le84(arg1: *const FloatMatrix,
                      arg2: *const FloatComplexMatrix) -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolMatrix@@AEBVFloatMatrix@@AEBVFloatComplexMatrix@@@Z"]
    pub fn mx_el_ge84(arg1: *const FloatMatrix,
                      arg2: *const FloatComplexMatrix) -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolMatrix@@AEBVFloatMatrix@@AEBVFloatComplexMatrix@@@Z"]
    pub fn mx_el_gt84(arg1: *const FloatMatrix,
                      arg2: *const FloatComplexMatrix) -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolMatrix@@AEBVFloatMatrix@@AEBVFloatComplexMatrix@@@Z"]
    pub fn mx_el_eq87(arg1: *const FloatMatrix,
                      arg2: *const FloatComplexMatrix) -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolMatrix@@AEBVFloatMatrix@@AEBVFloatComplexMatrix@@@Z"]
    pub fn mx_el_ne87(arg1: *const FloatMatrix,
                      arg2: *const FloatComplexMatrix) -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolMatrix@@AEBVFloatMatrix@@AEBVFloatComplexMatrix@@@Z"]
    pub fn mx_el_and89(arg1: *const FloatMatrix,
                       arg2: *const FloatComplexMatrix) -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolMatrix@@AEBVFloatMatrix@@AEBVFloatComplexMatrix@@@Z"]
    pub fn mx_el_or89(arg1: *const FloatMatrix,
                      arg2: *const FloatComplexMatrix) -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?product@@YA?AVFloatComplexNDArray@@AEBVFloatNDArray@@AEBV1@@Z"]
    pub fn product11(arg1: *const FloatNDArray,
                     arg2: *const FloatComplexNDArray) -> FloatComplexNDArray;
}
extern "C" {
    #[link_name =
          "?quotient@@YA?AVFloatComplexNDArray@@AEBVFloatNDArray@@AEBV1@@Z"]
    pub fn quotient7(arg1: *const FloatNDArray,
                     arg2: *const FloatComplexNDArray) -> FloatComplexNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBVFloatComplexNDArray@@@Z"]
    pub fn mx_el_lt85(arg1: *const FloatNDArray,
                      arg2: *const FloatComplexNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBVFloatComplexNDArray@@@Z"]
    pub fn mx_el_le85(arg1: *const FloatNDArray,
                      arg2: *const FloatComplexNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBVFloatComplexNDArray@@@Z"]
    pub fn mx_el_ge85(arg1: *const FloatNDArray,
                      arg2: *const FloatComplexNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBVFloatComplexNDArray@@@Z"]
    pub fn mx_el_gt85(arg1: *const FloatNDArray,
                      arg2: *const FloatComplexNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBVFloatComplexNDArray@@@Z"]
    pub fn mx_el_eq88(arg1: *const FloatNDArray,
                      arg2: *const FloatComplexNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBVFloatComplexNDArray@@@Z"]
    pub fn mx_el_ne88(arg1: *const FloatNDArray,
                      arg2: *const FloatComplexNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBVFloatComplexNDArray@@@Z"]
    pub fn mx_el_and90(arg1: *const FloatNDArray,
                       arg2: *const FloatComplexNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBVFloatComplexNDArray@@@Z"]
    pub fn mx_el_or90(arg1: *const FloatNDArray,
                      arg2: *const FloatComplexNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBVFloatComplexNDArray@@@Z"]
    pub fn mx_el_and_not34(arg1: *const FloatNDArray,
                           arg2: *const FloatComplexNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBVFloatComplexNDArray@@@Z"]
    pub fn mx_el_or_not34(arg1: *const FloatNDArray,
                          arg2: *const FloatComplexNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBVFloatComplexNDArray@@@Z"]
    pub fn mx_el_not_and35(arg1: *const FloatNDArray,
                           arg2: *const FloatComplexNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBVFloatComplexNDArray@@@Z"]
    pub fn mx_el_not_or35(arg1: *const FloatNDArray,
                          arg2: *const FloatComplexNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolMatrix@@AEBMAEBVFloatComplexMatrix@@@Z"]
    pub fn mx_el_lt86(arg1: *const f32, arg2: *const FloatComplexMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolMatrix@@AEBMAEBVFloatComplexMatrix@@@Z"]
    pub fn mx_el_le86(arg1: *const f32, arg2: *const FloatComplexMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolMatrix@@AEBMAEBVFloatComplexMatrix@@@Z"]
    pub fn mx_el_ge86(arg1: *const f32, arg2: *const FloatComplexMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolMatrix@@AEBMAEBVFloatComplexMatrix@@@Z"]
    pub fn mx_el_gt86(arg1: *const f32, arg2: *const FloatComplexMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolMatrix@@AEBMAEBVFloatComplexMatrix@@@Z"]
    pub fn mx_el_eq89(arg1: *const f32, arg2: *const FloatComplexMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolMatrix@@AEBMAEBVFloatComplexMatrix@@@Z"]
    pub fn mx_el_ne89(arg1: *const f32, arg2: *const FloatComplexMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolMatrix@@AEBMAEBVFloatComplexMatrix@@@Z"]
    pub fn mx_el_and91(arg1: *const f32, arg2: *const FloatComplexMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolMatrix@@AEBMAEBVFloatComplexMatrix@@@Z"]
    pub fn mx_el_or91(arg1: *const f32, arg2: *const FloatComplexMatrix)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBMAEBVFloatComplexNDArray@@@Z"]
    pub fn mx_el_lt87(arg1: *const f32, arg2: *const FloatComplexNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBMAEBVFloatComplexNDArray@@@Z"]
    pub fn mx_el_le87(arg1: *const f32, arg2: *const FloatComplexNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBMAEBVFloatComplexNDArray@@@Z"]
    pub fn mx_el_ge87(arg1: *const f32, arg2: *const FloatComplexNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBMAEBVFloatComplexNDArray@@@Z"]
    pub fn mx_el_gt87(arg1: *const f32, arg2: *const FloatComplexNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBMAEBVFloatComplexNDArray@@@Z"]
    pub fn mx_el_eq90(arg1: *const f32, arg2: *const FloatComplexNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBMAEBVFloatComplexNDArray@@@Z"]
    pub fn mx_el_ne90(arg1: *const f32, arg2: *const FloatComplexNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBMAEBVFloatComplexNDArray@@@Z"]
    pub fn mx_el_and92(arg1: *const f32, arg2: *const FloatComplexNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBMAEBVFloatComplexNDArray@@@Z"]
    pub fn mx_el_or92(arg1: *const f32, arg2: *const FloatComplexNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBMAEBVFloatComplexNDArray@@@Z"]
    pub fn mx_el_and_not35(arg1: *const f32, arg2: *const FloatComplexNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBMAEBVFloatComplexNDArray@@@Z"]
    pub fn mx_el_or_not35(arg1: *const f32, arg2: *const FloatComplexNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_lt88(arg1: *const f64, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_le88(arg1: *const f64, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_ge88(arg1: *const f64, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_gt88(arg1: *const f64, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_eq91(arg1: *const f64, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_ne91(arg1: *const f64, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_and93(arg1: *const f64, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_or93(arg1: *const f64, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_and_not36(arg1: *const f64, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_or_not36(arg1: *const f64, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBN@Z"]
    pub fn mx_el_lt89(arg1: *const int8NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBN@Z"]
    pub fn mx_el_le89(arg1: *const int8NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBN@Z"]
    pub fn mx_el_ge89(arg1: *const int8NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBN@Z"]
    pub fn mx_el_gt89(arg1: *const int8NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBN@Z"]
    pub fn mx_el_eq92(arg1: *const int8NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBN@Z"]
    pub fn mx_el_ne92(arg1: *const int8NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBN@Z"]
    pub fn mx_el_and94(arg1: *const int8NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBN@Z"]
    pub fn mx_el_or94(arg1: *const int8NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBN@Z"]
    pub fn mx_el_not_and36(arg1: *const int8NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBN@Z"]
    pub fn mx_el_not_or36(arg1: *const int8NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_lt90(arg1: *const f64, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_le90(arg1: *const f64, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_ge90(arg1: *const f64, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_gt90(arg1: *const f64, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_eq93(arg1: *const f64, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_ne93(arg1: *const f64, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_and95(arg1: *const f64, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_or95(arg1: *const f64, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_and_not37(arg1: *const f64, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_or_not37(arg1: *const f64, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBN@Z"]
    pub fn mx_el_lt91(arg1: *const uint8NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBN@Z"]
    pub fn mx_el_le91(arg1: *const uint8NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBN@Z"]
    pub fn mx_el_ge91(arg1: *const uint8NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBN@Z"]
    pub fn mx_el_gt91(arg1: *const uint8NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBN@Z"]
    pub fn mx_el_eq94(arg1: *const uint8NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBN@Z"]
    pub fn mx_el_ne94(arg1: *const uint8NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBN@Z"]
    pub fn mx_el_and96(arg1: *const uint8NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBN@Z"]
    pub fn mx_el_or96(arg1: *const uint8NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBN@Z"]
    pub fn mx_el_not_and37(arg1: *const uint8NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBN@Z"]
    pub fn mx_el_not_or37(arg1: *const uint8NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_lt92(arg1: *const f64, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_le92(arg1: *const f64, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_ge92(arg1: *const f64, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_gt92(arg1: *const f64, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_eq95(arg1: *const f64, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_ne95(arg1: *const f64, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_and97(arg1: *const f64, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_or97(arg1: *const f64, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_and_not38(arg1: *const f64, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_or_not38(arg1: *const f64, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBN@Z"]
    pub fn mx_el_lt93(arg1: *const int16NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBN@Z"]
    pub fn mx_el_le93(arg1: *const int16NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBN@Z"]
    pub fn mx_el_ge93(arg1: *const int16NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBN@Z"]
    pub fn mx_el_gt93(arg1: *const int16NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBN@Z"]
    pub fn mx_el_eq96(arg1: *const int16NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBN@Z"]
    pub fn mx_el_ne96(arg1: *const int16NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBN@Z"]
    pub fn mx_el_and98(arg1: *const int16NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBN@Z"]
    pub fn mx_el_or98(arg1: *const int16NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBN@Z"]
    pub fn mx_el_not_and38(arg1: *const int16NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBN@Z"]
    pub fn mx_el_not_or38(arg1: *const int16NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_lt94(arg1: *const f64, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_le94(arg1: *const f64, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_ge94(arg1: *const f64, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_gt94(arg1: *const f64, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_eq97(arg1: *const f64, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_ne97(arg1: *const f64, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_and99(arg1: *const f64, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_or99(arg1: *const f64, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_and_not39(arg1: *const f64, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_or_not39(arg1: *const f64, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBN@Z"]
    pub fn mx_el_lt95(arg1: *const uint16NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBN@Z"]
    pub fn mx_el_le95(arg1: *const uint16NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBN@Z"]
    pub fn mx_el_ge95(arg1: *const uint16NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBN@Z"]
    pub fn mx_el_gt95(arg1: *const uint16NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBN@Z"]
    pub fn mx_el_eq98(arg1: *const uint16NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBN@Z"]
    pub fn mx_el_ne98(arg1: *const uint16NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBN@Z"]
    pub fn mx_el_and100(arg1: *const uint16NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBN@Z"]
    pub fn mx_el_or100(arg1: *const uint16NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBN@Z"]
    pub fn mx_el_not_and39(arg1: *const uint16NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBN@Z"]
    pub fn mx_el_not_or39(arg1: *const uint16NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_lt96(arg1: *const f64, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_le96(arg1: *const f64, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_ge96(arg1: *const f64, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_gt96(arg1: *const f64, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_eq99(arg1: *const f64, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_ne99(arg1: *const f64, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_and101(arg1: *const f64, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_or101(arg1: *const f64, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_and_not40(arg1: *const f64, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_or_not40(arg1: *const f64, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBN@Z"]
    pub fn mx_el_lt97(arg1: *const int32NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBN@Z"]
    pub fn mx_el_le97(arg1: *const int32NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBN@Z"]
    pub fn mx_el_ge97(arg1: *const int32NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBN@Z"]
    pub fn mx_el_gt97(arg1: *const int32NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBN@Z"]
    pub fn mx_el_eq100(arg1: *const int32NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBN@Z"]
    pub fn mx_el_ne100(arg1: *const int32NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBN@Z"]
    pub fn mx_el_and102(arg1: *const int32NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBN@Z"]
    pub fn mx_el_or102(arg1: *const int32NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBN@Z"]
    pub fn mx_el_not_and40(arg1: *const int32NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBN@Z"]
    pub fn mx_el_not_or40(arg1: *const int32NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_lt98(arg1: *const f64, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_le98(arg1: *const f64, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_ge98(arg1: *const f64, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_gt98(arg1: *const f64, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_eq101(arg1: *const f64, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_ne101(arg1: *const f64, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_and103(arg1: *const f64, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_or103(arg1: *const f64, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_and_not41(arg1: *const f64, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_or_not41(arg1: *const f64, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBN@Z"]
    pub fn mx_el_lt99(arg1: *const uint32NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBN@Z"]
    pub fn mx_el_le99(arg1: *const uint32NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBN@Z"]
    pub fn mx_el_ge99(arg1: *const uint32NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBN@Z"]
    pub fn mx_el_gt99(arg1: *const uint32NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBN@Z"]
    pub fn mx_el_eq102(arg1: *const uint32NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBN@Z"]
    pub fn mx_el_ne102(arg1: *const uint32NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBN@Z"]
    pub fn mx_el_and104(arg1: *const uint32NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBN@Z"]
    pub fn mx_el_or104(arg1: *const uint32NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBN@Z"]
    pub fn mx_el_not_and41(arg1: *const uint32NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBN@Z"]
    pub fn mx_el_not_or41(arg1: *const uint32NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_lt100(arg1: *const f64, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_le100(arg1: *const f64, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_ge100(arg1: *const f64, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_gt100(arg1: *const f64, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_eq103(arg1: *const f64, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_ne103(arg1: *const f64, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_and105(arg1: *const f64, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_or105(arg1: *const f64, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_and_not42(arg1: *const f64, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_or_not42(arg1: *const f64, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBN@Z"]
    pub fn mx_el_lt101(arg1: *const int64NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBN@Z"]
    pub fn mx_el_le101(arg1: *const int64NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBN@Z"]
    pub fn mx_el_ge101(arg1: *const int64NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBN@Z"]
    pub fn mx_el_gt101(arg1: *const int64NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBN@Z"]
    pub fn mx_el_eq104(arg1: *const int64NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBN@Z"]
    pub fn mx_el_ne104(arg1: *const int64NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBN@Z"]
    pub fn mx_el_and106(arg1: *const int64NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBN@Z"]
    pub fn mx_el_or106(arg1: *const int64NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBN@Z"]
    pub fn mx_el_not_and42(arg1: *const int64NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBN@Z"]
    pub fn mx_el_not_or42(arg1: *const int64NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_lt102(arg1: *const f64, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_le102(arg1: *const f64, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_ge102(arg1: *const f64, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_gt102(arg1: *const f64, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_eq105(arg1: *const f64, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_ne105(arg1: *const f64, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_and107(arg1: *const f64, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_or107(arg1: *const f64, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_and_not43(arg1: *const f64, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBNAEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_or_not43(arg1: *const f64, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBN@Z"]
    pub fn mx_el_lt103(arg1: *const uint64NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBN@Z"]
    pub fn mx_el_le103(arg1: *const uint64NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBN@Z"]
    pub fn mx_el_ge103(arg1: *const uint64NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBN@Z"]
    pub fn mx_el_gt103(arg1: *const uint64NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBN@Z"]
    pub fn mx_el_eq106(arg1: *const uint64NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBN@Z"]
    pub fn mx_el_ne106(arg1: *const uint64NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBN@Z"]
    pub fn mx_el_and108(arg1: *const uint64NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBN@Z"]
    pub fn mx_el_or108(arg1: *const uint64NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBN@Z"]
    pub fn mx_el_not_and43(arg1: *const uint64NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBN@Z"]
    pub fn mx_el_not_or43(arg1: *const uint64NDArray, arg2: *const f64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_lt104(arg1: *const f32, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_le104(arg1: *const f32, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_ge104(arg1: *const f32, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_gt104(arg1: *const f32, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_eq107(arg1: *const f32, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_ne107(arg1: *const f32, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_and109(arg1: *const f32, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_or109(arg1: *const f32, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_and_not44(arg1: *const f32, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_or_not44(arg1: *const f32, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBM@Z"]
    pub fn mx_el_lt105(arg1: *const int8NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBM@Z"]
    pub fn mx_el_le105(arg1: *const int8NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBM@Z"]
    pub fn mx_el_ge105(arg1: *const int8NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBM@Z"]
    pub fn mx_el_gt105(arg1: *const int8NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBM@Z"]
    pub fn mx_el_eq108(arg1: *const int8NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBM@Z"]
    pub fn mx_el_ne108(arg1: *const int8NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBM@Z"]
    pub fn mx_el_and110(arg1: *const int8NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBM@Z"]
    pub fn mx_el_or110(arg1: *const int8NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBM@Z"]
    pub fn mx_el_not_and44(arg1: *const int8NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBM@Z"]
    pub fn mx_el_not_or44(arg1: *const int8NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_lt106(arg1: *const f32, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_le106(arg1: *const f32, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_ge106(arg1: *const f32, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_gt106(arg1: *const f32, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_eq109(arg1: *const f32, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_ne109(arg1: *const f32, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_and111(arg1: *const f32, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_or111(arg1: *const f32, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_and_not45(arg1: *const f32, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_or_not45(arg1: *const f32, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBM@Z"]
    pub fn mx_el_lt107(arg1: *const uint8NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBM@Z"]
    pub fn mx_el_le107(arg1: *const uint8NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBM@Z"]
    pub fn mx_el_ge107(arg1: *const uint8NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBM@Z"]
    pub fn mx_el_gt107(arg1: *const uint8NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBM@Z"]
    pub fn mx_el_eq110(arg1: *const uint8NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBM@Z"]
    pub fn mx_el_ne110(arg1: *const uint8NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBM@Z"]
    pub fn mx_el_and112(arg1: *const uint8NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBM@Z"]
    pub fn mx_el_or112(arg1: *const uint8NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBM@Z"]
    pub fn mx_el_not_and45(arg1: *const uint8NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBM@Z"]
    pub fn mx_el_not_or45(arg1: *const uint8NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_lt108(arg1: *const f32, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_le108(arg1: *const f32, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_ge108(arg1: *const f32, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_gt108(arg1: *const f32, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_eq111(arg1: *const f32, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_ne111(arg1: *const f32, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_and113(arg1: *const f32, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_or113(arg1: *const f32, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_and_not46(arg1: *const f32, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_or_not46(arg1: *const f32, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBM@Z"]
    pub fn mx_el_lt109(arg1: *const int16NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBM@Z"]
    pub fn mx_el_le109(arg1: *const int16NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBM@Z"]
    pub fn mx_el_ge109(arg1: *const int16NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBM@Z"]
    pub fn mx_el_gt109(arg1: *const int16NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBM@Z"]
    pub fn mx_el_eq112(arg1: *const int16NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBM@Z"]
    pub fn mx_el_ne112(arg1: *const int16NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBM@Z"]
    pub fn mx_el_and114(arg1: *const int16NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBM@Z"]
    pub fn mx_el_or114(arg1: *const int16NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBM@Z"]
    pub fn mx_el_not_and46(arg1: *const int16NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBM@Z"]
    pub fn mx_el_not_or46(arg1: *const int16NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_lt110(arg1: *const f32, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_le110(arg1: *const f32, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_ge110(arg1: *const f32, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_gt110(arg1: *const f32, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_eq113(arg1: *const f32, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_ne113(arg1: *const f32, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_and115(arg1: *const f32, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_or115(arg1: *const f32, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_and_not47(arg1: *const f32, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_or_not47(arg1: *const f32, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBM@Z"]
    pub fn mx_el_lt111(arg1: *const uint16NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBM@Z"]
    pub fn mx_el_le111(arg1: *const uint16NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBM@Z"]
    pub fn mx_el_ge111(arg1: *const uint16NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBM@Z"]
    pub fn mx_el_gt111(arg1: *const uint16NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBM@Z"]
    pub fn mx_el_eq114(arg1: *const uint16NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBM@Z"]
    pub fn mx_el_ne114(arg1: *const uint16NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBM@Z"]
    pub fn mx_el_and116(arg1: *const uint16NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBM@Z"]
    pub fn mx_el_or116(arg1: *const uint16NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBM@Z"]
    pub fn mx_el_not_and47(arg1: *const uint16NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBM@Z"]
    pub fn mx_el_not_or47(arg1: *const uint16NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_lt112(arg1: *const f32, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_le112(arg1: *const f32, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_ge112(arg1: *const f32, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_gt112(arg1: *const f32, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_eq115(arg1: *const f32, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_ne115(arg1: *const f32, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_and117(arg1: *const f32, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_or117(arg1: *const f32, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_and_not48(arg1: *const f32, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_or_not48(arg1: *const f32, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBM@Z"]
    pub fn mx_el_lt113(arg1: *const int32NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBM@Z"]
    pub fn mx_el_le113(arg1: *const int32NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBM@Z"]
    pub fn mx_el_ge113(arg1: *const int32NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBM@Z"]
    pub fn mx_el_gt113(arg1: *const int32NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBM@Z"]
    pub fn mx_el_eq116(arg1: *const int32NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBM@Z"]
    pub fn mx_el_ne116(arg1: *const int32NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBM@Z"]
    pub fn mx_el_and118(arg1: *const int32NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBM@Z"]
    pub fn mx_el_or118(arg1: *const int32NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBM@Z"]
    pub fn mx_el_not_and48(arg1: *const int32NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBM@Z"]
    pub fn mx_el_not_or48(arg1: *const int32NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_lt114(arg1: *const f32, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_le114(arg1: *const f32, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_ge114(arg1: *const f32, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_gt114(arg1: *const f32, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_eq117(arg1: *const f32, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_ne117(arg1: *const f32, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_and119(arg1: *const f32, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_or119(arg1: *const f32, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_and_not49(arg1: *const f32, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_or_not49(arg1: *const f32, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBM@Z"]
    pub fn mx_el_lt115(arg1: *const uint32NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBM@Z"]
    pub fn mx_el_le115(arg1: *const uint32NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBM@Z"]
    pub fn mx_el_ge115(arg1: *const uint32NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBM@Z"]
    pub fn mx_el_gt115(arg1: *const uint32NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBM@Z"]
    pub fn mx_el_eq118(arg1: *const uint32NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBM@Z"]
    pub fn mx_el_ne118(arg1: *const uint32NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBM@Z"]
    pub fn mx_el_and120(arg1: *const uint32NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBM@Z"]
    pub fn mx_el_or120(arg1: *const uint32NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBM@Z"]
    pub fn mx_el_not_and49(arg1: *const uint32NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBM@Z"]
    pub fn mx_el_not_or49(arg1: *const uint32NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_lt116(arg1: *const f32, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_le116(arg1: *const f32, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_ge116(arg1: *const f32, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_gt116(arg1: *const f32, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_eq119(arg1: *const f32, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_ne119(arg1: *const f32, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_and121(arg1: *const f32, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_or121(arg1: *const f32, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_and_not50(arg1: *const f32, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_or_not50(arg1: *const f32, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBM@Z"]
    pub fn mx_el_lt117(arg1: *const int64NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBM@Z"]
    pub fn mx_el_le117(arg1: *const int64NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBM@Z"]
    pub fn mx_el_ge117(arg1: *const int64NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBM@Z"]
    pub fn mx_el_gt117(arg1: *const int64NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBM@Z"]
    pub fn mx_el_eq120(arg1: *const int64NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBM@Z"]
    pub fn mx_el_ne120(arg1: *const int64NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBM@Z"]
    pub fn mx_el_and122(arg1: *const int64NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBM@Z"]
    pub fn mx_el_or122(arg1: *const int64NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBM@Z"]
    pub fn mx_el_not_and50(arg1: *const int64NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBM@Z"]
    pub fn mx_el_not_or50(arg1: *const int64NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_lt118(arg1: *const f32, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_le118(arg1: *const f32, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_ge118(arg1: *const f32, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_gt118(arg1: *const f32, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_eq121(arg1: *const f32, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_ne121(arg1: *const f32, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_and123(arg1: *const f32, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_or123(arg1: *const f32, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_and_not51(arg1: *const f32, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBMAEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_or_not51(arg1: *const f32, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBM@Z"]
    pub fn mx_el_lt119(arg1: *const uint64NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBM@Z"]
    pub fn mx_el_le119(arg1: *const uint64NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBM@Z"]
    pub fn mx_el_ge119(arg1: *const uint64NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBM@Z"]
    pub fn mx_el_gt119(arg1: *const uint64NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBM@Z"]
    pub fn mx_el_eq122(arg1: *const uint64NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBM@Z"]
    pub fn mx_el_ne122(arg1: *const uint64NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBM@Z"]
    pub fn mx_el_and124(arg1: *const uint64NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBM@Z"]
    pub fn mx_el_or124(arg1: *const uint64NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBM@Z"]
    pub fn mx_el_not_and51(arg1: *const uint64NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBM@Z"]
    pub fn mx_el_not_or51(arg1: *const uint64NDArray, arg2: *const f32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_lt120(arg1: *const NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_le120(arg1: *const NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_ge120(arg1: *const NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_gt120(arg1: *const NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_eq123(arg1: *const NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_ne123(arg1: *const NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_and125(arg1: *const NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_or125(arg1: *const NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_not_and52(arg1: *const NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_not_or52(arg1: *const NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBVNDArray@@@Z"]
    pub fn mx_el_lt121(arg1: *const octave_int8, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBVNDArray@@@Z"]
    pub fn mx_el_le121(arg1: *const octave_int8, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBVNDArray@@@Z"]
    pub fn mx_el_ge121(arg1: *const octave_int8, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBVNDArray@@@Z"]
    pub fn mx_el_gt121(arg1: *const octave_int8, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBVNDArray@@@Z"]
    pub fn mx_el_eq124(arg1: *const octave_int8, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBVNDArray@@@Z"]
    pub fn mx_el_ne124(arg1: *const octave_int8, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBVNDArray@@@Z"]
    pub fn mx_el_and126(arg1: *const octave_int8, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBVNDArray@@@Z"]
    pub fn mx_el_or126(arg1: *const octave_int8, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBVNDArray@@@Z"]
    pub fn mx_el_and_not52(arg1: *const octave_int8, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBVNDArray@@@Z"]
    pub fn mx_el_or_not52(arg1: *const octave_int8, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_lt122(arg1: *const NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_le122(arg1: *const NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_ge122(arg1: *const NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_gt122(arg1: *const NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_eq125(arg1: *const NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_ne125(arg1: *const NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_and127(arg1: *const NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_or127(arg1: *const NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_not_and53(arg1: *const NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_not_or53(arg1: *const NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBVNDArray@@@Z"]
    pub fn mx_el_lt123(arg1: *const octave_uint8, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBVNDArray@@@Z"]
    pub fn mx_el_le123(arg1: *const octave_uint8, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBVNDArray@@@Z"]
    pub fn mx_el_ge123(arg1: *const octave_uint8, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBVNDArray@@@Z"]
    pub fn mx_el_gt123(arg1: *const octave_uint8, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBVNDArray@@@Z"]
    pub fn mx_el_eq126(arg1: *const octave_uint8, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBVNDArray@@@Z"]
    pub fn mx_el_ne126(arg1: *const octave_uint8, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBVNDArray@@@Z"]
    pub fn mx_el_and128(arg1: *const octave_uint8, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBVNDArray@@@Z"]
    pub fn mx_el_or128(arg1: *const octave_uint8, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBVNDArray@@@Z"]
    pub fn mx_el_and_not53(arg1: *const octave_uint8, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBVNDArray@@@Z"]
    pub fn mx_el_or_not53(arg1: *const octave_uint8, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_lt124(arg1: *const NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_le124(arg1: *const NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_ge124(arg1: *const NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_gt124(arg1: *const NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_eq127(arg1: *const NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_ne127(arg1: *const NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_and129(arg1: *const NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_or129(arg1: *const NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_not_and54(arg1: *const NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_not_or54(arg1: *const NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBVNDArray@@@Z"]
    pub fn mx_el_lt125(arg1: *const octave_int16, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBVNDArray@@@Z"]
    pub fn mx_el_le125(arg1: *const octave_int16, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBVNDArray@@@Z"]
    pub fn mx_el_ge125(arg1: *const octave_int16, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBVNDArray@@@Z"]
    pub fn mx_el_gt125(arg1: *const octave_int16, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBVNDArray@@@Z"]
    pub fn mx_el_eq128(arg1: *const octave_int16, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBVNDArray@@@Z"]
    pub fn mx_el_ne128(arg1: *const octave_int16, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBVNDArray@@@Z"]
    pub fn mx_el_and130(arg1: *const octave_int16, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBVNDArray@@@Z"]
    pub fn mx_el_or130(arg1: *const octave_int16, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBVNDArray@@@Z"]
    pub fn mx_el_and_not54(arg1: *const octave_int16, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBVNDArray@@@Z"]
    pub fn mx_el_or_not54(arg1: *const octave_int16, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_lt126(arg1: *const NDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_le126(arg1: *const NDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_ge126(arg1: *const NDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_gt126(arg1: *const NDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_eq129(arg1: *const NDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_ne129(arg1: *const NDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_and131(arg1: *const NDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_or131(arg1: *const NDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_not_and55(arg1: *const NDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_not_or55(arg1: *const NDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBVNDArray@@@Z"]
    pub fn mx_el_lt127(arg1: *const octave_uint16, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBVNDArray@@@Z"]
    pub fn mx_el_le127(arg1: *const octave_uint16, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBVNDArray@@@Z"]
    pub fn mx_el_ge127(arg1: *const octave_uint16, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBVNDArray@@@Z"]
    pub fn mx_el_gt127(arg1: *const octave_uint16, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBVNDArray@@@Z"]
    pub fn mx_el_eq130(arg1: *const octave_uint16, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBVNDArray@@@Z"]
    pub fn mx_el_ne130(arg1: *const octave_uint16, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBVNDArray@@@Z"]
    pub fn mx_el_and132(arg1: *const octave_uint16, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBVNDArray@@@Z"]
    pub fn mx_el_or132(arg1: *const octave_uint16, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBVNDArray@@@Z"]
    pub fn mx_el_and_not55(arg1: *const octave_uint16, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBVNDArray@@@Z"]
    pub fn mx_el_or_not55(arg1: *const octave_uint16, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_lt128(arg1: *const NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_le128(arg1: *const NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_ge128(arg1: *const NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_gt128(arg1: *const NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_eq131(arg1: *const NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_ne131(arg1: *const NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_and133(arg1: *const NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_or133(arg1: *const NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_not_and56(arg1: *const NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_not_or56(arg1: *const NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBVNDArray@@@Z"]
    pub fn mx_el_lt129(arg1: *const octave_int32, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBVNDArray@@@Z"]
    pub fn mx_el_le129(arg1: *const octave_int32, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBVNDArray@@@Z"]
    pub fn mx_el_ge129(arg1: *const octave_int32, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBVNDArray@@@Z"]
    pub fn mx_el_gt129(arg1: *const octave_int32, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBVNDArray@@@Z"]
    pub fn mx_el_eq132(arg1: *const octave_int32, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBVNDArray@@@Z"]
    pub fn mx_el_ne132(arg1: *const octave_int32, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBVNDArray@@@Z"]
    pub fn mx_el_and134(arg1: *const octave_int32, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBVNDArray@@@Z"]
    pub fn mx_el_or134(arg1: *const octave_int32, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBVNDArray@@@Z"]
    pub fn mx_el_and_not56(arg1: *const octave_int32, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBVNDArray@@@Z"]
    pub fn mx_el_or_not56(arg1: *const octave_int32, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_lt130(arg1: *const NDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_le130(arg1: *const NDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_ge130(arg1: *const NDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_gt130(arg1: *const NDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_eq133(arg1: *const NDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_ne133(arg1: *const NDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_and135(arg1: *const NDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_or135(arg1: *const NDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_not_and57(arg1: *const NDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_not_or57(arg1: *const NDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBVNDArray@@@Z"]
    pub fn mx_el_lt131(arg1: *const octave_uint32, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBVNDArray@@@Z"]
    pub fn mx_el_le131(arg1: *const octave_uint32, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBVNDArray@@@Z"]
    pub fn mx_el_ge131(arg1: *const octave_uint32, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBVNDArray@@@Z"]
    pub fn mx_el_gt131(arg1: *const octave_uint32, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBVNDArray@@@Z"]
    pub fn mx_el_eq134(arg1: *const octave_uint32, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBVNDArray@@@Z"]
    pub fn mx_el_ne134(arg1: *const octave_uint32, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBVNDArray@@@Z"]
    pub fn mx_el_and136(arg1: *const octave_uint32, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBVNDArray@@@Z"]
    pub fn mx_el_or136(arg1: *const octave_uint32, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBVNDArray@@@Z"]
    pub fn mx_el_and_not57(arg1: *const octave_uint32, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBVNDArray@@@Z"]
    pub fn mx_el_or_not57(arg1: *const octave_uint32, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_lt132(arg1: *const NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_le132(arg1: *const NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_ge132(arg1: *const NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_gt132(arg1: *const NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_eq135(arg1: *const NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_ne135(arg1: *const NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_and137(arg1: *const NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_or137(arg1: *const NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_not_and58(arg1: *const NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_not_or58(arg1: *const NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBVNDArray@@@Z"]
    pub fn mx_el_lt133(arg1: *const octave_int64, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBVNDArray@@@Z"]
    pub fn mx_el_le133(arg1: *const octave_int64, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBVNDArray@@@Z"]
    pub fn mx_el_ge133(arg1: *const octave_int64, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBVNDArray@@@Z"]
    pub fn mx_el_gt133(arg1: *const octave_int64, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBVNDArray@@@Z"]
    pub fn mx_el_eq136(arg1: *const octave_int64, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBVNDArray@@@Z"]
    pub fn mx_el_ne136(arg1: *const octave_int64, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBVNDArray@@@Z"]
    pub fn mx_el_and138(arg1: *const octave_int64, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBVNDArray@@@Z"]
    pub fn mx_el_or138(arg1: *const octave_int64, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBVNDArray@@@Z"]
    pub fn mx_el_and_not58(arg1: *const octave_int64, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBVNDArray@@@Z"]
    pub fn mx_el_or_not58(arg1: *const octave_int64, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_lt134(arg1: *const NDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_le134(arg1: *const NDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_ge134(arg1: *const NDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_gt134(arg1: *const NDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_eq137(arg1: *const NDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_ne137(arg1: *const NDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_and139(arg1: *const NDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_or139(arg1: *const NDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_not_and59(arg1: *const NDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_not_or59(arg1: *const NDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBVNDArray@@@Z"]
    pub fn mx_el_lt135(arg1: *const octave_uint64, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBVNDArray@@@Z"]
    pub fn mx_el_le135(arg1: *const octave_uint64, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBVNDArray@@@Z"]
    pub fn mx_el_ge135(arg1: *const octave_uint64, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBVNDArray@@@Z"]
    pub fn mx_el_gt135(arg1: *const octave_uint64, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBVNDArray@@@Z"]
    pub fn mx_el_eq138(arg1: *const octave_uint64, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBVNDArray@@@Z"]
    pub fn mx_el_ne138(arg1: *const octave_uint64, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBVNDArray@@@Z"]
    pub fn mx_el_and140(arg1: *const octave_uint64, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBVNDArray@@@Z"]
    pub fn mx_el_or140(arg1: *const octave_uint64, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBVNDArray@@@Z"]
    pub fn mx_el_and_not59(arg1: *const octave_uint64, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBVNDArray@@@Z"]
    pub fn mx_el_or_not59(arg1: *const octave_uint64, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_lt136(arg1: *const FloatNDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_le136(arg1: *const FloatNDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_ge136(arg1: *const FloatNDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_gt136(arg1: *const FloatNDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_eq139(arg1: *const FloatNDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_ne139(arg1: *const FloatNDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_and141(arg1: *const FloatNDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_or141(arg1: *const FloatNDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_not_and60(arg1: *const FloatNDArray,
                           arg2: *const octave_int8) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_not_or60(arg1: *const FloatNDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_lt137(arg1: *const octave_int8, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_le137(arg1: *const octave_int8, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_ge137(arg1: *const octave_int8, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_gt137(arg1: *const octave_int8, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_eq140(arg1: *const octave_int8, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_ne140(arg1: *const octave_int8, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_and142(arg1: *const octave_int8, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_or142(arg1: *const octave_int8, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_and_not60(arg1: *const octave_int8,
                           arg2: *const FloatNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_or_not60(arg1: *const octave_int8, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_lt138(arg1: *const FloatNDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_le138(arg1: *const FloatNDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_ge138(arg1: *const FloatNDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_gt138(arg1: *const FloatNDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_eq141(arg1: *const FloatNDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_ne141(arg1: *const FloatNDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_and143(arg1: *const FloatNDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_or143(arg1: *const FloatNDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_not_and61(arg1: *const FloatNDArray,
                           arg2: *const octave_uint8) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_not_or61(arg1: *const FloatNDArray,
                          arg2: *const octave_uint8) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_lt139(arg1: *const octave_uint8, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_le139(arg1: *const octave_uint8, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_ge139(arg1: *const octave_uint8, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_gt139(arg1: *const octave_uint8, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_eq142(arg1: *const octave_uint8, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_ne142(arg1: *const octave_uint8, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_and144(arg1: *const octave_uint8, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_or144(arg1: *const octave_uint8, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_and_not61(arg1: *const octave_uint8,
                           arg2: *const FloatNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_or_not61(arg1: *const octave_uint8,
                          arg2: *const FloatNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_lt140(arg1: *const FloatNDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_le140(arg1: *const FloatNDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_ge140(arg1: *const FloatNDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_gt140(arg1: *const FloatNDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_eq143(arg1: *const FloatNDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_ne143(arg1: *const FloatNDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_and145(arg1: *const FloatNDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_or145(arg1: *const FloatNDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_not_and62(arg1: *const FloatNDArray,
                           arg2: *const octave_int16) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_not_or62(arg1: *const FloatNDArray,
                          arg2: *const octave_int16) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_lt141(arg1: *const octave_int16, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_le141(arg1: *const octave_int16, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_ge141(arg1: *const octave_int16, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_gt141(arg1: *const octave_int16, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_eq144(arg1: *const octave_int16, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_ne144(arg1: *const octave_int16, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_and146(arg1: *const octave_int16, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_or146(arg1: *const octave_int16, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_and_not62(arg1: *const octave_int16,
                           arg2: *const FloatNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_or_not62(arg1: *const octave_int16,
                          arg2: *const FloatNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_lt142(arg1: *const FloatNDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_le142(arg1: *const FloatNDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_ge142(arg1: *const FloatNDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_gt142(arg1: *const FloatNDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_eq145(arg1: *const FloatNDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_ne145(arg1: *const FloatNDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_and147(arg1: *const FloatNDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_or147(arg1: *const FloatNDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_not_and63(arg1: *const FloatNDArray,
                           arg2: *const octave_uint16) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_not_or63(arg1: *const FloatNDArray,
                          arg2: *const octave_uint16) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_lt143(arg1: *const octave_uint16, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_le143(arg1: *const octave_uint16, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_ge143(arg1: *const octave_uint16, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_gt143(arg1: *const octave_uint16, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_eq146(arg1: *const octave_uint16, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_ne146(arg1: *const octave_uint16, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_and148(arg1: *const octave_uint16, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_or148(arg1: *const octave_uint16, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_and_not63(arg1: *const octave_uint16,
                           arg2: *const FloatNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_or_not63(arg1: *const octave_uint16,
                          arg2: *const FloatNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_lt144(arg1: *const FloatNDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_le144(arg1: *const FloatNDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_ge144(arg1: *const FloatNDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_gt144(arg1: *const FloatNDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_eq147(arg1: *const FloatNDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_ne147(arg1: *const FloatNDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_and149(arg1: *const FloatNDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_or149(arg1: *const FloatNDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_not_and64(arg1: *const FloatNDArray,
                           arg2: *const octave_int32) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_not_or64(arg1: *const FloatNDArray,
                          arg2: *const octave_int32) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_lt145(arg1: *const octave_int32, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_le145(arg1: *const octave_int32, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_ge145(arg1: *const octave_int32, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_gt145(arg1: *const octave_int32, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_eq148(arg1: *const octave_int32, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_ne148(arg1: *const octave_int32, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_and150(arg1: *const octave_int32, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_or150(arg1: *const octave_int32, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_and_not64(arg1: *const octave_int32,
                           arg2: *const FloatNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_or_not64(arg1: *const octave_int32,
                          arg2: *const FloatNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_lt146(arg1: *const FloatNDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_le146(arg1: *const FloatNDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_ge146(arg1: *const FloatNDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_gt146(arg1: *const FloatNDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_eq149(arg1: *const FloatNDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_ne149(arg1: *const FloatNDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_and151(arg1: *const FloatNDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_or151(arg1: *const FloatNDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_not_and65(arg1: *const FloatNDArray,
                           arg2: *const octave_uint32) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_not_or65(arg1: *const FloatNDArray,
                          arg2: *const octave_uint32) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_lt147(arg1: *const octave_uint32, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_le147(arg1: *const octave_uint32, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_ge147(arg1: *const octave_uint32, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_gt147(arg1: *const octave_uint32, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_eq150(arg1: *const octave_uint32, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_ne150(arg1: *const octave_uint32, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_and152(arg1: *const octave_uint32, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_or152(arg1: *const octave_uint32, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_and_not65(arg1: *const octave_uint32,
                           arg2: *const FloatNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_or_not65(arg1: *const octave_uint32,
                          arg2: *const FloatNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_lt148(arg1: *const FloatNDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_le148(arg1: *const FloatNDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_ge148(arg1: *const FloatNDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_gt148(arg1: *const FloatNDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_eq151(arg1: *const FloatNDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_ne151(arg1: *const FloatNDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_and153(arg1: *const FloatNDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_or153(arg1: *const FloatNDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_not_and66(arg1: *const FloatNDArray,
                           arg2: *const octave_int64) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_not_or66(arg1: *const FloatNDArray,
                          arg2: *const octave_int64) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_lt149(arg1: *const octave_int64, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_le149(arg1: *const octave_int64, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_ge149(arg1: *const octave_int64, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_gt149(arg1: *const octave_int64, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_eq152(arg1: *const octave_int64, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_ne152(arg1: *const octave_int64, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_and154(arg1: *const octave_int64, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_or154(arg1: *const octave_int64, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_and_not66(arg1: *const octave_int64,
                           arg2: *const FloatNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_or_not66(arg1: *const octave_int64,
                          arg2: *const FloatNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_lt150(arg1: *const FloatNDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_le150(arg1: *const FloatNDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_ge150(arg1: *const FloatNDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_gt150(arg1: *const FloatNDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_eq153(arg1: *const FloatNDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_ne153(arg1: *const FloatNDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_and155(arg1: *const FloatNDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_or155(arg1: *const FloatNDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_not_and67(arg1: *const FloatNDArray,
                           arg2: *const octave_uint64) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_not_or67(arg1: *const FloatNDArray,
                          arg2: *const octave_uint64) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_lt151(arg1: *const octave_uint64, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_le151(arg1: *const octave_uint64, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_ge151(arg1: *const octave_uint64, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_gt151(arg1: *const octave_uint64, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_eq154(arg1: *const octave_uint64, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_ne154(arg1: *const octave_uint64, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_and156(arg1: *const octave_uint64, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_or156(arg1: *const octave_uint64, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_and_not67(arg1: *const octave_uint64,
                           arg2: *const FloatNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_or_not67(arg1: *const octave_uint64,
                          arg2: *const FloatNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?product@@YA?AV?$intNDArray@V?$octave_int@C@@@@AEBVNDArray@@AEBV1@@Z"]
    pub fn product12(arg1: *const NDArray, arg2: *const int8NDArray)
     -> int8NDArray;
}
extern "C" {
    #[link_name =
          "?quotient@@YA?AV?$intNDArray@V?$octave_int@C@@@@AEBVNDArray@@AEBV1@@Z"]
    pub fn quotient8(arg1: *const NDArray, arg2: *const int8NDArray)
     -> int8NDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_lt152(arg1: *const NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_le152(arg1: *const NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_ge152(arg1: *const NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_gt152(arg1: *const NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_eq155(arg1: *const NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_ne155(arg1: *const NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_and157(arg1: *const NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_or157(arg1: *const NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_and_not68(arg1: *const NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_or_not68(arg1: *const NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_not_and68(arg1: *const NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_not_or68(arg1: *const NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?product@@YA?AV?$intNDArray@V?$octave_int@C@@@@AEBV1@AEBVNDArray@@@Z"]
    pub fn product13(arg1: *const int8NDArray, arg2: *const NDArray)
     -> int8NDArray;
}
extern "C" {
    #[link_name =
          "?quotient@@YA?AV?$intNDArray@V?$octave_int@C@@@@AEBV1@AEBVNDArray@@@Z"]
    pub fn quotient9(arg1: *const int8NDArray, arg2: *const NDArray)
     -> int8NDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_lt153(arg1: *const int8NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_le153(arg1: *const int8NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_ge153(arg1: *const int8NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_gt153(arg1: *const int8NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_eq156(arg1: *const int8NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_ne156(arg1: *const int8NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_and158(arg1: *const int8NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_or158(arg1: *const int8NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_and_not69(arg1: *const int8NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_or_not69(arg1: *const int8NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_not_and69(arg1: *const int8NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_not_or69(arg1: *const int8NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?product@@YA?AV?$intNDArray@V?$octave_int@E@@@@AEBVNDArray@@AEBV1@@Z"]
    pub fn product14(arg1: *const NDArray, arg2: *const uint8NDArray)
     -> uint8NDArray;
}
extern "C" {
    #[link_name =
          "?quotient@@YA?AV?$intNDArray@V?$octave_int@E@@@@AEBVNDArray@@AEBV1@@Z"]
    pub fn quotient10(arg1: *const NDArray, arg2: *const uint8NDArray)
     -> uint8NDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_lt154(arg1: *const NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_le154(arg1: *const NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_ge154(arg1: *const NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_gt154(arg1: *const NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_eq157(arg1: *const NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_ne157(arg1: *const NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_and159(arg1: *const NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_or159(arg1: *const NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_and_not70(arg1: *const NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_or_not70(arg1: *const NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_not_and70(arg1: *const NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_not_or70(arg1: *const NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?product@@YA?AV?$intNDArray@V?$octave_int@E@@@@AEBV1@AEBVNDArray@@@Z"]
    pub fn product15(arg1: *const uint8NDArray, arg2: *const NDArray)
     -> uint8NDArray;
}
extern "C" {
    #[link_name =
          "?quotient@@YA?AV?$intNDArray@V?$octave_int@E@@@@AEBV1@AEBVNDArray@@@Z"]
    pub fn quotient11(arg1: *const uint8NDArray, arg2: *const NDArray)
     -> uint8NDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_lt155(arg1: *const uint8NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_le155(arg1: *const uint8NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_ge155(arg1: *const uint8NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_gt155(arg1: *const uint8NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_eq158(arg1: *const uint8NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_ne158(arg1: *const uint8NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_and160(arg1: *const uint8NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_or160(arg1: *const uint8NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_and_not71(arg1: *const uint8NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_or_not71(arg1: *const uint8NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_not_and71(arg1: *const uint8NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_not_or71(arg1: *const uint8NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?product@@YA?AV?$intNDArray@V?$octave_int@F@@@@AEBVNDArray@@AEBV1@@Z"]
    pub fn product16(arg1: *const NDArray, arg2: *const int16NDArray)
     -> int16NDArray;
}
extern "C" {
    #[link_name =
          "?quotient@@YA?AV?$intNDArray@V?$octave_int@F@@@@AEBVNDArray@@AEBV1@@Z"]
    pub fn quotient12(arg1: *const NDArray, arg2: *const int16NDArray)
     -> int16NDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_lt156(arg1: *const NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_le156(arg1: *const NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_ge156(arg1: *const NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_gt156(arg1: *const NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_eq159(arg1: *const NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_ne159(arg1: *const NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_and161(arg1: *const NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_or161(arg1: *const NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_and_not72(arg1: *const NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_or_not72(arg1: *const NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_not_and72(arg1: *const NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_not_or72(arg1: *const NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?product@@YA?AV?$intNDArray@V?$octave_int@F@@@@AEBV1@AEBVNDArray@@@Z"]
    pub fn product17(arg1: *const int16NDArray, arg2: *const NDArray)
     -> int16NDArray;
}
extern "C" {
    #[link_name =
          "?quotient@@YA?AV?$intNDArray@V?$octave_int@F@@@@AEBV1@AEBVNDArray@@@Z"]
    pub fn quotient13(arg1: *const int16NDArray, arg2: *const NDArray)
     -> int16NDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_lt157(arg1: *const int16NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_le157(arg1: *const int16NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_ge157(arg1: *const int16NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_gt157(arg1: *const int16NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_eq160(arg1: *const int16NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_ne160(arg1: *const int16NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_and162(arg1: *const int16NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_or162(arg1: *const int16NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_and_not73(arg1: *const int16NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_or_not73(arg1: *const int16NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_not_and73(arg1: *const int16NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_not_or73(arg1: *const int16NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?product@@YA?AV?$intNDArray@V?$octave_int@G@@@@AEBVNDArray@@AEBV1@@Z"]
    pub fn product18(arg1: *const NDArray, arg2: *const uint16NDArray)
     -> uint16NDArray;
}
extern "C" {
    #[link_name =
          "?quotient@@YA?AV?$intNDArray@V?$octave_int@G@@@@AEBVNDArray@@AEBV1@@Z"]
    pub fn quotient14(arg1: *const NDArray, arg2: *const uint16NDArray)
     -> uint16NDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_lt158(arg1: *const NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_le158(arg1: *const NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_ge158(arg1: *const NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_gt158(arg1: *const NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_eq161(arg1: *const NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_ne161(arg1: *const NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_and163(arg1: *const NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_or163(arg1: *const NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_and_not74(arg1: *const NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_or_not74(arg1: *const NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_not_and74(arg1: *const NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_not_or74(arg1: *const NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?product@@YA?AV?$intNDArray@V?$octave_int@G@@@@AEBV1@AEBVNDArray@@@Z"]
    pub fn product19(arg1: *const uint16NDArray, arg2: *const NDArray)
     -> uint16NDArray;
}
extern "C" {
    #[link_name =
          "?quotient@@YA?AV?$intNDArray@V?$octave_int@G@@@@AEBV1@AEBVNDArray@@@Z"]
    pub fn quotient15(arg1: *const uint16NDArray, arg2: *const NDArray)
     -> uint16NDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_lt159(arg1: *const uint16NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_le159(arg1: *const uint16NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_ge159(arg1: *const uint16NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_gt159(arg1: *const uint16NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_eq162(arg1: *const uint16NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_ne162(arg1: *const uint16NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_and164(arg1: *const uint16NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_or164(arg1: *const uint16NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_and_not75(arg1: *const uint16NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_or_not75(arg1: *const uint16NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_not_and75(arg1: *const uint16NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_not_or75(arg1: *const uint16NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?product@@YA?AV?$intNDArray@V?$octave_int@H@@@@AEBVNDArray@@AEBV1@@Z"]
    pub fn product20(arg1: *const NDArray, arg2: *const int32NDArray)
     -> int32NDArray;
}
extern "C" {
    #[link_name =
          "?quotient@@YA?AV?$intNDArray@V?$octave_int@H@@@@AEBVNDArray@@AEBV1@@Z"]
    pub fn quotient16(arg1: *const NDArray, arg2: *const int32NDArray)
     -> int32NDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_lt160(arg1: *const NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_le160(arg1: *const NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_ge160(arg1: *const NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_gt160(arg1: *const NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_eq163(arg1: *const NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_ne163(arg1: *const NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_and165(arg1: *const NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_or165(arg1: *const NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_and_not76(arg1: *const NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_or_not76(arg1: *const NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_not_and76(arg1: *const NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_not_or76(arg1: *const NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?product@@YA?AV?$intNDArray@V?$octave_int@H@@@@AEBV1@AEBVNDArray@@@Z"]
    pub fn product21(arg1: *const int32NDArray, arg2: *const NDArray)
     -> int32NDArray;
}
extern "C" {
    #[link_name =
          "?quotient@@YA?AV?$intNDArray@V?$octave_int@H@@@@AEBV1@AEBVNDArray@@@Z"]
    pub fn quotient17(arg1: *const int32NDArray, arg2: *const NDArray)
     -> int32NDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_lt161(arg1: *const int32NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_le161(arg1: *const int32NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_ge161(arg1: *const int32NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_gt161(arg1: *const int32NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_eq164(arg1: *const int32NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_ne164(arg1: *const int32NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_and166(arg1: *const int32NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_or166(arg1: *const int32NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_and_not77(arg1: *const int32NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_or_not77(arg1: *const int32NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_not_and77(arg1: *const int32NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_not_or77(arg1: *const int32NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?product@@YA?AV?$intNDArray@V?$octave_int@I@@@@AEBVNDArray@@AEBV1@@Z"]
    pub fn product22(arg1: *const NDArray, arg2: *const uint32NDArray)
     -> uint32NDArray;
}
extern "C" {
    #[link_name =
          "?quotient@@YA?AV?$intNDArray@V?$octave_int@I@@@@AEBVNDArray@@AEBV1@@Z"]
    pub fn quotient18(arg1: *const NDArray, arg2: *const uint32NDArray)
     -> uint32NDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_lt162(arg1: *const NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_le162(arg1: *const NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_ge162(arg1: *const NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_gt162(arg1: *const NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_eq165(arg1: *const NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_ne165(arg1: *const NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_and167(arg1: *const NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_or167(arg1: *const NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_and_not78(arg1: *const NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_or_not78(arg1: *const NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_not_and78(arg1: *const NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_not_or78(arg1: *const NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?product@@YA?AV?$intNDArray@V?$octave_int@I@@@@AEBV1@AEBVNDArray@@@Z"]
    pub fn product23(arg1: *const uint32NDArray, arg2: *const NDArray)
     -> uint32NDArray;
}
extern "C" {
    #[link_name =
          "?quotient@@YA?AV?$intNDArray@V?$octave_int@I@@@@AEBV1@AEBVNDArray@@@Z"]
    pub fn quotient19(arg1: *const uint32NDArray, arg2: *const NDArray)
     -> uint32NDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_lt163(arg1: *const uint32NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_le163(arg1: *const uint32NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_ge163(arg1: *const uint32NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_gt163(arg1: *const uint32NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_eq166(arg1: *const uint32NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_ne166(arg1: *const uint32NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_and168(arg1: *const uint32NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_or168(arg1: *const uint32NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_and_not79(arg1: *const uint32NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_or_not79(arg1: *const uint32NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_not_and79(arg1: *const uint32NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_not_or79(arg1: *const uint32NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?product@@YA?AV?$intNDArray@V?$octave_int@_J@@@@AEBVNDArray@@AEBV1@@Z"]
    pub fn product24(arg1: *const NDArray, arg2: *const int64NDArray)
     -> int64NDArray;
}
extern "C" {
    #[link_name =
          "?quotient@@YA?AV?$intNDArray@V?$octave_int@_J@@@@AEBVNDArray@@AEBV1@@Z"]
    pub fn quotient20(arg1: *const NDArray, arg2: *const int64NDArray)
     -> int64NDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_lt164(arg1: *const NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_le164(arg1: *const NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_ge164(arg1: *const NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_gt164(arg1: *const NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_eq167(arg1: *const NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_ne167(arg1: *const NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_and169(arg1: *const NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_or169(arg1: *const NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_and_not80(arg1: *const NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_or_not80(arg1: *const NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_not_and80(arg1: *const NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_not_or80(arg1: *const NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?product@@YA?AV?$intNDArray@V?$octave_int@_J@@@@AEBV1@AEBVNDArray@@@Z"]
    pub fn product25(arg1: *const int64NDArray, arg2: *const NDArray)
     -> int64NDArray;
}
extern "C" {
    #[link_name =
          "?quotient@@YA?AV?$intNDArray@V?$octave_int@_J@@@@AEBV1@AEBVNDArray@@@Z"]
    pub fn quotient21(arg1: *const int64NDArray, arg2: *const NDArray)
     -> int64NDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_lt165(arg1: *const int64NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_le165(arg1: *const int64NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_ge165(arg1: *const int64NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_gt165(arg1: *const int64NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_eq168(arg1: *const int64NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_ne168(arg1: *const int64NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_and170(arg1: *const int64NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_or170(arg1: *const int64NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_and_not81(arg1: *const int64NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_or_not81(arg1: *const int64NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_not_and81(arg1: *const int64NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_not_or81(arg1: *const int64NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?product@@YA?AV?$intNDArray@V?$octave_int@_K@@@@AEBVNDArray@@AEBV1@@Z"]
    pub fn product26(arg1: *const NDArray, arg2: *const uint64NDArray)
     -> uint64NDArray;
}
extern "C" {
    #[link_name =
          "?quotient@@YA?AV?$intNDArray@V?$octave_int@_K@@@@AEBVNDArray@@AEBV1@@Z"]
    pub fn quotient22(arg1: *const NDArray, arg2: *const uint64NDArray)
     -> uint64NDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_lt166(arg1: *const NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_le166(arg1: *const NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_ge166(arg1: *const NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_gt166(arg1: *const NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_eq169(arg1: *const NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_ne169(arg1: *const NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_and171(arg1: *const NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_or171(arg1: *const NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_and_not82(arg1: *const NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_or_not82(arg1: *const NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_not_and82(arg1: *const NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBVNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_not_or82(arg1: *const NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?product@@YA?AV?$intNDArray@V?$octave_int@_K@@@@AEBV1@AEBVNDArray@@@Z"]
    pub fn product27(arg1: *const uint64NDArray, arg2: *const NDArray)
     -> uint64NDArray;
}
extern "C" {
    #[link_name =
          "?quotient@@YA?AV?$intNDArray@V?$octave_int@_K@@@@AEBV1@AEBVNDArray@@@Z"]
    pub fn quotient23(arg1: *const uint64NDArray, arg2: *const NDArray)
     -> uint64NDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_lt167(arg1: *const uint64NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_le167(arg1: *const uint64NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_ge167(arg1: *const uint64NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_gt167(arg1: *const uint64NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_eq170(arg1: *const uint64NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_ne170(arg1: *const uint64NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_and172(arg1: *const uint64NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_or172(arg1: *const uint64NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_and_not83(arg1: *const uint64NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_or_not83(arg1: *const uint64NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_not_and83(arg1: *const uint64NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBVNDArray@@@Z"]
    pub fn mx_el_not_or83(arg1: *const uint64NDArray, arg2: *const NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?product@@YA?AV?$intNDArray@V?$octave_int@C@@@@AEBVFloatNDArray@@AEBV1@@Z"]
    pub fn product28(arg1: *const FloatNDArray, arg2: *const int8NDArray)
     -> int8NDArray;
}
extern "C" {
    #[link_name =
          "?quotient@@YA?AV?$intNDArray@V?$octave_int@C@@@@AEBVFloatNDArray@@AEBV1@@Z"]
    pub fn quotient24(arg1: *const FloatNDArray, arg2: *const int8NDArray)
     -> int8NDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_lt168(arg1: *const FloatNDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_le168(arg1: *const FloatNDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_ge168(arg1: *const FloatNDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_gt168(arg1: *const FloatNDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_eq171(arg1: *const FloatNDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_ne171(arg1: *const FloatNDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_and173(arg1: *const FloatNDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_or173(arg1: *const FloatNDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_and_not84(arg1: *const FloatNDArray,
                           arg2: *const int8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_or_not84(arg1: *const FloatNDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_not_and84(arg1: *const FloatNDArray,
                           arg2: *const int8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_not_or84(arg1: *const FloatNDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?product@@YA?AV?$intNDArray@V?$octave_int@C@@@@AEBV1@AEBVFloatNDArray@@@Z"]
    pub fn product29(arg1: *const int8NDArray, arg2: *const FloatNDArray)
     -> int8NDArray;
}
extern "C" {
    #[link_name =
          "?quotient@@YA?AV?$intNDArray@V?$octave_int@C@@@@AEBV1@AEBVFloatNDArray@@@Z"]
    pub fn quotient25(arg1: *const int8NDArray, arg2: *const FloatNDArray)
     -> int8NDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_lt169(arg1: *const int8NDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_le169(arg1: *const int8NDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_ge169(arg1: *const int8NDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_gt169(arg1: *const int8NDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_eq172(arg1: *const int8NDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_ne172(arg1: *const int8NDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_and174(arg1: *const int8NDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_or174(arg1: *const int8NDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_and_not85(arg1: *const int8NDArray,
                           arg2: *const FloatNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_or_not85(arg1: *const int8NDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_not_and85(arg1: *const int8NDArray,
                           arg2: *const FloatNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_not_or85(arg1: *const int8NDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?product@@YA?AV?$intNDArray@V?$octave_int@E@@@@AEBVFloatNDArray@@AEBV1@@Z"]
    pub fn product30(arg1: *const FloatNDArray, arg2: *const uint8NDArray)
     -> uint8NDArray;
}
extern "C" {
    #[link_name =
          "?quotient@@YA?AV?$intNDArray@V?$octave_int@E@@@@AEBVFloatNDArray@@AEBV1@@Z"]
    pub fn quotient26(arg1: *const FloatNDArray, arg2: *const uint8NDArray)
     -> uint8NDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_lt170(arg1: *const FloatNDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_le170(arg1: *const FloatNDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_ge170(arg1: *const FloatNDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_gt170(arg1: *const FloatNDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_eq173(arg1: *const FloatNDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_ne173(arg1: *const FloatNDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_and175(arg1: *const FloatNDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_or175(arg1: *const FloatNDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_and_not86(arg1: *const FloatNDArray,
                           arg2: *const uint8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_or_not86(arg1: *const FloatNDArray,
                          arg2: *const uint8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_not_and86(arg1: *const FloatNDArray,
                           arg2: *const uint8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_not_or86(arg1: *const FloatNDArray,
                          arg2: *const uint8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?product@@YA?AV?$intNDArray@V?$octave_int@E@@@@AEBV1@AEBVFloatNDArray@@@Z"]
    pub fn product31(arg1: *const uint8NDArray, arg2: *const FloatNDArray)
     -> uint8NDArray;
}
extern "C" {
    #[link_name =
          "?quotient@@YA?AV?$intNDArray@V?$octave_int@E@@@@AEBV1@AEBVFloatNDArray@@@Z"]
    pub fn quotient27(arg1: *const uint8NDArray, arg2: *const FloatNDArray)
     -> uint8NDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_lt171(arg1: *const uint8NDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_le171(arg1: *const uint8NDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_ge171(arg1: *const uint8NDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_gt171(arg1: *const uint8NDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_eq174(arg1: *const uint8NDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_ne174(arg1: *const uint8NDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_and176(arg1: *const uint8NDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_or176(arg1: *const uint8NDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_and_not87(arg1: *const uint8NDArray,
                           arg2: *const FloatNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_or_not87(arg1: *const uint8NDArray,
                          arg2: *const FloatNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_not_and87(arg1: *const uint8NDArray,
                           arg2: *const FloatNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_not_or87(arg1: *const uint8NDArray,
                          arg2: *const FloatNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?product@@YA?AV?$intNDArray@V?$octave_int@F@@@@AEBVFloatNDArray@@AEBV1@@Z"]
    pub fn product32(arg1: *const FloatNDArray, arg2: *const int16NDArray)
     -> int16NDArray;
}
extern "C" {
    #[link_name =
          "?quotient@@YA?AV?$intNDArray@V?$octave_int@F@@@@AEBVFloatNDArray@@AEBV1@@Z"]
    pub fn quotient28(arg1: *const FloatNDArray, arg2: *const int16NDArray)
     -> int16NDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_lt172(arg1: *const FloatNDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_le172(arg1: *const FloatNDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_ge172(arg1: *const FloatNDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_gt172(arg1: *const FloatNDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_eq175(arg1: *const FloatNDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_ne175(arg1: *const FloatNDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_and177(arg1: *const FloatNDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_or177(arg1: *const FloatNDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_and_not88(arg1: *const FloatNDArray,
                           arg2: *const int16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_or_not88(arg1: *const FloatNDArray,
                          arg2: *const int16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_not_and88(arg1: *const FloatNDArray,
                           arg2: *const int16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_not_or88(arg1: *const FloatNDArray,
                          arg2: *const int16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?product@@YA?AV?$intNDArray@V?$octave_int@F@@@@AEBV1@AEBVFloatNDArray@@@Z"]
    pub fn product33(arg1: *const int16NDArray, arg2: *const FloatNDArray)
     -> int16NDArray;
}
extern "C" {
    #[link_name =
          "?quotient@@YA?AV?$intNDArray@V?$octave_int@F@@@@AEBV1@AEBVFloatNDArray@@@Z"]
    pub fn quotient29(arg1: *const int16NDArray, arg2: *const FloatNDArray)
     -> int16NDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_lt173(arg1: *const int16NDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_le173(arg1: *const int16NDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_ge173(arg1: *const int16NDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_gt173(arg1: *const int16NDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_eq176(arg1: *const int16NDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_ne176(arg1: *const int16NDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_and178(arg1: *const int16NDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_or178(arg1: *const int16NDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_and_not89(arg1: *const int16NDArray,
                           arg2: *const FloatNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_or_not89(arg1: *const int16NDArray,
                          arg2: *const FloatNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_not_and89(arg1: *const int16NDArray,
                           arg2: *const FloatNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_not_or89(arg1: *const int16NDArray,
                          arg2: *const FloatNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?product@@YA?AV?$intNDArray@V?$octave_int@G@@@@AEBVFloatNDArray@@AEBV1@@Z"]
    pub fn product34(arg1: *const FloatNDArray, arg2: *const uint16NDArray)
     -> uint16NDArray;
}
extern "C" {
    #[link_name =
          "?quotient@@YA?AV?$intNDArray@V?$octave_int@G@@@@AEBVFloatNDArray@@AEBV1@@Z"]
    pub fn quotient30(arg1: *const FloatNDArray, arg2: *const uint16NDArray)
     -> uint16NDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_lt174(arg1: *const FloatNDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_le174(arg1: *const FloatNDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_ge174(arg1: *const FloatNDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_gt174(arg1: *const FloatNDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_eq177(arg1: *const FloatNDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_ne177(arg1: *const FloatNDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_and179(arg1: *const FloatNDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_or179(arg1: *const FloatNDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_and_not90(arg1: *const FloatNDArray,
                           arg2: *const uint16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_or_not90(arg1: *const FloatNDArray,
                          arg2: *const uint16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_not_and90(arg1: *const FloatNDArray,
                           arg2: *const uint16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_not_or90(arg1: *const FloatNDArray,
                          arg2: *const uint16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?product@@YA?AV?$intNDArray@V?$octave_int@G@@@@AEBV1@AEBVFloatNDArray@@@Z"]
    pub fn product35(arg1: *const uint16NDArray, arg2: *const FloatNDArray)
     -> uint16NDArray;
}
extern "C" {
    #[link_name =
          "?quotient@@YA?AV?$intNDArray@V?$octave_int@G@@@@AEBV1@AEBVFloatNDArray@@@Z"]
    pub fn quotient31(arg1: *const uint16NDArray, arg2: *const FloatNDArray)
     -> uint16NDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_lt175(arg1: *const uint16NDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_le175(arg1: *const uint16NDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_ge175(arg1: *const uint16NDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_gt175(arg1: *const uint16NDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_eq178(arg1: *const uint16NDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_ne178(arg1: *const uint16NDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_and180(arg1: *const uint16NDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_or180(arg1: *const uint16NDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_and_not91(arg1: *const uint16NDArray,
                           arg2: *const FloatNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_or_not91(arg1: *const uint16NDArray,
                          arg2: *const FloatNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_not_and91(arg1: *const uint16NDArray,
                           arg2: *const FloatNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_not_or91(arg1: *const uint16NDArray,
                          arg2: *const FloatNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?product@@YA?AV?$intNDArray@V?$octave_int@H@@@@AEBVFloatNDArray@@AEBV1@@Z"]
    pub fn product36(arg1: *const FloatNDArray, arg2: *const int32NDArray)
     -> int32NDArray;
}
extern "C" {
    #[link_name =
          "?quotient@@YA?AV?$intNDArray@V?$octave_int@H@@@@AEBVFloatNDArray@@AEBV1@@Z"]
    pub fn quotient32(arg1: *const FloatNDArray, arg2: *const int32NDArray)
     -> int32NDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_lt176(arg1: *const FloatNDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_le176(arg1: *const FloatNDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_ge176(arg1: *const FloatNDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_gt176(arg1: *const FloatNDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_eq179(arg1: *const FloatNDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_ne179(arg1: *const FloatNDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_and181(arg1: *const FloatNDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_or181(arg1: *const FloatNDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_and_not92(arg1: *const FloatNDArray,
                           arg2: *const int32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_or_not92(arg1: *const FloatNDArray,
                          arg2: *const int32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_not_and92(arg1: *const FloatNDArray,
                           arg2: *const int32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_not_or92(arg1: *const FloatNDArray,
                          arg2: *const int32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?product@@YA?AV?$intNDArray@V?$octave_int@H@@@@AEBV1@AEBVFloatNDArray@@@Z"]
    pub fn product37(arg1: *const int32NDArray, arg2: *const FloatNDArray)
     -> int32NDArray;
}
extern "C" {
    #[link_name =
          "?quotient@@YA?AV?$intNDArray@V?$octave_int@H@@@@AEBV1@AEBVFloatNDArray@@@Z"]
    pub fn quotient33(arg1: *const int32NDArray, arg2: *const FloatNDArray)
     -> int32NDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_lt177(arg1: *const int32NDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_le177(arg1: *const int32NDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_ge177(arg1: *const int32NDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_gt177(arg1: *const int32NDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_eq180(arg1: *const int32NDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_ne180(arg1: *const int32NDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_and182(arg1: *const int32NDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_or182(arg1: *const int32NDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_and_not93(arg1: *const int32NDArray,
                           arg2: *const FloatNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_or_not93(arg1: *const int32NDArray,
                          arg2: *const FloatNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_not_and93(arg1: *const int32NDArray,
                           arg2: *const FloatNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_not_or93(arg1: *const int32NDArray,
                          arg2: *const FloatNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?product@@YA?AV?$intNDArray@V?$octave_int@I@@@@AEBVFloatNDArray@@AEBV1@@Z"]
    pub fn product38(arg1: *const FloatNDArray, arg2: *const uint32NDArray)
     -> uint32NDArray;
}
extern "C" {
    #[link_name =
          "?quotient@@YA?AV?$intNDArray@V?$octave_int@I@@@@AEBVFloatNDArray@@AEBV1@@Z"]
    pub fn quotient34(arg1: *const FloatNDArray, arg2: *const uint32NDArray)
     -> uint32NDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_lt178(arg1: *const FloatNDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_le178(arg1: *const FloatNDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_ge178(arg1: *const FloatNDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_gt178(arg1: *const FloatNDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_eq181(arg1: *const FloatNDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_ne181(arg1: *const FloatNDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_and183(arg1: *const FloatNDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_or183(arg1: *const FloatNDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_and_not94(arg1: *const FloatNDArray,
                           arg2: *const uint32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_or_not94(arg1: *const FloatNDArray,
                          arg2: *const uint32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_not_and94(arg1: *const FloatNDArray,
                           arg2: *const uint32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_not_or94(arg1: *const FloatNDArray,
                          arg2: *const uint32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?product@@YA?AV?$intNDArray@V?$octave_int@I@@@@AEBV1@AEBVFloatNDArray@@@Z"]
    pub fn product39(arg1: *const uint32NDArray, arg2: *const FloatNDArray)
     -> uint32NDArray;
}
extern "C" {
    #[link_name =
          "?quotient@@YA?AV?$intNDArray@V?$octave_int@I@@@@AEBV1@AEBVFloatNDArray@@@Z"]
    pub fn quotient35(arg1: *const uint32NDArray, arg2: *const FloatNDArray)
     -> uint32NDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_lt179(arg1: *const uint32NDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_le179(arg1: *const uint32NDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_ge179(arg1: *const uint32NDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_gt179(arg1: *const uint32NDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_eq182(arg1: *const uint32NDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_ne182(arg1: *const uint32NDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_and184(arg1: *const uint32NDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_or184(arg1: *const uint32NDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_and_not95(arg1: *const uint32NDArray,
                           arg2: *const FloatNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_or_not95(arg1: *const uint32NDArray,
                          arg2: *const FloatNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_not_and95(arg1: *const uint32NDArray,
                           arg2: *const FloatNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_not_or95(arg1: *const uint32NDArray,
                          arg2: *const FloatNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?product@@YA?AV?$intNDArray@V?$octave_int@_J@@@@AEBVFloatNDArray@@AEBV1@@Z"]
    pub fn product40(arg1: *const FloatNDArray, arg2: *const int64NDArray)
     -> int64NDArray;
}
extern "C" {
    #[link_name =
          "?quotient@@YA?AV?$intNDArray@V?$octave_int@_J@@@@AEBVFloatNDArray@@AEBV1@@Z"]
    pub fn quotient36(arg1: *const FloatNDArray, arg2: *const int64NDArray)
     -> int64NDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_lt180(arg1: *const FloatNDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_le180(arg1: *const FloatNDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_ge180(arg1: *const FloatNDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_gt180(arg1: *const FloatNDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_eq183(arg1: *const FloatNDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_ne183(arg1: *const FloatNDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_and185(arg1: *const FloatNDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_or185(arg1: *const FloatNDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_and_not96(arg1: *const FloatNDArray,
                           arg2: *const int64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_or_not96(arg1: *const FloatNDArray,
                          arg2: *const int64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_not_and96(arg1: *const FloatNDArray,
                           arg2: *const int64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_not_or96(arg1: *const FloatNDArray,
                          arg2: *const int64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?product@@YA?AV?$intNDArray@V?$octave_int@_J@@@@AEBV1@AEBVFloatNDArray@@@Z"]
    pub fn product41(arg1: *const int64NDArray, arg2: *const FloatNDArray)
     -> int64NDArray;
}
extern "C" {
    #[link_name =
          "?quotient@@YA?AV?$intNDArray@V?$octave_int@_J@@@@AEBV1@AEBVFloatNDArray@@@Z"]
    pub fn quotient37(arg1: *const int64NDArray, arg2: *const FloatNDArray)
     -> int64NDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_lt181(arg1: *const int64NDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_le181(arg1: *const int64NDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_ge181(arg1: *const int64NDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_gt181(arg1: *const int64NDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_eq184(arg1: *const int64NDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_ne184(arg1: *const int64NDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_and186(arg1: *const int64NDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_or186(arg1: *const int64NDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_and_not97(arg1: *const int64NDArray,
                           arg2: *const FloatNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_or_not97(arg1: *const int64NDArray,
                          arg2: *const FloatNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_not_and97(arg1: *const int64NDArray,
                           arg2: *const FloatNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_not_or97(arg1: *const int64NDArray,
                          arg2: *const FloatNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?product@@YA?AV?$intNDArray@V?$octave_int@_K@@@@AEBVFloatNDArray@@AEBV1@@Z"]
    pub fn product42(arg1: *const FloatNDArray, arg2: *const uint64NDArray)
     -> uint64NDArray;
}
extern "C" {
    #[link_name =
          "?quotient@@YA?AV?$intNDArray@V?$octave_int@_K@@@@AEBVFloatNDArray@@AEBV1@@Z"]
    pub fn quotient38(arg1: *const FloatNDArray, arg2: *const uint64NDArray)
     -> uint64NDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_lt182(arg1: *const FloatNDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_le182(arg1: *const FloatNDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_ge182(arg1: *const FloatNDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_gt182(arg1: *const FloatNDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_eq185(arg1: *const FloatNDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_ne185(arg1: *const FloatNDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_and187(arg1: *const FloatNDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_or187(arg1: *const FloatNDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_and_not98(arg1: *const FloatNDArray,
                           arg2: *const uint64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_or_not98(arg1: *const FloatNDArray,
                          arg2: *const uint64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_not_and98(arg1: *const FloatNDArray,
                           arg2: *const uint64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBVFloatNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_not_or98(arg1: *const FloatNDArray,
                          arg2: *const uint64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?product@@YA?AV?$intNDArray@V?$octave_int@_K@@@@AEBV1@AEBVFloatNDArray@@@Z"]
    pub fn product43(arg1: *const uint64NDArray, arg2: *const FloatNDArray)
     -> uint64NDArray;
}
extern "C" {
    #[link_name =
          "?quotient@@YA?AV?$intNDArray@V?$octave_int@_K@@@@AEBV1@AEBVFloatNDArray@@@Z"]
    pub fn quotient39(arg1: *const uint64NDArray, arg2: *const FloatNDArray)
     -> uint64NDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_lt183(arg1: *const uint64NDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_le183(arg1: *const uint64NDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_ge183(arg1: *const uint64NDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_gt183(arg1: *const uint64NDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_eq186(arg1: *const uint64NDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_ne186(arg1: *const uint64NDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_and188(arg1: *const uint64NDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_or188(arg1: *const uint64NDArray, arg2: *const FloatNDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_and_not99(arg1: *const uint64NDArray,
                           arg2: *const FloatNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_or_not99(arg1: *const uint64NDArray,
                          arg2: *const FloatNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_not_and99(arg1: *const uint64NDArray,
                           arg2: *const FloatNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBVFloatNDArray@@@Z"]
    pub fn mx_el_not_or99(arg1: *const uint64NDArray,
                          arg2: *const FloatNDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_lt184(arg1: *const int8NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_le184(arg1: *const int8NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_ge184(arg1: *const int8NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_gt184(arg1: *const int8NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_eq187(arg1: *const int8NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_ne187(arg1: *const int8NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_and189(arg1: *const int8NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_or189(arg1: *const int8NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_not_and100(arg1: *const int8NDArray,
                            arg2: *const octave_uint8) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_not_or100(arg1: *const int8NDArray,
                           arg2: *const octave_uint8) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_lt185(arg1: *const int8NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_le185(arg1: *const int8NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_ge185(arg1: *const int8NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_gt185(arg1: *const int8NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_eq188(arg1: *const int8NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_ne188(arg1: *const int8NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_and190(arg1: *const int8NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_or190(arg1: *const int8NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_not_and101(arg1: *const int8NDArray,
                            arg2: *const octave_int16) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_not_or101(arg1: *const int8NDArray,
                           arg2: *const octave_int16) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_lt186(arg1: *const int8NDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_le186(arg1: *const int8NDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_ge186(arg1: *const int8NDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_gt186(arg1: *const int8NDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_eq189(arg1: *const int8NDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_ne189(arg1: *const int8NDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_and191(arg1: *const int8NDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_or191(arg1: *const int8NDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_not_and102(arg1: *const int8NDArray,
                            arg2: *const octave_uint16) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_not_or102(arg1: *const int8NDArray,
                           arg2: *const octave_uint16) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_lt187(arg1: *const int8NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_le187(arg1: *const int8NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_ge187(arg1: *const int8NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_gt187(arg1: *const int8NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_eq190(arg1: *const int8NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_ne190(arg1: *const int8NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_and192(arg1: *const int8NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_or192(arg1: *const int8NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_not_and103(arg1: *const int8NDArray,
                            arg2: *const octave_int32) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_not_or103(arg1: *const int8NDArray,
                           arg2: *const octave_int32) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_lt188(arg1: *const int8NDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_le188(arg1: *const int8NDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_ge188(arg1: *const int8NDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_gt188(arg1: *const int8NDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_eq191(arg1: *const int8NDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_ne191(arg1: *const int8NDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_and193(arg1: *const int8NDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_or193(arg1: *const int8NDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_not_and104(arg1: *const int8NDArray,
                            arg2: *const octave_uint32) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_not_or104(arg1: *const int8NDArray,
                           arg2: *const octave_uint32) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_lt189(arg1: *const int8NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_le189(arg1: *const int8NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_ge189(arg1: *const int8NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_gt189(arg1: *const int8NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_eq192(arg1: *const int8NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_ne192(arg1: *const int8NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_and194(arg1: *const int8NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_or194(arg1: *const int8NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_not_and105(arg1: *const int8NDArray,
                            arg2: *const octave_int64) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_not_or105(arg1: *const int8NDArray,
                           arg2: *const octave_int64) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_lt190(arg1: *const int8NDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_le190(arg1: *const int8NDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_ge190(arg1: *const int8NDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_gt190(arg1: *const int8NDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_eq193(arg1: *const int8NDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_ne193(arg1: *const int8NDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_and195(arg1: *const int8NDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_or195(arg1: *const int8NDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_not_and106(arg1: *const int8NDArray,
                            arg2: *const octave_uint64) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_not_or106(arg1: *const int8NDArray,
                           arg2: *const octave_uint64) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_lt191(arg1: *const int16NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_le191(arg1: *const int16NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_ge191(arg1: *const int16NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_gt191(arg1: *const int16NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_eq194(arg1: *const int16NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_ne194(arg1: *const int16NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_and196(arg1: *const int16NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_or196(arg1: *const int16NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_not_and107(arg1: *const int16NDArray,
                            arg2: *const octave_int8) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_not_or107(arg1: *const int16NDArray,
                           arg2: *const octave_int8) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_lt192(arg1: *const int16NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_le192(arg1: *const int16NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_ge192(arg1: *const int16NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_gt192(arg1: *const int16NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_eq195(arg1: *const int16NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_ne195(arg1: *const int16NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_and197(arg1: *const int16NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_or197(arg1: *const int16NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_not_and108(arg1: *const int16NDArray,
                            arg2: *const octave_uint8) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_not_or108(arg1: *const int16NDArray,
                           arg2: *const octave_uint8) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_lt193(arg1: *const int16NDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_le193(arg1: *const int16NDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_ge193(arg1: *const int16NDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_gt193(arg1: *const int16NDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_eq196(arg1: *const int16NDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_ne196(arg1: *const int16NDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_and198(arg1: *const int16NDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_or198(arg1: *const int16NDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_not_and109(arg1: *const int16NDArray,
                            arg2: *const octave_uint16) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_not_or109(arg1: *const int16NDArray,
                           arg2: *const octave_uint16) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_lt194(arg1: *const int16NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_le194(arg1: *const int16NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_ge194(arg1: *const int16NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_gt194(arg1: *const int16NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_eq197(arg1: *const int16NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_ne197(arg1: *const int16NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_and199(arg1: *const int16NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_or199(arg1: *const int16NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_not_and110(arg1: *const int16NDArray,
                            arg2: *const octave_int32) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_not_or110(arg1: *const int16NDArray,
                           arg2: *const octave_int32) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_lt195(arg1: *const int16NDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_le195(arg1: *const int16NDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_ge195(arg1: *const int16NDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_gt195(arg1: *const int16NDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_eq198(arg1: *const int16NDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_ne198(arg1: *const int16NDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_and200(arg1: *const int16NDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_or200(arg1: *const int16NDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_not_and111(arg1: *const int16NDArray,
                            arg2: *const octave_uint32) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_not_or111(arg1: *const int16NDArray,
                           arg2: *const octave_uint32) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_lt196(arg1: *const int16NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_le196(arg1: *const int16NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_ge196(arg1: *const int16NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_gt196(arg1: *const int16NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_eq199(arg1: *const int16NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_ne199(arg1: *const int16NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_and201(arg1: *const int16NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_or201(arg1: *const int16NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_not_and112(arg1: *const int16NDArray,
                            arg2: *const octave_int64) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_not_or112(arg1: *const int16NDArray,
                           arg2: *const octave_int64) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_lt197(arg1: *const int16NDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_le197(arg1: *const int16NDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_ge197(arg1: *const int16NDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_gt197(arg1: *const int16NDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_eq200(arg1: *const int16NDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_ne200(arg1: *const int16NDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_and202(arg1: *const int16NDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_or202(arg1: *const int16NDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_not_and113(arg1: *const int16NDArray,
                            arg2: *const octave_uint64) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_not_or113(arg1: *const int16NDArray,
                           arg2: *const octave_uint64) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_lt198(arg1: *const int32NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_le198(arg1: *const int32NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_ge198(arg1: *const int32NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_gt198(arg1: *const int32NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_eq201(arg1: *const int32NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_ne201(arg1: *const int32NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_and203(arg1: *const int32NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_or203(arg1: *const int32NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_not_and114(arg1: *const int32NDArray,
                            arg2: *const octave_int8) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_not_or114(arg1: *const int32NDArray,
                           arg2: *const octave_int8) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_lt199(arg1: *const int32NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_le199(arg1: *const int32NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_ge199(arg1: *const int32NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_gt199(arg1: *const int32NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_eq202(arg1: *const int32NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_ne202(arg1: *const int32NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_and204(arg1: *const int32NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_or204(arg1: *const int32NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_not_and115(arg1: *const int32NDArray,
                            arg2: *const octave_uint8) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_not_or115(arg1: *const int32NDArray,
                           arg2: *const octave_uint8) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_lt200(arg1: *const int32NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_le200(arg1: *const int32NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_ge200(arg1: *const int32NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_gt200(arg1: *const int32NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_eq203(arg1: *const int32NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_ne203(arg1: *const int32NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_and205(arg1: *const int32NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_or205(arg1: *const int32NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_not_and116(arg1: *const int32NDArray,
                            arg2: *const octave_int16) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_not_or116(arg1: *const int32NDArray,
                           arg2: *const octave_int16) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_lt201(arg1: *const int32NDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_le201(arg1: *const int32NDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_ge201(arg1: *const int32NDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_gt201(arg1: *const int32NDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_eq204(arg1: *const int32NDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_ne204(arg1: *const int32NDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_and206(arg1: *const int32NDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_or206(arg1: *const int32NDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_not_and117(arg1: *const int32NDArray,
                            arg2: *const octave_uint16) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_not_or117(arg1: *const int32NDArray,
                           arg2: *const octave_uint16) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_lt202(arg1: *const int32NDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_le202(arg1: *const int32NDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_ge202(arg1: *const int32NDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_gt202(arg1: *const int32NDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_eq205(arg1: *const int32NDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_ne205(arg1: *const int32NDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_and207(arg1: *const int32NDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_or207(arg1: *const int32NDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_not_and118(arg1: *const int32NDArray,
                            arg2: *const octave_uint32) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_not_or118(arg1: *const int32NDArray,
                           arg2: *const octave_uint32) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_lt203(arg1: *const int32NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_le203(arg1: *const int32NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_ge203(arg1: *const int32NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_gt203(arg1: *const int32NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_eq206(arg1: *const int32NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_ne206(arg1: *const int32NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_and208(arg1: *const int32NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_or208(arg1: *const int32NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_not_and119(arg1: *const int32NDArray,
                            arg2: *const octave_int64) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_not_or119(arg1: *const int32NDArray,
                           arg2: *const octave_int64) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_lt204(arg1: *const int32NDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_le204(arg1: *const int32NDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_ge204(arg1: *const int32NDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_gt204(arg1: *const int32NDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_eq207(arg1: *const int32NDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_ne207(arg1: *const int32NDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_and209(arg1: *const int32NDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_or209(arg1: *const int32NDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_not_and120(arg1: *const int32NDArray,
                            arg2: *const octave_uint64) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_not_or120(arg1: *const int32NDArray,
                           arg2: *const octave_uint64) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_lt205(arg1: *const int64NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_le205(arg1: *const int64NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_ge205(arg1: *const int64NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_gt205(arg1: *const int64NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_eq208(arg1: *const int64NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_ne208(arg1: *const int64NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_and210(arg1: *const int64NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_or210(arg1: *const int64NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_not_and121(arg1: *const int64NDArray,
                            arg2: *const octave_int8) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_not_or121(arg1: *const int64NDArray,
                           arg2: *const octave_int8) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_lt206(arg1: *const int64NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_le206(arg1: *const int64NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_ge206(arg1: *const int64NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_gt206(arg1: *const int64NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_eq209(arg1: *const int64NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_ne209(arg1: *const int64NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_and211(arg1: *const int64NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_or211(arg1: *const int64NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_not_and122(arg1: *const int64NDArray,
                            arg2: *const octave_uint8) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_not_or122(arg1: *const int64NDArray,
                           arg2: *const octave_uint8) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_lt207(arg1: *const int64NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_le207(arg1: *const int64NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_ge207(arg1: *const int64NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_gt207(arg1: *const int64NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_eq210(arg1: *const int64NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_ne210(arg1: *const int64NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_and212(arg1: *const int64NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_or212(arg1: *const int64NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_not_and123(arg1: *const int64NDArray,
                            arg2: *const octave_int16) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_not_or123(arg1: *const int64NDArray,
                           arg2: *const octave_int16) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_lt208(arg1: *const int64NDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_le208(arg1: *const int64NDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_ge208(arg1: *const int64NDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_gt208(arg1: *const int64NDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_eq211(arg1: *const int64NDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_ne211(arg1: *const int64NDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_and213(arg1: *const int64NDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_or213(arg1: *const int64NDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_not_and124(arg1: *const int64NDArray,
                            arg2: *const octave_uint16) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_not_or124(arg1: *const int64NDArray,
                           arg2: *const octave_uint16) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_lt209(arg1: *const int64NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_le209(arg1: *const int64NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_ge209(arg1: *const int64NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_gt209(arg1: *const int64NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_eq212(arg1: *const int64NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_ne212(arg1: *const int64NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_and214(arg1: *const int64NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_or214(arg1: *const int64NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_not_and125(arg1: *const int64NDArray,
                            arg2: *const octave_int32) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_not_or125(arg1: *const int64NDArray,
                           arg2: *const octave_int32) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_lt210(arg1: *const int64NDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_le210(arg1: *const int64NDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_ge210(arg1: *const int64NDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_gt210(arg1: *const int64NDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_eq213(arg1: *const int64NDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_ne213(arg1: *const int64NDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_and215(arg1: *const int64NDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_or215(arg1: *const int64NDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_not_and126(arg1: *const int64NDArray,
                            arg2: *const octave_uint32) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_not_or126(arg1: *const int64NDArray,
                           arg2: *const octave_uint32) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_lt211(arg1: *const int64NDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_le211(arg1: *const int64NDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_ge211(arg1: *const int64NDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_gt211(arg1: *const int64NDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_eq214(arg1: *const int64NDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_ne214(arg1: *const int64NDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_and216(arg1: *const int64NDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_or216(arg1: *const int64NDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_not_and127(arg1: *const int64NDArray,
                            arg2: *const octave_uint64) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_not_or127(arg1: *const int64NDArray,
                           arg2: *const octave_uint64) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_lt212(arg1: *const uint8NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_le212(arg1: *const uint8NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_ge212(arg1: *const uint8NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_gt212(arg1: *const uint8NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_eq215(arg1: *const uint8NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_ne215(arg1: *const uint8NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_and217(arg1: *const uint8NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_or217(arg1: *const uint8NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_not_and128(arg1: *const uint8NDArray,
                            arg2: *const octave_int8) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_not_or128(arg1: *const uint8NDArray,
                           arg2: *const octave_int8) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_lt213(arg1: *const uint8NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_le213(arg1: *const uint8NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_ge213(arg1: *const uint8NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_gt213(arg1: *const uint8NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_eq216(arg1: *const uint8NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_ne216(arg1: *const uint8NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_and218(arg1: *const uint8NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_or218(arg1: *const uint8NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_not_and129(arg1: *const uint8NDArray,
                            arg2: *const octave_int16) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_not_or129(arg1: *const uint8NDArray,
                           arg2: *const octave_int16) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_lt214(arg1: *const uint8NDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_le214(arg1: *const uint8NDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_ge214(arg1: *const uint8NDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_gt214(arg1: *const uint8NDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_eq217(arg1: *const uint8NDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_ne217(arg1: *const uint8NDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_and219(arg1: *const uint8NDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_or219(arg1: *const uint8NDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_not_and130(arg1: *const uint8NDArray,
                            arg2: *const octave_uint16) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_not_or130(arg1: *const uint8NDArray,
                           arg2: *const octave_uint16) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_lt215(arg1: *const uint8NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_le215(arg1: *const uint8NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_ge215(arg1: *const uint8NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_gt215(arg1: *const uint8NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_eq218(arg1: *const uint8NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_ne218(arg1: *const uint8NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_and220(arg1: *const uint8NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_or220(arg1: *const uint8NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_not_and131(arg1: *const uint8NDArray,
                            arg2: *const octave_int32) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_not_or131(arg1: *const uint8NDArray,
                           arg2: *const octave_int32) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_lt216(arg1: *const uint8NDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_le216(arg1: *const uint8NDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_ge216(arg1: *const uint8NDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_gt216(arg1: *const uint8NDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_eq219(arg1: *const uint8NDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_ne219(arg1: *const uint8NDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_and221(arg1: *const uint8NDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_or221(arg1: *const uint8NDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_not_and132(arg1: *const uint8NDArray,
                            arg2: *const octave_uint32) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_not_or132(arg1: *const uint8NDArray,
                           arg2: *const octave_uint32) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_lt217(arg1: *const uint8NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_le217(arg1: *const uint8NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_ge217(arg1: *const uint8NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_gt217(arg1: *const uint8NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_eq220(arg1: *const uint8NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_ne220(arg1: *const uint8NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_and222(arg1: *const uint8NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_or222(arg1: *const uint8NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_not_and133(arg1: *const uint8NDArray,
                            arg2: *const octave_int64) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_not_or133(arg1: *const uint8NDArray,
                           arg2: *const octave_int64) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_lt218(arg1: *const uint8NDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_le218(arg1: *const uint8NDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_ge218(arg1: *const uint8NDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_gt218(arg1: *const uint8NDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_eq221(arg1: *const uint8NDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_ne221(arg1: *const uint8NDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_and223(arg1: *const uint8NDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_or223(arg1: *const uint8NDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_not_and134(arg1: *const uint8NDArray,
                            arg2: *const octave_uint64) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_not_or134(arg1: *const uint8NDArray,
                           arg2: *const octave_uint64) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_lt219(arg1: *const uint16NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_le219(arg1: *const uint16NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_ge219(arg1: *const uint16NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_gt219(arg1: *const uint16NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_eq222(arg1: *const uint16NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_ne222(arg1: *const uint16NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_and224(arg1: *const uint16NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_or224(arg1: *const uint16NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_not_and135(arg1: *const uint16NDArray,
                            arg2: *const octave_int8) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_not_or135(arg1: *const uint16NDArray,
                           arg2: *const octave_int8) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_lt220(arg1: *const uint16NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_le220(arg1: *const uint16NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_ge220(arg1: *const uint16NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_gt220(arg1: *const uint16NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_eq223(arg1: *const uint16NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_ne223(arg1: *const uint16NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_and225(arg1: *const uint16NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_or225(arg1: *const uint16NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_not_and136(arg1: *const uint16NDArray,
                            arg2: *const octave_uint8) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_not_or136(arg1: *const uint16NDArray,
                           arg2: *const octave_uint8) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_lt221(arg1: *const uint16NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_le221(arg1: *const uint16NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_ge221(arg1: *const uint16NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_gt221(arg1: *const uint16NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_eq224(arg1: *const uint16NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_ne224(arg1: *const uint16NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_and226(arg1: *const uint16NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_or226(arg1: *const uint16NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_not_and137(arg1: *const uint16NDArray,
                            arg2: *const octave_int16) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_not_or137(arg1: *const uint16NDArray,
                           arg2: *const octave_int16) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_lt222(arg1: *const uint16NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_le222(arg1: *const uint16NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_ge222(arg1: *const uint16NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_gt222(arg1: *const uint16NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_eq225(arg1: *const uint16NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_ne225(arg1: *const uint16NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_and227(arg1: *const uint16NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_or227(arg1: *const uint16NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_not_and138(arg1: *const uint16NDArray,
                            arg2: *const octave_int32) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_not_or138(arg1: *const uint16NDArray,
                           arg2: *const octave_int32) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_lt223(arg1: *const uint16NDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_le223(arg1: *const uint16NDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_ge223(arg1: *const uint16NDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_gt223(arg1: *const uint16NDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_eq226(arg1: *const uint16NDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_ne226(arg1: *const uint16NDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_and228(arg1: *const uint16NDArray,
                        arg2: *const octave_uint32) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_or228(arg1: *const uint16NDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_not_and139(arg1: *const uint16NDArray,
                            arg2: *const octave_uint32) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_not_or139(arg1: *const uint16NDArray,
                           arg2: *const octave_uint32) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_lt224(arg1: *const uint16NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_le224(arg1: *const uint16NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_ge224(arg1: *const uint16NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_gt224(arg1: *const uint16NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_eq227(arg1: *const uint16NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_ne227(arg1: *const uint16NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_and229(arg1: *const uint16NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_or229(arg1: *const uint16NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_not_and140(arg1: *const uint16NDArray,
                            arg2: *const octave_int64) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_not_or140(arg1: *const uint16NDArray,
                           arg2: *const octave_int64) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_lt225(arg1: *const uint16NDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_le225(arg1: *const uint16NDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_ge225(arg1: *const uint16NDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_gt225(arg1: *const uint16NDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_eq228(arg1: *const uint16NDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_ne228(arg1: *const uint16NDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_and230(arg1: *const uint16NDArray,
                        arg2: *const octave_uint64) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_or230(arg1: *const uint16NDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_not_and141(arg1: *const uint16NDArray,
                            arg2: *const octave_uint64) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_not_or141(arg1: *const uint16NDArray,
                           arg2: *const octave_uint64) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_lt226(arg1: *const uint32NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_le226(arg1: *const uint32NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_ge226(arg1: *const uint32NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_gt226(arg1: *const uint32NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_eq229(arg1: *const uint32NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_ne229(arg1: *const uint32NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_and231(arg1: *const uint32NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_or231(arg1: *const uint32NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_not_and142(arg1: *const uint32NDArray,
                            arg2: *const octave_int8) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_not_or142(arg1: *const uint32NDArray,
                           arg2: *const octave_int8) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_lt227(arg1: *const uint32NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_le227(arg1: *const uint32NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_ge227(arg1: *const uint32NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_gt227(arg1: *const uint32NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_eq230(arg1: *const uint32NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_ne230(arg1: *const uint32NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_and232(arg1: *const uint32NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_or232(arg1: *const uint32NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_not_and143(arg1: *const uint32NDArray,
                            arg2: *const octave_uint8) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_not_or143(arg1: *const uint32NDArray,
                           arg2: *const octave_uint8) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_lt228(arg1: *const uint32NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_le228(arg1: *const uint32NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_ge228(arg1: *const uint32NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_gt228(arg1: *const uint32NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_eq231(arg1: *const uint32NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_ne231(arg1: *const uint32NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_and233(arg1: *const uint32NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_or233(arg1: *const uint32NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_not_and144(arg1: *const uint32NDArray,
                            arg2: *const octave_int16) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_not_or144(arg1: *const uint32NDArray,
                           arg2: *const octave_int16) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_lt229(arg1: *const uint32NDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_le229(arg1: *const uint32NDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_ge229(arg1: *const uint32NDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_gt229(arg1: *const uint32NDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_eq232(arg1: *const uint32NDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_ne232(arg1: *const uint32NDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_and234(arg1: *const uint32NDArray,
                        arg2: *const octave_uint16) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_or234(arg1: *const uint32NDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_not_and145(arg1: *const uint32NDArray,
                            arg2: *const octave_uint16) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_not_or145(arg1: *const uint32NDArray,
                           arg2: *const octave_uint16) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_lt230(arg1: *const uint32NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_le230(arg1: *const uint32NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_ge230(arg1: *const uint32NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_gt230(arg1: *const uint32NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_eq233(arg1: *const uint32NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_ne233(arg1: *const uint32NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_and235(arg1: *const uint32NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_or235(arg1: *const uint32NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_not_and146(arg1: *const uint32NDArray,
                            arg2: *const octave_int32) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_not_or146(arg1: *const uint32NDArray,
                           arg2: *const octave_int32) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_lt231(arg1: *const uint32NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_le231(arg1: *const uint32NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_ge231(arg1: *const uint32NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_gt231(arg1: *const uint32NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_eq234(arg1: *const uint32NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_ne234(arg1: *const uint32NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_and236(arg1: *const uint32NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_or236(arg1: *const uint32NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_not_and147(arg1: *const uint32NDArray,
                            arg2: *const octave_int64) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_not_or147(arg1: *const uint32NDArray,
                           arg2: *const octave_int64) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_lt232(arg1: *const uint32NDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_le232(arg1: *const uint32NDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_ge232(arg1: *const uint32NDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_gt232(arg1: *const uint32NDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_eq235(arg1: *const uint32NDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_ne235(arg1: *const uint32NDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_and237(arg1: *const uint32NDArray,
                        arg2: *const octave_uint64) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_or237(arg1: *const uint32NDArray, arg2: *const octave_uint64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_not_and148(arg1: *const uint32NDArray,
                            arg2: *const octave_uint64) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$octave_int@_K@@@Z"]
    pub fn mx_el_not_or148(arg1: *const uint32NDArray,
                           arg2: *const octave_uint64) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_lt233(arg1: *const uint64NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_le233(arg1: *const uint64NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_ge233(arg1: *const uint64NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_gt233(arg1: *const uint64NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_eq236(arg1: *const uint64NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_ne236(arg1: *const uint64NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_and238(arg1: *const uint64NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_or238(arg1: *const uint64NDArray, arg2: *const octave_int8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_not_and149(arg1: *const uint64NDArray,
                            arg2: *const octave_int8) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@C@@@Z"]
    pub fn mx_el_not_or149(arg1: *const uint64NDArray,
                           arg2: *const octave_int8) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_lt234(arg1: *const uint64NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_le234(arg1: *const uint64NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_ge234(arg1: *const uint64NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_gt234(arg1: *const uint64NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_eq237(arg1: *const uint64NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_ne237(arg1: *const uint64NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_and239(arg1: *const uint64NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_or239(arg1: *const uint64NDArray, arg2: *const octave_uint8)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_not_and150(arg1: *const uint64NDArray,
                            arg2: *const octave_uint8) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@E@@@Z"]
    pub fn mx_el_not_or150(arg1: *const uint64NDArray,
                           arg2: *const octave_uint8) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_lt235(arg1: *const uint64NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_le235(arg1: *const uint64NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_ge235(arg1: *const uint64NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_gt235(arg1: *const uint64NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_eq238(arg1: *const uint64NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_ne238(arg1: *const uint64NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_and240(arg1: *const uint64NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_or240(arg1: *const uint64NDArray, arg2: *const octave_int16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_not_and151(arg1: *const uint64NDArray,
                            arg2: *const octave_int16) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@F@@@Z"]
    pub fn mx_el_not_or151(arg1: *const uint64NDArray,
                           arg2: *const octave_int16) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_lt236(arg1: *const uint64NDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_le236(arg1: *const uint64NDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_ge236(arg1: *const uint64NDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_gt236(arg1: *const uint64NDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_eq239(arg1: *const uint64NDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_ne239(arg1: *const uint64NDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_and241(arg1: *const uint64NDArray,
                        arg2: *const octave_uint16) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_or241(arg1: *const uint64NDArray, arg2: *const octave_uint16)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_not_and152(arg1: *const uint64NDArray,
                            arg2: *const octave_uint16) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@G@@@Z"]
    pub fn mx_el_not_or152(arg1: *const uint64NDArray,
                           arg2: *const octave_uint16) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_lt237(arg1: *const uint64NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_le237(arg1: *const uint64NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_ge237(arg1: *const uint64NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_gt237(arg1: *const uint64NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_eq240(arg1: *const uint64NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_ne240(arg1: *const uint64NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_and242(arg1: *const uint64NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_or242(arg1: *const uint64NDArray, arg2: *const octave_int32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_not_and153(arg1: *const uint64NDArray,
                            arg2: *const octave_int32) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@H@@@Z"]
    pub fn mx_el_not_or153(arg1: *const uint64NDArray,
                           arg2: *const octave_int32) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_lt238(arg1: *const uint64NDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_le238(arg1: *const uint64NDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_ge238(arg1: *const uint64NDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_gt238(arg1: *const uint64NDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_eq241(arg1: *const uint64NDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_ne241(arg1: *const uint64NDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_and243(arg1: *const uint64NDArray,
                        arg2: *const octave_uint32) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_or243(arg1: *const uint64NDArray, arg2: *const octave_uint32)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_not_and154(arg1: *const uint64NDArray,
                            arg2: *const octave_uint32) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@I@@@Z"]
    pub fn mx_el_not_or154(arg1: *const uint64NDArray,
                           arg2: *const octave_uint32) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_lt239(arg1: *const uint64NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_le239(arg1: *const uint64NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_ge239(arg1: *const uint64NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_gt239(arg1: *const uint64NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_eq242(arg1: *const uint64NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_ne242(arg1: *const uint64NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_and244(arg1: *const uint64NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_or244(arg1: *const uint64NDArray, arg2: *const octave_int64)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_not_and155(arg1: *const uint64NDArray,
                            arg2: *const octave_int64) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$octave_int@_J@@@Z"]
    pub fn mx_el_not_or155(arg1: *const uint64NDArray,
                           arg2: *const octave_int64) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_lt240(arg1: *const octave_int8, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_le240(arg1: *const octave_int8, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_ge240(arg1: *const octave_int8, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_gt240(arg1: *const octave_int8, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_eq243(arg1: *const octave_int8, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_ne243(arg1: *const octave_int8, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_and245(arg1: *const octave_int8, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_or245(arg1: *const octave_int8, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_and_not100(arg1: *const octave_int8,
                            arg2: *const uint8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_or_not100(arg1: *const octave_int8,
                           arg2: *const uint8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_lt241(arg1: *const octave_int8, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_le241(arg1: *const octave_int8, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_ge241(arg1: *const octave_int8, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_gt241(arg1: *const octave_int8, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_eq244(arg1: *const octave_int8, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_ne244(arg1: *const octave_int8, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_and246(arg1: *const octave_int8, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_or246(arg1: *const octave_int8, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_and_not101(arg1: *const octave_int8,
                            arg2: *const int16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_or_not101(arg1: *const octave_int8,
                           arg2: *const int16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_lt242(arg1: *const octave_int8, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_le242(arg1: *const octave_int8, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_ge242(arg1: *const octave_int8, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_gt242(arg1: *const octave_int8, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_eq245(arg1: *const octave_int8, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_ne245(arg1: *const octave_int8, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_and247(arg1: *const octave_int8, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_or247(arg1: *const octave_int8, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_and_not102(arg1: *const octave_int8,
                            arg2: *const uint16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_or_not102(arg1: *const octave_int8,
                           arg2: *const uint16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_lt243(arg1: *const octave_int8, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_le243(arg1: *const octave_int8, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_ge243(arg1: *const octave_int8, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_gt243(arg1: *const octave_int8, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_eq246(arg1: *const octave_int8, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_ne246(arg1: *const octave_int8, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_and248(arg1: *const octave_int8, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_or248(arg1: *const octave_int8, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_and_not103(arg1: *const octave_int8,
                            arg2: *const int32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_or_not103(arg1: *const octave_int8,
                           arg2: *const int32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_lt244(arg1: *const octave_int8, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_le244(arg1: *const octave_int8, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_ge244(arg1: *const octave_int8, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_gt244(arg1: *const octave_int8, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_eq247(arg1: *const octave_int8, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_ne247(arg1: *const octave_int8, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_and249(arg1: *const octave_int8, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_or249(arg1: *const octave_int8, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_and_not104(arg1: *const octave_int8,
                            arg2: *const uint32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_or_not104(arg1: *const octave_int8,
                           arg2: *const uint32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_lt245(arg1: *const octave_int8, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_le245(arg1: *const octave_int8, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_ge245(arg1: *const octave_int8, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_gt245(arg1: *const octave_int8, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_eq248(arg1: *const octave_int8, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_ne248(arg1: *const octave_int8, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_and250(arg1: *const octave_int8, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_or250(arg1: *const octave_int8, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_and_not105(arg1: *const octave_int8,
                            arg2: *const int64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_or_not105(arg1: *const octave_int8,
                           arg2: *const int64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_lt246(arg1: *const octave_int8, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_le246(arg1: *const octave_int8, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_ge246(arg1: *const octave_int8, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_gt246(arg1: *const octave_int8, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_eq249(arg1: *const octave_int8, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_ne249(arg1: *const octave_int8, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_and251(arg1: *const octave_int8, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_or251(arg1: *const octave_int8, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_and_not106(arg1: *const octave_int8,
                            arg2: *const uint64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@C@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_or_not106(arg1: *const octave_int8,
                           arg2: *const uint64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_lt247(arg1: *const octave_int16, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_le247(arg1: *const octave_int16, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_ge247(arg1: *const octave_int16, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_gt247(arg1: *const octave_int16, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_eq250(arg1: *const octave_int16, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_ne250(arg1: *const octave_int16, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_and252(arg1: *const octave_int16, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_or252(arg1: *const octave_int16, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_and_not107(arg1: *const octave_int16,
                            arg2: *const int8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_or_not107(arg1: *const octave_int16,
                           arg2: *const int8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_lt248(arg1: *const octave_int16, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_le248(arg1: *const octave_int16, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_ge248(arg1: *const octave_int16, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_gt248(arg1: *const octave_int16, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_eq251(arg1: *const octave_int16, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_ne251(arg1: *const octave_int16, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_and253(arg1: *const octave_int16, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_or253(arg1: *const octave_int16, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_and_not108(arg1: *const octave_int16,
                            arg2: *const uint8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_or_not108(arg1: *const octave_int16,
                           arg2: *const uint8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_lt249(arg1: *const octave_int16, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_le249(arg1: *const octave_int16, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_ge249(arg1: *const octave_int16, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_gt249(arg1: *const octave_int16, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_eq252(arg1: *const octave_int16, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_ne252(arg1: *const octave_int16, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_and254(arg1: *const octave_int16, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_or254(arg1: *const octave_int16, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_and_not109(arg1: *const octave_int16,
                            arg2: *const uint16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_or_not109(arg1: *const octave_int16,
                           arg2: *const uint16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_lt250(arg1: *const octave_int16, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_le250(arg1: *const octave_int16, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_ge250(arg1: *const octave_int16, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_gt250(arg1: *const octave_int16, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_eq253(arg1: *const octave_int16, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_ne253(arg1: *const octave_int16, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_and255(arg1: *const octave_int16, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_or255(arg1: *const octave_int16, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_and_not110(arg1: *const octave_int16,
                            arg2: *const int32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_or_not110(arg1: *const octave_int16,
                           arg2: *const int32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_lt251(arg1: *const octave_int16, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_le251(arg1: *const octave_int16, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_ge251(arg1: *const octave_int16, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_gt251(arg1: *const octave_int16, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_eq254(arg1: *const octave_int16, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_ne254(arg1: *const octave_int16, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_and256(arg1: *const octave_int16, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_or256(arg1: *const octave_int16, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_and_not111(arg1: *const octave_int16,
                            arg2: *const uint32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_or_not111(arg1: *const octave_int16,
                           arg2: *const uint32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_lt252(arg1: *const octave_int16, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_le252(arg1: *const octave_int16, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_ge252(arg1: *const octave_int16, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_gt252(arg1: *const octave_int16, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_eq255(arg1: *const octave_int16, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_ne255(arg1: *const octave_int16, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_and257(arg1: *const octave_int16, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_or257(arg1: *const octave_int16, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_and_not112(arg1: *const octave_int16,
                            arg2: *const int64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_or_not112(arg1: *const octave_int16,
                           arg2: *const int64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_lt253(arg1: *const octave_int16, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_le253(arg1: *const octave_int16, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_ge253(arg1: *const octave_int16, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_gt253(arg1: *const octave_int16, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_eq256(arg1: *const octave_int16, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_ne256(arg1: *const octave_int16, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_and258(arg1: *const octave_int16, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_or258(arg1: *const octave_int16, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_and_not113(arg1: *const octave_int16,
                            arg2: *const uint64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@F@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_or_not113(arg1: *const octave_int16,
                           arg2: *const uint64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_lt254(arg1: *const octave_int32, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_le254(arg1: *const octave_int32, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_ge254(arg1: *const octave_int32, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_gt254(arg1: *const octave_int32, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_eq257(arg1: *const octave_int32, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_ne257(arg1: *const octave_int32, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_and259(arg1: *const octave_int32, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_or259(arg1: *const octave_int32, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_and_not114(arg1: *const octave_int32,
                            arg2: *const int8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_or_not114(arg1: *const octave_int32,
                           arg2: *const int8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_lt255(arg1: *const octave_int32, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_le255(arg1: *const octave_int32, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_ge255(arg1: *const octave_int32, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_gt255(arg1: *const octave_int32, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_eq258(arg1: *const octave_int32, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_ne258(arg1: *const octave_int32, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_and260(arg1: *const octave_int32, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_or260(arg1: *const octave_int32, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_and_not115(arg1: *const octave_int32,
                            arg2: *const uint8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_or_not115(arg1: *const octave_int32,
                           arg2: *const uint8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_lt256(arg1: *const octave_int32, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_le256(arg1: *const octave_int32, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_ge256(arg1: *const octave_int32, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_gt256(arg1: *const octave_int32, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_eq259(arg1: *const octave_int32, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_ne259(arg1: *const octave_int32, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_and261(arg1: *const octave_int32, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_or261(arg1: *const octave_int32, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_and_not116(arg1: *const octave_int32,
                            arg2: *const int16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_or_not116(arg1: *const octave_int32,
                           arg2: *const int16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_lt257(arg1: *const octave_int32, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_le257(arg1: *const octave_int32, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_ge257(arg1: *const octave_int32, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_gt257(arg1: *const octave_int32, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_eq260(arg1: *const octave_int32, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_ne260(arg1: *const octave_int32, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_and262(arg1: *const octave_int32, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_or262(arg1: *const octave_int32, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_and_not117(arg1: *const octave_int32,
                            arg2: *const uint16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_or_not117(arg1: *const octave_int32,
                           arg2: *const uint16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_lt258(arg1: *const octave_int32, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_le258(arg1: *const octave_int32, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_ge258(arg1: *const octave_int32, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_gt258(arg1: *const octave_int32, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_eq261(arg1: *const octave_int32, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_ne261(arg1: *const octave_int32, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_and263(arg1: *const octave_int32, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_or263(arg1: *const octave_int32, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_and_not118(arg1: *const octave_int32,
                            arg2: *const uint32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_or_not118(arg1: *const octave_int32,
                           arg2: *const uint32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_lt259(arg1: *const octave_int32, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_le259(arg1: *const octave_int32, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_ge259(arg1: *const octave_int32, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_gt259(arg1: *const octave_int32, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_eq262(arg1: *const octave_int32, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_ne262(arg1: *const octave_int32, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_and264(arg1: *const octave_int32, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_or264(arg1: *const octave_int32, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_and_not119(arg1: *const octave_int32,
                            arg2: *const int64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_or_not119(arg1: *const octave_int32,
                           arg2: *const int64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_lt260(arg1: *const octave_int32, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_le260(arg1: *const octave_int32, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_ge260(arg1: *const octave_int32, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_gt260(arg1: *const octave_int32, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_eq263(arg1: *const octave_int32, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_ne263(arg1: *const octave_int32, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_and265(arg1: *const octave_int32, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_or265(arg1: *const octave_int32, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_and_not120(arg1: *const octave_int32,
                            arg2: *const uint64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@H@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_or_not120(arg1: *const octave_int32,
                           arg2: *const uint64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_lt261(arg1: *const octave_int64, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_le261(arg1: *const octave_int64, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_ge261(arg1: *const octave_int64, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_gt261(arg1: *const octave_int64, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_eq264(arg1: *const octave_int64, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_ne264(arg1: *const octave_int64, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_and266(arg1: *const octave_int64, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_or266(arg1: *const octave_int64, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_and_not121(arg1: *const octave_int64,
                            arg2: *const int8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_or_not121(arg1: *const octave_int64,
                           arg2: *const int8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_lt262(arg1: *const octave_int64, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_le262(arg1: *const octave_int64, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_ge262(arg1: *const octave_int64, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_gt262(arg1: *const octave_int64, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_eq265(arg1: *const octave_int64, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_ne265(arg1: *const octave_int64, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_and267(arg1: *const octave_int64, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_or267(arg1: *const octave_int64, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_and_not122(arg1: *const octave_int64,
                            arg2: *const uint8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_or_not122(arg1: *const octave_int64,
                           arg2: *const uint8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_lt263(arg1: *const octave_int64, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_le263(arg1: *const octave_int64, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_ge263(arg1: *const octave_int64, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_gt263(arg1: *const octave_int64, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_eq266(arg1: *const octave_int64, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_ne266(arg1: *const octave_int64, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_and268(arg1: *const octave_int64, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_or268(arg1: *const octave_int64, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_and_not123(arg1: *const octave_int64,
                            arg2: *const int16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_or_not123(arg1: *const octave_int64,
                           arg2: *const int16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_lt264(arg1: *const octave_int64, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_le264(arg1: *const octave_int64, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_ge264(arg1: *const octave_int64, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_gt264(arg1: *const octave_int64, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_eq267(arg1: *const octave_int64, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_ne267(arg1: *const octave_int64, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_and269(arg1: *const octave_int64, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_or269(arg1: *const octave_int64, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_and_not124(arg1: *const octave_int64,
                            arg2: *const uint16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_or_not124(arg1: *const octave_int64,
                           arg2: *const uint16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_lt265(arg1: *const octave_int64, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_le265(arg1: *const octave_int64, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_ge265(arg1: *const octave_int64, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_gt265(arg1: *const octave_int64, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_eq268(arg1: *const octave_int64, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_ne268(arg1: *const octave_int64, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_and270(arg1: *const octave_int64, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_or270(arg1: *const octave_int64, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_and_not125(arg1: *const octave_int64,
                            arg2: *const int32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_or_not125(arg1: *const octave_int64,
                           arg2: *const int32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_lt266(arg1: *const octave_int64, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_le266(arg1: *const octave_int64, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_ge266(arg1: *const octave_int64, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_gt266(arg1: *const octave_int64, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_eq269(arg1: *const octave_int64, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_ne269(arg1: *const octave_int64, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_and271(arg1: *const octave_int64, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_or271(arg1: *const octave_int64, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_and_not126(arg1: *const octave_int64,
                            arg2: *const uint32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_or_not126(arg1: *const octave_int64,
                           arg2: *const uint32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_lt267(arg1: *const octave_int64, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_le267(arg1: *const octave_int64, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_ge267(arg1: *const octave_int64, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_gt267(arg1: *const octave_int64, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_eq270(arg1: *const octave_int64, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_ne270(arg1: *const octave_int64, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_and272(arg1: *const octave_int64, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_or272(arg1: *const octave_int64, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_and_not127(arg1: *const octave_int64,
                            arg2: *const uint64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@_J@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_or_not127(arg1: *const octave_int64,
                           arg2: *const uint64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_lt268(arg1: *const octave_uint8, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_le268(arg1: *const octave_uint8, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_ge268(arg1: *const octave_uint8, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_gt268(arg1: *const octave_uint8, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_eq271(arg1: *const octave_uint8, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_ne271(arg1: *const octave_uint8, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_and273(arg1: *const octave_uint8, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_or273(arg1: *const octave_uint8, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_and_not128(arg1: *const octave_uint8,
                            arg2: *const int8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_or_not128(arg1: *const octave_uint8,
                           arg2: *const int8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_lt269(arg1: *const octave_uint8, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_le269(arg1: *const octave_uint8, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_ge269(arg1: *const octave_uint8, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_gt269(arg1: *const octave_uint8, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_eq272(arg1: *const octave_uint8, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_ne272(arg1: *const octave_uint8, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_and274(arg1: *const octave_uint8, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_or274(arg1: *const octave_uint8, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_and_not129(arg1: *const octave_uint8,
                            arg2: *const int16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_or_not129(arg1: *const octave_uint8,
                           arg2: *const int16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_lt270(arg1: *const octave_uint8, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_le270(arg1: *const octave_uint8, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_ge270(arg1: *const octave_uint8, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_gt270(arg1: *const octave_uint8, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_eq273(arg1: *const octave_uint8, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_ne273(arg1: *const octave_uint8, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_and275(arg1: *const octave_uint8, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_or275(arg1: *const octave_uint8, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_and_not130(arg1: *const octave_uint8,
                            arg2: *const uint16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_or_not130(arg1: *const octave_uint8,
                           arg2: *const uint16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_lt271(arg1: *const octave_uint8, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_le271(arg1: *const octave_uint8, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_ge271(arg1: *const octave_uint8, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_gt271(arg1: *const octave_uint8, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_eq274(arg1: *const octave_uint8, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_ne274(arg1: *const octave_uint8, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_and276(arg1: *const octave_uint8, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_or276(arg1: *const octave_uint8, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_and_not131(arg1: *const octave_uint8,
                            arg2: *const int32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_or_not131(arg1: *const octave_uint8,
                           arg2: *const int32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_lt272(arg1: *const octave_uint8, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_le272(arg1: *const octave_uint8, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_ge272(arg1: *const octave_uint8, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_gt272(arg1: *const octave_uint8, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_eq275(arg1: *const octave_uint8, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_ne275(arg1: *const octave_uint8, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_and277(arg1: *const octave_uint8, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_or277(arg1: *const octave_uint8, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_and_not132(arg1: *const octave_uint8,
                            arg2: *const uint32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_or_not132(arg1: *const octave_uint8,
                           arg2: *const uint32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_lt273(arg1: *const octave_uint8, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_le273(arg1: *const octave_uint8, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_ge273(arg1: *const octave_uint8, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_gt273(arg1: *const octave_uint8, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_eq276(arg1: *const octave_uint8, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_ne276(arg1: *const octave_uint8, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_and278(arg1: *const octave_uint8, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_or278(arg1: *const octave_uint8, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_and_not133(arg1: *const octave_uint8,
                            arg2: *const int64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_or_not133(arg1: *const octave_uint8,
                           arg2: *const int64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_lt274(arg1: *const octave_uint8, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_le274(arg1: *const octave_uint8, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_ge274(arg1: *const octave_uint8, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_gt274(arg1: *const octave_uint8, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_eq277(arg1: *const octave_uint8, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_ne277(arg1: *const octave_uint8, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_and279(arg1: *const octave_uint8, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_or279(arg1: *const octave_uint8, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_and_not134(arg1: *const octave_uint8,
                            arg2: *const uint64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@E@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_or_not134(arg1: *const octave_uint8,
                           arg2: *const uint64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_lt275(arg1: *const octave_uint16, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_le275(arg1: *const octave_uint16, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_ge275(arg1: *const octave_uint16, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_gt275(arg1: *const octave_uint16, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_eq278(arg1: *const octave_uint16, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_ne278(arg1: *const octave_uint16, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_and280(arg1: *const octave_uint16, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_or280(arg1: *const octave_uint16, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_and_not135(arg1: *const octave_uint16,
                            arg2: *const int8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_or_not135(arg1: *const octave_uint16,
                           arg2: *const int8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_lt276(arg1: *const octave_uint16, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_le276(arg1: *const octave_uint16, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_ge276(arg1: *const octave_uint16, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_gt276(arg1: *const octave_uint16, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_eq279(arg1: *const octave_uint16, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_ne279(arg1: *const octave_uint16, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_and281(arg1: *const octave_uint16, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_or281(arg1: *const octave_uint16, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_and_not136(arg1: *const octave_uint16,
                            arg2: *const uint8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_or_not136(arg1: *const octave_uint16,
                           arg2: *const uint8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_lt277(arg1: *const octave_uint16, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_le277(arg1: *const octave_uint16, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_ge277(arg1: *const octave_uint16, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_gt277(arg1: *const octave_uint16, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_eq280(arg1: *const octave_uint16, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_ne280(arg1: *const octave_uint16, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_and282(arg1: *const octave_uint16, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_or282(arg1: *const octave_uint16, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_and_not137(arg1: *const octave_uint16,
                            arg2: *const int16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_or_not137(arg1: *const octave_uint16,
                           arg2: *const int16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_lt278(arg1: *const octave_uint16, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_le278(arg1: *const octave_uint16, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_ge278(arg1: *const octave_uint16, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_gt278(arg1: *const octave_uint16, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_eq281(arg1: *const octave_uint16, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_ne281(arg1: *const octave_uint16, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_and283(arg1: *const octave_uint16, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_or283(arg1: *const octave_uint16, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_and_not138(arg1: *const octave_uint16,
                            arg2: *const int32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_or_not138(arg1: *const octave_uint16,
                           arg2: *const int32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_lt279(arg1: *const octave_uint16, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_le279(arg1: *const octave_uint16, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_ge279(arg1: *const octave_uint16, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_gt279(arg1: *const octave_uint16, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_eq282(arg1: *const octave_uint16, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_ne282(arg1: *const octave_uint16, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_and284(arg1: *const octave_uint16,
                        arg2: *const uint32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_or284(arg1: *const octave_uint16, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_and_not139(arg1: *const octave_uint16,
                            arg2: *const uint32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_or_not139(arg1: *const octave_uint16,
                           arg2: *const uint32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_lt280(arg1: *const octave_uint16, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_le280(arg1: *const octave_uint16, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_ge280(arg1: *const octave_uint16, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_gt280(arg1: *const octave_uint16, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_eq283(arg1: *const octave_uint16, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_ne283(arg1: *const octave_uint16, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_and285(arg1: *const octave_uint16, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_or285(arg1: *const octave_uint16, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_and_not140(arg1: *const octave_uint16,
                            arg2: *const int64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_or_not140(arg1: *const octave_uint16,
                           arg2: *const int64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_lt281(arg1: *const octave_uint16, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_le281(arg1: *const octave_uint16, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_ge281(arg1: *const octave_uint16, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_gt281(arg1: *const octave_uint16, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_eq284(arg1: *const octave_uint16, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_ne284(arg1: *const octave_uint16, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_and286(arg1: *const octave_uint16,
                        arg2: *const uint64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_or286(arg1: *const octave_uint16, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_and_not141(arg1: *const octave_uint16,
                            arg2: *const uint64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@G@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_or_not141(arg1: *const octave_uint16,
                           arg2: *const uint64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_lt282(arg1: *const octave_uint32, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_le282(arg1: *const octave_uint32, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_ge282(arg1: *const octave_uint32, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_gt282(arg1: *const octave_uint32, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_eq285(arg1: *const octave_uint32, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_ne285(arg1: *const octave_uint32, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_and287(arg1: *const octave_uint32, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_or287(arg1: *const octave_uint32, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_and_not142(arg1: *const octave_uint32,
                            arg2: *const int8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_or_not142(arg1: *const octave_uint32,
                           arg2: *const int8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_lt283(arg1: *const octave_uint32, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_le283(arg1: *const octave_uint32, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_ge283(arg1: *const octave_uint32, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_gt283(arg1: *const octave_uint32, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_eq286(arg1: *const octave_uint32, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_ne286(arg1: *const octave_uint32, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_and288(arg1: *const octave_uint32, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_or288(arg1: *const octave_uint32, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_and_not143(arg1: *const octave_uint32,
                            arg2: *const uint8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_or_not143(arg1: *const octave_uint32,
                           arg2: *const uint8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_lt284(arg1: *const octave_uint32, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_le284(arg1: *const octave_uint32, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_ge284(arg1: *const octave_uint32, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_gt284(arg1: *const octave_uint32, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_eq287(arg1: *const octave_uint32, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_ne287(arg1: *const octave_uint32, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_and289(arg1: *const octave_uint32, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_or289(arg1: *const octave_uint32, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_and_not144(arg1: *const octave_uint32,
                            arg2: *const int16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_or_not144(arg1: *const octave_uint32,
                           arg2: *const int16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_lt285(arg1: *const octave_uint32, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_le285(arg1: *const octave_uint32, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_ge285(arg1: *const octave_uint32, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_gt285(arg1: *const octave_uint32, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_eq288(arg1: *const octave_uint32, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_ne288(arg1: *const octave_uint32, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_and290(arg1: *const octave_uint32,
                        arg2: *const uint16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_or290(arg1: *const octave_uint32, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_and_not145(arg1: *const octave_uint32,
                            arg2: *const uint16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_or_not145(arg1: *const octave_uint32,
                           arg2: *const uint16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_lt286(arg1: *const octave_uint32, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_le286(arg1: *const octave_uint32, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_ge286(arg1: *const octave_uint32, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_gt286(arg1: *const octave_uint32, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_eq289(arg1: *const octave_uint32, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_ne289(arg1: *const octave_uint32, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_and291(arg1: *const octave_uint32, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_or291(arg1: *const octave_uint32, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_and_not146(arg1: *const octave_uint32,
                            arg2: *const int32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_or_not146(arg1: *const octave_uint32,
                           arg2: *const int32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_lt287(arg1: *const octave_uint32, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_le287(arg1: *const octave_uint32, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_ge287(arg1: *const octave_uint32, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_gt287(arg1: *const octave_uint32, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_eq290(arg1: *const octave_uint32, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_ne290(arg1: *const octave_uint32, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_and292(arg1: *const octave_uint32, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_or292(arg1: *const octave_uint32, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_and_not147(arg1: *const octave_uint32,
                            arg2: *const int64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_or_not147(arg1: *const octave_uint32,
                           arg2: *const int64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_lt288(arg1: *const octave_uint32, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_le288(arg1: *const octave_uint32, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_ge288(arg1: *const octave_uint32, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_gt288(arg1: *const octave_uint32, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_eq291(arg1: *const octave_uint32, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_ne291(arg1: *const octave_uint32, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_and293(arg1: *const octave_uint32,
                        arg2: *const uint64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_or293(arg1: *const octave_uint32, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_and_not148(arg1: *const octave_uint32,
                            arg2: *const uint64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@I@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_or_not148(arg1: *const octave_uint32,
                           arg2: *const uint64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_lt289(arg1: *const octave_uint64, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_le289(arg1: *const octave_uint64, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_ge289(arg1: *const octave_uint64, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_gt289(arg1: *const octave_uint64, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_eq292(arg1: *const octave_uint64, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_ne292(arg1: *const octave_uint64, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_and294(arg1: *const octave_uint64, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_or294(arg1: *const octave_uint64, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_and_not149(arg1: *const octave_uint64,
                            arg2: *const int8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_or_not149(arg1: *const octave_uint64,
                           arg2: *const int8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_lt290(arg1: *const octave_uint64, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_le290(arg1: *const octave_uint64, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_ge290(arg1: *const octave_uint64, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_gt290(arg1: *const octave_uint64, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_eq293(arg1: *const octave_uint64, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_ne293(arg1: *const octave_uint64, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_and295(arg1: *const octave_uint64, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_or295(arg1: *const octave_uint64, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_and_not150(arg1: *const octave_uint64,
                            arg2: *const uint8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_or_not150(arg1: *const octave_uint64,
                           arg2: *const uint8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_lt291(arg1: *const octave_uint64, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_le291(arg1: *const octave_uint64, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_ge291(arg1: *const octave_uint64, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_gt291(arg1: *const octave_uint64, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_eq294(arg1: *const octave_uint64, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_ne294(arg1: *const octave_uint64, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_and296(arg1: *const octave_uint64, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_or296(arg1: *const octave_uint64, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_and_not151(arg1: *const octave_uint64,
                            arg2: *const int16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_or_not151(arg1: *const octave_uint64,
                           arg2: *const int16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_lt292(arg1: *const octave_uint64, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_le292(arg1: *const octave_uint64, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_ge292(arg1: *const octave_uint64, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_gt292(arg1: *const octave_uint64, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_eq295(arg1: *const octave_uint64, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_ne295(arg1: *const octave_uint64, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_and297(arg1: *const octave_uint64,
                        arg2: *const uint16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_or297(arg1: *const octave_uint64, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_and_not152(arg1: *const octave_uint64,
                            arg2: *const uint16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_or_not152(arg1: *const octave_uint64,
                           arg2: *const uint16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_lt293(arg1: *const octave_uint64, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_le293(arg1: *const octave_uint64, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_ge293(arg1: *const octave_uint64, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_gt293(arg1: *const octave_uint64, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_eq296(arg1: *const octave_uint64, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_ne296(arg1: *const octave_uint64, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_and298(arg1: *const octave_uint64, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_or298(arg1: *const octave_uint64, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_and_not153(arg1: *const octave_uint64,
                            arg2: *const int32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_or_not153(arg1: *const octave_uint64,
                           arg2: *const int32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_lt294(arg1: *const octave_uint64, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_le294(arg1: *const octave_uint64, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_ge294(arg1: *const octave_uint64, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_gt294(arg1: *const octave_uint64, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_eq297(arg1: *const octave_uint64, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_ne297(arg1: *const octave_uint64, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_and299(arg1: *const octave_uint64,
                        arg2: *const uint32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_or299(arg1: *const octave_uint64, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_and_not154(arg1: *const octave_uint64,
                            arg2: *const uint32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_or_not154(arg1: *const octave_uint64,
                           arg2: *const uint32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_lt295(arg1: *const octave_uint64, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_le295(arg1: *const octave_uint64, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_ge295(arg1: *const octave_uint64, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_gt295(arg1: *const octave_uint64, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_eq298(arg1: *const octave_uint64, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_ne298(arg1: *const octave_uint64, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_and300(arg1: *const octave_uint64, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_or300(arg1: *const octave_uint64, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_and_not155(arg1: *const octave_uint64,
                            arg2: *const int64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$octave_int@_K@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_or_not155(arg1: *const octave_uint64,
                           arg2: *const int64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_lt296(arg1: *const int8NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_le296(arg1: *const int8NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_ge296(arg1: *const int8NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_gt296(arg1: *const int8NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_eq299(arg1: *const int8NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_ne299(arg1: *const int8NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_and301(arg1: *const int8NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_or301(arg1: *const int8NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_and_not156(arg1: *const int8NDArray,
                            arg2: *const uint8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_or_not156(arg1: *const int8NDArray,
                           arg2: *const uint8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_not_and156(arg1: *const int8NDArray,
                            arg2: *const uint8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_not_or156(arg1: *const int8NDArray,
                           arg2: *const uint8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_lt297(arg1: *const int8NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_le297(arg1: *const int8NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_ge297(arg1: *const int8NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_gt297(arg1: *const int8NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_eq300(arg1: *const int8NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_ne300(arg1: *const int8NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_and302(arg1: *const int8NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_or302(arg1: *const int8NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_and_not157(arg1: *const int8NDArray,
                            arg2: *const int16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_or_not157(arg1: *const int8NDArray,
                           arg2: *const int16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_not_and157(arg1: *const int8NDArray,
                            arg2: *const int16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_not_or157(arg1: *const int8NDArray,
                           arg2: *const int16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_lt298(arg1: *const int8NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_le298(arg1: *const int8NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_ge298(arg1: *const int8NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_gt298(arg1: *const int8NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_eq301(arg1: *const int8NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_ne301(arg1: *const int8NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_and303(arg1: *const int8NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_or303(arg1: *const int8NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_and_not158(arg1: *const int8NDArray,
                            arg2: *const uint16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_or_not158(arg1: *const int8NDArray,
                           arg2: *const uint16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_not_and158(arg1: *const int8NDArray,
                            arg2: *const uint16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_not_or158(arg1: *const int8NDArray,
                           arg2: *const uint16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_lt299(arg1: *const int8NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_le299(arg1: *const int8NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_ge299(arg1: *const int8NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_gt299(arg1: *const int8NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_eq302(arg1: *const int8NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_ne302(arg1: *const int8NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_and304(arg1: *const int8NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_or304(arg1: *const int8NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_and_not159(arg1: *const int8NDArray,
                            arg2: *const int32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_or_not159(arg1: *const int8NDArray,
                           arg2: *const int32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_not_and159(arg1: *const int8NDArray,
                            arg2: *const int32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_not_or159(arg1: *const int8NDArray,
                           arg2: *const int32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_lt300(arg1: *const int8NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_le300(arg1: *const int8NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_ge300(arg1: *const int8NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_gt300(arg1: *const int8NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_eq303(arg1: *const int8NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_ne303(arg1: *const int8NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_and305(arg1: *const int8NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_or305(arg1: *const int8NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_and_not160(arg1: *const int8NDArray,
                            arg2: *const uint32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_or_not160(arg1: *const int8NDArray,
                           arg2: *const uint32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_not_and160(arg1: *const int8NDArray,
                            arg2: *const uint32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_not_or160(arg1: *const int8NDArray,
                           arg2: *const uint32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_lt301(arg1: *const int8NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_le301(arg1: *const int8NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_ge301(arg1: *const int8NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_gt301(arg1: *const int8NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_eq304(arg1: *const int8NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_ne304(arg1: *const int8NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_and306(arg1: *const int8NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_or306(arg1: *const int8NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_and_not161(arg1: *const int8NDArray,
                            arg2: *const int64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_or_not161(arg1: *const int8NDArray,
                           arg2: *const int64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_not_and161(arg1: *const int8NDArray,
                            arg2: *const int64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_not_or161(arg1: *const int8NDArray,
                           arg2: *const int64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_lt302(arg1: *const int8NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_le302(arg1: *const int8NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_ge302(arg1: *const int8NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_gt302(arg1: *const int8NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_eq305(arg1: *const int8NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_ne305(arg1: *const int8NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_and307(arg1: *const int8NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_or307(arg1: *const int8NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_and_not162(arg1: *const int8NDArray,
                            arg2: *const uint64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_or_not162(arg1: *const int8NDArray,
                           arg2: *const uint64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_not_and162(arg1: *const int8NDArray,
                            arg2: *const uint64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@C@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_not_or162(arg1: *const int8NDArray,
                           arg2: *const uint64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_lt303(arg1: *const int16NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_le303(arg1: *const int16NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_ge303(arg1: *const int16NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_gt303(arg1: *const int16NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_eq306(arg1: *const int16NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_ne306(arg1: *const int16NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_and308(arg1: *const int16NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_or308(arg1: *const int16NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_and_not163(arg1: *const int16NDArray,
                            arg2: *const int8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_or_not163(arg1: *const int16NDArray,
                           arg2: *const int8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_not_and163(arg1: *const int16NDArray,
                            arg2: *const int8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_not_or163(arg1: *const int16NDArray,
                           arg2: *const int8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_lt304(arg1: *const int16NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_le304(arg1: *const int16NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_ge304(arg1: *const int16NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_gt304(arg1: *const int16NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_eq307(arg1: *const int16NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_ne307(arg1: *const int16NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_and309(arg1: *const int16NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_or309(arg1: *const int16NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_and_not164(arg1: *const int16NDArray,
                            arg2: *const uint8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_or_not164(arg1: *const int16NDArray,
                           arg2: *const uint8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_not_and164(arg1: *const int16NDArray,
                            arg2: *const uint8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_not_or164(arg1: *const int16NDArray,
                           arg2: *const uint8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_lt305(arg1: *const int16NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_le305(arg1: *const int16NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_ge305(arg1: *const int16NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_gt305(arg1: *const int16NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_eq308(arg1: *const int16NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_ne308(arg1: *const int16NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_and310(arg1: *const int16NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_or310(arg1: *const int16NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_and_not165(arg1: *const int16NDArray,
                            arg2: *const uint16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_or_not165(arg1: *const int16NDArray,
                           arg2: *const uint16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_not_and165(arg1: *const int16NDArray,
                            arg2: *const uint16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_not_or165(arg1: *const int16NDArray,
                           arg2: *const uint16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_lt306(arg1: *const int16NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_le306(arg1: *const int16NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_ge306(arg1: *const int16NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_gt306(arg1: *const int16NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_eq309(arg1: *const int16NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_ne309(arg1: *const int16NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_and311(arg1: *const int16NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_or311(arg1: *const int16NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_and_not166(arg1: *const int16NDArray,
                            arg2: *const int32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_or_not166(arg1: *const int16NDArray,
                           arg2: *const int32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_not_and166(arg1: *const int16NDArray,
                            arg2: *const int32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_not_or166(arg1: *const int16NDArray,
                           arg2: *const int32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_lt307(arg1: *const int16NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_le307(arg1: *const int16NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_ge307(arg1: *const int16NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_gt307(arg1: *const int16NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_eq310(arg1: *const int16NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_ne310(arg1: *const int16NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_and312(arg1: *const int16NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_or312(arg1: *const int16NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_and_not167(arg1: *const int16NDArray,
                            arg2: *const uint32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_or_not167(arg1: *const int16NDArray,
                           arg2: *const uint32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_not_and167(arg1: *const int16NDArray,
                            arg2: *const uint32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_not_or167(arg1: *const int16NDArray,
                           arg2: *const uint32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_lt308(arg1: *const int16NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_le308(arg1: *const int16NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_ge308(arg1: *const int16NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_gt308(arg1: *const int16NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_eq311(arg1: *const int16NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_ne311(arg1: *const int16NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_and313(arg1: *const int16NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_or313(arg1: *const int16NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_and_not168(arg1: *const int16NDArray,
                            arg2: *const int64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_or_not168(arg1: *const int16NDArray,
                           arg2: *const int64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_not_and168(arg1: *const int16NDArray,
                            arg2: *const int64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_not_or168(arg1: *const int16NDArray,
                           arg2: *const int64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_lt309(arg1: *const int16NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_le309(arg1: *const int16NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_ge309(arg1: *const int16NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_gt309(arg1: *const int16NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_eq312(arg1: *const int16NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_ne312(arg1: *const int16NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_and314(arg1: *const int16NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_or314(arg1: *const int16NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_and_not169(arg1: *const int16NDArray,
                            arg2: *const uint64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_or_not169(arg1: *const int16NDArray,
                           arg2: *const uint64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_not_and169(arg1: *const int16NDArray,
                            arg2: *const uint64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@F@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_not_or169(arg1: *const int16NDArray,
                           arg2: *const uint64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_lt310(arg1: *const int32NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_le310(arg1: *const int32NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_ge310(arg1: *const int32NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_gt310(arg1: *const int32NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_eq313(arg1: *const int32NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_ne313(arg1: *const int32NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_and315(arg1: *const int32NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_or315(arg1: *const int32NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_and_not170(arg1: *const int32NDArray,
                            arg2: *const int8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_or_not170(arg1: *const int32NDArray,
                           arg2: *const int8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_not_and170(arg1: *const int32NDArray,
                            arg2: *const int8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_not_or170(arg1: *const int32NDArray,
                           arg2: *const int8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_lt311(arg1: *const int32NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_le311(arg1: *const int32NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_ge311(arg1: *const int32NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_gt311(arg1: *const int32NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_eq314(arg1: *const int32NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_ne314(arg1: *const int32NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_and316(arg1: *const int32NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_or316(arg1: *const int32NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_and_not171(arg1: *const int32NDArray,
                            arg2: *const uint8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_or_not171(arg1: *const int32NDArray,
                           arg2: *const uint8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_not_and171(arg1: *const int32NDArray,
                            arg2: *const uint8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_not_or171(arg1: *const int32NDArray,
                           arg2: *const uint8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_lt312(arg1: *const int32NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_le312(arg1: *const int32NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_ge312(arg1: *const int32NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_gt312(arg1: *const int32NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_eq315(arg1: *const int32NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_ne315(arg1: *const int32NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_and317(arg1: *const int32NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_or317(arg1: *const int32NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_and_not172(arg1: *const int32NDArray,
                            arg2: *const int16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_or_not172(arg1: *const int32NDArray,
                           arg2: *const int16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_not_and172(arg1: *const int32NDArray,
                            arg2: *const int16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_not_or172(arg1: *const int32NDArray,
                           arg2: *const int16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_lt313(arg1: *const int32NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_le313(arg1: *const int32NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_ge313(arg1: *const int32NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_gt313(arg1: *const int32NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_eq316(arg1: *const int32NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_ne316(arg1: *const int32NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_and318(arg1: *const int32NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_or318(arg1: *const int32NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_and_not173(arg1: *const int32NDArray,
                            arg2: *const uint16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_or_not173(arg1: *const int32NDArray,
                           arg2: *const uint16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_not_and173(arg1: *const int32NDArray,
                            arg2: *const uint16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_not_or173(arg1: *const int32NDArray,
                           arg2: *const uint16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_lt314(arg1: *const int32NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_le314(arg1: *const int32NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_ge314(arg1: *const int32NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_gt314(arg1: *const int32NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_eq317(arg1: *const int32NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_ne317(arg1: *const int32NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_and319(arg1: *const int32NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_or319(arg1: *const int32NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_and_not174(arg1: *const int32NDArray,
                            arg2: *const uint32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_or_not174(arg1: *const int32NDArray,
                           arg2: *const uint32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_not_and174(arg1: *const int32NDArray,
                            arg2: *const uint32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_not_or174(arg1: *const int32NDArray,
                           arg2: *const uint32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_lt315(arg1: *const int32NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_le315(arg1: *const int32NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_ge315(arg1: *const int32NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_gt315(arg1: *const int32NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_eq318(arg1: *const int32NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_ne318(arg1: *const int32NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_and320(arg1: *const int32NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_or320(arg1: *const int32NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_and_not175(arg1: *const int32NDArray,
                            arg2: *const int64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_or_not175(arg1: *const int32NDArray,
                           arg2: *const int64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_not_and175(arg1: *const int32NDArray,
                            arg2: *const int64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_not_or175(arg1: *const int32NDArray,
                           arg2: *const int64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_lt316(arg1: *const int32NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_le316(arg1: *const int32NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_ge316(arg1: *const int32NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_gt316(arg1: *const int32NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_eq319(arg1: *const int32NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_ne319(arg1: *const int32NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_and321(arg1: *const int32NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_or321(arg1: *const int32NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_and_not176(arg1: *const int32NDArray,
                            arg2: *const uint64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_or_not176(arg1: *const int32NDArray,
                           arg2: *const uint64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_not_and176(arg1: *const int32NDArray,
                            arg2: *const uint64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@H@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_not_or176(arg1: *const int32NDArray,
                           arg2: *const uint64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_lt317(arg1: *const int64NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_le317(arg1: *const int64NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_ge317(arg1: *const int64NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_gt317(arg1: *const int64NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_eq320(arg1: *const int64NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_ne320(arg1: *const int64NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_and322(arg1: *const int64NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_or322(arg1: *const int64NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_and_not177(arg1: *const int64NDArray,
                            arg2: *const int8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_or_not177(arg1: *const int64NDArray,
                           arg2: *const int8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_not_and177(arg1: *const int64NDArray,
                            arg2: *const int8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_not_or177(arg1: *const int64NDArray,
                           arg2: *const int8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_lt318(arg1: *const int64NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_le318(arg1: *const int64NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_ge318(arg1: *const int64NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_gt318(arg1: *const int64NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_eq321(arg1: *const int64NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_ne321(arg1: *const int64NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_and323(arg1: *const int64NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_or323(arg1: *const int64NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_and_not178(arg1: *const int64NDArray,
                            arg2: *const uint8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_or_not178(arg1: *const int64NDArray,
                           arg2: *const uint8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_not_and178(arg1: *const int64NDArray,
                            arg2: *const uint8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_not_or178(arg1: *const int64NDArray,
                           arg2: *const uint8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_lt319(arg1: *const int64NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_le319(arg1: *const int64NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_ge319(arg1: *const int64NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_gt319(arg1: *const int64NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_eq322(arg1: *const int64NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_ne322(arg1: *const int64NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_and324(arg1: *const int64NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_or324(arg1: *const int64NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_and_not179(arg1: *const int64NDArray,
                            arg2: *const int16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_or_not179(arg1: *const int64NDArray,
                           arg2: *const int16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_not_and179(arg1: *const int64NDArray,
                            arg2: *const int16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_not_or179(arg1: *const int64NDArray,
                           arg2: *const int16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_lt320(arg1: *const int64NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_le320(arg1: *const int64NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_ge320(arg1: *const int64NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_gt320(arg1: *const int64NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_eq323(arg1: *const int64NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_ne323(arg1: *const int64NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_and325(arg1: *const int64NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_or325(arg1: *const int64NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_and_not180(arg1: *const int64NDArray,
                            arg2: *const uint16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_or_not180(arg1: *const int64NDArray,
                           arg2: *const uint16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_not_and180(arg1: *const int64NDArray,
                            arg2: *const uint16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_not_or180(arg1: *const int64NDArray,
                           arg2: *const uint16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_lt321(arg1: *const int64NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_le321(arg1: *const int64NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_ge321(arg1: *const int64NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_gt321(arg1: *const int64NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_eq324(arg1: *const int64NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_ne324(arg1: *const int64NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_and326(arg1: *const int64NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_or326(arg1: *const int64NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_and_not181(arg1: *const int64NDArray,
                            arg2: *const int32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_or_not181(arg1: *const int64NDArray,
                           arg2: *const int32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_not_and181(arg1: *const int64NDArray,
                            arg2: *const int32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_not_or181(arg1: *const int64NDArray,
                           arg2: *const int32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_lt322(arg1: *const int64NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_le322(arg1: *const int64NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_ge322(arg1: *const int64NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_gt322(arg1: *const int64NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_eq325(arg1: *const int64NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_ne325(arg1: *const int64NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_and327(arg1: *const int64NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_or327(arg1: *const int64NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_and_not182(arg1: *const int64NDArray,
                            arg2: *const uint32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_or_not182(arg1: *const int64NDArray,
                           arg2: *const uint32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_not_and182(arg1: *const int64NDArray,
                            arg2: *const uint32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_not_or182(arg1: *const int64NDArray,
                           arg2: *const uint32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_lt323(arg1: *const int64NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_le323(arg1: *const int64NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_ge323(arg1: *const int64NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_gt323(arg1: *const int64NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_eq326(arg1: *const int64NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_ne326(arg1: *const int64NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_and328(arg1: *const int64NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_or328(arg1: *const int64NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_and_not183(arg1: *const int64NDArray,
                            arg2: *const uint64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_or_not183(arg1: *const int64NDArray,
                           arg2: *const uint64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_not_and183(arg1: *const int64NDArray,
                            arg2: *const uint64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_J@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_not_or183(arg1: *const int64NDArray,
                           arg2: *const uint64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_lt324(arg1: *const uint8NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_le324(arg1: *const uint8NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_ge324(arg1: *const uint8NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_gt324(arg1: *const uint8NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_eq327(arg1: *const uint8NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_ne327(arg1: *const uint8NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_and329(arg1: *const uint8NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_or329(arg1: *const uint8NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_and_not184(arg1: *const uint8NDArray,
                            arg2: *const int8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_or_not184(arg1: *const uint8NDArray,
                           arg2: *const int8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_not_and184(arg1: *const uint8NDArray,
                            arg2: *const int8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_not_or184(arg1: *const uint8NDArray,
                           arg2: *const int8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_lt325(arg1: *const uint8NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_le325(arg1: *const uint8NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_ge325(arg1: *const uint8NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_gt325(arg1: *const uint8NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_eq328(arg1: *const uint8NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_ne328(arg1: *const uint8NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_and330(arg1: *const uint8NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_or330(arg1: *const uint8NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_and_not185(arg1: *const uint8NDArray,
                            arg2: *const int16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_or_not185(arg1: *const uint8NDArray,
                           arg2: *const int16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_not_and185(arg1: *const uint8NDArray,
                            arg2: *const int16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_not_or185(arg1: *const uint8NDArray,
                           arg2: *const int16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_lt326(arg1: *const uint8NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_le326(arg1: *const uint8NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_ge326(arg1: *const uint8NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_gt326(arg1: *const uint8NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_eq329(arg1: *const uint8NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_ne329(arg1: *const uint8NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_and331(arg1: *const uint8NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_or331(arg1: *const uint8NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_and_not186(arg1: *const uint8NDArray,
                            arg2: *const uint16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_or_not186(arg1: *const uint8NDArray,
                           arg2: *const uint16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_not_and186(arg1: *const uint8NDArray,
                            arg2: *const uint16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_not_or186(arg1: *const uint8NDArray,
                           arg2: *const uint16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_lt327(arg1: *const uint8NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_le327(arg1: *const uint8NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_ge327(arg1: *const uint8NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_gt327(arg1: *const uint8NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_eq330(arg1: *const uint8NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_ne330(arg1: *const uint8NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_and332(arg1: *const uint8NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_or332(arg1: *const uint8NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_and_not187(arg1: *const uint8NDArray,
                            arg2: *const int32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_or_not187(arg1: *const uint8NDArray,
                           arg2: *const int32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_not_and187(arg1: *const uint8NDArray,
                            arg2: *const int32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_not_or187(arg1: *const uint8NDArray,
                           arg2: *const int32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_lt328(arg1: *const uint8NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_le328(arg1: *const uint8NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_ge328(arg1: *const uint8NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_gt328(arg1: *const uint8NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_eq331(arg1: *const uint8NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_ne331(arg1: *const uint8NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_and333(arg1: *const uint8NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_or333(arg1: *const uint8NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_and_not188(arg1: *const uint8NDArray,
                            arg2: *const uint32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_or_not188(arg1: *const uint8NDArray,
                           arg2: *const uint32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_not_and188(arg1: *const uint8NDArray,
                            arg2: *const uint32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_not_or188(arg1: *const uint8NDArray,
                           arg2: *const uint32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_lt329(arg1: *const uint8NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_le329(arg1: *const uint8NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_ge329(arg1: *const uint8NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_gt329(arg1: *const uint8NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_eq332(arg1: *const uint8NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_ne332(arg1: *const uint8NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_and334(arg1: *const uint8NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_or334(arg1: *const uint8NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_and_not189(arg1: *const uint8NDArray,
                            arg2: *const int64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_or_not189(arg1: *const uint8NDArray,
                           arg2: *const int64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_not_and189(arg1: *const uint8NDArray,
                            arg2: *const int64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_not_or189(arg1: *const uint8NDArray,
                           arg2: *const int64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_lt330(arg1: *const uint8NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_le330(arg1: *const uint8NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_ge330(arg1: *const uint8NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_gt330(arg1: *const uint8NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_eq333(arg1: *const uint8NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_ne333(arg1: *const uint8NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_and335(arg1: *const uint8NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_or335(arg1: *const uint8NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_and_not190(arg1: *const uint8NDArray,
                            arg2: *const uint64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_or_not190(arg1: *const uint8NDArray,
                           arg2: *const uint64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_not_and190(arg1: *const uint8NDArray,
                            arg2: *const uint64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@E@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_not_or190(arg1: *const uint8NDArray,
                           arg2: *const uint64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_lt331(arg1: *const uint16NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_le331(arg1: *const uint16NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_ge331(arg1: *const uint16NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_gt331(arg1: *const uint16NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_eq334(arg1: *const uint16NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_ne334(arg1: *const uint16NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_and336(arg1: *const uint16NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_or336(arg1: *const uint16NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_and_not191(arg1: *const uint16NDArray,
                            arg2: *const int8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_or_not191(arg1: *const uint16NDArray,
                           arg2: *const int8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_not_and191(arg1: *const uint16NDArray,
                            arg2: *const int8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_not_or191(arg1: *const uint16NDArray,
                           arg2: *const int8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_lt332(arg1: *const uint16NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_le332(arg1: *const uint16NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_ge332(arg1: *const uint16NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_gt332(arg1: *const uint16NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_eq335(arg1: *const uint16NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_ne335(arg1: *const uint16NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_and337(arg1: *const uint16NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_or337(arg1: *const uint16NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_and_not192(arg1: *const uint16NDArray,
                            arg2: *const uint8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_or_not192(arg1: *const uint16NDArray,
                           arg2: *const uint8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_not_and192(arg1: *const uint16NDArray,
                            arg2: *const uint8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_not_or192(arg1: *const uint16NDArray,
                           arg2: *const uint8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_lt333(arg1: *const uint16NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_le333(arg1: *const uint16NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_ge333(arg1: *const uint16NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_gt333(arg1: *const uint16NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_eq336(arg1: *const uint16NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_ne336(arg1: *const uint16NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_and338(arg1: *const uint16NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_or338(arg1: *const uint16NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_and_not193(arg1: *const uint16NDArray,
                            arg2: *const int16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_or_not193(arg1: *const uint16NDArray,
                           arg2: *const int16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_not_and193(arg1: *const uint16NDArray,
                            arg2: *const int16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_not_or193(arg1: *const uint16NDArray,
                           arg2: *const int16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_lt334(arg1: *const uint16NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_le334(arg1: *const uint16NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_ge334(arg1: *const uint16NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_gt334(arg1: *const uint16NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_eq337(arg1: *const uint16NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_ne337(arg1: *const uint16NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_and339(arg1: *const uint16NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_or339(arg1: *const uint16NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_and_not194(arg1: *const uint16NDArray,
                            arg2: *const int32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_or_not194(arg1: *const uint16NDArray,
                           arg2: *const int32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_not_and194(arg1: *const uint16NDArray,
                            arg2: *const int32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_not_or194(arg1: *const uint16NDArray,
                           arg2: *const int32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_lt335(arg1: *const uint16NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_le335(arg1: *const uint16NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_ge335(arg1: *const uint16NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_gt335(arg1: *const uint16NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_eq338(arg1: *const uint16NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_ne338(arg1: *const uint16NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_and340(arg1: *const uint16NDArray,
                        arg2: *const uint32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_or340(arg1: *const uint16NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_and_not195(arg1: *const uint16NDArray,
                            arg2: *const uint32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_or_not195(arg1: *const uint16NDArray,
                           arg2: *const uint32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_not_and195(arg1: *const uint16NDArray,
                            arg2: *const uint32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_not_or195(arg1: *const uint16NDArray,
                           arg2: *const uint32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_lt336(arg1: *const uint16NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_le336(arg1: *const uint16NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_ge336(arg1: *const uint16NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_gt336(arg1: *const uint16NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_eq339(arg1: *const uint16NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_ne339(arg1: *const uint16NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_and341(arg1: *const uint16NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_or341(arg1: *const uint16NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_and_not196(arg1: *const uint16NDArray,
                            arg2: *const int64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_or_not196(arg1: *const uint16NDArray,
                           arg2: *const int64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_not_and196(arg1: *const uint16NDArray,
                            arg2: *const int64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_not_or196(arg1: *const uint16NDArray,
                           arg2: *const int64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_lt337(arg1: *const uint16NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_le337(arg1: *const uint16NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_ge337(arg1: *const uint16NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_gt337(arg1: *const uint16NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_eq340(arg1: *const uint16NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_ne340(arg1: *const uint16NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_and342(arg1: *const uint16NDArray,
                        arg2: *const uint64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_or342(arg1: *const uint16NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_and_not197(arg1: *const uint16NDArray,
                            arg2: *const uint64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_or_not197(arg1: *const uint16NDArray,
                           arg2: *const uint64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_not_and197(arg1: *const uint16NDArray,
                            arg2: *const uint64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@G@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_not_or197(arg1: *const uint16NDArray,
                           arg2: *const uint64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_lt338(arg1: *const uint32NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_le338(arg1: *const uint32NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_ge338(arg1: *const uint32NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_gt338(arg1: *const uint32NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_eq341(arg1: *const uint32NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_ne341(arg1: *const uint32NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_and343(arg1: *const uint32NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_or343(arg1: *const uint32NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_and_not198(arg1: *const uint32NDArray,
                            arg2: *const int8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_or_not198(arg1: *const uint32NDArray,
                           arg2: *const int8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_not_and198(arg1: *const uint32NDArray,
                            arg2: *const int8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_not_or198(arg1: *const uint32NDArray,
                           arg2: *const int8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_lt339(arg1: *const uint32NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_le339(arg1: *const uint32NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_ge339(arg1: *const uint32NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_gt339(arg1: *const uint32NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_eq342(arg1: *const uint32NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_ne342(arg1: *const uint32NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_and344(arg1: *const uint32NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_or344(arg1: *const uint32NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_and_not199(arg1: *const uint32NDArray,
                            arg2: *const uint8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_or_not199(arg1: *const uint32NDArray,
                           arg2: *const uint8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_not_and199(arg1: *const uint32NDArray,
                            arg2: *const uint8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_not_or199(arg1: *const uint32NDArray,
                           arg2: *const uint8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_lt340(arg1: *const uint32NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_le340(arg1: *const uint32NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_ge340(arg1: *const uint32NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_gt340(arg1: *const uint32NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_eq343(arg1: *const uint32NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_ne343(arg1: *const uint32NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_and345(arg1: *const uint32NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_or345(arg1: *const uint32NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_and_not200(arg1: *const uint32NDArray,
                            arg2: *const int16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_or_not200(arg1: *const uint32NDArray,
                           arg2: *const int16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_not_and200(arg1: *const uint32NDArray,
                            arg2: *const int16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_not_or200(arg1: *const uint32NDArray,
                           arg2: *const int16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_lt341(arg1: *const uint32NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_le341(arg1: *const uint32NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_ge341(arg1: *const uint32NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_gt341(arg1: *const uint32NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_eq344(arg1: *const uint32NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_ne344(arg1: *const uint32NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_and346(arg1: *const uint32NDArray,
                        arg2: *const uint16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_or346(arg1: *const uint32NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_and_not201(arg1: *const uint32NDArray,
                            arg2: *const uint16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_or_not201(arg1: *const uint32NDArray,
                           arg2: *const uint16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_not_and201(arg1: *const uint32NDArray,
                            arg2: *const uint16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_not_or201(arg1: *const uint32NDArray,
                           arg2: *const uint16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_lt342(arg1: *const uint32NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_le342(arg1: *const uint32NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_ge342(arg1: *const uint32NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_gt342(arg1: *const uint32NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_eq345(arg1: *const uint32NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_ne345(arg1: *const uint32NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_and347(arg1: *const uint32NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_or347(arg1: *const uint32NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_and_not202(arg1: *const uint32NDArray,
                            arg2: *const int32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_or_not202(arg1: *const uint32NDArray,
                           arg2: *const int32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_not_and202(arg1: *const uint32NDArray,
                            arg2: *const int32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_not_or202(arg1: *const uint32NDArray,
                           arg2: *const int32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_lt343(arg1: *const uint32NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_le343(arg1: *const uint32NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_ge343(arg1: *const uint32NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_gt343(arg1: *const uint32NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_eq346(arg1: *const uint32NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_ne346(arg1: *const uint32NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_and348(arg1: *const uint32NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_or348(arg1: *const uint32NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_and_not203(arg1: *const uint32NDArray,
                            arg2: *const int64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_or_not203(arg1: *const uint32NDArray,
                           arg2: *const int64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_not_and203(arg1: *const uint32NDArray,
                            arg2: *const int64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_not_or203(arg1: *const uint32NDArray,
                           arg2: *const int64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_lt344(arg1: *const uint32NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_le344(arg1: *const uint32NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_ge344(arg1: *const uint32NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_gt344(arg1: *const uint32NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_eq347(arg1: *const uint32NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_ne347(arg1: *const uint32NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_and349(arg1: *const uint32NDArray,
                        arg2: *const uint64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_or349(arg1: *const uint32NDArray, arg2: *const uint64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_and_not204(arg1: *const uint32NDArray,
                            arg2: *const uint64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_or_not204(arg1: *const uint32NDArray,
                           arg2: *const uint64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_not_and204(arg1: *const uint32NDArray,
                            arg2: *const uint64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@I@@@@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn mx_el_not_or204(arg1: *const uint32NDArray,
                           arg2: *const uint64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_lt345(arg1: *const uint64NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_le345(arg1: *const uint64NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_ge345(arg1: *const uint64NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_gt345(arg1: *const uint64NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_eq348(arg1: *const uint64NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_ne348(arg1: *const uint64NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_and350(arg1: *const uint64NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_or350(arg1: *const uint64NDArray, arg2: *const int8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_and_not205(arg1: *const uint64NDArray,
                            arg2: *const int8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_or_not205(arg1: *const uint64NDArray,
                           arg2: *const int8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_not_and205(arg1: *const uint64NDArray,
                            arg2: *const int8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn mx_el_not_or205(arg1: *const uint64NDArray,
                           arg2: *const int8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_lt346(arg1: *const uint64NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_le346(arg1: *const uint64NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_ge346(arg1: *const uint64NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_gt346(arg1: *const uint64NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_eq349(arg1: *const uint64NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_ne349(arg1: *const uint64NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_and351(arg1: *const uint64NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_or351(arg1: *const uint64NDArray, arg2: *const uint8NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_and_not206(arg1: *const uint64NDArray,
                            arg2: *const uint8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_or_not206(arg1: *const uint64NDArray,
                           arg2: *const uint8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_not_and206(arg1: *const uint64NDArray,
                            arg2: *const uint8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn mx_el_not_or206(arg1: *const uint64NDArray,
                           arg2: *const uint8NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_lt347(arg1: *const uint64NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_le347(arg1: *const uint64NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_ge347(arg1: *const uint64NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_gt347(arg1: *const uint64NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_eq350(arg1: *const uint64NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_ne350(arg1: *const uint64NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_and352(arg1: *const uint64NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_or352(arg1: *const uint64NDArray, arg2: *const int16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_and_not207(arg1: *const uint64NDArray,
                            arg2: *const int16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_or_not207(arg1: *const uint64NDArray,
                           arg2: *const int16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_not_and207(arg1: *const uint64NDArray,
                            arg2: *const int16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn mx_el_not_or207(arg1: *const uint64NDArray,
                           arg2: *const int16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_lt348(arg1: *const uint64NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_le348(arg1: *const uint64NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_ge348(arg1: *const uint64NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_gt348(arg1: *const uint64NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_eq351(arg1: *const uint64NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_ne351(arg1: *const uint64NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_and353(arg1: *const uint64NDArray,
                        arg2: *const uint16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_or353(arg1: *const uint64NDArray, arg2: *const uint16NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_and_not208(arg1: *const uint64NDArray,
                            arg2: *const uint16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_or_not208(arg1: *const uint64NDArray,
                           arg2: *const uint16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_not_and208(arg1: *const uint64NDArray,
                            arg2: *const uint16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn mx_el_not_or208(arg1: *const uint64NDArray,
                           arg2: *const uint16NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_lt349(arg1: *const uint64NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_le349(arg1: *const uint64NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_ge349(arg1: *const uint64NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_gt349(arg1: *const uint64NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_eq352(arg1: *const uint64NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_ne352(arg1: *const uint64NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_and354(arg1: *const uint64NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_or354(arg1: *const uint64NDArray, arg2: *const int32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_and_not209(arg1: *const uint64NDArray,
                            arg2: *const int32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_or_not209(arg1: *const uint64NDArray,
                           arg2: *const int32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_not_and209(arg1: *const uint64NDArray,
                            arg2: *const int32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn mx_el_not_or209(arg1: *const uint64NDArray,
                           arg2: *const int32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_lt350(arg1: *const uint64NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_le350(arg1: *const uint64NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_ge350(arg1: *const uint64NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_gt350(arg1: *const uint64NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_eq353(arg1: *const uint64NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_ne353(arg1: *const uint64NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_and355(arg1: *const uint64NDArray,
                        arg2: *const uint32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_or355(arg1: *const uint64NDArray, arg2: *const uint32NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_and_not210(arg1: *const uint64NDArray,
                            arg2: *const uint32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_or_not210(arg1: *const uint64NDArray,
                           arg2: *const uint32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_not_and210(arg1: *const uint64NDArray,
                            arg2: *const uint32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn mx_el_not_or210(arg1: *const uint64NDArray,
                           arg2: *const uint32NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_lt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_lt351(arg1: *const uint64NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_le@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_le351(arg1: *const uint64NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ge@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_ge351(arg1: *const uint64NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_gt@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_gt351(arg1: *const uint64NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_eq@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_eq354(arg1: *const uint64NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_ne@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_ne354(arg1: *const uint64NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_and356(arg1: *const uint64NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_or356(arg1: *const uint64NDArray, arg2: *const int64NDArray)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_and_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_and_not211(arg1: *const uint64NDArray,
                            arg2: *const int64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_or_not@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_or_not211(arg1: *const uint64NDArray,
                           arg2: *const int64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_and@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_not_and211(arg1: *const uint64NDArray,
                            arg2: *const int64NDArray) -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?mx_el_not_or@@YA?AVboolNDArray@@AEBV?$intNDArray@V?$octave_int@_K@@@@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn mx_el_not_or211(arg1: *const uint64NDArray,
                           arg2: *const int64NDArray) -> boolNDArray;
}
pub type clock_t = ::std::os::raw::c_long;
extern "C" {
    #[link_name = "_daylight"]
    pub static mut _daylight: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_dstbias"]
    pub static mut _dstbias: ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "_timezone"]
    pub static mut _timezone: ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "_tzname"]
    pub static mut _tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub fn _get_daylight(_Daylight: *mut ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn _get_dstbias(_Daylight_savings_bias: *mut ::std::os::raw::c_long)
     -> errno_t;
}
extern "C" {
    pub fn _get_timezone(_Timezone: *mut ::std::os::raw::c_long) -> errno_t;
}
extern "C" {
    pub fn _get_tzname(_ReturnValue: *mut usize,
                       _Buffer: *mut ::std::os::raw::c_char,
                       _SizeInBytes: usize, _Index: ::std::os::raw::c_int)
     -> errno_t;
}
extern "C" {
    pub fn asctime(_Tm: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn asctime_s(_Buf: *mut ::std::os::raw::c_char, _SizeInWords: usize,
                     _Tm: *const tm) -> errno_t;
}
extern "C" {
    pub fn _ctime32(_Time: *const __time32_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ctime32_s(_Buf: *mut ::std::os::raw::c_char, _SizeInBytes: usize,
                      _Time: *const __time32_t) -> errno_t;
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn _difftime32(_Time1: __time32_t, _Time2: __time32_t) -> f64;
}
extern "C" {
    pub fn _gmtime32(_Time: *const __time32_t) -> *mut tm;
}
extern "C" {
    pub fn _gmtime32_s(_Tm: *mut tm, _Time: *const __time32_t) -> errno_t;
}
extern "C" {
    pub fn _localtime32(_Time: *const __time32_t) -> *mut tm;
}
extern "C" {
    pub fn _localtime32_s(_Tm: *mut tm, _Time: *const __time32_t) -> errno_t;
}
extern "C" {
    pub fn strftime(_Buf: *mut ::std::os::raw::c_char, _SizeInBytes: usize,
                    _Format: *const ::std::os::raw::c_char, _Tm: *const tm)
     -> usize;
}
extern "C" {
    pub fn _strftime_l(_Buf: *mut ::std::os::raw::c_char, _Max_size: usize,
                       _Format: *const ::std::os::raw::c_char, _Tm: *const tm,
                       _Locale: _locale_t) -> usize;
}
extern "C" {
    pub fn _strdate(_Buffer: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strdate_s(_Buf: *mut ::std::os::raw::c_char, _SizeInBytes: usize)
     -> errno_t;
}
extern "C" {
    pub fn _strtime(_Buffer: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strtime_s(_Buf: *mut ::std::os::raw::c_char, _SizeInBytes: usize)
     -> errno_t;
}
extern "C" {
    pub fn _time32(_Time: *mut __time32_t) -> __time32_t;
}
extern "C" {
    pub fn _mktime32(_Tm: *mut tm) -> __time32_t;
}
extern "C" {
    pub fn _mkgmtime32(_Tm: *mut tm) -> __time32_t;
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub fn _tzset();
}
extern "C" {
    pub fn _difftime64(_Time1: __time64_t, _Time2: __time64_t) -> f64;
}
extern "C" {
    pub fn _ctime64(_Time: *const __time64_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ctime64_s(_Buf: *mut ::std::os::raw::c_char, _SizeInBytes: usize,
                      _Time: *const __time64_t) -> errno_t;
}
extern "C" {
    pub fn _gmtime64(_Time: *const __time64_t) -> *mut tm;
}
extern "C" {
    pub fn _gmtime64_s(_Tm: *mut tm, _Time: *const __time64_t) -> errno_t;
}
extern "C" {
    pub fn _localtime64(_Time: *const __time64_t) -> *mut tm;
}
extern "C" {
    pub fn _localtime64_s(_Tm: *mut tm, _Time: *const __time64_t) -> errno_t;
}
extern "C" {
    pub fn _mktime64(_Tm: *mut tm) -> __time64_t;
}
extern "C" {
    pub fn _mkgmtime64(_Tm: *mut tm) -> __time64_t;
}
extern "C" {
    pub fn _time64(_Time: *mut __time64_t) -> __time64_t;
}
extern "C" {
    pub fn _getsystime(_Tm: *mut tm) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _setsystime(_Tm: *mut tm, _MilliSec: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn difftime(_Time1: time_t, _Time2: time_t) -> f64;
}
extern "C" {
    pub fn ctime(_Time: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gmtime(_Time: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(_Time: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn mktime(_Tm: *mut tm) -> time_t;
}
extern "C" {
    pub fn _mkgmtime(_Tm: *mut tm) -> time_t;
}
extern "C" {
    pub fn time(_Time: *mut time_t) -> time_t;
}
extern "C" {
    #[link_name = "daylight"]
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "timezone"]
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "tzname"]
    pub static mut tzname: [*mut ::std::os::raw::c_char; 2usize];
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct timeval {
    pub tv_sec: ::std::os::raw::c_long,
    pub tv_usec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(::std::mem::size_of::<timeval>() , 8usize , concat ! (
               "Size of: " , stringify ! ( timeval ) ));
    assert_eq! (::std::mem::align_of::<timeval>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( timeval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval ) ) . tv_sec as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval ) ) . tv_usec as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval ) , "::" ,
                stringify ! ( tv_usec ) ));
}
impl Clone for timeval {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct timezone {
    pub tz_minuteswest: ::std::os::raw::c_int,
    pub tz_dsttime: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_timezone() {
    assert_eq!(::std::mem::size_of::<timezone>() , 8usize , concat ! (
               "Size of: " , stringify ! ( timezone ) ));
    assert_eq! (::std::mem::align_of::<timezone>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( timezone ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timezone ) ) . tz_minuteswest as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timezone ) , "::" ,
                stringify ! ( tz_minuteswest ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timezone ) ) . tz_dsttime as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( timezone ) , "::" ,
                stringify ! ( tz_dsttime ) ));
}
impl Clone for timezone {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn mingw_gettimeofday(p: *mut timeval, z: *mut timezone)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __timeb32 {
    pub time: __time32_t,
    pub millitm: ::std::os::raw::c_ushort,
    pub timezone: ::std::os::raw::c_short,
    pub dstflag: ::std::os::raw::c_short,
}
#[test]
fn bindgen_test_layout___timeb32() {
    assert_eq!(::std::mem::size_of::<__timeb32>() , 12usize , concat ! (
               "Size of: " , stringify ! ( __timeb32 ) ));
    assert_eq! (::std::mem::align_of::<__timeb32>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( __timeb32 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __timeb32 ) ) . time as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __timeb32 ) , "::" ,
                stringify ! ( time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __timeb32 ) ) . millitm as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __timeb32 ) , "::" ,
                stringify ! ( millitm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __timeb32 ) ) . timezone as * const _ as
                usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( __timeb32 ) , "::" ,
                stringify ! ( timezone ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __timeb32 ) ) . dstflag as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __timeb32 ) , "::" ,
                stringify ! ( dstflag ) ));
}
impl Clone for __timeb32 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct timeb {
    pub time: time_t,
    pub millitm: ::std::os::raw::c_ushort,
    pub timezone: ::std::os::raw::c_short,
    pub dstflag: ::std::os::raw::c_short,
}
#[test]
fn bindgen_test_layout_timeb() {
    assert_eq!(::std::mem::size_of::<timeb>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timeb ) ));
    assert_eq! (::std::mem::align_of::<timeb>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timeb ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeb ) ) . time as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timeb ) , "::" ,
                stringify ! ( time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeb ) ) . millitm as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timeb ) , "::" ,
                stringify ! ( millitm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeb ) ) . timezone as * const _ as
                usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( timeb ) , "::" ,
                stringify ! ( timezone ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeb ) ) . dstflag as * const _ as usize
                } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( timeb ) , "::" ,
                stringify ! ( dstflag ) ));
}
impl Clone for timeb {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __timeb64 {
    pub time: __time64_t,
    pub millitm: ::std::os::raw::c_ushort,
    pub timezone: ::std::os::raw::c_short,
    pub dstflag: ::std::os::raw::c_short,
}
#[test]
fn bindgen_test_layout___timeb64() {
    assert_eq!(::std::mem::size_of::<__timeb64>() , 16usize , concat ! (
               "Size of: " , stringify ! ( __timeb64 ) ));
    assert_eq! (::std::mem::align_of::<__timeb64>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __timeb64 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __timeb64 ) ) . time as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __timeb64 ) , "::" ,
                stringify ! ( time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __timeb64 ) ) . millitm as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __timeb64 ) , "::" ,
                stringify ! ( millitm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __timeb64 ) ) . timezone as * const _ as
                usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( __timeb64 ) , "::" ,
                stringify ! ( timezone ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __timeb64 ) ) . dstflag as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( __timeb64 ) , "::" ,
                stringify ! ( dstflag ) ));
}
impl Clone for __timeb64 {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn _ftime64(_Time: *mut __timeb64);
}
extern "C" {
    pub fn _ftime(arg1: *mut __timeb64);
}
extern "C" {
    pub fn ftime(arg1: *mut timeb);
}
pub type clockid_t = ::std::os::raw::c_int;
extern "C" {
    pub fn nanosleep(request: *const timespec, remain: *mut timespec)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_nanosleep(clock_id: clockid_t, flags: ::std::os::raw::c_int,
                           request: *const timespec, remain: *mut timespec)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getres(clock_id: clockid_t, res: *mut timespec)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(clock_id: clockid_t, tp: *mut timespec)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_settime(clock_id: clockid_t, tp: *const timespec)
     -> ::std::os::raw::c_int;
}
pub type octave_time = octave_sys_time;
pub type octave_base_tm = octave_sys_base_tm;
pub type octave_localtime = octave_sys_localtime;
pub type octave_gmtime = octave_sys_gmtime;
pub type octave_strptime = octave_sys_strptime;
pub type oct_mach_info = octave_mach_info;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct oct_data_conv {
    pub _address: u8,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum oct_data_conv_data_type {
    dt_int8 = 0,
    dt_uint8 = 1,
    dt_int16 = 2,
    dt_uint16 = 3,
    dt_int32 = 4,
    dt_uint32 = 5,
    dt_int64 = 6,
    dt_uint64 = 7,
    dt_single = 8,
    dt_double = 9,
    dt_char = 10,
    dt_schar = 11,
    dt_uchar = 12,
    dt_logical = 13,
    dt_short = 14,
    dt_ushort = 15,
    dt_int = 16,
    dt_uint = 17,
    dt_long = 18,
    dt_ulong = 19,
    dt_longlong = 20,
    dt_ulonglong = 21,
    dt_float = 22,
    dt_unknown = 23,
}
#[test]
fn bindgen_test_layout_oct_data_conv() {
    assert_eq!(::std::mem::size_of::<oct_data_conv>() , 1usize , concat ! (
               "Size of: " , stringify ! ( oct_data_conv ) ));
    assert_eq! (::std::mem::align_of::<oct_data_conv>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( oct_data_conv ) ));
}
extern "C" {
    #[link_name = "?data_type_size@oct_data_conv@@SA_KW4data_type@1@@Z"]
    pub fn oct_data_conv_data_type_size(dt: oct_data_conv_data_type) -> usize;
}
extern "C" {
    #[link_name =
          "?string_to_data_type@oct_data_conv@@SA?AW4data_type@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn oct_data_conv_string_to_data_type(s: *const std_string)
     -> oct_data_conv_data_type;
}
extern "C" {
    #[link_name =
          "?string_to_data_type@oct_data_conv@@SAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAHAEAW4data_type@1@2@Z"]
    pub fn oct_data_conv_string_to_data_type1(s: *const std_string,
                                              block_size:
                                                  *mut ::std::os::raw::c_int,
                                              input_type:
                                                  *mut oct_data_conv_data_type,
                                              output_type:
                                                  *mut oct_data_conv_data_type);
}
extern "C" {
    #[link_name =
          "?string_to_data_type@oct_data_conv@@SAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAHAEAW4data_type@1@@Z"]
    pub fn oct_data_conv_string_to_data_type2(s: *const std_string,
                                              block_size:
                                                  *mut ::std::os::raw::c_int,
                                              output_type:
                                                  *mut oct_data_conv_data_type);
}
extern "C" {
    #[link_name =
          "?data_type_as_string@oct_data_conv@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4data_type@1@@Z"]
    pub fn oct_data_conv_data_type_as_string(dt: oct_data_conv_data_type)
     -> std_string;
}
impl Clone for oct_data_conv {
    fn clone(&self) -> Self { *self }
}
impl oct_data_conv {
    #[inline]
    pub unsafe fn data_type_size(dt: oct_data_conv_data_type) -> usize {
        oct_data_conv_data_type_size(dt)
    }
    #[inline]
    pub unsafe fn string_to_data_type(s: *const std_string)
     -> oct_data_conv_data_type {
        oct_data_conv_string_to_data_type(s)
    }
    #[inline]
    pub unsafe fn string_to_data_type1(s: *const std_string,
                                       block_size: *mut ::std::os::raw::c_int,
                                       input_type:
                                           *mut oct_data_conv_data_type,
                                       output_type:
                                           *mut oct_data_conv_data_type) {
        oct_data_conv_string_to_data_type1(s, block_size, input_type,
                                           output_type)
    }
    #[inline]
    pub unsafe fn string_to_data_type2(s: *const std_string,
                                       block_size: *mut ::std::os::raw::c_int,
                                       output_type:
                                           *mut oct_data_conv_data_type) {
        oct_data_conv_string_to_data_type2(s, block_size, output_type)
    }
    #[inline]
    pub unsafe fn data_type_as_string(dt: oct_data_conv_data_type)
     -> std_string {
        oct_data_conv_data_type_as_string(dt)
    }
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum save_type {
    LS_U_CHAR = 0,
    LS_U_SHORT = 1,
    LS_U_INT = 2,
    LS_CHAR = 3,
    LS_SHORT = 4,
    LS_INT = 5,
    LS_FLOAT = 6,
    LS_DOUBLE = 7,
    LS_U_LONG = 8,
    LS_LONG = 9,
}
extern "C" {
    #[link_name =
          "?do_double_format_conversion@@YAXPEAXHW4float_format@mach_info@octave@@1@Z"]
    pub fn do_double_format_conversion(data: *mut ::std::os::raw::c_void,
                                       len: octave_idx_type,
                                       from_fmt:
                                           octave_mach_info_float_format,
                                       to_fmt: octave_mach_info_float_format);
}
extern "C" {
    #[link_name =
          "?do_float_format_conversion@@YAXPEAXHW4float_format@mach_info@octave@@1@Z"]
    pub fn do_float_format_conversion(data: *mut ::std::os::raw::c_void,
                                      len: octave_idx_type,
                                      from_fmt: octave_mach_info_float_format,
                                      to_fmt: octave_mach_info_float_format);
}
extern "C" {
    #[link_name =
          "?do_float_format_conversion@@YAXPEAX_KHW4float_format@mach_info@octave@@2@Z"]
    pub fn do_float_format_conversion1(data: *mut ::std::os::raw::c_void,
                                       sz: usize, len: octave_idx_type,
                                       from_fmt:
                                           octave_mach_info_float_format,
                                       to_fmt: octave_mach_info_float_format);
}
extern "C" {
    #[link_name =
          "?read_doubles@@YAXAEAV?$basic_istream@DU?$char_traits@D@std@@@std@@PEANW4save_type@@H_NW4float_format@mach_info@octave@@@Z"]
    pub fn read_doubles(is: *mut std_istream, data: *mut f64,
                        type_: save_type, len: octave_idx_type, swap: bool,
                        fmt: octave_mach_info_float_format);
}
extern "C" {
    #[link_name =
          "?write_doubles@@YAXAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@PEBNW4save_type@@H@Z"]
    pub fn write_doubles(os: *mut std_ostream, data: *const f64,
                         type_: save_type, len: octave_idx_type);
}
extern "C" {
    #[link_name =
          "?read_floats@@YAXAEAV?$basic_istream@DU?$char_traits@D@std@@@std@@PEAMW4save_type@@H_NW4float_format@mach_info@octave@@@Z"]
    pub fn read_floats(is: *mut std_istream, data: *mut f32, type_: save_type,
                       len: octave_idx_type, swap: bool,
                       fmt: octave_mach_info_float_format);
}
extern "C" {
    #[link_name =
          "?write_floats@@YAXAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@PEBMW4save_type@@H@Z"]
    pub fn write_floats(os: *mut std_ostream, data: *const f32,
                        type_: save_type, len: octave_idx_type);
}
#[repr(C)]
#[derive(Debug)]
pub struct Cell {
    pub _base: Array<octave_value>,
}
pub type Cell_ctype_mapper =
    ::std::option::Option<unsafe extern "C" fn() -> octave_value>;
#[test]
fn bindgen_test_layout_Cell() {
    assert_eq!(::std::mem::size_of::<Cell>() , 40usize , concat ! (
               "Size of: " , stringify ! ( Cell ) ));
    assert_eq! (::std::mem::align_of::<Cell>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( Cell ) ));
}
extern "C" {
    #[link_name = "?is_cellstr@Cell@@QEBA_NXZ"]
    pub fn Cell_is_cellstr(this: *const Cell) -> bool;
}
extern "C" {
    #[link_name =
          "?cellstr_value@Cell@@QEBA?AV?$Array@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@@XZ"]
    pub fn Cell_cellstr_value(this: *const Cell)
     -> Array<std_basic_string<::std::os::raw::c_char, std_allocator>>;
}
extern "C" {
    #[link_name = "?index@Cell@@QEBA?AV1@AEBVoctave_value_list@@_N@Z"]
    pub fn Cell_index(this: *const Cell, idx: *const octave_value_list,
                      resize_ok: bool) -> Cell;
}
extern "C" {
    #[link_name = "?delete_elements@Cell@@QEAAXAEBVoctave_value_list@@@Z"]
    pub fn Cell_delete_elements(this: *mut Cell,
                                idx: *const octave_value_list);
}
extern "C" {
    #[link_name =
          "?assign@Cell@@QEAAXAEBVoctave_value_list@@AEBV1@AEBVoctave_value@@@Z"]
    pub fn Cell_assign(this: *mut Cell, idx: *const octave_value_list,
                       rhs: *const Cell, fill_val: *const octave_value);
}
extern "C" {
    #[link_name = "?nnz@Cell@@QEBAHXZ"]
    pub fn Cell_nnz(this: *const Cell) -> octave_idx_type;
}
extern "C" {
    #[link_name = "?column@Cell@@QEBA?AV1@H@Z"]
    pub fn Cell_column(this: *const Cell, i: octave_idx_type) -> Cell;
}
extern "C" {
    #[link_name = "?concat@Cell@@QEAA?AV1@AEBV1@AEBV?$Array@H@@@Z"]
    pub fn Cell_concat(this: *mut Cell, rb: *const Cell,
                       ra_idx: *const Array<::std::os::raw::c_int>) -> Cell;
}
extern "C" {
    #[link_name = "?insert@Cell@@QEAAAEAV1@AEBV1@HH@Z"]
    pub fn Cell_insert(this: *mut Cell, a: *const Cell, r: octave_idx_type,
                       c: octave_idx_type) -> *mut Cell;
}
extern "C" {
    #[link_name = "?insert@Cell@@QEAAAEAV1@AEBV1@AEBV?$Array@H@@@Z"]
    pub fn Cell_insert1(this: *mut Cell, a: *const Cell,
                        ra_idx: *const Array<::std::os::raw::c_int>)
     -> *mut Cell;
}
extern "C" {
    #[link_name = "?diag@Cell@@QEBA?AV1@H@Z"]
    pub fn Cell_diag(this: *const Cell, k: octave_idx_type) -> Cell;
}
extern "C" {
    #[link_name = "?diag@Cell@@QEBA?AV1@HH@Z"]
    pub fn Cell_diag1(this: *const Cell, m: octave_idx_type,
                      n: octave_idx_type) -> Cell;
}
extern "C" {
    #[link_name = "??0Cell@@QEAA@AEBVoctave_value_list@@@Z"]
    pub fn Cell_Cell(this: *mut Cell, ovl: *const octave_value_list);
}
extern "C" {
    #[link_name = "??0Cell@@QEAA@AEBVstring_vector@@_N@Z"]
    pub fn Cell_Cell1(this: *mut Cell, sv: *const string_vector, trim: bool);
}
extern "C" {
    #[link_name =
          "??0Cell@@QEAA@AEBV?$list@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z"]
    pub fn Cell_Cell2(this: *mut Cell, lst: *const std_list);
}
extern "C" {
    #[link_name =
          "??0Cell@@QEAA@AEBV?$Array@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@@@Z"]
    pub fn Cell_Cell3(this: *mut Cell,
                      sa:
                          *const Array<std_basic_string<::std::os::raw::c_char,
                                                        std_allocator>>);
}
extern "C" {
    #[link_name = "??0Cell@@QEAA@AEBVdim_vector@@AEBVstring_vector@@_N@Z"]
    pub fn Cell_Cell4(this: *mut Cell, dv: *const dim_vector,
                      sv: *const string_vector, trim: bool);
}
impl Cell {
    #[inline]
    pub unsafe fn is_cellstr(&self) -> bool { Cell_is_cellstr(self) }
    #[inline]
    pub unsafe fn cellstr_value(&self)
     -> Array<std_basic_string<::std::os::raw::c_char, std_allocator>> {
        Cell_cellstr_value(self)
    }
    #[inline]
    pub unsafe fn index(&self, idx: *const octave_value_list, resize_ok: bool)
     -> Cell {
        Cell_index(self, idx, resize_ok)
    }
    #[inline]
    pub unsafe fn delete_elements(&mut self, idx: *const octave_value_list) {
        Cell_delete_elements(self, idx)
    }
    #[inline]
    pub unsafe fn assign(&mut self, idx: *const octave_value_list,
                         rhs: *const Cell, fill_val: *const octave_value) {
        Cell_assign(self, idx, rhs, fill_val)
    }
    #[inline]
    pub unsafe fn nnz(&self) -> octave_idx_type { Cell_nnz(self) }
    #[inline]
    pub unsafe fn column(&self, i: octave_idx_type) -> Cell {
        Cell_column(self, i)
    }
    #[inline]
    pub unsafe fn concat(&mut self, rb: *const Cell,
                         ra_idx: *const Array<::std::os::raw::c_int>)
     -> Cell {
        Cell_concat(self, rb, ra_idx)
    }
    #[inline]
    pub unsafe fn insert(&mut self, a: *const Cell, r: octave_idx_type,
                         c: octave_idx_type) -> *mut Cell {
        Cell_insert(self, a, r, c)
    }
    #[inline]
    pub unsafe fn insert1(&mut self, a: *const Cell,
                          ra_idx: *const Array<::std::os::raw::c_int>)
     -> *mut Cell {
        Cell_insert1(self, a, ra_idx)
    }
    #[inline]
    pub unsafe fn diag(&self, k: octave_idx_type) -> Cell {
        Cell_diag(self, k)
    }
    #[inline]
    pub unsafe fn diag1(&self, m: octave_idx_type, n: octave_idx_type)
     -> Cell {
        Cell_diag1(self, m, n)
    }
    #[inline]
    pub unsafe fn new(ovl: *const octave_value_list) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        Cell_Cell(&mut __bindgen_tmp, ovl);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(sv: *const string_vector, trim: bool) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        Cell_Cell1(&mut __bindgen_tmp, sv, trim);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new2(lst: *const std_list) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        Cell_Cell2(&mut __bindgen_tmp, lst);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new3(sa:
                           *const Array<std_basic_string<::std::os::raw::c_char,
                                                         std_allocator>>)
     -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        Cell_Cell3(&mut __bindgen_tmp, sa);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new4(dv: *const dim_vector, sv: *const string_vector,
                       trim: bool) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        Cell_Cell4(&mut __bindgen_tmp, dv, sv, trim);
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mxArray([u8; 0]);
#[repr(C)]
#[derive(Debug)]
pub struct octave_map {
    pub xkeys: octave_fields,
    pub xvals: std_vector,
    pub dimensions: dim_vector,
}
pub type octave_map_element_type = octave_scalar_map;
pub type octave_map_const_iterator = octave_fields_const_iterator;
pub type octave_map_iterator = octave_map_const_iterator;
#[test]
fn bindgen_test_layout_octave_map() {
    assert_eq!(::std::mem::size_of::<octave_map>() , 40usize , concat ! (
               "Size of: " , stringify ! ( octave_map ) ));
    assert_eq! (::std::mem::align_of::<octave_map>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( octave_map ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_map ) ) . xkeys as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_map ) , "::" ,
                stringify ! ( xkeys ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_map ) ) . xvals as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_map ) , "::" ,
                stringify ! ( xvals ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_map ) ) . dimensions as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_map ) , "::" ,
                stringify ! ( dimensions ) ));
}
extern "C" {
    #[link_name =
          "?getfield@octave_map@@QEBA?AVCell@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn octave_map_getfield(this: *const octave_map,
                               key: *const std_string) -> Cell;
}
extern "C" {
    #[link_name =
          "?setfield@octave_map@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBVCell@@@Z"]
    pub fn octave_map_setfield(this: *mut octave_map, key: *const std_string,
                               val: *const Cell);
}
extern "C" {
    #[link_name =
          "?rmfield@octave_map@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn octave_map_rmfield(this: *mut octave_map, key: *const std_string);
}
extern "C" {
    #[link_name = "?orderfields@octave_map@@QEBA?AV1@XZ"]
    pub fn octave_map_orderfields(this: *const octave_map) -> octave_map;
}
extern "C" {
    #[link_name = "?orderfields@octave_map@@QEBA?AV1@AEAV?$Array@H@@@Z"]
    pub fn octave_map_orderfields1(this: *const octave_map,
                                   perm: *mut Array<::std::os::raw::c_int>)
     -> octave_map;
}
extern "C" {
    #[link_name = "?orderfields@octave_map@@QEBA?AV1@AEBV1@AEAV?$Array@H@@@Z"]
    pub fn octave_map_orderfields2(this: *const octave_map,
                                   other: *const octave_map,
                                   perm: *mut Array<::std::os::raw::c_int>)
     -> octave_map;
}
extern "C" {
    #[link_name =
          "?contents@octave_map@@QEBA?AVCell@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn octave_map_contents(this: *const octave_map, k: *const std_string)
     -> Cell;
}
extern "C" {
    #[link_name =
          "?contents@octave_map@@QEAAAEAVCell@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn octave_map_contents1(this: *mut octave_map, k: *const std_string)
     -> *mut Cell;
}
extern "C" {
    #[link_name = "?checkelem@octave_map@@QEBA?AVoctave_scalar_map@@H@Z"]
    pub fn octave_map_checkelem(this: *const octave_map, n: octave_idx_type)
     -> octave_scalar_map;
}
extern "C" {
    #[link_name = "?checkelem@octave_map@@QEBA?AVoctave_scalar_map@@HH@Z"]
    pub fn octave_map_checkelem1(this: *const octave_map, i: octave_idx_type,
                                 j: octave_idx_type) -> octave_scalar_map;
}
extern "C" {
    #[link_name =
          "?checkelem@octave_map@@QEBA?AVoctave_scalar_map@@AEBV?$Array@H@@@Z"]
    pub fn octave_map_checkelem2(this: *const octave_map,
                                 ra_idx: *const Array<::std::os::raw::c_int>)
     -> octave_scalar_map;
}
extern "C" {
    #[link_name = "?squeeze@octave_map@@QEBA?AV1@XZ"]
    pub fn octave_map_squeeze(this: *const octave_map) -> octave_map;
}
extern "C" {
    #[link_name = "?permute@octave_map@@QEBA?AV1@AEBV?$Array@H@@_N@Z"]
    pub fn octave_map_permute(this: *const octave_map,
                              vec: *const Array<::std::os::raw::c_int>,
                              inv: bool) -> octave_map;
}
extern "C" {
    #[link_name = "?transpose@octave_map@@QEBA?AV1@XZ"]
    pub fn octave_map_transpose(this: *const octave_map) -> octave_map;
}
extern "C" {
    #[link_name = "?reshape@octave_map@@QEBA?AV1@AEBVdim_vector@@@Z"]
    pub fn octave_map_reshape(this: *const octave_map, dv: *const dim_vector)
     -> octave_map;
}
extern "C" {
    #[link_name = "?resize@octave_map@@QEAAXAEBVdim_vector@@_N@Z"]
    pub fn octave_map_resize(this: *mut octave_map, dv: *const dim_vector,
                             fill: bool);
}
extern "C" {
    #[link_name = "?cat@octave_map@@SA?AV1@HHPEBVoctave_scalar_map@@@Z"]
    pub fn octave_map_cat(dim: ::std::os::raw::c_int, n: octave_idx_type,
                          map_list: *const octave_scalar_map) -> octave_map;
}
extern "C" {
    #[link_name = "?cat@octave_map@@SA?AV1@HHPEBV1@@Z"]
    pub fn octave_map_cat1(dim: ::std::os::raw::c_int, n: octave_idx_type,
                           map_list: *const octave_map) -> octave_map;
}
extern "C" {
    #[link_name = "?index@octave_map@@QEBA?AV1@AEBVidx_vector@@_N@Z"]
    pub fn octave_map_index(this: *const octave_map, i: *const idx_vector,
                            resize_ok: bool) -> octave_map;
}
extern "C" {
    #[link_name = "?index@octave_map@@QEBA?AV1@AEBVidx_vector@@0_N@Z"]
    pub fn octave_map_index1(this: *const octave_map, i: *const idx_vector,
                             j: *const idx_vector, resize_ok: bool)
     -> octave_map;
}
extern "C" {
    #[link_name =
          "?index@octave_map@@QEBA?AV1@AEBV?$Array@Vidx_vector@@@@_N@Z"]
    pub fn octave_map_index2(this: *const octave_map,
                             ia: *const Array<idx_vector>, resize_ok: bool)
     -> octave_map;
}
extern "C" {
    #[link_name = "?index@octave_map@@QEBA?AV1@AEBVoctave_value_list@@_N@Z"]
    pub fn octave_map_index3(this: *const octave_map,
                             arg1: *const octave_value_list, resize_ok: bool)
     -> octave_map;
}
extern "C" {
    #[link_name = "?column@octave_map@@QEBA?AV1@H@Z"]
    pub fn octave_map_column(this: *const octave_map, k: octave_idx_type)
     -> octave_map;
}
extern "C" {
    #[link_name = "?page@octave_map@@QEBA?AV1@H@Z"]
    pub fn octave_map_page(this: *const octave_map, k: octave_idx_type)
     -> octave_map;
}
extern "C" {
    #[link_name = "?assign@octave_map@@QEAAXAEBVidx_vector@@AEBV1@@Z"]
    pub fn octave_map_assign(this: *mut octave_map, i: *const idx_vector,
                             rhs: *const octave_map);
}
extern "C" {
    #[link_name = "?assign@octave_map@@QEAAXAEBVidx_vector@@0AEBV1@@Z"]
    pub fn octave_map_assign1(this: *mut octave_map, i: *const idx_vector,
                              j: *const idx_vector, rhs: *const octave_map);
}
extern "C" {
    #[link_name =
          "?assign@octave_map@@QEAAXAEBV?$Array@Vidx_vector@@@@AEBV1@@Z"]
    pub fn octave_map_assign2(this: *mut octave_map,
                              ia: *const Array<idx_vector>,
                              rhs: *const octave_map);
}
extern "C" {
    #[link_name = "?assign@octave_map@@QEAAXAEBVoctave_value_list@@AEBV1@@Z"]
    pub fn octave_map_assign3(this: *mut octave_map,
                              arg1: *const octave_value_list,
                              rhs: *const octave_map);
}
extern "C" {
    #[link_name =
          "?assign@octave_map@@QEAAXAEBVoctave_value_list@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBVCell@@@Z"]
    pub fn octave_map_assign4(this: *mut octave_map,
                              idx: *const octave_value_list,
                              k: *const std_string, rhs: *const Cell);
}
extern "C" {
    #[link_name = "?delete_elements@octave_map@@QEAAXAEBVidx_vector@@@Z"]
    pub fn octave_map_delete_elements(this: *mut octave_map,
                                      i: *const idx_vector);
}
extern "C" {
    #[link_name = "?delete_elements@octave_map@@QEAAXHAEBVidx_vector@@@Z"]
    pub fn octave_map_delete_elements1(this: *mut octave_map,
                                       dim: ::std::os::raw::c_int,
                                       i: *const idx_vector);
}
extern "C" {
    #[link_name =
          "?delete_elements@octave_map@@QEAAXAEBV?$Array@Vidx_vector@@@@@Z"]
    pub fn octave_map_delete_elements2(this: *mut octave_map,
                                       ia: *const Array<idx_vector>);
}
extern "C" {
    #[link_name =
          "?delete_elements@octave_map@@QEAAXAEBVoctave_value_list@@@Z"]
    pub fn octave_map_delete_elements3(this: *mut octave_map,
                                       arg1: *const octave_value_list);
}
extern "C" {
    #[link_name = "?concat@octave_map@@QEAA?AV1@AEBV1@AEBV?$Array@H@@@Z"]
    pub fn octave_map_concat(this: *mut octave_map, rb: *const octave_map,
                             ra_idx: *const Array<::std::os::raw::c_int>)
     -> octave_map;
}
extern "C" {
    #[link_name =
          "?fast_elem_extract@octave_map@@QEBA?AVoctave_scalar_map@@H@Z"]
    pub fn octave_map_fast_elem_extract(this: *const octave_map,
                                        n: octave_idx_type)
     -> octave_scalar_map;
}
extern "C" {
    #[link_name =
          "?fast_elem_insert@octave_map@@QEAA_NHAEBVoctave_scalar_map@@@Z"]
    pub fn octave_map_fast_elem_insert(this: *mut octave_map,
                                       n: octave_idx_type,
                                       rhs: *const octave_scalar_map) -> bool;
}
extern "C" {
    #[link_name = "??0octave_map@@QEAA@AEBVoctave_scalar_map@@@Z"]
    pub fn octave_map_octave_map(this: *mut octave_map,
                                 m: *const octave_scalar_map);
}
impl octave_map {
    #[inline]
    pub unsafe fn getfield(&self, key: *const std_string) -> Cell {
        octave_map_getfield(self, key)
    }
    #[inline]
    pub unsafe fn setfield(&mut self, key: *const std_string,
                           val: *const Cell) {
        octave_map_setfield(self, key, val)
    }
    #[inline]
    pub unsafe fn rmfield(&mut self, key: *const std_string) {
        octave_map_rmfield(self, key)
    }
    #[inline]
    pub unsafe fn orderfields(&self) -> octave_map {
        octave_map_orderfields(self)
    }
    #[inline]
    pub unsafe fn orderfields1(&self, perm: *mut Array<::std::os::raw::c_int>)
     -> octave_map {
        octave_map_orderfields1(self, perm)
    }
    #[inline]
    pub unsafe fn orderfields2(&self, other: *const octave_map,
                               perm: *mut Array<::std::os::raw::c_int>)
     -> octave_map {
        octave_map_orderfields2(self, other, perm)
    }
    #[inline]
    pub unsafe fn contents(&self, k: *const std_string) -> Cell {
        octave_map_contents(self, k)
    }
    #[inline]
    pub unsafe fn contents1(&mut self, k: *const std_string) -> *mut Cell {
        octave_map_contents1(self, k)
    }
    #[inline]
    pub unsafe fn checkelem(&self, n: octave_idx_type) -> octave_scalar_map {
        octave_map_checkelem(self, n)
    }
    #[inline]
    pub unsafe fn checkelem1(&self, i: octave_idx_type, j: octave_idx_type)
     -> octave_scalar_map {
        octave_map_checkelem1(self, i, j)
    }
    #[inline]
    pub unsafe fn checkelem2(&self,
                             ra_idx: *const Array<::std::os::raw::c_int>)
     -> octave_scalar_map {
        octave_map_checkelem2(self, ra_idx)
    }
    #[inline]
    pub unsafe fn squeeze(&self) -> octave_map { octave_map_squeeze(self) }
    #[inline]
    pub unsafe fn permute(&self, vec: *const Array<::std::os::raw::c_int>,
                          inv: bool) -> octave_map {
        octave_map_permute(self, vec, inv)
    }
    #[inline]
    pub unsafe fn transpose(&self) -> octave_map {
        octave_map_transpose(self)
    }
    #[inline]
    pub unsafe fn reshape(&self, dv: *const dim_vector) -> octave_map {
        octave_map_reshape(self, dv)
    }
    #[inline]
    pub unsafe fn resize(&mut self, dv: *const dim_vector, fill: bool) {
        octave_map_resize(self, dv, fill)
    }
    #[inline]
    pub unsafe fn cat(dim: ::std::os::raw::c_int, n: octave_idx_type,
                      map_list: *const octave_scalar_map) -> octave_map {
        octave_map_cat(dim, n, map_list)
    }
    #[inline]
    pub unsafe fn cat1(dim: ::std::os::raw::c_int, n: octave_idx_type,
                       map_list: *const octave_map) -> octave_map {
        octave_map_cat1(dim, n, map_list)
    }
    #[inline]
    pub unsafe fn index(&self, i: *const idx_vector, resize_ok: bool)
     -> octave_map {
        octave_map_index(self, i, resize_ok)
    }
    #[inline]
    pub unsafe fn index1(&self, i: *const idx_vector, j: *const idx_vector,
                         resize_ok: bool) -> octave_map {
        octave_map_index1(self, i, j, resize_ok)
    }
    #[inline]
    pub unsafe fn index2(&self, ia: *const Array<idx_vector>, resize_ok: bool)
     -> octave_map {
        octave_map_index2(self, ia, resize_ok)
    }
    #[inline]
    pub unsafe fn index3(&self, arg1: *const octave_value_list,
                         resize_ok: bool) -> octave_map {
        octave_map_index3(self, arg1, resize_ok)
    }
    #[inline]
    pub unsafe fn column(&self, k: octave_idx_type) -> octave_map {
        octave_map_column(self, k)
    }
    #[inline]
    pub unsafe fn page(&self, k: octave_idx_type) -> octave_map {
        octave_map_page(self, k)
    }
    #[inline]
    pub unsafe fn assign(&mut self, i: *const idx_vector,
                         rhs: *const octave_map) {
        octave_map_assign(self, i, rhs)
    }
    #[inline]
    pub unsafe fn assign1(&mut self, i: *const idx_vector,
                          j: *const idx_vector, rhs: *const octave_map) {
        octave_map_assign1(self, i, j, rhs)
    }
    #[inline]
    pub unsafe fn assign2(&mut self, ia: *const Array<idx_vector>,
                          rhs: *const octave_map) {
        octave_map_assign2(self, ia, rhs)
    }
    #[inline]
    pub unsafe fn assign3(&mut self, arg1: *const octave_value_list,
                          rhs: *const octave_map) {
        octave_map_assign3(self, arg1, rhs)
    }
    #[inline]
    pub unsafe fn assign4(&mut self, idx: *const octave_value_list,
                          k: *const std_string, rhs: *const Cell) {
        octave_map_assign4(self, idx, k, rhs)
    }
    #[inline]
    pub unsafe fn delete_elements(&mut self, i: *const idx_vector) {
        octave_map_delete_elements(self, i)
    }
    #[inline]
    pub unsafe fn delete_elements1(&mut self, dim: ::std::os::raw::c_int,
                                   i: *const idx_vector) {
        octave_map_delete_elements1(self, dim, i)
    }
    #[inline]
    pub unsafe fn delete_elements2(&mut self, ia: *const Array<idx_vector>) {
        octave_map_delete_elements2(self, ia)
    }
    #[inline]
    pub unsafe fn delete_elements3(&mut self,
                                   arg1: *const octave_value_list) {
        octave_map_delete_elements3(self, arg1)
    }
    #[inline]
    pub unsafe fn concat(&mut self, rb: *const octave_map,
                         ra_idx: *const Array<::std::os::raw::c_int>)
     -> octave_map {
        octave_map_concat(self, rb, ra_idx)
    }
    #[inline]
    pub unsafe fn fast_elem_extract(&self, n: octave_idx_type)
     -> octave_scalar_map {
        octave_map_fast_elem_extract(self, n)
    }
    #[inline]
    pub unsafe fn fast_elem_insert(&mut self, n: octave_idx_type,
                                   rhs: *const octave_scalar_map) -> bool {
        octave_map_fast_elem_insert(self, n, rhs)
    }
    #[inline]
    pub unsafe fn new(m: *const octave_scalar_map) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_map_octave_map(&mut __bindgen_tmp, m);
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct octave_scalar_map {
    pub xkeys: octave_fields,
    pub xvals: std_vector,
}
pub type octave_scalar_map_const_iterator = octave_fields_const_iterator;
pub type octave_scalar_map_iterator = octave_scalar_map_const_iterator;
#[test]
fn bindgen_test_layout_octave_scalar_map() {
    assert_eq!(::std::mem::size_of::<octave_scalar_map>() , 32usize , concat !
               ( "Size of: " , stringify ! ( octave_scalar_map ) ));
    assert_eq! (::std::mem::align_of::<octave_scalar_map>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( octave_scalar_map ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_scalar_map ) ) . xkeys as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_scalar_map ) ,
                "::" , stringify ! ( xkeys ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_scalar_map ) ) . xvals as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_scalar_map ) ,
                "::" , stringify ! ( xvals ) ));
}
extern "C" {
    #[link_name =
          "?getfield@octave_scalar_map@@QEBA?AVoctave_value@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn octave_scalar_map_getfield(this: *const octave_scalar_map,
                                      key: *const std_string) -> octave_value;
}
extern "C" {
    #[link_name =
          "?setfield@octave_scalar_map@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBVoctave_value@@@Z"]
    pub fn octave_scalar_map_setfield(this: *mut octave_scalar_map,
                                      key: *const std_string,
                                      val: *const octave_value);
}
extern "C" {
    #[link_name =
          "?rmfield@octave_scalar_map@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn octave_scalar_map_rmfield(this: *mut octave_scalar_map,
                                     key: *const std_string);
}
extern "C" {
    #[link_name = "?orderfields@octave_scalar_map@@QEBA?AV1@XZ"]
    pub fn octave_scalar_map_orderfields(this: *const octave_scalar_map)
     -> octave_scalar_map;
}
extern "C" {
    #[link_name =
          "?orderfields@octave_scalar_map@@QEBA?AV1@AEAV?$Array@H@@@Z"]
    pub fn octave_scalar_map_orderfields1(this: *const octave_scalar_map,
                                          perm:
                                              *mut Array<::std::os::raw::c_int>)
     -> octave_scalar_map;
}
extern "C" {
    #[link_name =
          "?orderfields@octave_scalar_map@@QEBA?AV1@AEBV1@AEAV?$Array@H@@@Z"]
    pub fn octave_scalar_map_orderfields2(this: *const octave_scalar_map,
                                          other: *const octave_scalar_map,
                                          perm:
                                              *mut Array<::std::os::raw::c_int>)
     -> octave_scalar_map;
}
extern "C" {
    #[link_name =
          "?contents@octave_scalar_map@@QEBA?AVoctave_value@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn octave_scalar_map_contents(this: *const octave_scalar_map,
                                      k: *const std_string) -> octave_value;
}
extern "C" {
    #[link_name =
          "?contents@octave_scalar_map@@QEAAAEAVoctave_value@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn octave_scalar_map_contents1(this: *mut octave_scalar_map,
                                       k: *const std_string)
     -> *mut octave_value;
}
impl octave_scalar_map {
    #[inline]
    pub unsafe fn getfield(&self, key: *const std_string) -> octave_value {
        octave_scalar_map_getfield(self, key)
    }
    #[inline]
    pub unsafe fn setfield(&mut self, key: *const std_string,
                           val: *const octave_value) {
        octave_scalar_map_setfield(self, key, val)
    }
    #[inline]
    pub unsafe fn rmfield(&mut self, key: *const std_string) {
        octave_scalar_map_rmfield(self, key)
    }
    #[inline]
    pub unsafe fn orderfields(&self) -> octave_scalar_map {
        octave_scalar_map_orderfields(self)
    }
    #[inline]
    pub unsafe fn orderfields1(&self, perm: *mut Array<::std::os::raw::c_int>)
     -> octave_scalar_map {
        octave_scalar_map_orderfields1(self, perm)
    }
    #[inline]
    pub unsafe fn orderfields2(&self, other: *const octave_scalar_map,
                               perm: *mut Array<::std::os::raw::c_int>)
     -> octave_scalar_map {
        octave_scalar_map_orderfields2(self, other, perm)
    }
    #[inline]
    pub unsafe fn contents(&self, k: *const std_string) -> octave_value {
        octave_scalar_map_contents(self, k)
    }
    #[inline]
    pub unsafe fn contents1(&mut self, k: *const std_string)
     -> *mut octave_value {
        octave_scalar_map_contents1(self, k)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct octave_stream([u8; 0]);
#[repr(C)]
#[derive(Debug)]
pub struct octave_function {
    pub _base: octave_base_value,
    pub relative: bool,
    pub locked: bool,
    pub private_function: bool,
    pub xdispatch_class: std_string,
    pub xpackage_name: std_string,
    pub my_name: std_string,
    pub my_dir_name: std_string,
    pub doc: std_string,
}
#[test]
fn bindgen_test_layout_octave_function() {
    assert_eq!(::std::mem::size_of::<octave_function>() , 64usize , concat ! (
               "Size of: " , stringify ! ( octave_function ) ));
    assert_eq! (::std::mem::align_of::<octave_function>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( octave_function ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_function ) ) . relative as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_function ) ,
                "::" , stringify ! ( relative ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_function ) ) . locked as * const _
                as usize } , 17usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_function ) ,
                "::" , stringify ! ( locked ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_function ) ) . private_function as
                * const _ as usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_function ) ,
                "::" , stringify ! ( private_function ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_function ) ) . xdispatch_class as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_function ) ,
                "::" , stringify ! ( xdispatch_class ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_function ) ) . xpackage_name as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_function ) ,
                "::" , stringify ! ( xpackage_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_function ) ) . my_name as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_function ) ,
                "::" , stringify ! ( my_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_function ) ) . my_dir_name as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_function ) ,
                "::" , stringify ! ( my_dir_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_function ) ) . doc as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_function ) ,
                "::" , stringify ! ( doc ) ));
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct octave_user_function([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct octave_fcn_handle([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct octave_fcn_inline([u8; 0]);
#[repr(C)]
#[derive(Debug)]
pub struct octave_value_list {
    pub data: Array<octave_value>,
    pub names: string_vector,
}
#[test]
fn bindgen_test_layout_octave_value_list() {
    assert_eq!(::std::mem::size_of::<octave_value_list>() , 80usize , concat !
               ( "Size of: " , stringify ! ( octave_value_list ) ));
    assert_eq! (::std::mem::align_of::<octave_value_list>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( octave_value_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_value_list ) ) . data as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_value_list ) ,
                "::" , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_value_list ) ) . names as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_value_list ) ,
                "::" , stringify ! ( names ) ));
}
extern "C" {
    #[link_name =
          "?prepend@octave_value_list@@QEAAAEAV1@AEBVoctave_value@@@Z"]
    pub fn octave_value_list_prepend(this: *mut octave_value_list,
                                     val: *const octave_value)
     -> *mut octave_value_list;
}
extern "C" {
    #[link_name = "?append@octave_value_list@@QEAAAEAV1@AEBVoctave_value@@@Z"]
    pub fn octave_value_list_append(this: *mut octave_value_list,
                                    val: *const octave_value)
     -> *mut octave_value_list;
}
extern "C" {
    #[link_name = "?append@octave_value_list@@QEAAAEAV1@AEBV1@@Z"]
    pub fn octave_value_list_append1(this: *mut octave_value_list,
                                     lst: *const octave_value_list)
     -> *mut octave_value_list;
}
extern "C" {
    #[link_name = "?reverse@octave_value_list@@QEAAAEAV1@XZ"]
    pub fn octave_value_list_reverse(this: *mut octave_value_list)
     -> *mut octave_value_list;
}
extern "C" {
    #[link_name = "?splice@octave_value_list@@QEBA?AV1@HHAEBV1@@Z"]
    pub fn octave_value_list_splice(this: *const octave_value_list,
                                    offset: octave_idx_type,
                                    len: octave_idx_type,
                                    lst: *const octave_value_list)
     -> octave_value_list;
}
extern "C" {
    #[link_name = "?all_strings_p@octave_value_list@@QEBA_NXZ"]
    pub fn octave_value_list_all_strings_p(this: *const octave_value_list)
     -> bool;
}
extern "C" {
    #[link_name = "?all_scalars@octave_value_list@@QEBA_NXZ"]
    pub fn octave_value_list_all_scalars(this: *const octave_value_list)
     -> bool;
}
extern "C" {
    #[link_name = "?any_cell@octave_value_list@@QEBA_NXZ"]
    pub fn octave_value_list_any_cell(this: *const octave_value_list) -> bool;
}
extern "C" {
    #[link_name = "?has_magic_colon@octave_value_list@@QEBA_NXZ"]
    pub fn octave_value_list_has_magic_colon(this: *const octave_value_list)
     -> bool;
}
extern "C" {
    #[link_name =
          "?make_argv@octave_value_list@@QEBA?AVstring_vector@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn octave_value_list_make_argv(this: *const octave_value_list,
                                       arg1: *const std_string)
     -> string_vector;
}
extern "C" {
    #[link_name = "?make_storable_values@octave_value_list@@QEAAXXZ"]
    pub fn octave_value_list_make_storable_values(this:
                                                      *mut octave_value_list);
}
extern "C" {
    #[link_name =
          "??0octave_value_list@@QEAA@AEBV?$list@Voctave_value_list@@V?$allocator@Voctave_value_list@@@std@@@std@@@Z"]
    pub fn octave_value_list_octave_value_list(this: *mut octave_value_list,
                                               arg1: *const std_list);
}
impl octave_value_list {
    #[inline]
    pub unsafe fn prepend(&mut self, val: *const octave_value)
     -> *mut octave_value_list {
        octave_value_list_prepend(self, val)
    }
    #[inline]
    pub unsafe fn append(&mut self, val: *const octave_value)
     -> *mut octave_value_list {
        octave_value_list_append(self, val)
    }
    #[inline]
    pub unsafe fn append1(&mut self, lst: *const octave_value_list)
     -> *mut octave_value_list {
        octave_value_list_append1(self, lst)
    }
    #[inline]
    pub unsafe fn reverse(&mut self) -> *mut octave_value_list {
        octave_value_list_reverse(self)
    }
    #[inline]
    pub unsafe fn splice(&self, offset: octave_idx_type, len: octave_idx_type,
                         lst: *const octave_value_list) -> octave_value_list {
        octave_value_list_splice(self, offset, len, lst)
    }
    #[inline]
    pub unsafe fn all_strings_p(&self) -> bool {
        octave_value_list_all_strings_p(self)
    }
    #[inline]
    pub unsafe fn all_scalars(&self) -> bool {
        octave_value_list_all_scalars(self)
    }
    #[inline]
    pub unsafe fn any_cell(&self) -> bool { octave_value_list_any_cell(self) }
    #[inline]
    pub unsafe fn has_magic_colon(&self) -> bool {
        octave_value_list_has_magic_colon(self)
    }
    #[inline]
    pub unsafe fn make_argv(&self, arg1: *const std_string) -> string_vector {
        octave_value_list_make_argv(self, arg1)
    }
    #[inline]
    pub unsafe fn make_storable_values(&mut self) {
        octave_value_list_make_storable_values(self)
    }
    #[inline]
    pub unsafe fn new(arg1: *const std_list) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_list_octave_value_list(&mut __bindgen_tmp, arg1);
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct octave_lvalue([u8; 0]);
#[repr(C)]
pub struct action_container__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct action_container {
    pub vtable_: *const action_container__bindgen_vtable,
}
#[repr(C)]
pub struct action_container_elem__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct action_container_elem {
    pub vtable_: *const action_container_elem__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_action_container_elem() {
    assert_eq!(::std::mem::size_of::<action_container_elem>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( action_container_elem )
               ));
    assert_eq! (::std::mem::align_of::<action_container_elem>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( action_container_elem ) ));
}
#[repr(C)]
#[derive(Debug)]
pub struct action_container_fcn_elem {
    pub _base: action_container_elem,
    pub e_fptr: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout_action_container_fcn_elem() {
    assert_eq!(::std::mem::size_of::<action_container_fcn_elem>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( action_container_fcn_elem ) ));
    assert_eq! (::std::mem::align_of::<action_container_fcn_elem>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( action_container_fcn_elem )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const action_container_fcn_elem ) ) . e_fptr as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                action_container_fcn_elem ) , "::" , stringify ! ( e_fptr )
                ));
}
#[repr(C)]
#[derive(Debug)]
pub struct action_container_fcn_arg_elem<T> {
    pub _base: action_container_elem,
    pub e_fcn: ::std::option::Option<unsafe extern "C" fn(arg1: T)>,
    pub e_arg: T,
}
#[repr(C)]
#[derive(Debug)]
pub struct action_container_fcn_crefarg_elem<T> {
    pub _base: action_container_elem,
    pub e_fcn: ::std::option::Option<unsafe extern "C" fn(arg1: *mut T)>,
    pub e_arg: T,
}
#[repr(C)]
#[derive(Debug)]
pub struct action_container_method_elem<T> {
    pub _base: action_container_elem,
    pub e_obj: *mut T,
    pub e_method: ::std::option::Option<unsafe extern "C" fn()>,
}
#[repr(C)]
#[derive(Debug)]
pub struct action_container_method_arg_elem<T, A> {
    pub _base: action_container_elem,
    pub e_obj: *mut T,
    pub e_method: ::std::option::Option<unsafe extern "C" fn(arg1: A)>,
    pub e_arg: A,
}
#[repr(C)]
#[derive(Debug)]
pub struct action_container_method_crefarg_elem<T, A> {
    pub _base: action_container_elem,
    pub e_obj: *mut T,
    pub e_method: ::std::option::Option<unsafe extern "C" fn(arg1: *mut A)>,
    pub e_arg: A,
}
#[repr(C)]
#[derive(Debug)]
pub struct action_container_restore_var_elem<T> {
    pub _base: action_container_elem,
    pub e_ptr: *mut T,
    pub e_val: T,
}
#[repr(C)]
#[derive(Debug)]
pub struct action_container_delete_ptr_elem<T> {
    pub _base: action_container_elem,
    pub e_ptr: *mut T,
}
#[test]
fn bindgen_test_layout_action_container() {
    assert_eq!(::std::mem::size_of::<action_container>() , 8usize , concat ! (
               "Size of: " , stringify ! ( action_container ) ));
    assert_eq! (::std::mem::align_of::<action_container>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( action_container ) ));
}
pub type unwind_protect = octave_unwind_protect;
pub type unwind_protect_safe = octave_unwind_protect_safe;
extern "C" {
    #[link_name = "?reset_error_handler@@YAXXZ"]
    pub fn reset_error_handler();
}
extern "C" {
    #[link_name =
          "?warning_enabled@@YAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn warning_enabled(id: *const std_string) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "?vmessage@@YAXPEBD0PEAD@Z"]
    pub fn vmessage(name: *const ::std::os::raw::c_char,
                    fmt: *const ::std::os::raw::c_char, args: va_list);
}
extern "C" {
    #[link_name = "?message@@YAXPEBD0ZZ"]
    pub fn message(name: *const ::std::os::raw::c_char,
                   fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[link_name = "?vusage@@YAXPEBDPEAD@Z"]
    pub fn vusage(fmt: *const ::std::os::raw::c_char, args: va_list);
}
extern "C" {
    #[link_name = "?usage@@YAXPEBDZZ"]
    pub fn usage(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[link_name = "?vwarning@@YAXPEBDPEAD@Z"]
    pub fn vwarning(fmt: *const ::std::os::raw::c_char, args: va_list);
}
extern "C" {
    #[link_name = "?warning@@YAXPEBDZZ"]
    pub fn warning(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[link_name = "?verror@@YAXPEBDPEAD@Z"]
    pub fn verror(fmt: *const ::std::os::raw::c_char, args: va_list);
}
extern "C" {
    #[link_name = "?error@@YAXPEBDZZ"]
    pub fn error(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[link_name = "?verror@@YAXAEAVexecution_exception@octave@@PEBDPEAD@Z"]
    pub fn verror1(arg1: *mut octave_execution_exception,
                   fmt: *const ::std::os::raw::c_char, args: va_list);
}
extern "C" {
    #[link_name = "?error@@YAXAEAVexecution_exception@octave@@PEBDZZ"]
    pub fn error1(arg1: *mut octave_execution_exception,
                  fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[link_name = "?verror_with_cfn@@YAXPEBDPEAD@Z"]
    pub fn verror_with_cfn(fmt: *const ::std::os::raw::c_char, args: va_list);
}
extern "C" {
    #[link_name = "?error_with_cfn@@YAXPEBDZZ"]
    pub fn error_with_cfn(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[link_name = "?vparse_error@@YAXPEBDPEAD@Z"]
    pub fn vparse_error(fmt: *const ::std::os::raw::c_char, args: va_list);
}
extern "C" {
    #[link_name = "?parse_error@@YAXPEBDZZ"]
    pub fn parse_error(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[link_name = "?vmessage_with_id@@YAXPEBD00PEAD@Z"]
    pub fn vmessage_with_id(id: *const ::std::os::raw::c_char,
                            name: *const ::std::os::raw::c_char,
                            fmt: *const ::std::os::raw::c_char,
                            args: va_list);
}
extern "C" {
    #[link_name = "?message_with_id@@YAXPEBD00ZZ"]
    pub fn message_with_id(id: *const ::std::os::raw::c_char,
                           name: *const ::std::os::raw::c_char,
                           fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[link_name = "?vusage_with_id@@YAXPEBD0PEAD@Z"]
    pub fn vusage_with_id(id: *const ::std::os::raw::c_char,
                          fmt: *const ::std::os::raw::c_char, args: va_list);
}
extern "C" {
    #[link_name = "?usage_with_id@@YAXPEBD0ZZ"]
    pub fn usage_with_id(id: *const ::std::os::raw::c_char,
                         fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[link_name = "?vwarning_with_id@@YAXPEBD0PEAD@Z"]
    pub fn vwarning_with_id(id: *const ::std::os::raw::c_char,
                            fmt: *const ::std::os::raw::c_char,
                            args: va_list);
}
extern "C" {
    #[link_name = "?warning_with_id@@YAXPEBD0ZZ"]
    pub fn warning_with_id(id: *const ::std::os::raw::c_char,
                           fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[link_name = "?verror_with_id@@YAXPEBD0PEAD@Z"]
    pub fn verror_with_id(id: *const ::std::os::raw::c_char,
                          fmt: *const ::std::os::raw::c_char, args: va_list);
}
extern "C" {
    #[link_name = "?error_with_id@@YAXPEBD0ZZ"]
    pub fn error_with_id(id: *const ::std::os::raw::c_char,
                         fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[link_name = "?verror_with_id_cfn@@YAXPEBD0PEAD@Z"]
    pub fn verror_with_id_cfn(id: *const ::std::os::raw::c_char,
                              fmt: *const ::std::os::raw::c_char,
                              args: va_list);
}
extern "C" {
    #[link_name = "?error_with_id_cfn@@YAXPEBD0ZZ"]
    pub fn error_with_id_cfn(id: *const ::std::os::raw::c_char,
                             fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[link_name = "?vparse_error_with_id@@YAXPEBD0PEAD@Z"]
    pub fn vparse_error_with_id(id: *const ::std::os::raw::c_char,
                                fmt: *const ::std::os::raw::c_char,
                                args: va_list);
}
extern "C" {
    #[link_name = "?parse_error_with_id@@YAXPEBD0ZZ"]
    pub fn parse_error_with_id(id: *const ::std::os::raw::c_char,
                               fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[link_name = "?panic@@YAXPEBDZZ"]
    pub fn panic(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[link_name =
          "?defun_usage_message@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn defun_usage_message(msg: *const std_string);
}
extern "C" {
    #[link_name =
          "?set_warning_state@@YA?AVoctave_value_list@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z"]
    pub fn set_warning_state(id: *const std_string, state: *const std_string)
     -> octave_value_list;
}
extern "C" {
    #[link_name = "?set_warning_state@@YA?AVoctave_value_list@@AEBV1@@Z"]
    pub fn set_warning_state1(args: *const octave_value_list)
     -> octave_value_list;
}
extern "C" {
    #[link_name =
          "?disable_warning@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn disable_warning(id: *const std_string);
}
extern "C" {
    #[link_name = "?initialize_default_warning_state@@YAXXZ"]
    pub fn initialize_default_warning_state();
}
extern "C" {
    #[link_name = "?Vdebug_on_error@@3_NA"]
    pub static mut Vdebug_on_error: bool;
}
extern "C" {
    #[link_name = "?Vdebug_on_caught@@3_NA"]
    pub static mut Vdebug_on_caught: bool;
}
extern "C" {
    #[link_name = "?Vdebug_on_warning@@3_NA"]
    pub static mut Vdebug_on_warning: bool;
}
extern "C" {
    #[link_name = "?error_state@@3HA"]
    pub static mut error_state: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "?warning_state@@3HA"]
    pub static mut warning_state: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "?buffer_error_messages@@3HA"]
    pub static mut buffer_error_messages: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "?in_try_catch@@3HA"]
    pub static mut in_try_catch: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "?discard_error_messages@@3_NA"]
    pub static mut discard_error_messages: bool;
}
extern "C" {
    #[link_name = "?discard_warning_messages@@3_NA"]
    pub static mut discard_warning_messages: bool;
}
extern "C" {
    #[link_name =
          "?last_error_message@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ"]
    pub fn last_error_message() -> std_string;
}
extern "C" {
    #[link_name =
          "?last_error_id@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ"]
    pub fn last_error_id() -> std_string;
}
extern "C" {
    #[link_name = "?last_error_stack@@YA?AVoctave_map@@XZ"]
    pub fn last_error_stack() -> octave_map;
}
extern "C" {
    #[link_name =
          "?last_warning_message@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ"]
    pub fn last_warning_message() -> std_string;
}
extern "C" {
    #[link_name =
          "?last_warning_id@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ"]
    pub fn last_warning_id() -> std_string;
}
extern "C" {
    #[link_name = "?interpreter_try@@YAXAEAVunwind_protect@octave@@@Z"]
    pub fn interpreter_try(arg1: *mut octave_unwind_protect);
}
extern "C" {
    #[link_name = "?check_hdf5_types@@YA_N_N@Z"]
    pub fn check_hdf5_types(warn: bool) -> bool;
}
pub type octave_hdf5_id = i64;
pub type octave_hdf5_err = ::std::os::raw::c_int;
extern "C" {
    #[link_name = "octave_H5E_DEFAULT"]
    pub static octave_H5E_DEFAULT: octave_hdf5_id;
}
extern "C" {
    #[link_name = "octave_H5P_DEFAULT"]
    pub static octave_H5P_DEFAULT: octave_hdf5_id;
}
extern "C" {
    #[link_name = "octave_H5S_ALL"]
    pub static octave_H5S_ALL: octave_hdf5_id;
}
#[repr(C)]
pub struct octave_value__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct octave_value {
    pub vtable_: *const octave_value__bindgen_vtable,
    pub rep: *mut octave_base_value,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum octave_value_unary_op {
    op_not = 0,
    op_uplus = 1,
    op_uminus = 2,
    op_transpose = 3,
    op_hermitian = 4,
    op_incr = 5,
    op_decr = 6,
    num_unary_ops = 7,
    unknown_unary_op = 8,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum octave_value_binary_op {
    op_add = 0,
    op_sub = 1,
    op_mul = 2,
    op_div = 3,
    op_pow = 4,
    op_ldiv = 5,
    op_lt = 6,
    op_le = 7,
    op_eq = 8,
    op_ge = 9,
    op_gt = 10,
    op_ne = 11,
    op_el_mul = 12,
    op_el_div = 13,
    op_el_pow = 14,
    op_el_ldiv = 15,
    op_el_and = 16,
    op_el_or = 17,
    op_struct_ref = 18,
    num_binary_ops = 19,
    unknown_binary_op = 20,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum octave_value_compound_binary_op {
    op_trans_mul = 0,
    op_mul_trans = 1,
    op_herm_mul = 2,
    op_mul_herm = 3,
    op_trans_ldiv = 4,
    op_herm_ldiv = 5,
    op_el_not_and = 6,
    op_el_not_or = 7,
    op_el_and_not = 8,
    op_el_or_not = 9,
    num_compound_binary_ops = 10,
    unknown_compound_binary_op = 11,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum octave_value_assign_op {
    op_asn_eq = 0,
    op_add_eq = 1,
    op_sub_eq = 2,
    op_mul_eq = 3,
    op_div_eq = 4,
    op_ldiv_eq = 5,
    op_pow_eq = 6,
    op_el_mul_eq = 7,
    op_el_div_eq = 8,
    op_el_ldiv_eq = 9,
    op_el_pow_eq = 10,
    op_el_and_eq = 11,
    op_el_or_eq = 12,
    num_assign_ops = 13,
    unknown_assign_op = 14,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum octave_value_magic_colon { magic_colon_t = 0, }
#[test]
fn bindgen_test_layout_octave_value() {
    assert_eq!(::std::mem::size_of::<octave_value>() , 16usize , concat ! (
               "Size of: " , stringify ! ( octave_value ) ));
    assert_eq! (::std::mem::align_of::<octave_value>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( octave_value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_value ) ) . rep as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_value ) , "::" ,
                stringify ! ( rep ) ));
}
extern "C" {
    #[link_name =
          "?assign_op_to_binary_op@octave_value@@SA?AW4binary_op@1@W4assign_op@1@@Z"]
    pub fn octave_value_assign_op_to_binary_op(arg1: octave_value_assign_op)
     -> octave_value_binary_op;
}
extern "C" {
    #[link_name =
          "?binary_op_to_assign_op@octave_value@@SA?AW4assign_op@1@W4binary_op@1@@Z"]
    pub fn octave_value_binary_op_to_assign_op(arg1: octave_value_binary_op)
     -> octave_value_assign_op;
}
extern "C" {
    #[link_name =
          "?unary_op_as_string@octave_value@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4unary_op@1@@Z"]
    pub fn octave_value_unary_op_as_string(arg1: octave_value_unary_op)
     -> std_string;
}
extern "C" {
    #[link_name =
          "?unary_op_fcn_name@octave_value@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4unary_op@1@@Z"]
    pub fn octave_value_unary_op_fcn_name(arg1: octave_value_unary_op)
     -> std_string;
}
extern "C" {
    #[link_name =
          "?binary_op_as_string@octave_value@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4binary_op@1@@Z"]
    pub fn octave_value_binary_op_as_string(arg1: octave_value_binary_op)
     -> std_string;
}
extern "C" {
    #[link_name =
          "?binary_op_fcn_name@octave_value@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4binary_op@1@@Z"]
    pub fn octave_value_binary_op_fcn_name(arg1: octave_value_binary_op)
     -> std_string;
}
extern "C" {
    #[link_name =
          "?binary_op_fcn_name@octave_value@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4compound_binary_op@1@@Z"]
    pub fn octave_value_binary_op_fcn_name1(arg1:
                                                octave_value_compound_binary_op)
     -> std_string;
}
extern "C" {
    #[link_name =
          "?assign_op_as_string@octave_value@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4assign_op@1@@Z"]
    pub fn octave_value_assign_op_as_string(arg1: octave_value_assign_op)
     -> std_string;
}
extern "C" {
    #[link_name =
          "?empty_conv@octave_value@@SA?AV1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV1@@Z"]
    pub fn octave_value_empty_conv(type_: *const std_string,
                                   rhs: *const octave_value) -> octave_value;
}
extern "C" {
    #[link_name = "?clone@octave_value@@QEBAPEAVoctave_base_value@@XZ"]
    pub fn octave_value_clone(this: *const octave_value)
     -> *mut octave_base_value;
}
extern "C" {
    #[link_name = "?maybe_mutate@octave_value@@QEAAXXZ"]
    pub fn octave_value_maybe_mutate(this: *mut octave_value);
}
extern "C" {
    #[link_name =
          "?single_subsref@octave_value@@QEAA?AV1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBVoctave_value_list@@@Z"]
    pub fn octave_value_single_subsref(this: *mut octave_value,
                                       type_: *const std_string,
                                       idx: *const octave_value_list)
     -> octave_value;
}
extern "C" {
    #[link_name =
          "?subsref@octave_value@@QEAA?AVoctave_value_list@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$list@Voctave_value_list@@V?$allocator@Voctave_value_list@@@std@@@4@H@Z"]
    pub fn octave_value_subsref(this: *mut octave_value,
                                type_: *const std_string,
                                idx: *const std_list,
                                nargout: ::std::os::raw::c_int)
     -> octave_value_list;
}
extern "C" {
    #[link_name =
          "?subsref@octave_value@@QEAA?AVoctave_value_list@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$list@Voctave_value_list@@V?$allocator@Voctave_value_list@@@std@@@4@HPEBV?$list@Voctave_lvalue@@V?$allocator@Voctave_lvalue@@@std@@@4@@Z"]
    pub fn octave_value_subsref1(this: *mut octave_value,
                                 type_: *const std_string,
                                 idx: *const std_list,
                                 nargout: ::std::os::raw::c_int,
                                 lvalue_list: *const std_list)
     -> octave_value_list;
}
extern "C" {
    #[link_name =
          "?next_subsref@octave_value@@QEAA?AV1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$list@Voctave_value_list@@V?$allocator@Voctave_value_list@@@std@@@3@_K@Z"]
    pub fn octave_value_next_subsref(this: *mut octave_value,
                                     type_: *const std_string,
                                     idx: *const std_list, skip: usize)
     -> octave_value;
}
extern "C" {
    #[link_name =
          "?next_subsref@octave_value@@QEAA?AVoctave_value_list@@HAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$list@Voctave_value_list@@V?$allocator@Voctave_value_list@@@std@@@4@_K@Z"]
    pub fn octave_value_next_subsref1(this: *mut octave_value,
                                      nargout: ::std::os::raw::c_int,
                                      type_: *const std_string,
                                      idx: *const std_list, skip: usize)
     -> octave_value_list;
}
extern "C" {
    #[link_name =
          "?next_subsref@octave_value@@QEAA?AVoctave_value_list@@HAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$list@Voctave_value_list@@V?$allocator@Voctave_value_list@@@std@@@4@PEBV?$list@Voctave_lvalue@@V?$allocator@Voctave_lvalue@@@std@@@4@_K@Z"]
    pub fn octave_value_next_subsref2(this: *mut octave_value,
                                      nargout: ::std::os::raw::c_int,
                                      type_: *const std_string,
                                      idx: *const std_list,
                                      lvalue_list: *const std_list,
                                      skip: usize) -> octave_value_list;
}
extern "C" {
    #[link_name =
          "?next_subsref@octave_value@@QEAA?AV1@_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$list@Voctave_value_list@@V?$allocator@Voctave_value_list@@@std@@@3@_K@Z"]
    pub fn octave_value_next_subsref3(this: *mut octave_value, auto_add: bool,
                                      type_: *const std_string,
                                      idx: *const std_list, skip: usize)
     -> octave_value;
}
extern "C" {
    #[link_name =
          "?do_multi_index_op@octave_value@@QEAA?AVoctave_value_list@@HAEBV2@@Z"]
    pub fn octave_value_do_multi_index_op(this: *mut octave_value,
                                          nargout: ::std::os::raw::c_int,
                                          idx: *const octave_value_list)
     -> octave_value_list;
}
extern "C" {
    #[link_name =
          "?do_multi_index_op@octave_value@@QEAA?AVoctave_value_list@@HAEBV2@PEBV?$list@Voctave_lvalue@@V?$allocator@Voctave_lvalue@@@std@@@std@@@Z"]
    pub fn octave_value_do_multi_index_op1(this: *mut octave_value,
                                           nargout: ::std::os::raw::c_int,
                                           idx: *const octave_value_list,
                                           lvalue_list: *const std_list)
     -> octave_value_list;
}
extern "C" {
    #[link_name =
          "?subsasgn@octave_value@@QEAA?AV1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$list@Voctave_value_list@@V?$allocator@Voctave_value_list@@@std@@@3@AEBV1@@Z"]
    pub fn octave_value_subsasgn(this: *mut octave_value,
                                 type_: *const std_string,
                                 idx: *const std_list,
                                 rhs: *const octave_value) -> octave_value;
}
extern "C" {
    #[link_name =
          "?undef_subsasgn@octave_value@@QEAA?AV1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$list@Voctave_value_list@@V?$allocator@Voctave_value_list@@@std@@@3@AEBV1@@Z"]
    pub fn octave_value_undef_subsasgn(this: *mut octave_value,
                                       type_: *const std_string,
                                       idx: *const std_list,
                                       rhs: *const octave_value)
     -> octave_value;
}
extern "C" {
    #[link_name =
          "?assign@octave_value@@QEAAAEAV1@W4assign_op@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$list@Voctave_value_list@@V?$allocator@Voctave_value_list@@@std@@@4@AEBV1@@Z"]
    pub fn octave_value_assign(this: *mut octave_value,
                               op: octave_value_assign_op,
                               type_: *const std_string, idx: *const std_list,
                               rhs: *const octave_value) -> *mut octave_value;
}
extern "C" {
    #[link_name = "?assign@octave_value@@QEAAAEAV1@W4assign_op@1@AEBV1@@Z"]
    pub fn octave_value_assign1(this: *mut octave_value,
                                arg1: octave_value_assign_op,
                                rhs: *const octave_value)
     -> *mut octave_value;
}
extern "C" {
    #[link_name = "?length@octave_value@@QEBAHXZ"]
    pub fn octave_value_length(this: *const octave_value) -> octave_idx_type;
}
extern "C" {
    #[link_name = "?is_equal@octave_value@@QEBA_NAEBV1@@Z"]
    pub fn octave_value_is_equal(this: *const octave_value,
                                 arg1: *const octave_value) -> bool;
}
extern "C" {
    #[link_name = "?idx_type_value@octave_value@@QEBAH_N0@Z"]
    pub fn octave_value_idx_type_value(this: *const octave_value,
                                       req_int: bool, frc_str_conv: bool)
     -> octave_idx_type;
}
extern "C" {
    #[link_name = "?cell_value@octave_value@@QEBA?AVCell@@XZ"]
    pub fn octave_value_cell_value(this: *const octave_value) -> Cell;
}
extern "C" {
    #[link_name = "?map_value@octave_value@@QEBA?AVoctave_map@@XZ"]
    pub fn octave_value_map_value(this: *const octave_value) -> octave_map;
}
extern "C" {
    #[link_name =
          "?scalar_map_value@octave_value@@QEBA?AVoctave_scalar_map@@XZ"]
    pub fn octave_value_scalar_map_value(this: *const octave_value)
     -> octave_scalar_map;
}
extern "C" {
    #[link_name =
          "?function_value@octave_value@@QEBAPEAVoctave_function@@_N@Z"]
    pub fn octave_value_function_value(this: *const octave_value,
                                       silent: bool) -> *mut octave_function;
}
extern "C" {
    #[link_name =
          "?user_function_value@octave_value@@QEBAPEAVoctave_user_function@@_N@Z"]
    pub fn octave_value_user_function_value(this: *const octave_value,
                                            silent: bool)
     -> *mut octave_user_function;
}
extern "C" {
    #[link_name =
          "?user_script_value@octave_value@@QEBAPEAVoctave_user_script@@_N@Z"]
    pub fn octave_value_user_script_value(this: *const octave_value,
                                          silent: bool)
     -> *mut octave_user_script;
}
extern "C" {
    #[link_name =
          "?user_code_value@octave_value@@QEBAPEAVoctave_user_code@@_N@Z"]
    pub fn octave_value_user_code_value(this: *const octave_value,
                                        silent: bool)
     -> *mut octave_user_code;
}
extern "C" {
    #[link_name =
          "?fcn_handle_value@octave_value@@QEBAPEAVoctave_fcn_handle@@_N@Z"]
    pub fn octave_value_fcn_handle_value(this: *const octave_value,
                                         silent: bool)
     -> *mut octave_fcn_handle;
}
extern "C" {
    #[link_name =
          "?fcn_inline_value@octave_value@@QEBAPEAVoctave_fcn_inline@@_N@Z"]
    pub fn octave_value_fcn_inline_value(this: *const octave_value,
                                         silent: bool)
     -> *mut octave_fcn_inline;
}
extern "C" {
    #[link_name = "?list_value@octave_value@@QEBA?AVoctave_value_list@@XZ"]
    pub fn octave_value_list_value(this: *const octave_value)
     -> octave_value_list;
}
extern "C" {
    #[link_name =
          "?column_vector_value@octave_value@@QEBA?AVColumnVector@@_N0@Z"]
    pub fn octave_value_column_vector_value(this: *const octave_value,
                                            frc_str_conv: bool,
                                            frc_vec_conv: bool)
     -> ColumnVector;
}
extern "C" {
    #[link_name =
          "?complex_column_vector_value@octave_value@@QEBA?AVComplexColumnVector@@_N0@Z"]
    pub fn octave_value_complex_column_vector_value(this: *const octave_value,
                                                    frc_str_conv: bool,
                                                    frc_vec_conv: bool)
     -> ComplexColumnVector;
}
extern "C" {
    #[link_name = "?row_vector_value@octave_value@@QEBA?AVRowVector@@_N0@Z"]
    pub fn octave_value_row_vector_value(this: *const octave_value,
                                         frc_str_conv: bool,
                                         frc_vec_conv: bool) -> RowVector;
}
extern "C" {
    #[link_name =
          "?complex_row_vector_value@octave_value@@QEBA?AVComplexRowVector@@_N0@Z"]
    pub fn octave_value_complex_row_vector_value(this: *const octave_value,
                                                 frc_str_conv: bool,
                                                 frc_vec_conv: bool)
     -> ComplexRowVector;
}
extern "C" {
    #[link_name =
          "?float_column_vector_value@octave_value@@QEBA?AVFloatColumnVector@@_N0@Z"]
    pub fn octave_value_float_column_vector_value(this: *const octave_value,
                                                  frc_str_conv: bool,
                                                  frc_vec_conv: bool)
     -> FloatColumnVector;
}
extern "C" {
    #[link_name =
          "?float_complex_column_vector_value@octave_value@@QEBA?AVFloatComplexColumnVector@@_N0@Z"]
    pub fn octave_value_float_complex_column_vector_value(this:
                                                              *const octave_value,
                                                          frc_str_conv: bool,
                                                          frc_vec_conv: bool)
     -> FloatComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?float_row_vector_value@octave_value@@QEBA?AVFloatRowVector@@_N0@Z"]
    pub fn octave_value_float_row_vector_value(this: *const octave_value,
                                               frc_str_conv: bool,
                                               frc_vec_conv: bool)
     -> FloatRowVector;
}
extern "C" {
    #[link_name =
          "?float_complex_row_vector_value@octave_value@@QEBA?AVFloatComplexRowVector@@_N0@Z"]
    pub fn octave_value_float_complex_row_vector_value(this:
                                                           *const octave_value,
                                                       frc_str_conv: bool,
                                                       frc_vec_conv: bool)
     -> FloatComplexRowVector;
}
extern "C" {
    #[link_name = "?int_vector_value@octave_value@@QEBA?AV?$Array@H@@_N00@Z"]
    pub fn octave_value_int_vector_value(this: *const octave_value,
                                         req_int: bool, frc_str_conv: bool,
                                         frc_vec_conv: bool)
     -> Array<::std::os::raw::c_int>;
}
extern "C" {
    #[link_name =
          "?octave_idx_type_vector_value@octave_value@@QEBA?AV?$Array@H@@_N00@Z"]
    pub fn octave_value_octave_idx_type_vector_value(this:
                                                         *const octave_value,
                                                     req_int: bool,
                                                     frc_str_conv: bool,
                                                     frc_vec_conv: bool)
     -> Array<::std::os::raw::c_int>;
}
extern "C" {
    #[link_name = "?vector_value@octave_value@@QEBA?AV?$Array@N@@_N0@Z"]
    pub fn octave_value_vector_value(this: *const octave_value,
                                     frc_str_conv: bool, frc_vec_conv: bool)
     -> Array<f64>;
}
extern "C" {
    #[link_name =
          "?complex_vector_value@octave_value@@QEBA?AV?$Array@U?$complex@N@std@@@@_N0@Z"]
    pub fn octave_value_complex_vector_value(this: *const octave_value,
                                             frc_str_conv: bool,
                                             frc_vec_conv: bool)
     -> Array<std_complex<f64>>;
}
extern "C" {
    #[link_name = "?float_vector_value@octave_value@@QEBA?AV?$Array@M@@_N0@Z"]
    pub fn octave_value_float_vector_value(this: *const octave_value,
                                           frc_str_conv: bool,
                                           frc_vec_conv: bool) -> Array<f32>;
}
extern "C" {
    #[link_name =
          "?float_complex_vector_value@octave_value@@QEBA?AV?$Array@U?$complex@M@std@@@@_N0@Z"]
    pub fn octave_value_float_complex_vector_value(this: *const octave_value,
                                                   frc_str_conv: bool,
                                                   frc_vec_conv: bool)
     -> Array<std_complex<f32>>;
}
extern "C" {
    #[link_name = "?xshort_value@octave_value@@QEBAFPEBDZZ"]
    pub fn octave_value_xshort_value(this: *const octave_value,
                                     fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_short;
}
extern "C" {
    #[link_name = "?xushort_value@octave_value@@QEBAGPEBDZZ"]
    pub fn octave_value_xushort_value(this: *const octave_value,
                                      fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_ushort;
}
extern "C" {
    #[link_name = "?xint_value@octave_value@@QEBAHPEBDZZ"]
    pub fn octave_value_xint_value(this: *const octave_value,
                                   fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "?xuint_value@octave_value@@QEBAIPEBDZZ"]
    pub fn octave_value_xuint_value(this: *const octave_value,
                                    fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "?xnint_value@octave_value@@QEBAHPEBDZZ"]
    pub fn octave_value_xnint_value(this: *const octave_value,
                                    fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "?xlong_value@octave_value@@QEBAJPEBDZZ"]
    pub fn octave_value_xlong_value(this: *const octave_value,
                                    fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "?xulong_value@octave_value@@QEBAKPEBDZZ"]
    pub fn octave_value_xulong_value(this: *const octave_value,
                                     fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "?xint64_value@octave_value@@QEBA_JPEBDZZ"]
    pub fn octave_value_xint64_value(this: *const octave_value,
                                     fmt: *const ::std::os::raw::c_char, ...)
     -> i64;
}
extern "C" {
    #[link_name = "?xuint64_value@octave_value@@QEBA_KPEBDZZ"]
    pub fn octave_value_xuint64_value(this: *const octave_value,
                                      fmt: *const ::std::os::raw::c_char, ...)
     -> u64;
}
extern "C" {
    #[link_name = "?xidx_type_value@octave_value@@QEBAHPEBDZZ"]
    pub fn octave_value_xidx_type_value(this: *const octave_value,
                                        fmt:
                                            *const ::std::os::raw::c_char, ...)
     -> octave_idx_type;
}
extern "C" {
    #[link_name = "?xdouble_value@octave_value@@QEBANPEBDZZ"]
    pub fn octave_value_xdouble_value(this: *const octave_value,
                                      fmt: *const ::std::os::raw::c_char, ...)
     -> f64;
}
extern "C" {
    #[link_name = "?xfloat_value@octave_value@@QEBAMPEBDZZ"]
    pub fn octave_value_xfloat_value(this: *const octave_value,
                                     fmt: *const ::std::os::raw::c_char, ...)
     -> f32;
}
extern "C" {
    #[link_name = "?xscalar_value@octave_value@@QEBANPEBDZZ"]
    pub fn octave_value_xscalar_value(this: *const octave_value,
                                      fmt: *const ::std::os::raw::c_char, ...)
     -> f64;
}
extern "C" {
    #[link_name = "?xfloat_scalar_value@octave_value@@QEBAMPEBDZZ"]
    pub fn octave_value_xfloat_scalar_value(this: *const octave_value,
                                            fmt:
                                                *const ::std::os::raw::c_char, ...)
     -> f32;
}
extern "C" {
    #[link_name = "?xmatrix_value@octave_value@@QEBA?AVMatrix@@PEBDZZ"]
    pub fn octave_value_xmatrix_value(this: *const octave_value,
                                      fmt: *const ::std::os::raw::c_char, ...)
     -> Matrix;
}
extern "C" {
    #[link_name =
          "?xfloat_matrix_value@octave_value@@QEBA?AVFloatMatrix@@PEBDZZ"]
    pub fn octave_value_xfloat_matrix_value(this: *const octave_value,
                                            fmt:
                                                *const ::std::os::raw::c_char, ...)
     -> FloatMatrix;
}
extern "C" {
    #[link_name = "?xarray_value@octave_value@@QEBA?AVNDArray@@PEBDZZ"]
    pub fn octave_value_xarray_value(this: *const octave_value,
                                     fmt: *const ::std::os::raw::c_char, ...)
     -> NDArray;
}
extern "C" {
    #[link_name =
          "?xfloat_array_value@octave_value@@QEBA?AVFloatNDArray@@PEBDZZ"]
    pub fn octave_value_xfloat_array_value(this: *const octave_value,
                                           fmt:
                                               *const ::std::os::raw::c_char, ...)
     -> FloatNDArray;
}
extern "C" {
    #[link_name =
          "?xcomplex_value@octave_value@@QEBA?AU?$complex@N@std@@PEBDZZ"]
    pub fn octave_value_xcomplex_value(this: *const octave_value,
                                       fmt:
                                           *const ::std::os::raw::c_char, ...)
     -> Complex;
}
extern "C" {
    #[link_name =
          "?xfloat_complex_value@octave_value@@QEBA?AU?$complex@M@std@@PEBDZZ"]
    pub fn octave_value_xfloat_complex_value(this: *const octave_value,
                                             fmt:
                                                 *const ::std::os::raw::c_char, ...)
     -> FloatComplex;
}
extern "C" {
    #[link_name =
          "?xcomplex_matrix_value@octave_value@@QEBA?AVComplexMatrix@@PEBDZZ"]
    pub fn octave_value_xcomplex_matrix_value(this: *const octave_value,
                                              fmt:
                                                  *const ::std::os::raw::c_char, ...)
     -> ComplexMatrix;
}
extern "C" {
    #[link_name =
          "?xfloat_complex_matrix_value@octave_value@@QEBA?AVFloatComplexMatrix@@PEBDZZ"]
    pub fn octave_value_xfloat_complex_matrix_value(this: *const octave_value,
                                                    fmt:
                                                        *const ::std::os::raw::c_char, ...)
     -> FloatComplexMatrix;
}
extern "C" {
    #[link_name =
          "?xcomplex_array_value@octave_value@@QEBA?AVComplexNDArray@@PEBDZZ"]
    pub fn octave_value_xcomplex_array_value(this: *const octave_value,
                                             fmt:
                                                 *const ::std::os::raw::c_char, ...)
     -> ComplexNDArray;
}
extern "C" {
    #[link_name =
          "?xfloat_complex_array_value@octave_value@@QEBA?AVFloatComplexNDArray@@PEBDZZ"]
    pub fn octave_value_xfloat_complex_array_value(this: *const octave_value,
                                                   fmt:
                                                       *const ::std::os::raw::c_char, ...)
     -> FloatComplexNDArray;
}
extern "C" {
    #[link_name = "?xbool_value@octave_value@@QEBA_NPEBDZZ"]
    pub fn octave_value_xbool_value(this: *const octave_value,
                                    fmt: *const ::std::os::raw::c_char, ...)
     -> bool;
}
extern "C" {
    #[link_name =
          "?xbool_matrix_value@octave_value@@QEBA?AVboolMatrix@@PEBDZZ"]
    pub fn octave_value_xbool_matrix_value(this: *const octave_value,
                                           fmt:
                                               *const ::std::os::raw::c_char, ...)
     -> boolMatrix;
}
extern "C" {
    #[link_name =
          "?xbool_array_value@octave_value@@QEBA?AVboolNDArray@@PEBDZZ"]
    pub fn octave_value_xbool_array_value(this: *const octave_value,
                                          fmt:
                                              *const ::std::os::raw::c_char, ...)
     -> boolNDArray;
}
extern "C" {
    #[link_name =
          "?xchar_matrix_value@octave_value@@QEBA?AVcharMatrix@@PEBDZZ"]
    pub fn octave_value_xchar_matrix_value(this: *const octave_value,
                                           fmt:
                                               *const ::std::os::raw::c_char, ...)
     -> charMatrix;
}
extern "C" {
    #[link_name =
          "?xchar_array_value@octave_value@@QEBA?AVcharNDArray@@PEBDZZ"]
    pub fn octave_value_xchar_array_value(this: *const octave_value,
                                          fmt:
                                              *const ::std::os::raw::c_char, ...)
     -> charNDArray;
}
extern "C" {
    #[link_name =
          "?xsparse_matrix_value@octave_value@@QEBA?AVSparseMatrix@@PEBDZZ"]
    pub fn octave_value_xsparse_matrix_value(this: *const octave_value,
                                             fmt:
                                                 *const ::std::os::raw::c_char, ...)
     -> SparseMatrix;
}
extern "C" {
    #[link_name =
          "?xsparse_complex_matrix_value@octave_value@@QEBA?AVSparseComplexMatrix@@PEBDZZ"]
    pub fn octave_value_xsparse_complex_matrix_value(this:
                                                         *const octave_value,
                                                     fmt:
                                                         *const ::std::os::raw::c_char, ...)
     -> SparseComplexMatrix;
}
extern "C" {
    #[link_name =
          "?xsparse_bool_matrix_value@octave_value@@QEBA?AVSparseBoolMatrix@@PEBDZZ"]
    pub fn octave_value_xsparse_bool_matrix_value(this: *const octave_value,
                                                  fmt:
                                                      *const ::std::os::raw::c_char, ...)
     -> SparseBoolMatrix;
}
extern "C" {
    #[link_name =
          "?xdiag_matrix_value@octave_value@@QEBA?AVDiagMatrix@@PEBDZZ"]
    pub fn octave_value_xdiag_matrix_value(this: *const octave_value,
                                           fmt:
                                               *const ::std::os::raw::c_char, ...)
     -> DiagMatrix;
}
extern "C" {
    #[link_name =
          "?xfloat_diag_matrix_value@octave_value@@QEBA?AVFloatDiagMatrix@@PEBDZZ"]
    pub fn octave_value_xfloat_diag_matrix_value(this: *const octave_value,
                                                 fmt:
                                                     *const ::std::os::raw::c_char, ...)
     -> FloatDiagMatrix;
}
extern "C" {
    #[link_name =
          "?xcomplex_diag_matrix_value@octave_value@@QEBA?AVComplexDiagMatrix@@PEBDZZ"]
    pub fn octave_value_xcomplex_diag_matrix_value(this: *const octave_value,
                                                   fmt:
                                                       *const ::std::os::raw::c_char, ...)
     -> ComplexDiagMatrix;
}
extern "C" {
    #[link_name =
          "?xfloat_complex_diag_matrix_value@octave_value@@QEBA?AVFloatComplexDiagMatrix@@PEBDZZ"]
    pub fn octave_value_xfloat_complex_diag_matrix_value(this:
                                                             *const octave_value,
                                                         fmt:
                                                             *const ::std::os::raw::c_char, ...)
     -> FloatComplexDiagMatrix;
}
extern "C" {
    #[link_name =
          "?xperm_matrix_value@octave_value@@QEBA?AVPermMatrix@@PEBDZZ"]
    pub fn octave_value_xperm_matrix_value(this: *const octave_value,
                                           fmt:
                                               *const ::std::os::raw::c_char, ...)
     -> PermMatrix;
}
extern "C" {
    #[link_name =
          "?xint8_scalar_value@octave_value@@QEBA?AV?$octave_int@C@@PEBDZZ"]
    pub fn octave_value_xint8_scalar_value(this: *const octave_value,
                                           fmt:
                                               *const ::std::os::raw::c_char, ...)
     -> octave_int8;
}
extern "C" {
    #[link_name =
          "?xint16_scalar_value@octave_value@@QEBA?AV?$octave_int@F@@PEBDZZ"]
    pub fn octave_value_xint16_scalar_value(this: *const octave_value,
                                            fmt:
                                                *const ::std::os::raw::c_char, ...)
     -> octave_int16;
}
extern "C" {
    #[link_name =
          "?xint32_scalar_value@octave_value@@QEBA?AV?$octave_int@H@@PEBDZZ"]
    pub fn octave_value_xint32_scalar_value(this: *const octave_value,
                                            fmt:
                                                *const ::std::os::raw::c_char, ...)
     -> octave_int32;
}
extern "C" {
    #[link_name =
          "?xint64_scalar_value@octave_value@@QEBA?AV?$octave_int@_J@@PEBDZZ"]
    pub fn octave_value_xint64_scalar_value(this: *const octave_value,
                                            fmt:
                                                *const ::std::os::raw::c_char, ...)
     -> octave_int64;
}
extern "C" {
    #[link_name =
          "?xuint8_scalar_value@octave_value@@QEBA?AV?$octave_int@E@@PEBDZZ"]
    pub fn octave_value_xuint8_scalar_value(this: *const octave_value,
                                            fmt:
                                                *const ::std::os::raw::c_char, ...)
     -> octave_uint8;
}
extern "C" {
    #[link_name =
          "?xuint16_scalar_value@octave_value@@QEBA?AV?$octave_int@G@@PEBDZZ"]
    pub fn octave_value_xuint16_scalar_value(this: *const octave_value,
                                             fmt:
                                                 *const ::std::os::raw::c_char, ...)
     -> octave_uint16;
}
extern "C" {
    #[link_name =
          "?xuint32_scalar_value@octave_value@@QEBA?AV?$octave_int@I@@PEBDZZ"]
    pub fn octave_value_xuint32_scalar_value(this: *const octave_value,
                                             fmt:
                                                 *const ::std::os::raw::c_char, ...)
     -> octave_uint32;
}
extern "C" {
    #[link_name =
          "?xuint64_scalar_value@octave_value@@QEBA?AV?$octave_int@_K@@PEBDZZ"]
    pub fn octave_value_xuint64_scalar_value(this: *const octave_value,
                                             fmt:
                                                 *const ::std::os::raw::c_char, ...)
     -> octave_uint64;
}
extern "C" {
    #[link_name =
          "?xint8_array_value@octave_value@@QEBA?AV?$intNDArray@V?$octave_int@C@@@@PEBDZZ"]
    pub fn octave_value_xint8_array_value(this: *const octave_value,
                                          fmt:
                                              *const ::std::os::raw::c_char, ...)
     -> int8NDArray;
}
extern "C" {
    #[link_name =
          "?xint16_array_value@octave_value@@QEBA?AV?$intNDArray@V?$octave_int@F@@@@PEBDZZ"]
    pub fn octave_value_xint16_array_value(this: *const octave_value,
                                           fmt:
                                               *const ::std::os::raw::c_char, ...)
     -> int16NDArray;
}
extern "C" {
    #[link_name =
          "?xint32_array_value@octave_value@@QEBA?AV?$intNDArray@V?$octave_int@H@@@@PEBDZZ"]
    pub fn octave_value_xint32_array_value(this: *const octave_value,
                                           fmt:
                                               *const ::std::os::raw::c_char, ...)
     -> int32NDArray;
}
extern "C" {
    #[link_name =
          "?xint64_array_value@octave_value@@QEBA?AV?$intNDArray@V?$octave_int@_J@@@@PEBDZZ"]
    pub fn octave_value_xint64_array_value(this: *const octave_value,
                                           fmt:
                                               *const ::std::os::raw::c_char, ...)
     -> int64NDArray;
}
extern "C" {
    #[link_name =
          "?xuint8_array_value@octave_value@@QEBA?AV?$intNDArray@V?$octave_int@E@@@@PEBDZZ"]
    pub fn octave_value_xuint8_array_value(this: *const octave_value,
                                           fmt:
                                               *const ::std::os::raw::c_char, ...)
     -> uint8NDArray;
}
extern "C" {
    #[link_name =
          "?xuint16_array_value@octave_value@@QEBA?AV?$intNDArray@V?$octave_int@G@@@@PEBDZZ"]
    pub fn octave_value_xuint16_array_value(this: *const octave_value,
                                            fmt:
                                                *const ::std::os::raw::c_char, ...)
     -> uint16NDArray;
}
extern "C" {
    #[link_name =
          "?xuint32_array_value@octave_value@@QEBA?AV?$intNDArray@V?$octave_int@I@@@@PEBDZZ"]
    pub fn octave_value_xuint32_array_value(this: *const octave_value,
                                            fmt:
                                                *const ::std::os::raw::c_char, ...)
     -> uint32NDArray;
}
extern "C" {
    #[link_name =
          "?xuint64_array_value@octave_value@@QEBA?AV?$intNDArray@V?$octave_int@_K@@@@PEBDZZ"]
    pub fn octave_value_xuint64_array_value(this: *const octave_value,
                                            fmt:
                                                *const ::std::os::raw::c_char, ...)
     -> uint64NDArray;
}
extern "C" {
    #[link_name =
          "?xstring_value@octave_value@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDZZ"]
    pub fn octave_value_xstring_value(this: *const octave_value,
                                      fmt: *const ::std::os::raw::c_char, ...)
     -> std_string;
}
extern "C" {
    #[link_name =
          "?xstring_vector_value@octave_value@@QEBA?AVstring_vector@@PEBDZZ"]
    pub fn octave_value_xstring_vector_value(this: *const octave_value,
                                             fmt:
                                                 *const ::std::os::raw::c_char, ...)
     -> string_vector;
}
extern "C" {
    #[link_name = "?xcell_value@octave_value@@QEBA?AVCell@@PEBDZZ"]
    pub fn octave_value_xcell_value(this: *const octave_value,
                                    fmt: *const ::std::os::raw::c_char, ...)
     -> Cell;
}
extern "C" {
    #[link_name =
          "?xcellstr_value@octave_value@@QEBA?AV?$Array@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@@PEBDZZ"]
    pub fn octave_value_xcellstr_value(this: *const octave_value,
                                       fmt:
                                           *const ::std::os::raw::c_char, ...)
     -> Array<std_basic_string<::std::os::raw::c_char, std_allocator>>;
}
extern "C" {
    #[link_name = "?xrange_value@octave_value@@QEBA?AVRange@@PEBDZZ"]
    pub fn octave_value_xrange_value(this: *const octave_value,
                                     fmt: *const ::std::os::raw::c_char, ...)
     -> Range;
}
extern "C" {
    #[link_name = "?xmap_value@octave_value@@QEBA?AVoctave_map@@PEBDZZ"]
    pub fn octave_value_xmap_value(this: *const octave_value,
                                   fmt: *const ::std::os::raw::c_char, ...)
     -> octave_map;
}
extern "C" {
    #[link_name =
          "?xscalar_map_value@octave_value@@QEBA?AVoctave_scalar_map@@PEBDZZ"]
    pub fn octave_value_xscalar_map_value(this: *const octave_value,
                                          fmt:
                                              *const ::std::os::raw::c_char, ...)
     -> octave_scalar_map;
}
extern "C" {
    #[link_name =
          "?xcolumn_vector_value@octave_value@@QEBA?AVColumnVector@@PEBDZZ"]
    pub fn octave_value_xcolumn_vector_value(this: *const octave_value,
                                             fmt:
                                                 *const ::std::os::raw::c_char, ...)
     -> ColumnVector;
}
extern "C" {
    #[link_name =
          "?xcomplex_column_vector_value@octave_value@@QEBA?AVComplexColumnVector@@PEBDZZ"]
    pub fn octave_value_xcomplex_column_vector_value(this:
                                                         *const octave_value,
                                                     fmt:
                                                         *const ::std::os::raw::c_char, ...)
     -> ComplexColumnVector;
}
extern "C" {
    #[link_name = "?xrow_vector_value@octave_value@@QEBA?AVRowVector@@PEBDZZ"]
    pub fn octave_value_xrow_vector_value(this: *const octave_value,
                                          fmt:
                                              *const ::std::os::raw::c_char, ...)
     -> RowVector;
}
extern "C" {
    #[link_name =
          "?xcomplex_row_vector_value@octave_value@@QEBA?AVComplexRowVector@@PEBDZZ"]
    pub fn octave_value_xcomplex_row_vector_value(this: *const octave_value,
                                                  fmt:
                                                      *const ::std::os::raw::c_char, ...)
     -> ComplexRowVector;
}
extern "C" {
    #[link_name =
          "?xfloat_column_vector_value@octave_value@@QEBA?AVFloatColumnVector@@PEBDZZ"]
    pub fn octave_value_xfloat_column_vector_value(this: *const octave_value,
                                                   fmt:
                                                       *const ::std::os::raw::c_char, ...)
     -> FloatColumnVector;
}
extern "C" {
    #[link_name =
          "?xfloat_complex_column_vector_value@octave_value@@QEBA?AVFloatComplexColumnVector@@PEBDZZ"]
    pub fn octave_value_xfloat_complex_column_vector_value(this:
                                                               *const octave_value,
                                                           fmt:
                                                               *const ::std::os::raw::c_char, ...)
     -> FloatComplexColumnVector;
}
extern "C" {
    #[link_name =
          "?xfloat_row_vector_value@octave_value@@QEBA?AVFloatRowVector@@PEBDZZ"]
    pub fn octave_value_xfloat_row_vector_value(this: *const octave_value,
                                                fmt:
                                                    *const ::std::os::raw::c_char, ...)
     -> FloatRowVector;
}
extern "C" {
    #[link_name =
          "?xfloat_complex_row_vector_value@octave_value@@QEBA?AVFloatComplexRowVector@@PEBDZZ"]
    pub fn octave_value_xfloat_complex_row_vector_value(this:
                                                            *const octave_value,
                                                        fmt:
                                                            *const ::std::os::raw::c_char, ...)
     -> FloatComplexRowVector;
}
extern "C" {
    #[link_name = "?xint_vector_value@octave_value@@QEBA?AV?$Array@H@@PEBDZZ"]
    pub fn octave_value_xint_vector_value(this: *const octave_value,
                                          fmt:
                                              *const ::std::os::raw::c_char, ...)
     -> Array<::std::os::raw::c_int>;
}
extern "C" {
    #[link_name =
          "?xoctave_idx_type_vector_value@octave_value@@QEBA?AV?$Array@H@@PEBDZZ"]
    pub fn octave_value_xoctave_idx_type_vector_value(this:
                                                          *const octave_value,
                                                      fmt:
                                                          *const ::std::os::raw::c_char, ...)
     -> Array<::std::os::raw::c_int>;
}
extern "C" {
    #[link_name = "?xvector_value@octave_value@@QEBA?AV?$Array@N@@PEBDZZ"]
    pub fn octave_value_xvector_value(this: *const octave_value,
                                      fmt: *const ::std::os::raw::c_char, ...)
     -> Array<f64>;
}
extern "C" {
    #[link_name =
          "?xcomplex_vector_value@octave_value@@QEBA?AV?$Array@U?$complex@N@std@@@@PEBDZZ"]
    pub fn octave_value_xcomplex_vector_value(this: *const octave_value,
                                              fmt:
                                                  *const ::std::os::raw::c_char, ...)
     -> Array<std_complex<f64>>;
}
extern "C" {
    #[link_name =
          "?xfloat_vector_value@octave_value@@QEBA?AV?$Array@M@@PEBDZZ"]
    pub fn octave_value_xfloat_vector_value(this: *const octave_value,
                                            fmt:
                                                *const ::std::os::raw::c_char, ...)
     -> Array<f32>;
}
extern "C" {
    #[link_name =
          "?xfloat_complex_vector_value@octave_value@@QEBA?AV?$Array@U?$complex@M@std@@@@PEBDZZ"]
    pub fn octave_value_xfloat_complex_vector_value(this: *const octave_value,
                                                    fmt:
                                                        *const ::std::os::raw::c_char, ...)
     -> Array<std_complex<f32>>;
}
extern "C" {
    #[link_name =
          "?xfunction_value@octave_value@@QEBAPEAVoctave_function@@PEBDZZ"]
    pub fn octave_value_xfunction_value(this: *const octave_value,
                                        fmt:
                                            *const ::std::os::raw::c_char, ...)
     -> *mut octave_function;
}
extern "C" {
    #[link_name =
          "?xuser_function_value@octave_value@@QEBAPEAVoctave_user_function@@PEBDZZ"]
    pub fn octave_value_xuser_function_value(this: *const octave_value,
                                             fmt:
                                                 *const ::std::os::raw::c_char, ...)
     -> *mut octave_user_function;
}
extern "C" {
    #[link_name =
          "?xuser_script_value@octave_value@@QEBAPEAVoctave_user_script@@PEBDZZ"]
    pub fn octave_value_xuser_script_value(this: *const octave_value,
                                           fmt:
                                               *const ::std::os::raw::c_char, ...)
     -> *mut octave_user_script;
}
extern "C" {
    #[link_name =
          "?xuser_code_value@octave_value@@QEBAPEAVoctave_user_code@@PEBDZZ"]
    pub fn octave_value_xuser_code_value(this: *const octave_value,
                                         fmt:
                                             *const ::std::os::raw::c_char, ...)
     -> *mut octave_user_code;
}
extern "C" {
    #[link_name =
          "?xfcn_handle_value@octave_value@@QEBAPEAVoctave_fcn_handle@@PEBDZZ"]
    pub fn octave_value_xfcn_handle_value(this: *const octave_value,
                                          fmt:
                                              *const ::std::os::raw::c_char, ...)
     -> *mut octave_fcn_handle;
}
extern "C" {
    #[link_name =
          "?xfcn_inline_value@octave_value@@QEBAPEAVoctave_fcn_inline@@PEBDZZ"]
    pub fn octave_value_xfcn_inline_value(this: *const octave_value,
                                          fmt:
                                              *const ::std::os::raw::c_char, ...)
     -> *mut octave_fcn_inline;
}
extern "C" {
    #[link_name =
          "?xlist_value@octave_value@@QEBA?AVoctave_value_list@@PEBDZZ"]
    pub fn octave_value_xlist_value(this: *const octave_value,
                                    fmt: *const ::std::os::raw::c_char, ...)
     -> octave_value_list;
}
extern "C" {
    #[link_name = "?storable_value@octave_value@@QEBA?AV1@XZ"]
    pub fn octave_value_storable_value(this: *const octave_value)
     -> octave_value;
}
extern "C" {
    #[link_name = "?make_storable_value@octave_value@@QEAAXXZ"]
    pub fn octave_value_make_storable_value(this: *mut octave_value);
}
extern "C" {
    #[link_name =
          "?do_non_const_unary_op@octave_value@@QEAAAEAV1@W4unary_op@1@@Z"]
    pub fn octave_value_do_non_const_unary_op(this: *mut octave_value,
                                              op: octave_value_unary_op)
     -> *mut octave_value;
}
extern "C" {
    #[link_name =
          "?do_non_const_unary_op@octave_value@@QEAAAEAV1@W4unary_op@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$list@Voctave_value_list@@V?$allocator@Voctave_value_list@@@std@@@4@@Z"]
    pub fn octave_value_do_non_const_unary_op1(this: *mut octave_value,
                                               op: octave_value_unary_op,
                                               type_: *const std_string,
                                               idx: *const std_list)
     -> *mut octave_value;
}
extern "C" {
    #[link_name =
          "?print_info@octave_value@@QEBAXAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z"]
    pub fn octave_value_print_info(this: *const octave_value,
                                   os: *mut std_ostream,
                                   prefix: *const std_string);
}
extern "C" {
    #[link_name =
          "?write@octave_value@@QEBAHAEAVoctave_stream@@HW4data_type@oct_data_conv@@HW4float_format@mach_info@octave@@@Z"]
    pub fn octave_value_write(this: *const octave_value,
                              os: *mut octave_stream,
                              block_size: ::std::os::raw::c_int,
                              output_type: oct_data_conv_data_type,
                              skip: ::std::os::raw::c_int,
                              flt_fmt: octave_mach_info_float_format)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@F@Z"]
    pub fn octave_value_octave_value(this: *mut octave_value,
                                     i: ::std::os::raw::c_short);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@G@Z"]
    pub fn octave_value_octave_value1(this: *mut octave_value,
                                      i: ::std::os::raw::c_ushort);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@H@Z"]
    pub fn octave_value_octave_value2(this: *mut octave_value,
                                      i: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@I@Z"]
    pub fn octave_value_octave_value3(this: *mut octave_value,
                                      i: ::std::os::raw::c_uint);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@J@Z"]
    pub fn octave_value_octave_value4(this: *mut octave_value,
                                      i: ::std::os::raw::c_long);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@K@Z"]
    pub fn octave_value_octave_value5(this: *mut octave_value,
                                      i: ::std::os::raw::c_ulong);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@_J@Z"]
    pub fn octave_value_octave_value6(this: *mut octave_value,
                                      i: ::std::os::raw::c_longlong);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@_K@Z"]
    pub fn octave_value_octave_value7(this: *mut octave_value,
                                      i: ::std::os::raw::c_ulonglong);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@Vtime@sys@octave@@@Z"]
    pub fn octave_value_octave_value8(this: *mut octave_value,
                                      t: octave_sys_time);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@N@Z"]
    pub fn octave_value_octave_value9(this: *mut octave_value, d: f64);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@M@Z"]
    pub fn octave_value_octave_value10(this: *mut octave_value, d: f32);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@AEBV?$Array@Voctave_value@@@@_N@Z"]
    pub fn octave_value_octave_value11(this: *mut octave_value,
                                       a: *const Array<octave_value>,
                                       is_cs_list: bool);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@AEBVCell@@_N@Z"]
    pub fn octave_value_octave_value12(this: *mut octave_value,
                                       c: *const Cell, is_cs_list: bool);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@AEBVMatrix@@AEBVMatrixType@@@Z"]
    pub fn octave_value_octave_value13(this: *mut octave_value,
                                       m: *const Matrix,
                                       t: *const MatrixType);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@AEBVFloatMatrix@@AEBVMatrixType@@@Z"]
    pub fn octave_value_octave_value14(this: *mut octave_value,
                                       m: *const FloatMatrix,
                                       t: *const MatrixType);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@AEBVNDArray@@@Z"]
    pub fn octave_value_octave_value15(this: *mut octave_value,
                                       nda: *const NDArray);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@AEBVFloatNDArray@@@Z"]
    pub fn octave_value_octave_value16(this: *mut octave_value,
                                       nda: *const FloatNDArray);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@AEBV?$Array@N@@@Z"]
    pub fn octave_value_octave_value17(this: *mut octave_value,
                                       m: *const Array<f64>);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@AEBV?$Array@M@@@Z"]
    pub fn octave_value_octave_value18(this: *mut octave_value,
                                       m: *const Array<f32>);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@AEBVDiagMatrix@@@Z"]
    pub fn octave_value_octave_value19(this: *mut octave_value,
                                       d: *const DiagMatrix);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@AEBV?$DiagArray2@N@@@Z"]
    pub fn octave_value_octave_value20(this: *mut octave_value,
                                       d: *const DiagArray2<f64>);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@AEBV?$DiagArray2@M@@@Z"]
    pub fn octave_value_octave_value21(this: *mut octave_value,
                                       d: *const DiagArray2<f32>);
}
extern "C" {
    #[link_name =
          "??0octave_value@@QEAA@AEBV?$DiagArray2@U?$complex@N@std@@@@@Z"]
    pub fn octave_value_octave_value22(this: *mut octave_value,
                                       d:
                                           *const DiagArray2<std_complex<f64>>);
}
extern "C" {
    #[link_name =
          "??0octave_value@@QEAA@AEBV?$DiagArray2@U?$complex@M@std@@@@@Z"]
    pub fn octave_value_octave_value23(this: *mut octave_value,
                                       d:
                                           *const DiagArray2<std_complex<f32>>);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@AEBVFloatDiagMatrix@@@Z"]
    pub fn octave_value_octave_value24(this: *mut octave_value,
                                       d: *const FloatDiagMatrix);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@AEBVRowVector@@@Z"]
    pub fn octave_value_octave_value25(this: *mut octave_value,
                                       v: *const RowVector);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@AEBVFloatRowVector@@@Z"]
    pub fn octave_value_octave_value26(this: *mut octave_value,
                                       v: *const FloatRowVector);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@AEBVColumnVector@@@Z"]
    pub fn octave_value_octave_value27(this: *mut octave_value,
                                       v: *const ColumnVector);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@AEBVFloatColumnVector@@@Z"]
    pub fn octave_value_octave_value28(this: *mut octave_value,
                                       v: *const FloatColumnVector);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@AEBU?$complex@N@std@@@Z"]
    pub fn octave_value_octave_value29(this: *mut octave_value,
                                       C: *const Complex);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@AEBU?$complex@M@std@@@Z"]
    pub fn octave_value_octave_value30(this: *mut octave_value,
                                       C: *const FloatComplex);
}
extern "C" {
    #[link_name =
          "??0octave_value@@QEAA@AEBVComplexMatrix@@AEBVMatrixType@@@Z"]
    pub fn octave_value_octave_value31(this: *mut octave_value,
                                       m: *const ComplexMatrix,
                                       t: *const MatrixType);
}
extern "C" {
    #[link_name =
          "??0octave_value@@QEAA@AEBVFloatComplexMatrix@@AEBVMatrixType@@@Z"]
    pub fn octave_value_octave_value32(this: *mut octave_value,
                                       m: *const FloatComplexMatrix,
                                       t: *const MatrixType);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@AEBVComplexNDArray@@@Z"]
    pub fn octave_value_octave_value33(this: *mut octave_value,
                                       cnda: *const ComplexNDArray);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@AEBVFloatComplexNDArray@@@Z"]
    pub fn octave_value_octave_value34(this: *mut octave_value,
                                       cnda: *const FloatComplexNDArray);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@AEBV?$Array@U?$complex@N@std@@@@@Z"]
    pub fn octave_value_octave_value35(this: *mut octave_value,
                                       m: *const Array<std_complex<f64>>);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@AEBV?$Array@U?$complex@M@std@@@@@Z"]
    pub fn octave_value_octave_value36(this: *mut octave_value,
                                       m: *const Array<std_complex<f32>>);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@AEBVComplexDiagMatrix@@@Z"]
    pub fn octave_value_octave_value37(this: *mut octave_value,
                                       d: *const ComplexDiagMatrix);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@AEBVFloatComplexDiagMatrix@@@Z"]
    pub fn octave_value_octave_value38(this: *mut octave_value,
                                       d: *const FloatComplexDiagMatrix);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@AEBVComplexRowVector@@@Z"]
    pub fn octave_value_octave_value39(this: *mut octave_value,
                                       v: *const ComplexRowVector);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@AEBVFloatComplexRowVector@@@Z"]
    pub fn octave_value_octave_value40(this: *mut octave_value,
                                       v: *const FloatComplexRowVector);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@AEBVComplexColumnVector@@@Z"]
    pub fn octave_value_octave_value41(this: *mut octave_value,
                                       v: *const ComplexColumnVector);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@AEBVFloatComplexColumnVector@@@Z"]
    pub fn octave_value_octave_value42(this: *mut octave_value,
                                       v: *const FloatComplexColumnVector);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@AEBVPermMatrix@@@Z"]
    pub fn octave_value_octave_value43(this: *mut octave_value,
                                       p: *const PermMatrix);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@_N@Z"]
    pub fn octave_value_octave_value44(this: *mut octave_value, b: bool);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@AEBVboolMatrix@@AEBVMatrixType@@@Z"]
    pub fn octave_value_octave_value45(this: *mut octave_value,
                                       bm: *const boolMatrix,
                                       t: *const MatrixType);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@AEBVboolNDArray@@@Z"]
    pub fn octave_value_octave_value46(this: *mut octave_value,
                                       bnda: *const boolNDArray);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@AEBV?$Array@_N@@@Z"]
    pub fn octave_value_octave_value47(this: *mut octave_value,
                                       bnda: *const Array<bool>);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@DD@Z"]
    pub fn octave_value_octave_value48(this: *mut octave_value,
                                       c: ::std::os::raw::c_char,
                                       type_: ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@PEBDD@Z"]
    pub fn octave_value_octave_value49(this: *mut octave_value,
                                       s: *const ::std::os::raw::c_char,
                                       type_: ::std::os::raw::c_char);
}
extern "C" {
    #[link_name =
          "??0octave_value@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@D@Z"]
    pub fn octave_value_octave_value50(this: *mut octave_value,
                                       s: *const std_string,
                                       type_: ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@AEBVstring_vector@@D@Z"]
    pub fn octave_value_octave_value51(this: *mut octave_value,
                                       s: *const string_vector,
                                       type_: ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@AEBVcharMatrix@@D@Z"]
    pub fn octave_value_octave_value52(this: *mut octave_value,
                                       chm: *const charMatrix,
                                       type_: ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@AEBVcharNDArray@@D@Z"]
    pub fn octave_value_octave_value53(this: *mut octave_value,
                                       chnda: *const charNDArray,
                                       type_: ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@AEBV?$Array@D@@D@Z"]
    pub fn octave_value_octave_value54(this: *mut octave_value,
                                       chnda:
                                           *const Array<::std::os::raw::c_char>,
                                       type_: ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@AEBVcharMatrix@@_ND@Z"]
    pub fn octave_value_octave_value55(this: *mut octave_value,
                                       chm: *const charMatrix,
                                       is_string: bool,
                                       type_: ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@AEBVcharNDArray@@_ND@Z"]
    pub fn octave_value_octave_value56(this: *mut octave_value,
                                       chnda: *const charNDArray,
                                       is_string: bool,
                                       type_: ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@AEBV?$Array@D@@_ND@Z"]
    pub fn octave_value_octave_value57(this: *mut octave_value,
                                       chnda:
                                           *const Array<::std::os::raw::c_char>,
                                       is_string: bool,
                                       type_: ::std::os::raw::c_char);
}
extern "C" {
    #[link_name =
          "??0octave_value@@QEAA@AEBVSparseMatrix@@AEBVMatrixType@@@Z"]
    pub fn octave_value_octave_value58(this: *mut octave_value,
                                       m: *const SparseMatrix,
                                       t: *const MatrixType);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@AEBV?$Sparse@N@@AEBVMatrixType@@@Z"]
    pub fn octave_value_octave_value59(this: *mut octave_value,
                                       m: *const Sparse<f64>,
                                       t: *const MatrixType);
}
extern "C" {
    #[link_name =
          "??0octave_value@@QEAA@AEBVSparseComplexMatrix@@AEBVMatrixType@@@Z"]
    pub fn octave_value_octave_value60(this: *mut octave_value,
                                       m: *const SparseComplexMatrix,
                                       t: *const MatrixType);
}
extern "C" {
    #[link_name =
          "??0octave_value@@QEAA@AEBV?$Sparse@U?$complex@N@std@@@@AEBVMatrixType@@@Z"]
    pub fn octave_value_octave_value61(this: *mut octave_value,
                                       m: *const Sparse<std_complex<f64>>,
                                       t: *const MatrixType);
}
extern "C" {
    #[link_name =
          "??0octave_value@@QEAA@AEBVSparseBoolMatrix@@AEBVMatrixType@@@Z"]
    pub fn octave_value_octave_value62(this: *mut octave_value,
                                       bm: *const SparseBoolMatrix,
                                       t: *const MatrixType);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@AEBV?$Sparse@_N@@AEBVMatrixType@@@Z"]
    pub fn octave_value_octave_value63(this: *mut octave_value,
                                       m: *const Sparse<bool>,
                                       t: *const MatrixType);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@AEBV?$octave_int@C@@@Z"]
    pub fn octave_value_octave_value64(this: *mut octave_value,
                                       i: *const octave_int8);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@AEBV?$octave_int@F@@@Z"]
    pub fn octave_value_octave_value65(this: *mut octave_value,
                                       i: *const octave_int16);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@AEBV?$octave_int@H@@@Z"]
    pub fn octave_value_octave_value66(this: *mut octave_value,
                                       i: *const octave_int32);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@AEBV?$octave_int@_J@@@Z"]
    pub fn octave_value_octave_value67(this: *mut octave_value,
                                       i: *const octave_int64);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@AEBV?$octave_int@E@@@Z"]
    pub fn octave_value_octave_value68(this: *mut octave_value,
                                       i: *const octave_uint8);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@AEBV?$octave_int@G@@@Z"]
    pub fn octave_value_octave_value69(this: *mut octave_value,
                                       i: *const octave_uint16);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@AEBV?$octave_int@I@@@Z"]
    pub fn octave_value_octave_value70(this: *mut octave_value,
                                       i: *const octave_uint32);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@AEBV?$octave_int@_K@@@Z"]
    pub fn octave_value_octave_value71(this: *mut octave_value,
                                       i: *const octave_uint64);
}
extern "C" {
    #[link_name =
          "??0octave_value@@QEAA@AEBV?$intNDArray@V?$octave_int@C@@@@@Z"]
    pub fn octave_value_octave_value72(this: *mut octave_value,
                                       inda: *const int8NDArray);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@AEBV?$Array@V?$octave_int@C@@@@@Z"]
    pub fn octave_value_octave_value73(this: *mut octave_value,
                                       inda:
                                           *const Array<octave_int<::std::os::raw::c_schar>>);
}
extern "C" {
    #[link_name =
          "??0octave_value@@QEAA@AEBV?$intNDArray@V?$octave_int@F@@@@@Z"]
    pub fn octave_value_octave_value74(this: *mut octave_value,
                                       inda: *const int16NDArray);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@AEBV?$Array@V?$octave_int@F@@@@@Z"]
    pub fn octave_value_octave_value75(this: *mut octave_value,
                                       inda:
                                           *const Array<octave_int<::std::os::raw::c_short>>);
}
extern "C" {
    #[link_name =
          "??0octave_value@@QEAA@AEBV?$intNDArray@V?$octave_int@H@@@@@Z"]
    pub fn octave_value_octave_value76(this: *mut octave_value,
                                       inda: *const int32NDArray);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@AEBV?$Array@V?$octave_int@H@@@@@Z"]
    pub fn octave_value_octave_value77(this: *mut octave_value,
                                       inda:
                                           *const Array<octave_int<::std::os::raw::c_int>>);
}
extern "C" {
    #[link_name =
          "??0octave_value@@QEAA@AEBV?$intNDArray@V?$octave_int@_J@@@@@Z"]
    pub fn octave_value_octave_value78(this: *mut octave_value,
                                       inda: *const int64NDArray);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@AEBV?$Array@V?$octave_int@_J@@@@@Z"]
    pub fn octave_value_octave_value79(this: *mut octave_value,
                                       inda:
                                           *const Array<octave_int<::std::os::raw::c_longlong>>);
}
extern "C" {
    #[link_name =
          "??0octave_value@@QEAA@AEBV?$intNDArray@V?$octave_int@E@@@@@Z"]
    pub fn octave_value_octave_value80(this: *mut octave_value,
                                       inda: *const uint8NDArray);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@AEBV?$Array@V?$octave_int@E@@@@@Z"]
    pub fn octave_value_octave_value81(this: *mut octave_value,
                                       inda:
                                           *const Array<octave_int<::std::os::raw::c_uchar>>);
}
extern "C" {
    #[link_name =
          "??0octave_value@@QEAA@AEBV?$intNDArray@V?$octave_int@G@@@@@Z"]
    pub fn octave_value_octave_value82(this: *mut octave_value,
                                       inda: *const uint16NDArray);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@AEBV?$Array@V?$octave_int@G@@@@@Z"]
    pub fn octave_value_octave_value83(this: *mut octave_value,
                                       inda:
                                           *const Array<octave_int<::std::os::raw::c_ushort>>);
}
extern "C" {
    #[link_name =
          "??0octave_value@@QEAA@AEBV?$intNDArray@V?$octave_int@I@@@@@Z"]
    pub fn octave_value_octave_value84(this: *mut octave_value,
                                       inda: *const uint32NDArray);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@AEBV?$Array@V?$octave_int@I@@@@@Z"]
    pub fn octave_value_octave_value85(this: *mut octave_value,
                                       inda:
                                           *const Array<octave_int<::std::os::raw::c_uint>>);
}
extern "C" {
    #[link_name =
          "??0octave_value@@QEAA@AEBV?$intNDArray@V?$octave_int@_K@@@@@Z"]
    pub fn octave_value_octave_value86(this: *mut octave_value,
                                       inda: *const uint64NDArray);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@AEBV?$Array@V?$octave_int@_K@@@@@Z"]
    pub fn octave_value_octave_value87(this: *mut octave_value,
                                       inda:
                                           *const Array<octave_int<::std::os::raw::c_ulonglong>>);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@AEBV?$Array@H@@_N1@Z"]
    pub fn octave_value_octave_value88(this: *mut octave_value,
                                       inda:
                                           *const Array<::std::os::raw::c_int>,
                                       zero_based: bool, cache_index: bool);
}
extern "C" {
    #[link_name =
          "??0octave_value@@QEAA@AEBV?$Array@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@@@Z"]
    pub fn octave_value_octave_value89(this: *mut octave_value,
                                       cellstr:
                                           *const Array<std_basic_string<::std::os::raw::c_char,
                                                                         std_allocator>>);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@AEBVidx_vector@@_N@Z"]
    pub fn octave_value_octave_value90(this: *mut octave_value,
                                       idx: *const idx_vector, lazy: bool);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@NNN@Z"]
    pub fn octave_value_octave_value91(this: *mut octave_value, base: f64,
                                       limit: f64, inc: f64);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@AEBVRange@@_N@Z"]
    pub fn octave_value_octave_value92(this: *mut octave_value,
                                       r: *const Range, force_range: bool);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@AEBVoctave_map@@@Z"]
    pub fn octave_value_octave_value93(this: *mut octave_value,
                                       m: *const octave_map);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@AEBVoctave_scalar_map@@@Z"]
    pub fn octave_value_octave_value94(this: *mut octave_value,
                                       m: *const octave_scalar_map);
}
extern "C" {
    #[link_name =
          "??0octave_value@@QEAA@AEBVoctave_map@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$list@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@3@@Z"]
    pub fn octave_value_octave_value95(this: *mut octave_value,
                                       m: *const octave_map,
                                       id: *const std_string,
                                       plist: *const std_list);
}
extern "C" {
    #[link_name =
          "??0octave_value@@QEAA@AEBVoctave_scalar_map@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$list@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@3@@Z"]
    pub fn octave_value_octave_value96(this: *mut octave_value,
                                       m: *const octave_scalar_map,
                                       id: *const std_string,
                                       plist: *const std_list);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@AEBVoctave_value_list@@_N@Z"]
    pub fn octave_value_octave_value97(this: *mut octave_value,
                                       m: *const octave_value_list,
                                       arg1: bool);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@W4magic_colon@0@@Z"]
    pub fn octave_value_octave_value98(this: *mut octave_value,
                                       arg1: octave_value_magic_colon);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@PEAVoctave_base_value@@_N@Z"]
    pub fn octave_value_octave_value99(this: *mut octave_value,
                                       new_rep: *mut octave_base_value,
                                       borrow: bool);
}
extern "C" {
    #[link_name = "??0octave_value@@QEAA@PEAVoctave_base_value@@H@Z"]
    pub fn octave_value_octave_value100(this: *mut octave_value,
                                        new_rep: *mut octave_base_value,
                                        xcount: ::std::os::raw::c_int);
}
impl octave_value {
    #[inline]
    pub unsafe fn assign_op_to_binary_op(arg1: octave_value_assign_op)
     -> octave_value_binary_op {
        octave_value_assign_op_to_binary_op(arg1)
    }
    #[inline]
    pub unsafe fn binary_op_to_assign_op(arg1: octave_value_binary_op)
     -> octave_value_assign_op {
        octave_value_binary_op_to_assign_op(arg1)
    }
    #[inline]
    pub unsafe fn unary_op_as_string(arg1: octave_value_unary_op)
     -> std_string {
        octave_value_unary_op_as_string(arg1)
    }
    #[inline]
    pub unsafe fn unary_op_fcn_name(arg1: octave_value_unary_op)
     -> std_string {
        octave_value_unary_op_fcn_name(arg1)
    }
    #[inline]
    pub unsafe fn binary_op_as_string(arg1: octave_value_binary_op)
     -> std_string {
        octave_value_binary_op_as_string(arg1)
    }
    #[inline]
    pub unsafe fn binary_op_fcn_name(arg1: octave_value_binary_op)
     -> std_string {
        octave_value_binary_op_fcn_name(arg1)
    }
    #[inline]
    pub unsafe fn binary_op_fcn_name1(arg1: octave_value_compound_binary_op)
     -> std_string {
        octave_value_binary_op_fcn_name1(arg1)
    }
    #[inline]
    pub unsafe fn assign_op_as_string(arg1: octave_value_assign_op)
     -> std_string {
        octave_value_assign_op_as_string(arg1)
    }
    #[inline]
    pub unsafe fn empty_conv(type_: *const std_string,
                             rhs: *const octave_value) -> octave_value {
        octave_value_empty_conv(type_, rhs)
    }
    #[inline]
    pub unsafe fn clone(&self) -> *mut octave_base_value {
        octave_value_clone(self)
    }
    #[inline]
    pub unsafe fn maybe_mutate(&mut self) { octave_value_maybe_mutate(self) }
    #[inline]
    pub unsafe fn single_subsref(&mut self, type_: *const std_string,
                                 idx: *const octave_value_list)
     -> octave_value {
        octave_value_single_subsref(self, type_, idx)
    }
    #[inline]
    pub unsafe fn subsref(&mut self, type_: *const std_string,
                          idx: *const std_list,
                          nargout: ::std::os::raw::c_int)
     -> octave_value_list {
        octave_value_subsref(self, type_, idx, nargout)
    }
    #[inline]
    pub unsafe fn subsref1(&mut self, type_: *const std_string,
                           idx: *const std_list,
                           nargout: ::std::os::raw::c_int,
                           lvalue_list: *const std_list)
     -> octave_value_list {
        octave_value_subsref1(self, type_, idx, nargout, lvalue_list)
    }
    #[inline]
    pub unsafe fn next_subsref(&mut self, type_: *const std_string,
                               idx: *const std_list, skip: usize)
     -> octave_value {
        octave_value_next_subsref(self, type_, idx, skip)
    }
    #[inline]
    pub unsafe fn next_subsref1(&mut self, nargout: ::std::os::raw::c_int,
                                type_: *const std_string,
                                idx: *const std_list, skip: usize)
     -> octave_value_list {
        octave_value_next_subsref1(self, nargout, type_, idx, skip)
    }
    #[inline]
    pub unsafe fn next_subsref2(&mut self, nargout: ::std::os::raw::c_int,
                                type_: *const std_string,
                                idx: *const std_list,
                                lvalue_list: *const std_list, skip: usize)
     -> octave_value_list {
        octave_value_next_subsref2(self, nargout, type_, idx, lvalue_list,
                                   skip)
    }
    #[inline]
    pub unsafe fn next_subsref3(&mut self, auto_add: bool,
                                type_: *const std_string,
                                idx: *const std_list, skip: usize)
     -> octave_value {
        octave_value_next_subsref3(self, auto_add, type_, idx, skip)
    }
    #[inline]
    pub unsafe fn do_multi_index_op(&mut self, nargout: ::std::os::raw::c_int,
                                    idx: *const octave_value_list)
     -> octave_value_list {
        octave_value_do_multi_index_op(self, nargout, idx)
    }
    #[inline]
    pub unsafe fn do_multi_index_op1(&mut self,
                                     nargout: ::std::os::raw::c_int,
                                     idx: *const octave_value_list,
                                     lvalue_list: *const std_list)
     -> octave_value_list {
        octave_value_do_multi_index_op1(self, nargout, idx, lvalue_list)
    }
    #[inline]
    pub unsafe fn subsasgn(&mut self, type_: *const std_string,
                           idx: *const std_list, rhs: *const octave_value)
     -> octave_value {
        octave_value_subsasgn(self, type_, idx, rhs)
    }
    #[inline]
    pub unsafe fn undef_subsasgn(&mut self, type_: *const std_string,
                                 idx: *const std_list,
                                 rhs: *const octave_value) -> octave_value {
        octave_value_undef_subsasgn(self, type_, idx, rhs)
    }
    #[inline]
    pub unsafe fn assign(&mut self, op: octave_value_assign_op,
                         type_: *const std_string, idx: *const std_list,
                         rhs: *const octave_value) -> *mut octave_value {
        octave_value_assign(self, op, type_, idx, rhs)
    }
    #[inline]
    pub unsafe fn assign1(&mut self, arg1: octave_value_assign_op,
                          rhs: *const octave_value) -> *mut octave_value {
        octave_value_assign1(self, arg1, rhs)
    }
    #[inline]
    pub unsafe fn length(&self) -> octave_idx_type {
        octave_value_length(self)
    }
    #[inline]
    pub unsafe fn is_equal(&self, arg1: *const octave_value) -> bool {
        octave_value_is_equal(self, arg1)
    }
    #[inline]
    pub unsafe fn idx_type_value(&self, req_int: bool, frc_str_conv: bool)
     -> octave_idx_type {
        octave_value_idx_type_value(self, req_int, frc_str_conv)
    }
    #[inline]
    pub unsafe fn cell_value(&self) -> Cell { octave_value_cell_value(self) }
    #[inline]
    pub unsafe fn map_value(&self) -> octave_map {
        octave_value_map_value(self)
    }
    #[inline]
    pub unsafe fn scalar_map_value(&self) -> octave_scalar_map {
        octave_value_scalar_map_value(self)
    }
    #[inline]
    pub unsafe fn function_value(&self, silent: bool)
     -> *mut octave_function {
        octave_value_function_value(self, silent)
    }
    #[inline]
    pub unsafe fn user_function_value(&self, silent: bool)
     -> *mut octave_user_function {
        octave_value_user_function_value(self, silent)
    }
    #[inline]
    pub unsafe fn user_script_value(&self, silent: bool)
     -> *mut octave_user_script {
        octave_value_user_script_value(self, silent)
    }
    #[inline]
    pub unsafe fn user_code_value(&self, silent: bool)
     -> *mut octave_user_code {
        octave_value_user_code_value(self, silent)
    }
    #[inline]
    pub unsafe fn fcn_handle_value(&self, silent: bool)
     -> *mut octave_fcn_handle {
        octave_value_fcn_handle_value(self, silent)
    }
    #[inline]
    pub unsafe fn fcn_inline_value(&self, silent: bool)
     -> *mut octave_fcn_inline {
        octave_value_fcn_inline_value(self, silent)
    }
    #[inline]
    pub unsafe fn list_value(&self) -> octave_value_list {
        octave_value_list_value(self)
    }
    #[inline]
    pub unsafe fn column_vector_value(&self, frc_str_conv: bool,
                                      frc_vec_conv: bool) -> ColumnVector {
        octave_value_column_vector_value(self, frc_str_conv, frc_vec_conv)
    }
    #[inline]
    pub unsafe fn complex_column_vector_value(&self, frc_str_conv: bool,
                                              frc_vec_conv: bool)
     -> ComplexColumnVector {
        octave_value_complex_column_vector_value(self, frc_str_conv,
                                                 frc_vec_conv)
    }
    #[inline]
    pub unsafe fn row_vector_value(&self, frc_str_conv: bool,
                                   frc_vec_conv: bool) -> RowVector {
        octave_value_row_vector_value(self, frc_str_conv, frc_vec_conv)
    }
    #[inline]
    pub unsafe fn complex_row_vector_value(&self, frc_str_conv: bool,
                                           frc_vec_conv: bool)
     -> ComplexRowVector {
        octave_value_complex_row_vector_value(self, frc_str_conv,
                                              frc_vec_conv)
    }
    #[inline]
    pub unsafe fn float_column_vector_value(&self, frc_str_conv: bool,
                                            frc_vec_conv: bool)
     -> FloatColumnVector {
        octave_value_float_column_vector_value(self, frc_str_conv,
                                               frc_vec_conv)
    }
    #[inline]
    pub unsafe fn float_complex_column_vector_value(&self, frc_str_conv: bool,
                                                    frc_vec_conv: bool)
     -> FloatComplexColumnVector {
        octave_value_float_complex_column_vector_value(self, frc_str_conv,
                                                       frc_vec_conv)
    }
    #[inline]
    pub unsafe fn float_row_vector_value(&self, frc_str_conv: bool,
                                         frc_vec_conv: bool)
     -> FloatRowVector {
        octave_value_float_row_vector_value(self, frc_str_conv, frc_vec_conv)
    }
    #[inline]
    pub unsafe fn float_complex_row_vector_value(&self, frc_str_conv: bool,
                                                 frc_vec_conv: bool)
     -> FloatComplexRowVector {
        octave_value_float_complex_row_vector_value(self, frc_str_conv,
                                                    frc_vec_conv)
    }
    #[inline]
    pub unsafe fn int_vector_value(&self, req_int: bool, frc_str_conv: bool,
                                   frc_vec_conv: bool)
     -> Array<::std::os::raw::c_int> {
        octave_value_int_vector_value(self, req_int, frc_str_conv,
                                      frc_vec_conv)
    }
    #[inline]
    pub unsafe fn octave_idx_type_vector_value(&self, req_int: bool,
                                               frc_str_conv: bool,
                                               frc_vec_conv: bool)
     -> Array<::std::os::raw::c_int> {
        octave_value_octave_idx_type_vector_value(self, req_int, frc_str_conv,
                                                  frc_vec_conv)
    }
    #[inline]
    pub unsafe fn vector_value(&self, frc_str_conv: bool, frc_vec_conv: bool)
     -> Array<f64> {
        octave_value_vector_value(self, frc_str_conv, frc_vec_conv)
    }
    #[inline]
    pub unsafe fn complex_vector_value(&self, frc_str_conv: bool,
                                       frc_vec_conv: bool)
     -> Array<std_complex<f64>> {
        octave_value_complex_vector_value(self, frc_str_conv, frc_vec_conv)
    }
    #[inline]
    pub unsafe fn float_vector_value(&self, frc_str_conv: bool,
                                     frc_vec_conv: bool) -> Array<f32> {
        octave_value_float_vector_value(self, frc_str_conv, frc_vec_conv)
    }
    #[inline]
    pub unsafe fn float_complex_vector_value(&self, frc_str_conv: bool,
                                             frc_vec_conv: bool)
     -> Array<std_complex<f32>> {
        octave_value_float_complex_vector_value(self, frc_str_conv,
                                                frc_vec_conv)
    }
    #[inline]
    pub unsafe fn storable_value(&self) -> octave_value {
        octave_value_storable_value(self)
    }
    #[inline]
    pub unsafe fn make_storable_value(&mut self) {
        octave_value_make_storable_value(self)
    }
    #[inline]
    pub unsafe fn do_non_const_unary_op(&mut self, op: octave_value_unary_op)
     -> *mut octave_value {
        octave_value_do_non_const_unary_op(self, op)
    }
    #[inline]
    pub unsafe fn do_non_const_unary_op1(&mut self, op: octave_value_unary_op,
                                         type_: *const std_string,
                                         idx: *const std_list)
     -> *mut octave_value {
        octave_value_do_non_const_unary_op1(self, op, type_, idx)
    }
    #[inline]
    pub unsafe fn print_info(&self, os: *mut std_ostream,
                             prefix: *const std_string) {
        octave_value_print_info(self, os, prefix)
    }
    #[inline]
    pub unsafe fn write(&self, os: *mut octave_stream,
                        block_size: ::std::os::raw::c_int,
                        output_type: oct_data_conv_data_type,
                        skip: ::std::os::raw::c_int,
                        flt_fmt: octave_mach_info_float_format)
     -> ::std::os::raw::c_int {
        octave_value_write(self, os, block_size, output_type, skip, flt_fmt)
    }
    #[inline]
    pub unsafe fn new(i: ::std::os::raw::c_short) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value(&mut __bindgen_tmp, i);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(i: ::std::os::raw::c_ushort) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value1(&mut __bindgen_tmp, i);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new2(i: ::std::os::raw::c_int) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value2(&mut __bindgen_tmp, i);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new3(i: ::std::os::raw::c_uint) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value3(&mut __bindgen_tmp, i);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new4(i: ::std::os::raw::c_long) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value4(&mut __bindgen_tmp, i);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new5(i: ::std::os::raw::c_ulong) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value5(&mut __bindgen_tmp, i);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new6(i: ::std::os::raw::c_longlong) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value6(&mut __bindgen_tmp, i);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new7(i: ::std::os::raw::c_ulonglong) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value7(&mut __bindgen_tmp, i);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new8(t: octave_sys_time) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value8(&mut __bindgen_tmp, t);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new9(d: f64) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value9(&mut __bindgen_tmp, d);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new10(d: f32) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value10(&mut __bindgen_tmp, d);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new11(a: *const Array<octave_value>, is_cs_list: bool)
     -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value11(&mut __bindgen_tmp, a, is_cs_list);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new12(c: *const Cell, is_cs_list: bool) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value12(&mut __bindgen_tmp, c, is_cs_list);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new13(m: *const Matrix, t: *const MatrixType) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value13(&mut __bindgen_tmp, m, t);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new14(m: *const FloatMatrix, t: *const MatrixType) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value14(&mut __bindgen_tmp, m, t);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new15(nda: *const NDArray) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value15(&mut __bindgen_tmp, nda);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new16(nda: *const FloatNDArray) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value16(&mut __bindgen_tmp, nda);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new17(m: *const Array<f64>) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value17(&mut __bindgen_tmp, m);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new18(m: *const Array<f32>) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value18(&mut __bindgen_tmp, m);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new19(d: *const DiagMatrix) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value19(&mut __bindgen_tmp, d);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new20(d: *const DiagArray2<f64>) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value20(&mut __bindgen_tmp, d);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new21(d: *const DiagArray2<f32>) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value21(&mut __bindgen_tmp, d);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new22(d: *const DiagArray2<std_complex<f64>>) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value22(&mut __bindgen_tmp, d);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new23(d: *const DiagArray2<std_complex<f32>>) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value23(&mut __bindgen_tmp, d);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new24(d: *const FloatDiagMatrix) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value24(&mut __bindgen_tmp, d);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new25(v: *const RowVector) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value25(&mut __bindgen_tmp, v);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new26(v: *const FloatRowVector) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value26(&mut __bindgen_tmp, v);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new27(v: *const ColumnVector) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value27(&mut __bindgen_tmp, v);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new28(v: *const FloatColumnVector) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value28(&mut __bindgen_tmp, v);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new29(C: *const Complex) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value29(&mut __bindgen_tmp, C);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new30(C: *const FloatComplex) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value30(&mut __bindgen_tmp, C);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new31(m: *const ComplexMatrix, t: *const MatrixType)
     -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value31(&mut __bindgen_tmp, m, t);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new32(m: *const FloatComplexMatrix, t: *const MatrixType)
     -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value32(&mut __bindgen_tmp, m, t);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new33(cnda: *const ComplexNDArray) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value33(&mut __bindgen_tmp, cnda);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new34(cnda: *const FloatComplexNDArray) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value34(&mut __bindgen_tmp, cnda);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new35(m: *const Array<std_complex<f64>>) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value35(&mut __bindgen_tmp, m);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new36(m: *const Array<std_complex<f32>>) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value36(&mut __bindgen_tmp, m);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new37(d: *const ComplexDiagMatrix) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value37(&mut __bindgen_tmp, d);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new38(d: *const FloatComplexDiagMatrix) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value38(&mut __bindgen_tmp, d);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new39(v: *const ComplexRowVector) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value39(&mut __bindgen_tmp, v);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new40(v: *const FloatComplexRowVector) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value40(&mut __bindgen_tmp, v);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new41(v: *const ComplexColumnVector) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value41(&mut __bindgen_tmp, v);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new42(v: *const FloatComplexColumnVector) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value42(&mut __bindgen_tmp, v);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new43(p: *const PermMatrix) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value43(&mut __bindgen_tmp, p);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new44(b: bool) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value44(&mut __bindgen_tmp, b);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new45(bm: *const boolMatrix, t: *const MatrixType) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value45(&mut __bindgen_tmp, bm, t);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new46(bnda: *const boolNDArray) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value46(&mut __bindgen_tmp, bnda);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new47(bnda: *const Array<bool>) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value47(&mut __bindgen_tmp, bnda);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new48(c: ::std::os::raw::c_char,
                        type_: ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value48(&mut __bindgen_tmp, c, type_);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new49(s: *const ::std::os::raw::c_char,
                        type_: ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value49(&mut __bindgen_tmp, s, type_);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new50(s: *const std_string, type_: ::std::os::raw::c_char)
     -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value50(&mut __bindgen_tmp, s, type_);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new51(s: *const string_vector,
                        type_: ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value51(&mut __bindgen_tmp, s, type_);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new52(chm: *const charMatrix, type_: ::std::os::raw::c_char)
     -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value52(&mut __bindgen_tmp, chm, type_);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new53(chnda: *const charNDArray,
                        type_: ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value53(&mut __bindgen_tmp, chnda, type_);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new54(chnda: *const Array<::std::os::raw::c_char>,
                        type_: ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value54(&mut __bindgen_tmp, chnda, type_);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new55(chm: *const charMatrix, is_string: bool,
                        type_: ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value55(&mut __bindgen_tmp, chm, is_string,
                                    type_);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new56(chnda: *const charNDArray, is_string: bool,
                        type_: ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value56(&mut __bindgen_tmp, chnda, is_string,
                                    type_);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new57(chnda: *const Array<::std::os::raw::c_char>,
                        is_string: bool, type_: ::std::os::raw::c_char)
     -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value57(&mut __bindgen_tmp, chnda, is_string,
                                    type_);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new58(m: *const SparseMatrix, t: *const MatrixType)
     -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value58(&mut __bindgen_tmp, m, t);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new59(m: *const Sparse<f64>, t: *const MatrixType) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value59(&mut __bindgen_tmp, m, t);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new60(m: *const SparseComplexMatrix, t: *const MatrixType)
     -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value60(&mut __bindgen_tmp, m, t);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new61(m: *const Sparse<std_complex<f64>>,
                        t: *const MatrixType) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value61(&mut __bindgen_tmp, m, t);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new62(bm: *const SparseBoolMatrix, t: *const MatrixType)
     -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value62(&mut __bindgen_tmp, bm, t);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new63(m: *const Sparse<bool>, t: *const MatrixType)
     -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value63(&mut __bindgen_tmp, m, t);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new64(i: *const octave_int8) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value64(&mut __bindgen_tmp, i);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new65(i: *const octave_int16) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value65(&mut __bindgen_tmp, i);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new66(i: *const octave_int32) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value66(&mut __bindgen_tmp, i);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new67(i: *const octave_int64) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value67(&mut __bindgen_tmp, i);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new68(i: *const octave_uint8) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value68(&mut __bindgen_tmp, i);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new69(i: *const octave_uint16) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value69(&mut __bindgen_tmp, i);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new70(i: *const octave_uint32) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value70(&mut __bindgen_tmp, i);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new71(i: *const octave_uint64) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value71(&mut __bindgen_tmp, i);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new72(inda: *const int8NDArray) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value72(&mut __bindgen_tmp, inda);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new73(inda:
                            *const Array<octave_int<::std::os::raw::c_schar>>)
     -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value73(&mut __bindgen_tmp, inda);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new74(inda: *const int16NDArray) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value74(&mut __bindgen_tmp, inda);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new75(inda:
                            *const Array<octave_int<::std::os::raw::c_short>>)
     -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value75(&mut __bindgen_tmp, inda);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new76(inda: *const int32NDArray) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value76(&mut __bindgen_tmp, inda);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new77(inda: *const Array<octave_int<::std::os::raw::c_int>>)
     -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value77(&mut __bindgen_tmp, inda);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new78(inda: *const int64NDArray) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value78(&mut __bindgen_tmp, inda);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new79(inda:
                            *const Array<octave_int<::std::os::raw::c_longlong>>)
     -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value79(&mut __bindgen_tmp, inda);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new80(inda: *const uint8NDArray) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value80(&mut __bindgen_tmp, inda);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new81(inda:
                            *const Array<octave_int<::std::os::raw::c_uchar>>)
     -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value81(&mut __bindgen_tmp, inda);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new82(inda: *const uint16NDArray) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value82(&mut __bindgen_tmp, inda);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new83(inda:
                            *const Array<octave_int<::std::os::raw::c_ushort>>)
     -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value83(&mut __bindgen_tmp, inda);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new84(inda: *const uint32NDArray) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value84(&mut __bindgen_tmp, inda);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new85(inda:
                            *const Array<octave_int<::std::os::raw::c_uint>>)
     -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value85(&mut __bindgen_tmp, inda);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new86(inda: *const uint64NDArray) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value86(&mut __bindgen_tmp, inda);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new87(inda:
                            *const Array<octave_int<::std::os::raw::c_ulonglong>>)
     -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value87(&mut __bindgen_tmp, inda);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new88(inda: *const Array<::std::os::raw::c_int>,
                        zero_based: bool, cache_index: bool) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value88(&mut __bindgen_tmp, inda, zero_based,
                                    cache_index);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new89(cellstr:
                            *const Array<std_basic_string<::std::os::raw::c_char,
                                                          std_allocator>>)
     -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value89(&mut __bindgen_tmp, cellstr);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new90(idx: *const idx_vector, lazy: bool) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value90(&mut __bindgen_tmp, idx, lazy);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new91(base: f64, limit: f64, inc: f64) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value91(&mut __bindgen_tmp, base, limit, inc);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new92(r: *const Range, force_range: bool) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value92(&mut __bindgen_tmp, r, force_range);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new93(m: *const octave_map) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value93(&mut __bindgen_tmp, m);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new94(m: *const octave_scalar_map) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value94(&mut __bindgen_tmp, m);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new95(m: *const octave_map, id: *const std_string,
                        plist: *const std_list) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value95(&mut __bindgen_tmp, m, id, plist);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new96(m: *const octave_scalar_map, id: *const std_string,
                        plist: *const std_list) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value96(&mut __bindgen_tmp, m, id, plist);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new97(m: *const octave_value_list, arg1: bool) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value97(&mut __bindgen_tmp, m, arg1);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new98(arg1: octave_value_magic_colon) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value98(&mut __bindgen_tmp, arg1);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new99(new_rep: *mut octave_base_value, borrow: bool)
     -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value99(&mut __bindgen_tmp, new_rep, borrow);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new100(new_rep: *mut octave_base_value,
                         xcount: ::std::os::raw::c_int) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_value_octave_value100(&mut __bindgen_tmp, new_rep, xcount);
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct octave_user_script([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct octave_user_code([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tree_walker([u8; 0]);
pub const builtin_type_t_btyp_num_types: builtin_type_t =
    builtin_type_t::btyp_unknown;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum builtin_type_t {
    btyp_double = 0,
    btyp_float = 1,
    btyp_complex = 2,
    btyp_float_complex = 3,
    btyp_int8 = 4,
    btyp_int16 = 5,
    btyp_int32 = 6,
    btyp_int64 = 7,
    btyp_uint8 = 8,
    btyp_uint16 = 9,
    btyp_uint32 = 10,
    btyp_uint64 = 11,
    btyp_bool = 12,
    btyp_char = 13,
    btyp_struct = 14,
    btyp_cell = 15,
    btyp_func_handle = 16,
    btyp_unknown = 17,
}
extern "C" {
    #[link_name =
          "?btyp_class_name@@3PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A"]
    pub static mut btyp_class_name: [std_string; 17usize];
}
extern "C" {
    #[link_name = "?get_builtin_classes@@YA?AVstring_vector@@XZ"]
    pub fn get_builtin_classes() -> string_vector;
}
extern "C" {
    #[link_name = "?btyp_mixed_numeric@@YA?AW4builtin_type_t@@W41@0@Z"]
    pub fn btyp_mixed_numeric(x: builtin_type_t, y: builtin_type_t)
     -> builtin_type_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct class_to_btyp {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_class_to_btyp_instantiation_63062() {
    assert_eq!(::std::mem::size_of::<class_to_btyp>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               class_to_btyp ) ));
    assert_eq!(::std::mem::align_of::<class_to_btyp>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               class_to_btyp ) ));
}
#[test]
fn __bindgen_test_layout_class_to_btyp_instantiation_63066() {
    assert_eq!(::std::mem::size_of::<class_to_btyp>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               class_to_btyp ) ));
    assert_eq!(::std::mem::align_of::<class_to_btyp>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               class_to_btyp ) ));
}
#[test]
fn __bindgen_test_layout_class_to_btyp_instantiation_63070() {
    assert_eq!(::std::mem::size_of::<class_to_btyp>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               class_to_btyp ) ));
    assert_eq!(::std::mem::align_of::<class_to_btyp>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               class_to_btyp ) ));
}
#[test]
fn __bindgen_test_layout_class_to_btyp_instantiation_63073() {
    assert_eq!(::std::mem::size_of::<class_to_btyp>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               class_to_btyp ) ));
    assert_eq!(::std::mem::align_of::<class_to_btyp>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               class_to_btyp ) ));
}
#[test]
fn __bindgen_test_layout_class_to_btyp_instantiation_63076() {
    assert_eq!(::std::mem::size_of::<class_to_btyp>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               class_to_btyp ) ));
    assert_eq!(::std::mem::align_of::<class_to_btyp>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               class_to_btyp ) ));
}
#[test]
fn __bindgen_test_layout_class_to_btyp_instantiation_63079() {
    assert_eq!(::std::mem::size_of::<class_to_btyp>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               class_to_btyp ) ));
    assert_eq!(::std::mem::align_of::<class_to_btyp>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               class_to_btyp ) ));
}
#[test]
fn __bindgen_test_layout_class_to_btyp_instantiation_63082() {
    assert_eq!(::std::mem::size_of::<class_to_btyp>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               class_to_btyp ) ));
    assert_eq!(::std::mem::align_of::<class_to_btyp>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               class_to_btyp ) ));
}
#[test]
fn __bindgen_test_layout_class_to_btyp_instantiation_63085() {
    assert_eq!(::std::mem::size_of::<class_to_btyp>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               class_to_btyp ) ));
    assert_eq!(::std::mem::align_of::<class_to_btyp>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               class_to_btyp ) ));
}
#[test]
fn __bindgen_test_layout_class_to_btyp_instantiation_63088() {
    assert_eq!(::std::mem::size_of::<class_to_btyp>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               class_to_btyp ) ));
    assert_eq!(::std::mem::align_of::<class_to_btyp>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               class_to_btyp ) ));
}
#[test]
fn __bindgen_test_layout_class_to_btyp_instantiation_63091() {
    assert_eq!(::std::mem::size_of::<class_to_btyp>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               class_to_btyp ) ));
    assert_eq!(::std::mem::align_of::<class_to_btyp>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               class_to_btyp ) ));
}
#[test]
fn __bindgen_test_layout_class_to_btyp_instantiation_63094() {
    assert_eq!(::std::mem::size_of::<class_to_btyp>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               class_to_btyp ) ));
    assert_eq!(::std::mem::align_of::<class_to_btyp>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               class_to_btyp ) ));
}
#[test]
fn __bindgen_test_layout_class_to_btyp_instantiation_63097() {
    assert_eq!(::std::mem::size_of::<class_to_btyp>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               class_to_btyp ) ));
    assert_eq!(::std::mem::align_of::<class_to_btyp>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               class_to_btyp ) ));
}
#[test]
fn __bindgen_test_layout_class_to_btyp_instantiation_63100() {
    assert_eq!(::std::mem::size_of::<class_to_btyp>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               class_to_btyp ) ));
    assert_eq!(::std::mem::align_of::<class_to_btyp>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               class_to_btyp ) ));
}
#[test]
fn __bindgen_test_layout_class_to_btyp_instantiation_63104() {
    assert_eq!(::std::mem::size_of::<class_to_btyp>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               class_to_btyp ) ));
    assert_eq!(::std::mem::align_of::<class_to_btyp>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               class_to_btyp ) ));
}
#[repr(C)]
pub struct octave_base_value__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct octave_base_value {
    pub vtable_: *const octave_base_value__bindgen_vtable,
    pub count: octave_refcount<::std::os::raw::c_int>,
}
pub type octave_base_value_type_conv_fcn =
    ::std::option::Option<unsafe extern "C" fn(arg1: *const octave_base_value)
                              -> *mut octave_base_value>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct octave_base_value_type_conv_info {
    pub _fcn: octave_base_value_type_conv_fcn,
    pub _type_id: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_octave_base_value_type_conv_info() {
    assert_eq!(::std::mem::size_of::<octave_base_value_type_conv_info>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( octave_base_value_type_conv_info )
               ));
    assert_eq! (::std::mem::align_of::<octave_base_value_type_conv_info>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                octave_base_value_type_conv_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_base_value_type_conv_info ) ) .
                _fcn as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                octave_base_value_type_conv_info ) , "::" , stringify ! ( _fcn
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_base_value_type_conv_info ) ) .
                _type_id as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                octave_base_value_type_conv_info ) , "::" , stringify ! (
                _type_id ) ));
}
impl Clone for octave_base_value_type_conv_info {
    fn clone(&self) -> Self { *self }
}
pub const octave_base_value_unary_mapper_t_num_unary_mappers:
          octave_base_value_unary_mapper_t =
    octave_base_value_unary_mapper_t::umap_unknown;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum octave_base_value_unary_mapper_t {
    umap_abs = 0,
    umap_acos = 1,
    umap_acosh = 2,
    umap_angle = 3,
    umap_arg = 4,
    umap_asin = 5,
    umap_asinh = 6,
    umap_atan = 7,
    umap_atanh = 8,
    umap_cbrt = 9,
    umap_ceil = 10,
    umap_conj = 11,
    umap_cos = 12,
    umap_cosh = 13,
    umap_erf = 14,
    umap_erfinv = 15,
    umap_erfcinv = 16,
    umap_erfc = 17,
    umap_erfcx = 18,
    umap_erfi = 19,
    umap_dawson = 20,
    umap_exp = 21,
    umap_expm1 = 22,
    umap_isfinite = 23,
    umap_fix = 24,
    umap_floor = 25,
    umap_gamma = 26,
    umap_imag = 27,
    umap_isinf = 28,
    umap_isna = 29,
    umap_isnan = 30,
    umap_lgamma = 31,
    umap_log = 32,
    umap_log2 = 33,
    umap_log10 = 34,
    umap_log1p = 35,
    umap_real = 36,
    umap_round = 37,
    umap_roundb = 38,
    umap_signum = 39,
    umap_sin = 40,
    umap_sinh = 41,
    umap_sqrt = 42,
    umap_tan = 43,
    umap_tanh = 44,
    umap_xisalnum = 45,
    umap_xisalpha = 46,
    umap_xisascii = 47,
    umap_xiscntrl = 48,
    umap_xisdigit = 49,
    umap_xisgraph = 50,
    umap_xislower = 51,
    umap_xisprint = 52,
    umap_xispunct = 53,
    umap_xisspace = 54,
    umap_xisupper = 55,
    umap_xisxdigit = 56,
    umap_xsignbit = 57,
    umap_xtoascii = 58,
    umap_xtolower = 59,
    umap_xtoupper = 60,
    umap_unknown = 61,
}
extern "C" {
    #[link_name = "?curr_print_indent_level@octave_base_value@@0HA"]
    pub static mut octave_base_value_curr_print_indent_level:
               ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "?beginning_of_line@octave_base_value@@0_NA"]
    pub static mut octave_base_value_beginning_of_line: bool;
}
extern "C" {
    #[link_name = "?t_id@octave_base_value@@0HA"]
    pub static mut octave_base_value_t_id: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name =
          "?t_name@octave_base_value@@0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B"]
    pub static octave_base_value_t_name: std_string;
}
extern "C" {
    #[link_name =
          "?c_name@octave_base_value@@0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B"]
    pub static octave_base_value_c_name: std_string;
}
#[test]
fn bindgen_test_layout_octave_base_value() {
    assert_eq!(::std::mem::size_of::<octave_base_value>() , 16usize , concat !
               ( "Size of: " , stringify ! ( octave_base_value ) ));
    assert_eq! (::std::mem::align_of::<octave_base_value>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( octave_base_value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_base_value ) ) . count as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_base_value ) ,
                "::" , stringify ! ( count ) ));
}
extern "C" {
    #[link_name =
          "?numeric_assign@octave_base_value@@IEAA?AVoctave_value@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$list@Voctave_value_list@@V?$allocator@Voctave_value_list@@@std@@@4@AEBV2@@Z"]
    pub fn octave_base_value_numeric_assign(this: *mut octave_base_value,
                                            type_: *const std_string,
                                            idx: *const std_list,
                                            rhs: *const octave_value)
     -> octave_value;
}
extern "C" {
    #[link_name =
          "?indent@octave_base_value@@IEBAXAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@@Z"]
    pub fn octave_base_value_indent(this: *const octave_base_value,
                                    os: *mut std_ostream);
}
extern "C" {
    #[link_name =
          "?newline@octave_base_value@@IEBAXAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@@Z"]
    pub fn octave_base_value_newline(this: *const octave_base_value,
                                     os: *mut std_ostream);
}
extern "C" {
    #[link_name = "?reset@octave_base_value@@IEBAXXZ"]
    pub fn octave_base_value_reset(this: *const octave_base_value);
}
extern "C" {
    #[link_name =
          "?get_umap_name@octave_base_value@@KAPEBDW4unary_mapper_t@1@@Z"]
    pub fn octave_base_value_get_umap_name(arg1:
                                               octave_base_value_unary_mapper_t)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "?warn_load@octave_base_value@@IEBAXPEBD@Z"]
    pub fn octave_base_value_warn_load(this: *const octave_base_value,
                                       type_: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "?warn_save@octave_base_value@@IEBAXPEBD@Z"]
    pub fn octave_base_value_warn_save(this: *const octave_base_value,
                                       type_: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "?register_type@octave_base_value@@SAXXZ"]
    pub fn octave_base_value_register_type();
}
impl octave_base_value {
    #[inline]
    pub unsafe fn numeric_assign(&mut self, type_: *const std_string,
                                 idx: *const std_list,
                                 rhs: *const octave_value) -> octave_value {
        octave_base_value_numeric_assign(self, type_, idx, rhs)
    }
    #[inline]
    pub unsafe fn indent(&self, os: *mut std_ostream) {
        octave_base_value_indent(self, os)
    }
    #[inline]
    pub unsafe fn newline(&self, os: *mut std_ostream) {
        octave_base_value_newline(self, os)
    }
    #[inline]
    pub unsafe fn reset(&self) { octave_base_value_reset(self) }
    #[inline]
    pub unsafe fn get_umap_name(arg1: octave_base_value_unary_mapper_t)
     -> *const ::std::os::raw::c_char {
        octave_base_value_get_umap_name(arg1)
    }
    #[inline]
    pub unsafe fn warn_load(&self, type_: *const ::std::os::raw::c_char) {
        octave_base_value_warn_load(self, type_)
    }
    #[inline]
    pub unsafe fn warn_save(&self, type_: *const ::std::os::raw::c_char) {
        octave_base_value_warn_save(self, type_)
    }
    #[inline]
    pub unsafe fn register_type() { octave_base_value_register_type() }
}
extern "C" {
    #[link_name = "?Vsparse_auto_mutate@@3_NA"]
    pub static mut Vsparse_auto_mutate: bool;
}
extern "C" {
    #[link_name =
          "?make_idx_args@@YA?AVoctave_value@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$list@Voctave_value_list@@V?$allocator@Voctave_value_list@@@std@@@3@0@Z"]
    pub fn make_idx_args(type_: *const std_string, idx: *const std_list,
                         who: *const std_string) -> octave_value;
}
extern "C" {
    #[link_name = "?called_from_builtin@@YA_NXZ"]
    pub fn called_from_builtin() -> bool;
}
extern "C" {
    #[link_name = "?do_colon_op@@YA?AVoctave_value@@AEBV1@0_N@Z"]
    pub fn do_colon_op(base: *const octave_value, limit: *const octave_value,
                       is_for_cmd_expr: bool) -> octave_value;
}
extern "C" {
    #[link_name = "?do_colon_op@@YA?AVoctave_value@@AEBV1@00_N@Z"]
    pub fn do_colon_op1(base: *const octave_value,
                        increment: *const octave_value,
                        limit: *const octave_value, is_for_cmd_expr: bool)
     -> octave_value;
}
extern "C" {
    #[link_name = "?do_unary_op@@YA?AVoctave_value@@W4unary_op@1@AEBV1@@Z"]
    pub fn do_unary_op(op: octave_value_unary_op, a: *const octave_value)
     -> octave_value;
}
extern "C" {
    #[link_name = "?do_binary_op@@YA?AVoctave_value@@W4binary_op@1@AEBV1@1@Z"]
    pub fn do_binary_op(op: octave_value_binary_op, a: *const octave_value,
                        b: *const octave_value) -> octave_value;
}
extern "C" {
    #[link_name =
          "?do_binary_op@@YA?AVoctave_value@@W4compound_binary_op@1@AEBV1@1@Z"]
    pub fn do_binary_op1(op: octave_value_compound_binary_op,
                         a: *const octave_value, b: *const octave_value)
     -> octave_value;
}
extern "C" {
    #[link_name = "?install_types@@YAXXZ"]
    pub fn install_types();
}
#[repr(C)]
#[derive(Debug)]
pub struct octave_fields {
    pub rep: *mut octave_fields_fields_rep,
}
#[repr(C)]
pub struct octave_fields_fields_rep {
    pub _base: std_map,
    pub count: octave_refcount<::std::os::raw::c_int>,
}
#[test]
fn bindgen_test_layout_octave_fields_fields_rep() {
    assert_eq!(::std::mem::size_of::<octave_fields_fields_rep>() , 56usize ,
               concat ! (
               "Size of: " , stringify ! ( octave_fields_fields_rep ) ));
    assert_eq! (::std::mem::align_of::<octave_fields_fields_rep>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( octave_fields_fields_rep ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_fields_fields_rep ) ) . count as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                octave_fields_fields_rep ) , "::" , stringify ! ( count ) ));
}
pub type octave_fields_const_iterator = u64;
pub type octave_fields_iterator = octave_fields_const_iterator;
#[test]
fn bindgen_test_layout_octave_fields() {
    assert_eq!(::std::mem::size_of::<octave_fields>() , 8usize , concat ! (
               "Size of: " , stringify ! ( octave_fields ) ));
    assert_eq! (::std::mem::align_of::<octave_fields>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( octave_fields ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_fields ) ) . rep as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_fields ) , "::"
                , stringify ! ( rep ) ));
}
extern "C" {
    #[link_name =
          "?isfield@octave_fields@@QEBA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn octave_fields_isfield(this: *const octave_fields,
                                 name: *const std_string) -> bool;
}
extern "C" {
    #[link_name =
          "?getfield@octave_fields@@QEBAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn octave_fields_getfield(this: *const octave_fields,
                                  name: *const std_string) -> octave_idx_type;
}
extern "C" {
    #[link_name =
          "?getfield@octave_fields@@QEAAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn octave_fields_getfield1(this: *mut octave_fields,
                                   name: *const std_string)
     -> octave_idx_type;
}
extern "C" {
    #[link_name =
          "?rmfield@octave_fields@@QEAAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn octave_fields_rmfield(this: *mut octave_fields,
                                 name: *const std_string) -> octave_idx_type;
}
extern "C" {
    #[link_name = "?orderfields@octave_fields@@QEAAXAEAV?$Array@H@@@Z"]
    pub fn octave_fields_orderfields(this: *mut octave_fields,
                                     perm: *mut Array<::std::os::raw::c_int>);
}
extern "C" {
    #[link_name = "?equal_up_to_order@octave_fields@@QEBA_NAEBV1@PEAH@Z"]
    pub fn octave_fields_equal_up_to_order(this: *const octave_fields,
                                           other: *const octave_fields,
                                           perm: *mut octave_idx_type)
     -> bool;
}
extern "C" {
    #[link_name =
          "?equal_up_to_order@octave_fields@@QEBA_NAEBV1@AEAV?$Array@H@@@Z"]
    pub fn octave_fields_equal_up_to_order1(this: *const octave_fields,
                                            other: *const octave_fields,
                                            perm:
                                                *mut Array<::std::os::raw::c_int>)
     -> bool;
}
extern "C" {
    #[link_name = "?fieldnames@octave_fields@@QEBA?AVstring_vector@@XZ"]
    pub fn octave_fields_fieldnames(this: *const octave_fields)
     -> string_vector;
}
extern "C" {
    #[link_name = "??0octave_fields@@QEAA@AEBVstring_vector@@@Z"]
    pub fn octave_fields_octave_fields(this: *mut octave_fields,
                                       arg1: *const string_vector);
}
extern "C" {
    #[link_name = "??0octave_fields@@QEAA@PEBQEBD@Z"]
    pub fn octave_fields_octave_fields1(this: *mut octave_fields,
                                        arg1:
                                            *const *const ::std::os::raw::c_char);
}
impl octave_fields {
    #[inline]
    pub unsafe fn isfield(&self, name: *const std_string) -> bool {
        octave_fields_isfield(self, name)
    }
    #[inline]
    pub unsafe fn getfield(&self, name: *const std_string)
     -> octave_idx_type {
        octave_fields_getfield(self, name)
    }
    #[inline]
    pub unsafe fn getfield1(&mut self, name: *const std_string)
     -> octave_idx_type {
        octave_fields_getfield1(self, name)
    }
    #[inline]
    pub unsafe fn rmfield(&mut self, name: *const std_string)
     -> octave_idx_type {
        octave_fields_rmfield(self, name)
    }
    #[inline]
    pub unsafe fn orderfields(&mut self,
                              perm: *mut Array<::std::os::raw::c_int>) {
        octave_fields_orderfields(self, perm)
    }
    #[inline]
    pub unsafe fn equal_up_to_order(&self, other: *const octave_fields,
                                    perm: *mut octave_idx_type) -> bool {
        octave_fields_equal_up_to_order(self, other, perm)
    }
    #[inline]
    pub unsafe fn equal_up_to_order1(&self, other: *const octave_fields,
                                     perm: *mut Array<::std::os::raw::c_int>)
     -> bool {
        octave_fields_equal_up_to_order1(self, other, perm)
    }
    #[inline]
    pub unsafe fn fieldnames(&self) -> string_vector {
        octave_fields_fieldnames(self)
    }
    #[inline]
    pub unsafe fn new(arg1: *const string_vector) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_fields_octave_fields(&mut __bindgen_tmp, arg1);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(arg1: *const *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_fields_octave_fields1(&mut __bindgen_tmp, arg1);
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct octave_value_typeinfo {
    pub num_types: ::std::os::raw::c_int,
    pub types: Array<std_basic_string<::std::os::raw::c_char, std_allocator>>,
    pub vals: Array<octave_value>,
    pub unary_class_ops: Array<*mut ::std::os::raw::c_void>,
    pub unary_ops: Array<*mut ::std::os::raw::c_void>,
    pub non_const_unary_ops: Array<*mut ::std::os::raw::c_void>,
    pub binary_class_ops: Array<*mut ::std::os::raw::c_void>,
    pub binary_ops: Array<*mut ::std::os::raw::c_void>,
    pub compound_binary_class_ops: Array<*mut ::std::os::raw::c_void>,
    pub compound_binary_ops: Array<*mut ::std::os::raw::c_void>,
    pub cat_ops: Array<*mut ::std::os::raw::c_void>,
    pub assign_ops: Array<*mut ::std::os::raw::c_void>,
    pub assignany_ops: Array<*mut ::std::os::raw::c_void>,
    pub pref_assign_conv: Array<::std::os::raw::c_int>,
    pub widening_ops: Array<*mut ::std::os::raw::c_void>,
}
pub type octave_value_typeinfo_unary_class_op_fcn =
    ::std::option::Option<unsafe extern "C" fn(arg1: *const octave_value)
                              -> octave_value>;
pub type octave_value_typeinfo_unary_op_fcn =
    ::std::option::Option<unsafe extern "C" fn(arg1: *const octave_base_value)
                              -> octave_value>;
pub type octave_value_typeinfo_non_const_unary_op_fcn =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut octave_base_value)>;
pub type octave_value_typeinfo_binary_class_op_fcn =
    ::std::option::Option<unsafe extern "C" fn(arg1: *const octave_value,
                                               arg2: *const octave_value)
                              -> octave_value>;
pub type octave_value_typeinfo_binary_op_fcn =
    ::std::option::Option<unsafe extern "C" fn(arg1: *const octave_base_value,
                                               arg2: *const octave_base_value)
                              -> octave_value>;
pub type octave_value_typeinfo_cat_op_fcn =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut octave_base_value,
                                               arg2: *const octave_base_value,
                                               ra_idx:
                                                   *const Array<::std::os::raw::c_int>)
                              -> octave_value>;
pub type octave_value_typeinfo_assign_op_fcn =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut octave_base_value,
                                               arg2: *const octave_value_list,
                                               arg3: *const octave_base_value)
                              -> octave_value>;
pub type octave_value_typeinfo_assignany_op_fcn =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut octave_base_value,
                                               arg2: *const octave_value_list,
                                               arg3: *const octave_value)
                              -> octave_value>;
extern "C" {
    #[link_name = "?init_tab_sz@octave_value_typeinfo@@0HB"]
    pub static octave_value_typeinfo_init_tab_sz: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "?instance@octave_value_typeinfo@@0PEAV1@EA"]
    pub static mut octave_value_typeinfo_instance: *mut octave_value_typeinfo;
}
#[test]
fn bindgen_test_layout_octave_value_typeinfo() {
    assert_eq!(::std::mem::size_of::<octave_value_typeinfo>() , 568usize ,
               concat ! ( "Size of: " , stringify ! ( octave_value_typeinfo )
               ));
    assert_eq! (::std::mem::align_of::<octave_value_typeinfo>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( octave_value_typeinfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_value_typeinfo ) ) . num_types as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_value_typeinfo )
                , "::" , stringify ! ( num_types ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_value_typeinfo ) ) . types as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_value_typeinfo )
                , "::" , stringify ! ( types ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_value_typeinfo ) ) . vals as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_value_typeinfo )
                , "::" , stringify ! ( vals ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_value_typeinfo ) ) .
                unary_class_ops as * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_value_typeinfo )
                , "::" , stringify ! ( unary_class_ops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_value_typeinfo ) ) . unary_ops as
                * const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_value_typeinfo )
                , "::" , stringify ! ( unary_ops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_value_typeinfo ) ) .
                non_const_unary_ops as * const _ as usize } , 168usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( octave_value_typeinfo )
                , "::" , stringify ! ( non_const_unary_ops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_value_typeinfo ) ) .
                binary_class_ops as * const _ as usize } , 208usize , concat !
                (
                "Alignment of field: " , stringify ! ( octave_value_typeinfo )
                , "::" , stringify ! ( binary_class_ops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_value_typeinfo ) ) . binary_ops as
                * const _ as usize } , 248usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_value_typeinfo )
                , "::" , stringify ! ( binary_ops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_value_typeinfo ) ) .
                compound_binary_class_ops as * const _ as usize } , 288usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( octave_value_typeinfo )
                , "::" , stringify ! ( compound_binary_class_ops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_value_typeinfo ) ) .
                compound_binary_ops as * const _ as usize } , 328usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( octave_value_typeinfo )
                , "::" , stringify ! ( compound_binary_ops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_value_typeinfo ) ) . cat_ops as *
                const _ as usize } , 368usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_value_typeinfo )
                , "::" , stringify ! ( cat_ops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_value_typeinfo ) ) . assign_ops as
                * const _ as usize } , 408usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_value_typeinfo )
                , "::" , stringify ! ( assign_ops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_value_typeinfo ) ) . assignany_ops
                as * const _ as usize } , 448usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_value_typeinfo )
                , "::" , stringify ! ( assignany_ops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_value_typeinfo ) ) .
                pref_assign_conv as * const _ as usize } , 488usize , concat !
                (
                "Alignment of field: " , stringify ! ( octave_value_typeinfo )
                , "::" , stringify ! ( pref_assign_conv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_value_typeinfo ) ) . widening_ops
                as * const _ as usize } , 528usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_value_typeinfo )
                , "::" , stringify ! ( widening_ops ) ));
}
extern "C" {
    #[link_name = "?instance_ok@octave_value_typeinfo@@SA_NXZ"]
    pub fn octave_value_typeinfo_instance_ok() -> bool;
}
extern "C" {
    #[link_name =
          "?register_type@octave_value_typeinfo@@SAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0AEBVoctave_value@@@Z"]
    pub fn octave_value_typeinfo_register_type(arg1: *const std_string,
                                               arg2: *const std_string,
                                               arg3: *const octave_value)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name =
          "?register_unary_class_op@octave_value_typeinfo@@SA_NW4unary_op@octave_value@@P6A?AV3@AEBV3@@Z@Z"]
    pub fn octave_value_typeinfo_register_unary_class_op(arg1:
                                                             octave_value_unary_op,
                                                         arg2:
                                                             octave_value_typeinfo_unary_class_op_fcn)
     -> bool;
}
extern "C" {
    #[link_name =
          "?register_unary_op@octave_value_typeinfo@@SA_NW4unary_op@octave_value@@HP6A?AV3@AEBVoctave_base_value@@@Z@Z"]
    pub fn octave_value_typeinfo_register_unary_op(arg1:
                                                       octave_value_unary_op,
                                                   arg2:
                                                       ::std::os::raw::c_int,
                                                   arg3:
                                                       octave_value_typeinfo_unary_op_fcn)
     -> bool;
}
extern "C" {
    #[link_name =
          "?register_non_const_unary_op@octave_value_typeinfo@@SA_NW4unary_op@octave_value@@HP6AXAEAVoctave_base_value@@@Z@Z"]
    pub fn octave_value_typeinfo_register_non_const_unary_op(arg1:
                                                                 octave_value_unary_op,
                                                             arg2:
                                                                 ::std::os::raw::c_int,
                                                             arg3:
                                                                 octave_value_typeinfo_non_const_unary_op_fcn)
     -> bool;
}
extern "C" {
    #[link_name =
          "?register_binary_class_op@octave_value_typeinfo@@SA_NW4binary_op@octave_value@@P6A?AV3@AEBV3@1@Z@Z"]
    pub fn octave_value_typeinfo_register_binary_class_op(arg1:
                                                              octave_value_binary_op,
                                                          arg2:
                                                              octave_value_typeinfo_binary_class_op_fcn)
     -> bool;
}
extern "C" {
    #[link_name =
          "?register_binary_op@octave_value_typeinfo@@SA_NW4binary_op@octave_value@@HHP6A?AV3@AEBVoctave_base_value@@1@Z@Z"]
    pub fn octave_value_typeinfo_register_binary_op(arg1:
                                                        octave_value_binary_op,
                                                    arg2:
                                                        ::std::os::raw::c_int,
                                                    arg3:
                                                        ::std::os::raw::c_int,
                                                    arg4:
                                                        octave_value_typeinfo_binary_op_fcn)
     -> bool;
}
extern "C" {
    #[link_name =
          "?register_binary_class_op@octave_value_typeinfo@@SA_NW4compound_binary_op@octave_value@@P6A?AV3@AEBV3@1@Z@Z"]
    pub fn octave_value_typeinfo_register_binary_class_op1(arg1:
                                                               octave_value_compound_binary_op,
                                                           arg2:
                                                               octave_value_typeinfo_binary_class_op_fcn)
     -> bool;
}
extern "C" {
    #[link_name =
          "?register_binary_op@octave_value_typeinfo@@SA_NW4compound_binary_op@octave_value@@HHP6A?AV3@AEBVoctave_base_value@@1@Z@Z"]
    pub fn octave_value_typeinfo_register_binary_op1(arg1:
                                                         octave_value_compound_binary_op,
                                                     arg2:
                                                         ::std::os::raw::c_int,
                                                     arg3:
                                                         ::std::os::raw::c_int,
                                                     arg4:
                                                         octave_value_typeinfo_binary_op_fcn)
     -> bool;
}
extern "C" {
    #[link_name =
          "?register_cat_op@octave_value_typeinfo@@SA_NHHP6A?AVoctave_value@@AEAVoctave_base_value@@AEBV3@AEBV?$Array@H@@@Z@Z"]
    pub fn octave_value_typeinfo_register_cat_op(arg1: ::std::os::raw::c_int,
                                                 arg2: ::std::os::raw::c_int,
                                                 arg3:
                                                     octave_value_typeinfo_cat_op_fcn)
     -> bool;
}
extern "C" {
    #[link_name =
          "?register_assign_op@octave_value_typeinfo@@SA_NW4assign_op@octave_value@@HHP6A?AV3@AEAVoctave_base_value@@AEBVoctave_value_list@@AEBV4@@Z@Z"]
    pub fn octave_value_typeinfo_register_assign_op(arg1:
                                                        octave_value_assign_op,
                                                    arg2:
                                                        ::std::os::raw::c_int,
                                                    arg3:
                                                        ::std::os::raw::c_int,
                                                    arg4:
                                                        octave_value_typeinfo_assign_op_fcn)
     -> bool;
}
extern "C" {
    #[link_name =
          "?register_assignany_op@octave_value_typeinfo@@SA_NW4assign_op@octave_value@@HP6A?AV3@AEAVoctave_base_value@@AEBVoctave_value_list@@AEBV3@@Z@Z"]
    pub fn octave_value_typeinfo_register_assignany_op(arg1:
                                                           octave_value_assign_op,
                                                       arg2:
                                                           ::std::os::raw::c_int,
                                                       arg3:
                                                           octave_value_typeinfo_assignany_op_fcn)
     -> bool;
}
extern "C" {
    #[link_name =
          "?register_pref_assign_conv@octave_value_typeinfo@@SA_NHHH@Z"]
    pub fn octave_value_typeinfo_register_pref_assign_conv(arg1:
                                                               ::std::os::raw::c_int,
                                                           arg2:
                                                               ::std::os::raw::c_int,
                                                           arg3:
                                                               ::std::os::raw::c_int)
     -> bool;
}
extern "C" {
    #[link_name =
          "?register_widening_op@octave_value_typeinfo@@SA_NHHP6APEAVoctave_base_value@@AEBV2@@Z@Z"]
    pub fn octave_value_typeinfo_register_widening_op(arg1:
                                                          ::std::os::raw::c_int,
                                                      arg2:
                                                          ::std::os::raw::c_int,
                                                      arg3:
                                                          octave_base_value_type_conv_fcn)
     -> bool;
}
impl octave_value_typeinfo {
    #[inline]
    pub unsafe fn instance_ok() -> bool {
        octave_value_typeinfo_instance_ok()
    }
    #[inline]
    pub unsafe fn register_type(arg1: *const std_string,
                                arg2: *const std_string,
                                arg3: *const octave_value)
     -> ::std::os::raw::c_int {
        octave_value_typeinfo_register_type(arg1, arg2, arg3)
    }
    #[inline]
    pub unsafe fn register_unary_class_op(arg1: octave_value_unary_op,
                                          arg2:
                                              octave_value_typeinfo_unary_class_op_fcn)
     -> bool {
        octave_value_typeinfo_register_unary_class_op(arg1, arg2)
    }
    #[inline]
    pub unsafe fn register_unary_op(arg1: octave_value_unary_op,
                                    arg2: ::std::os::raw::c_int,
                                    arg3: octave_value_typeinfo_unary_op_fcn)
     -> bool {
        octave_value_typeinfo_register_unary_op(arg1, arg2, arg3)
    }
    #[inline]
    pub unsafe fn register_non_const_unary_op(arg1: octave_value_unary_op,
                                              arg2: ::std::os::raw::c_int,
                                              arg3:
                                                  octave_value_typeinfo_non_const_unary_op_fcn)
     -> bool {
        octave_value_typeinfo_register_non_const_unary_op(arg1, arg2, arg3)
    }
    #[inline]
    pub unsafe fn register_binary_class_op(arg1: octave_value_binary_op,
                                           arg2:
                                               octave_value_typeinfo_binary_class_op_fcn)
     -> bool {
        octave_value_typeinfo_register_binary_class_op(arg1, arg2)
    }
    #[inline]
    pub unsafe fn register_binary_op(arg1: octave_value_binary_op,
                                     arg2: ::std::os::raw::c_int,
                                     arg3: ::std::os::raw::c_int,
                                     arg4:
                                         octave_value_typeinfo_binary_op_fcn)
     -> bool {
        octave_value_typeinfo_register_binary_op(arg1, arg2, arg3, arg4)
    }
    #[inline]
    pub unsafe fn register_binary_class_op1(arg1:
                                                octave_value_compound_binary_op,
                                            arg2:
                                                octave_value_typeinfo_binary_class_op_fcn)
     -> bool {
        octave_value_typeinfo_register_binary_class_op1(arg1, arg2)
    }
    #[inline]
    pub unsafe fn register_binary_op1(arg1: octave_value_compound_binary_op,
                                      arg2: ::std::os::raw::c_int,
                                      arg3: ::std::os::raw::c_int,
                                      arg4:
                                          octave_value_typeinfo_binary_op_fcn)
     -> bool {
        octave_value_typeinfo_register_binary_op1(arg1, arg2, arg3, arg4)
    }
    #[inline]
    pub unsafe fn register_cat_op(arg1: ::std::os::raw::c_int,
                                  arg2: ::std::os::raw::c_int,
                                  arg3: octave_value_typeinfo_cat_op_fcn)
     -> bool {
        octave_value_typeinfo_register_cat_op(arg1, arg2, arg3)
    }
    #[inline]
    pub unsafe fn register_assign_op(arg1: octave_value_assign_op,
                                     arg2: ::std::os::raw::c_int,
                                     arg3: ::std::os::raw::c_int,
                                     arg4:
                                         octave_value_typeinfo_assign_op_fcn)
     -> bool {
        octave_value_typeinfo_register_assign_op(arg1, arg2, arg3, arg4)
    }
    #[inline]
    pub unsafe fn register_assignany_op(arg1: octave_value_assign_op,
                                        arg2: ::std::os::raw::c_int,
                                        arg3:
                                            octave_value_typeinfo_assignany_op_fcn)
     -> bool {
        octave_value_typeinfo_register_assignany_op(arg1, arg2, arg3)
    }
    #[inline]
    pub unsafe fn register_pref_assign_conv(arg1: ::std::os::raw::c_int,
                                            arg2: ::std::os::raw::c_int,
                                            arg3: ::std::os::raw::c_int)
     -> bool {
        octave_value_typeinfo_register_pref_assign_conv(arg1, arg2, arg3)
    }
    #[inline]
    pub unsafe fn register_widening_op(arg1: ::std::os::raw::c_int,
                                       arg2: ::std::os::raw::c_int,
                                       arg3: octave_base_value_type_conv_fcn)
     -> bool {
        octave_value_typeinfo_register_widening_op(arg1, arg2, arg3)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct glob_match {
    pub pat: string_vector,
    pub fnmatch_flags: ::std::os::raw::c_int,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum glob_match_opts { pathname = 1, noescape = 2, period = 4, }
#[test]
fn bindgen_test_layout_glob_match() {
    assert_eq!(::std::mem::size_of::<glob_match>() , 48usize , concat ! (
               "Size of: " , stringify ! ( glob_match ) ));
    assert_eq! (::std::mem::align_of::<glob_match>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( glob_match ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const glob_match ) ) . pat as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( glob_match ) , "::" ,
                stringify ! ( pat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const glob_match ) ) . fnmatch_flags as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( glob_match ) , "::" ,
                stringify ! ( fnmatch_flags ) ));
}
extern "C" {
    #[link_name =
          "?match@glob_match@@QEBA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn glob_match_match(this: *const glob_match, str: *const std_string)
     -> bool;
}
extern "C" {
    #[link_name = "?glob@glob_match@@QEBA?AVstring_vector@@XZ"]
    pub fn glob_match_glob(this: *const glob_match) -> string_vector;
}
impl glob_match {
    #[inline]
    pub unsafe fn match_(&self, str: *const std_string) -> bool {
        glob_match_match(self, str)
    }
    #[inline]
    pub unsafe fn glob(&self) -> string_vector { glob_match_glob(self) }
}
pub type regexp = octave_regexp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tree_argument_list([u8; 0]);
#[repr(C)]
#[derive(Debug)]
pub struct workspace_element {
    pub xscope: ::std::os::raw::c_char,
    pub xsymbol: std_string,
    pub xclass_name: std_string,
    pub xvalue: std_string,
    pub xdimension: std_string,
    pub xcomplex_flag: bool,
}
#[test]
fn bindgen_test_layout_workspace_element() {
    assert_eq!(::std::mem::size_of::<workspace_element>() , 48usize , concat !
               ( "Size of: " , stringify ! ( workspace_element ) ));
    assert_eq! (::std::mem::align_of::<workspace_element>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( workspace_element ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const workspace_element ) ) . xscope as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( workspace_element ) ,
                "::" , stringify ! ( xscope ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const workspace_element ) ) . xsymbol as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( workspace_element ) ,
                "::" , stringify ! ( xsymbol ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const workspace_element ) ) . xclass_name as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( workspace_element ) ,
                "::" , stringify ! ( xclass_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const workspace_element ) ) . xvalue as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( workspace_element ) ,
                "::" , stringify ! ( xvalue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const workspace_element ) ) . xdimension as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( workspace_element ) ,
                "::" , stringify ! ( xdimension ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const workspace_element ) ) . xcomplex_flag as
                * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( workspace_element ) ,
                "::" , stringify ! ( xcomplex_flag ) ));
}
#[test]
fn __bindgen_test_layout_std_map_instantiation_68229() {
    assert_eq!(::std::mem::size_of::<std_map>() , 48usize , concat ! (
               "Size of template specialization: " , stringify ! ( std_map )
               ));
    assert_eq!(::std::mem::align_of::<std_map>() , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_map ) ));
}
#[test]
fn __bindgen_test_layout_std_map_instantiation_68240() {
    assert_eq!(::std::mem::size_of::<std_map>() , 48usize , concat ! (
               "Size of template specialization: " , stringify ! ( std_map )
               ));
    assert_eq!(::std::mem::align_of::<std_map>() , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_map ) ));
}
#[test]
fn __bindgen_test_layout_std_map_instantiation_68248() {
    assert_eq!(::std::mem::size_of::<std_map>() , 48usize , concat ! (
               "Size of template specialization: " , stringify ! ( std_map )
               ));
    assert_eq!(::std::mem::align_of::<std_map>() , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_map ) ));
}
#[test]
fn __bindgen_test_layout_std_map_instantiation_68255() {
    assert_eq!(::std::mem::size_of::<std_map>() , 48usize , concat ! (
               "Size of template specialization: " , stringify ! ( std_map )
               ));
    assert_eq!(::std::mem::align_of::<std_map>() , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_map ) ));
}
#[test]
fn __bindgen_test_layout_std_map_instantiation_68266() {
    assert_eq!(::std::mem::size_of::<std_map>() , 48usize , concat ! (
               "Size of template specialization: " , stringify ! ( std_map )
               ));
    assert_eq!(::std::mem::align_of::<std_map>() , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_map ) ));
}
#[repr(C)]
pub struct symbol_table {
    pub my_scope: symbol_table_scope_id,
    pub table_name: std_string,
    pub table: std_map,
    pub nest_children: std_vector,
    pub nest_parent: *mut symbol_table,
    pub curr_fcn: *mut octave_user_function,
    pub static_workspace: bool,
    pub persistent_table: std_map,
}
pub type symbol_table_scope_id = ::std::os::raw::c_int;
pub type symbol_table_context_id = usize;
#[repr(C)]
pub struct symbol_table_scope_id_cache {
    pub next_available: symbol_table_scope_id,
    pub in_use: std_set,
    pub free_list: std_set,
}
pub type symbol_table_scope_id_cache_set_iterator = u64;
pub type symbol_table_scope_id_cache_set_const_iterator = u64;
extern "C" {
    #[link_name = "?instance@scope_id_cache@symbol_table@@0PEAV12@EA"]
    pub static mut symbol_table_scope_id_cache_instance:
               *mut symbol_table_scope_id_cache;
}
#[test]
fn bindgen_test_layout_symbol_table_scope_id_cache() {
    assert_eq!(::std::mem::size_of::<symbol_table_scope_id_cache>() , 104usize
               , concat ! (
               "Size of: " , stringify ! ( symbol_table_scope_id_cache ) ));
    assert_eq! (::std::mem::align_of::<symbol_table_scope_id_cache>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( symbol_table_scope_id_cache )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symbol_table_scope_id_cache ) ) .
                next_available as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                symbol_table_scope_id_cache ) , "::" , stringify ! (
                next_available ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symbol_table_scope_id_cache ) ) . in_use
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                symbol_table_scope_id_cache ) , "::" , stringify ! ( in_use )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symbol_table_scope_id_cache ) ) .
                free_list as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! (
                symbol_table_scope_id_cache ) , "::" , stringify ! ( free_list
                ) ));
}
extern "C" {
    #[link_name = "?create_instance@scope_id_cache@symbol_table@@SAXXZ"]
    pub fn symbol_table_scope_id_cache_create_instance();
}
impl symbol_table_scope_id_cache {
    #[inline]
    pub unsafe fn create_instance() {
        symbol_table_scope_id_cache_create_instance()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct symbol_table_fcn_info {
    pub rep: *mut symbol_table_fcn_info_fcn_info_rep,
}
pub type symbol_table_fcn_info_dispatch_map_type = std_map;
pub type symbol_table_fcn_info_scope_val_const_iterator = u64;
pub type symbol_table_fcn_info_scope_val_iterator = u64;
pub type symbol_table_fcn_info_str_val_const_iterator = u64;
pub type symbol_table_fcn_info_str_val_iterator = u64;
pub type symbol_table_fcn_info_dispatch_map_const_iterator = u64;
pub type symbol_table_fcn_info_dispatch_map_iterator = u64;
#[repr(C)]
pub struct symbol_table_fcn_info_fcn_info_rep {
    pub name: std_string,
    pub package_name: std_string,
    pub subfunctions: std_map,
    pub private_functions: std_map,
    pub class_constructors: std_map,
    pub class_methods: std_map,
    pub dispatch_map: symbol_table_fcn_info_dispatch_map_type,
    pub cmdline_function: octave_value,
    pub autoload_function: octave_value,
    pub function_on_path: octave_value,
    pub package: octave_value,
    pub built_in_function: octave_value,
    pub count: octave_refcount<::std::os::raw::c_ulonglong>,
}
#[test]
fn bindgen_test_layout_symbol_table_fcn_info_fcn_info_rep() {
    assert_eq!(::std::mem::size_of::<symbol_table_fcn_info_fcn_info_rep>() ,
               344usize , concat ! (
               "Size of: " , stringify ! ( symbol_table_fcn_info_fcn_info_rep
               ) ));
    assert_eq! (::std::mem::align_of::<symbol_table_fcn_info_fcn_info_rep>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                symbol_table_fcn_info_fcn_info_rep ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symbol_table_fcn_info_fcn_info_rep ) ) .
                name as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                symbol_table_fcn_info_fcn_info_rep ) , "::" , stringify ! (
                name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symbol_table_fcn_info_fcn_info_rep ) ) .
                package_name as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                symbol_table_fcn_info_fcn_info_rep ) , "::" , stringify ! (
                package_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symbol_table_fcn_info_fcn_info_rep ) ) .
                subfunctions as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                symbol_table_fcn_info_fcn_info_rep ) , "::" , stringify ! (
                subfunctions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symbol_table_fcn_info_fcn_info_rep ) ) .
                private_functions as * const _ as usize } , 64usize , concat !
                (
                "Alignment of field: " , stringify ! (
                symbol_table_fcn_info_fcn_info_rep ) , "::" , stringify ! (
                private_functions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symbol_table_fcn_info_fcn_info_rep ) ) .
                class_constructors as * const _ as usize } , 112usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                symbol_table_fcn_info_fcn_info_rep ) , "::" , stringify ! (
                class_constructors ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symbol_table_fcn_info_fcn_info_rep ) ) .
                class_methods as * const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! (
                symbol_table_fcn_info_fcn_info_rep ) , "::" , stringify ! (
                class_methods ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symbol_table_fcn_info_fcn_info_rep ) ) .
                dispatch_map as * const _ as usize } , 208usize , concat ! (
                "Alignment of field: " , stringify ! (
                symbol_table_fcn_info_fcn_info_rep ) , "::" , stringify ! (
                dispatch_map ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symbol_table_fcn_info_fcn_info_rep ) ) .
                cmdline_function as * const _ as usize } , 256usize , concat !
                (
                "Alignment of field: " , stringify ! (
                symbol_table_fcn_info_fcn_info_rep ) , "::" , stringify ! (
                cmdline_function ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symbol_table_fcn_info_fcn_info_rep ) ) .
                autoload_function as * const _ as usize } , 272usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                symbol_table_fcn_info_fcn_info_rep ) , "::" , stringify ! (
                autoload_function ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symbol_table_fcn_info_fcn_info_rep ) ) .
                function_on_path as * const _ as usize } , 288usize , concat !
                (
                "Alignment of field: " , stringify ! (
                symbol_table_fcn_info_fcn_info_rep ) , "::" , stringify ! (
                function_on_path ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symbol_table_fcn_info_fcn_info_rep ) ) .
                package as * const _ as usize } , 304usize , concat ! (
                "Alignment of field: " , stringify ! (
                symbol_table_fcn_info_fcn_info_rep ) , "::" , stringify ! (
                package ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symbol_table_fcn_info_fcn_info_rep ) ) .
                built_in_function as * const _ as usize } , 320usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                symbol_table_fcn_info_fcn_info_rep ) , "::" , stringify ! (
                built_in_function ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symbol_table_fcn_info_fcn_info_rep ) ) .
                count as * const _ as usize } , 336usize , concat ! (
                "Alignment of field: " , stringify ! (
                symbol_table_fcn_info_fcn_info_rep ) , "::" , stringify ! (
                count ) ));
}
extern "C" {
    #[link_name =
          "?load_private_function@fcn_info_rep@fcn_info@symbol_table@@QEAA?AVoctave_value@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn symbol_table_fcn_info_fcn_info_rep_load_private_function(this:
                                                                        *mut symbol_table_fcn_info_fcn_info_rep,
                                                                    dir_name:
                                                                        *const std_string)
     -> octave_value;
}
extern "C" {
    #[link_name =
          "?load_class_constructor@fcn_info_rep@fcn_info@symbol_table@@QEAA?AVoctave_value@@XZ"]
    pub fn symbol_table_fcn_info_fcn_info_rep_load_class_constructor(this:
                                                                         *mut symbol_table_fcn_info_fcn_info_rep)
     -> octave_value;
}
extern "C" {
    #[link_name =
          "?load_class_method@fcn_info_rep@fcn_info@symbol_table@@QEAA?AVoctave_value@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn symbol_table_fcn_info_fcn_info_rep_load_class_method(this:
                                                                    *mut symbol_table_fcn_info_fcn_info_rep,
                                                                dispatch_type:
                                                                    *const std_string)
     -> octave_value;
}
extern "C" {
    #[link_name =
          "?find@fcn_info_rep@fcn_info@symbol_table@@QEAA?AVoctave_value@@AEBVoctave_value_list@@_N@Z"]
    pub fn symbol_table_fcn_info_fcn_info_rep_find(this:
                                                       *mut symbol_table_fcn_info_fcn_info_rep,
                                                   args:
                                                       *const octave_value_list,
                                                   local_funcs: bool)
     -> octave_value;
}
extern "C" {
    #[link_name =
          "?builtin_find@fcn_info_rep@fcn_info@symbol_table@@QEAA?AVoctave_value@@XZ"]
    pub fn symbol_table_fcn_info_fcn_info_rep_builtin_find(this:
                                                               *mut symbol_table_fcn_info_fcn_info_rep)
     -> octave_value;
}
extern "C" {
    #[link_name =
          "?find_method@fcn_info_rep@fcn_info@symbol_table@@QEAA?AVoctave_value@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn symbol_table_fcn_info_fcn_info_rep_find_method(this:
                                                              *mut symbol_table_fcn_info_fcn_info_rep,
                                                          dispatch_type:
                                                              *const std_string)
     -> octave_value;
}
extern "C" {
    #[link_name =
          "?find_autoload@fcn_info_rep@fcn_info@symbol_table@@QEAA?AVoctave_value@@XZ"]
    pub fn symbol_table_fcn_info_fcn_info_rep_find_autoload(this:
                                                                *mut symbol_table_fcn_info_fcn_info_rep)
     -> octave_value;
}
extern "C" {
    #[link_name =
          "?find_package@fcn_info_rep@fcn_info@symbol_table@@QEAA?AVoctave_value@@XZ"]
    pub fn symbol_table_fcn_info_fcn_info_rep_find_package(this:
                                                               *mut symbol_table_fcn_info_fcn_info_rep)
     -> octave_value;
}
extern "C" {
    #[link_name =
          "?find_user_function@fcn_info_rep@fcn_info@symbol_table@@QEAA?AVoctave_value@@XZ"]
    pub fn symbol_table_fcn_info_fcn_info_rep_find_user_function(this:
                                                                     *mut symbol_table_fcn_info_fcn_info_rep)
     -> octave_value;
}
extern "C" {
    #[link_name =
          "?mark_subfunction_in_scope_as_private@fcn_info_rep@fcn_info@symbol_table@@QEAAXHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn symbol_table_fcn_info_fcn_info_rep_mark_subfunction_in_scope_as_private(this:
                                                                                       *mut symbol_table_fcn_info_fcn_info_rep,
                                                                                   scope:
                                                                                       symbol_table_scope_id,
                                                                                   class_name:
                                                                                       *const std_string);
}
extern "C" {
    #[link_name =
          "?print_dispatch@fcn_info_rep@fcn_info@symbol_table@@QEBAXAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@@Z"]
    pub fn symbol_table_fcn_info_fcn_info_rep_print_dispatch(this:
                                                                 *const symbol_table_fcn_info_fcn_info_rep,
                                                             os:
                                                                 *mut std_ostream);
}
extern "C" {
    #[link_name =
          "?help_for_dispatch@fcn_info_rep@fcn_info@symbol_table@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ"]
    pub fn symbol_table_fcn_info_fcn_info_rep_help_for_dispatch(this:
                                                                    *const symbol_table_fcn_info_fcn_info_rep)
     -> std_string;
}
extern "C" {
    #[link_name =
          "?dump@fcn_info_rep@fcn_info@symbol_table@@QEBAXAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@5@@Z"]
    pub fn symbol_table_fcn_info_fcn_info_rep_dump(this:
                                                       *const symbol_table_fcn_info_fcn_info_rep,
                                                   os: *mut std_ostream,
                                                   prefix: *const std_string);
}
impl symbol_table_fcn_info_fcn_info_rep {
    #[inline]
    pub unsafe fn load_private_function(&mut self,
                                        dir_name: *const std_string)
     -> octave_value {
        symbol_table_fcn_info_fcn_info_rep_load_private_function(self,
                                                                 dir_name)
    }
    #[inline]
    pub unsafe fn load_class_constructor(&mut self) -> octave_value {
        symbol_table_fcn_info_fcn_info_rep_load_class_constructor(self)
    }
    #[inline]
    pub unsafe fn load_class_method(&mut self,
                                    dispatch_type: *const std_string)
     -> octave_value {
        symbol_table_fcn_info_fcn_info_rep_load_class_method(self,
                                                             dispatch_type)
    }
    #[inline]
    pub unsafe fn find(&mut self, args: *const octave_value_list,
                       local_funcs: bool) -> octave_value {
        symbol_table_fcn_info_fcn_info_rep_find(self, args, local_funcs)
    }
    #[inline]
    pub unsafe fn builtin_find(&mut self) -> octave_value {
        symbol_table_fcn_info_fcn_info_rep_builtin_find(self)
    }
    #[inline]
    pub unsafe fn find_method(&mut self, dispatch_type: *const std_string)
     -> octave_value {
        symbol_table_fcn_info_fcn_info_rep_find_method(self, dispatch_type)
    }
    #[inline]
    pub unsafe fn find_autoload(&mut self) -> octave_value {
        symbol_table_fcn_info_fcn_info_rep_find_autoload(self)
    }
    #[inline]
    pub unsafe fn find_package(&mut self) -> octave_value {
        symbol_table_fcn_info_fcn_info_rep_find_package(self)
    }
    #[inline]
    pub unsafe fn find_user_function(&mut self) -> octave_value {
        symbol_table_fcn_info_fcn_info_rep_find_user_function(self)
    }
    #[inline]
    pub unsafe fn mark_subfunction_in_scope_as_private(&mut self,
                                                       scope:
                                                           symbol_table_scope_id,
                                                       class_name:
                                                           *const std_string) {
        symbol_table_fcn_info_fcn_info_rep_mark_subfunction_in_scope_as_private(self,
                                                                                scope,
                                                                                class_name)
    }
    #[inline]
    pub unsafe fn print_dispatch(&self, os: *mut std_ostream) {
        symbol_table_fcn_info_fcn_info_rep_print_dispatch(self, os)
    }
    #[inline]
    pub unsafe fn help_for_dispatch(&self) -> std_string {
        symbol_table_fcn_info_fcn_info_rep_help_for_dispatch(self)
    }
    #[inline]
    pub unsafe fn dump(&self, os: *mut std_ostream,
                       prefix: *const std_string) {
        symbol_table_fcn_info_fcn_info_rep_dump(self, os, prefix)
    }
}
#[test]
fn bindgen_test_layout_symbol_table_fcn_info() {
    assert_eq!(::std::mem::size_of::<symbol_table_fcn_info>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( symbol_table_fcn_info )
               ));
    assert_eq! (::std::mem::align_of::<symbol_table_fcn_info>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( symbol_table_fcn_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symbol_table_fcn_info ) ) . rep as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( symbol_table_fcn_info )
                , "::" , stringify ! ( rep ) ));
}
#[repr(C)]
#[derive(Debug)]
pub struct symbol_table_symbol_record {
    pub rep: *mut symbol_table_symbol_record_symbol_record_rep,
}
#[repr(C)]
pub struct symbol_table_symbol_record_symbol_record_rep {
    pub decl_scope: symbol_table_scope_id,
    pub curr_fcn: *mut octave_user_function,
    pub name: std_string,
    pub value_stack: std_deque<octave_value>,
    pub storage_class: ::std::os::raw::c_uint,
    pub finfo: *mut symbol_table_fcn_info,
    pub valid: bool,
    pub count: octave_refcount<::std::os::raw::c_ulonglong>,
}
#[test]
fn bindgen_test_layout_symbol_table_symbol_record_symbol_record_rep() {
    assert_eq!(::std::mem::size_of::<symbol_table_symbol_record_symbol_record_rep>()
               , 136usize , concat ! (
               "Size of: " , stringify ! (
               symbol_table_symbol_record_symbol_record_rep ) ));
    assert_eq! (::std::mem::align_of::<symbol_table_symbol_record_symbol_record_rep>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                symbol_table_symbol_record_symbol_record_rep ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const symbol_table_symbol_record_symbol_record_rep
                ) ) . decl_scope as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                symbol_table_symbol_record_symbol_record_rep ) , "::" ,
                stringify ! ( decl_scope ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const symbol_table_symbol_record_symbol_record_rep
                ) ) . curr_fcn as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                symbol_table_symbol_record_symbol_record_rep ) , "::" ,
                stringify ! ( curr_fcn ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const symbol_table_symbol_record_symbol_record_rep
                ) ) . name as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                symbol_table_symbol_record_symbol_record_rep ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const symbol_table_symbol_record_symbol_record_rep
                ) ) . value_stack as * const _ as usize } , 24usize , concat !
                (
                "Alignment of field: " , stringify ! (
                symbol_table_symbol_record_symbol_record_rep ) , "::" ,
                stringify ! ( value_stack ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const symbol_table_symbol_record_symbol_record_rep
                ) ) . storage_class as * const _ as usize } , 104usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                symbol_table_symbol_record_symbol_record_rep ) , "::" ,
                stringify ! ( storage_class ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const symbol_table_symbol_record_symbol_record_rep
                ) ) . finfo as * const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! (
                symbol_table_symbol_record_symbol_record_rep ) , "::" ,
                stringify ! ( finfo ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const symbol_table_symbol_record_symbol_record_rep
                ) ) . valid as * const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! (
                symbol_table_symbol_record_symbol_record_rep ) , "::" ,
                stringify ! ( valid ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const symbol_table_symbol_record_symbol_record_rep
                ) ) . count as * const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! (
                symbol_table_symbol_record_symbol_record_rep ) , "::" ,
                stringify ! ( count ) ));
}
extern "C" {
    #[link_name =
          "?active_context@symbol_record_rep@symbol_record@symbol_table@@QEBA_KXZ"]
    pub fn symbol_table_symbol_record_symbol_record_rep_active_context(this:
                                                                           *const symbol_table_symbol_record_symbol_record_rep)
     -> symbol_table_context_id;
}
extern "C" {
    #[link_name =
          "?dump@symbol_record_rep@symbol_record@symbol_table@@QEBAXAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@5@@Z"]
    pub fn symbol_table_symbol_record_symbol_record_rep_dump(this:
                                                                 *const symbol_table_symbol_record_symbol_record_rep,
                                                             os:
                                                                 *mut std_ostream,
                                                             prefix:
                                                                 *const std_string);
}
impl symbol_table_symbol_record_symbol_record_rep {
    #[inline]
    pub unsafe fn active_context(&self) -> symbol_table_context_id {
        symbol_table_symbol_record_symbol_record_rep_active_context(self)
    }
    #[inline]
    pub unsafe fn dump(&self, os: *mut std_ostream,
                       prefix: *const std_string) {
        symbol_table_symbol_record_symbol_record_rep_dump(self, os, prefix)
    }
}
pub const symbol_table_symbol_record_local: ::std::os::raw::c_uint = 1;
pub const symbol_table_symbol_record_automatic: ::std::os::raw::c_uint = 2;
pub const symbol_table_symbol_record_formal: ::std::os::raw::c_uint = 4;
pub const symbol_table_symbol_record_hidden: ::std::os::raw::c_uint = 8;
pub const symbol_table_symbol_record_inherited: ::std::os::raw::c_uint = 16;
pub const symbol_table_symbol_record_global: ::std::os::raw::c_uint = 32;
pub const symbol_table_symbol_record_persistent: ::std::os::raw::c_uint = 64;
pub const symbol_table_symbol_record_added_static: ::std::os::raw::c_uint =
    128;
#[test]
fn bindgen_test_layout_symbol_table_symbol_record() {
    assert_eq!(::std::mem::size_of::<symbol_table_symbol_record>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( symbol_table_symbol_record ) ));
    assert_eq! (::std::mem::align_of::<symbol_table_symbol_record>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( symbol_table_symbol_record )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symbol_table_symbol_record ) ) . rep as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                symbol_table_symbol_record ) , "::" , stringify ! ( rep ) ));
}
extern "C" {
    #[link_name =
          "?find@symbol_record@symbol_table@@QEBA?AVoctave_value@@AEBVoctave_value_list@@@Z"]
    pub fn symbol_table_symbol_record_find(this:
                                               *const symbol_table_symbol_record,
                                           args: *const octave_value_list)
     -> octave_value;
}
impl symbol_table_symbol_record {
    #[inline]
    pub unsafe fn find(&self, args: *const octave_value_list)
     -> octave_value {
        symbol_table_symbol_record_find(self, args)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct symbol_table_symbol_reference {
    pub scope: symbol_table_scope_id,
    pub sym: symbol_table_symbol_record,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct symbol_table_symbol_reference_comparator {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_symbol_table_symbol_reference_comparator() {
    assert_eq!(::std::mem::size_of::<symbol_table_symbol_reference_comparator>()
               , 1usize , concat ! (
               "Size of: " , stringify ! (
               symbol_table_symbol_reference_comparator ) ));
    assert_eq! (::std::mem::align_of::<symbol_table_symbol_reference_comparator>()
                , 1usize , concat ! (
                "Alignment of " , stringify ! (
                symbol_table_symbol_reference_comparator ) ));
}
impl Clone for symbol_table_symbol_reference_comparator {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_symbol_table_symbol_reference() {
    assert_eq!(::std::mem::size_of::<symbol_table_symbol_reference>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( symbol_table_symbol_reference ) ));
    assert_eq! (::std::mem::align_of::<symbol_table_symbol_reference>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( symbol_table_symbol_reference
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symbol_table_symbol_reference ) ) . scope
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                symbol_table_symbol_reference ) , "::" , stringify ! ( scope )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symbol_table_symbol_reference ) ) . sym
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                symbol_table_symbol_reference ) , "::" , stringify ! ( sym )
                ));
}
pub type symbol_table_table_const_iterator = u64;
pub type symbol_table_table_iterator = u64;
pub type symbol_table_global_table_const_iterator = u64;
pub type symbol_table_global_table_iterator = u64;
pub type symbol_table_persistent_table_const_iterator = u64;
pub type symbol_table_persistent_table_iterator = u64;
pub type symbol_table_all_instances_const_iterator = u64;
pub type symbol_table_all_instances_iterator = u64;
pub type symbol_table_fcn_table_const_iterator = u64;
pub type symbol_table_fcn_table_iterator = u64;
pub type symbol_table_class_precedence_table_const_iterator = u8;
pub type symbol_table_class_precedence_table_iterator = u8;
pub type symbol_table_const_parent_map_iterator = u64;
pub type symbol_table_parent_map_iterator = u64;
extern "C" {
    #[link_name = "?dummy_octave_value@symbol_table@@2Voctave_value@@A"]
    pub static mut symbol_table_dummy_octave_value: octave_value;
}
extern "C" {
    #[link_name = "?dummy_symbol_record@symbol_table@@2Vsymbol_record@1@A"]
    pub static mut symbol_table_dummy_symbol_record:
               symbol_table_symbol_record;
}
extern "C" {
    #[link_name =
          "?global_table@symbol_table@@0V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Voctave_value@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Voctave_value@@@std@@@2@@std@@A"]
    pub static mut symbol_table_global_table: std_map;
}
extern "C" {
    #[link_name = "?instance@symbol_table@@0PEAV1@EA"]
    pub static mut symbol_table_instance: *mut symbol_table;
}
extern "C" {
    #[link_name =
          "?all_instances@symbol_table@@0V?$map@HPEAVsymbol_table@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPEAVsymbol_table@@@std@@@3@@std@@A"]
    pub static mut symbol_table_all_instances: std_map;
}
extern "C" {
    #[link_name =
          "?fcn_table@symbol_table@@0V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Vfcn_info@symbol_table@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Vfcn_info@symbol_table@@@std@@@2@@std@@A"]
    pub static mut symbol_table_fcn_table: std_map;
}
extern "C" {
    #[link_name =
          "?class_precedence_table@symbol_table@@0V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$set@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$set@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@A"]
    pub static mut symbol_table_class_precedence_table: std_map;
}
extern "C" {
    #[link_name =
          "?parent_map@symbol_table@@0V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$list@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$list@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@A"]
    pub static mut symbol_table_parent_map: std_map;
}
extern "C" {
    #[link_name = "?xglobal_scope@symbol_table@@0HB"]
    pub static symbol_table_xglobal_scope: symbol_table_scope_id;
}
extern "C" {
    #[link_name = "?xtop_scope@symbol_table@@0HB"]
    pub static symbol_table_xtop_scope: symbol_table_scope_id;
}
extern "C" {
    #[link_name = "?xcurrent_scope@symbol_table@@0HA"]
    pub static mut symbol_table_xcurrent_scope: symbol_table_scope_id;
}
extern "C" {
    #[link_name = "?xcurrent_context@symbol_table@@0_KA"]
    pub static mut symbol_table_xcurrent_context: symbol_table_context_id;
}
extern "C" {
    #[link_name = "?xdefault_context@symbol_table@@0_KB"]
    pub static symbol_table_xdefault_context: symbol_table_context_id;
}
#[test]
fn bindgen_test_layout_symbol_table() {
    assert_eq!(::std::mem::size_of::<symbol_table>() , 160usize , concat ! (
               "Size of: " , stringify ! ( symbol_table ) ));
    assert_eq! (::std::mem::align_of::<symbol_table>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( symbol_table ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symbol_table ) ) . my_scope as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( symbol_table ) , "::" ,
                stringify ! ( my_scope ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symbol_table ) ) . table_name as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( symbol_table ) , "::" ,
                stringify ! ( table_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symbol_table ) ) . table as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( symbol_table ) , "::" ,
                stringify ! ( table ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symbol_table ) ) . nest_children as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( symbol_table ) , "::" ,
                stringify ! ( nest_children ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symbol_table ) ) . nest_parent as * const
                _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( symbol_table ) , "::" ,
                stringify ! ( nest_parent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symbol_table ) ) . curr_fcn as * const _
                as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( symbol_table ) , "::" ,
                stringify ! ( curr_fcn ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symbol_table ) ) . static_workspace as *
                const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( symbol_table ) , "::" ,
                stringify ! ( static_workspace ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symbol_table ) ) . persistent_table as *
                const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( symbol_table ) , "::" ,
                stringify ! ( persistent_table ) ));
}
extern "C" {
    #[link_name =
          "?find@symbol_table@@SA?AVoctave_value@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBVoctave_value_list@@_N2@Z"]
    pub fn symbol_table_find(name: *const std_string,
                             args: *const octave_value_list,
                             skip_variables: bool, local_funcs: bool)
     -> octave_value;
}
extern "C" {
    #[link_name =
          "?builtin_find@symbol_table@@SA?AVoctave_value@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn symbol_table_builtin_find(name: *const std_string) -> octave_value;
}
extern "C" {
    #[link_name =
          "?find_submethod@symbol_table@@SA?AVoctave_value@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z"]
    pub fn symbol_table_find_submethod(name: *const std_string,
                                       dispatch_type: *const std_string)
     -> octave_value;
}
extern "C" {
    #[link_name =
          "?find_function@symbol_table@@SA?AVoctave_value@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBVoctave_value_list@@_N@Z"]
    pub fn symbol_table_find_function(name: *const std_string,
                                      args: *const octave_value_list,
                                      local_funcs: bool) -> octave_value;
}
extern "C" {
    #[link_name =
          "?install_nestfunction@symbol_table@@SAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBVoctave_value@@H@Z"]
    pub fn symbol_table_install_nestfunction(name: *const std_string,
                                             fcn: *const octave_value,
                                             parent_scope:
                                                 symbol_table_scope_id);
}
extern "C" {
    #[link_name =
          "?set_class_relationship@symbol_table@@SA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z"]
    pub fn symbol_table_set_class_relationship(sup_class: *const std_string,
                                               inf_class: *const std_string)
     -> bool;
}
extern "C" {
    #[link_name =
          "?is_superiorto@symbol_table@@SA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z"]
    pub fn symbol_table_is_superiorto(a: *const std_string,
                                      b: *const std_string) -> bool;
}
extern "C" {
    #[link_name =
          "?dump@symbol_table@@SAXAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@H@Z"]
    pub fn symbol_table_dump(os: *mut std_ostream,
                             scope: symbol_table_scope_id);
}
extern "C" {
    #[link_name =
          "?dump_global@symbol_table@@SAXAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@@Z"]
    pub fn symbol_table_dump_global(os: *mut std_ostream);
}
extern "C" {
    #[link_name =
          "?dump_functions@symbol_table@@SAXAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@@Z"]
    pub fn symbol_table_dump_functions(os: *mut std_ostream);
}
extern "C" {
    #[link_name =
          "?stash_dir_name_for_subfunctions@symbol_table@@SAXHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn symbol_table_stash_dir_name_for_subfunctions(scope:
                                                            symbol_table_scope_id,
                                                        dir_name:
                                                            *const std_string);
}
extern "C" {
    #[link_name = "?cleanup@symbol_table@@SAXXZ"]
    pub fn symbol_table_cleanup();
}
impl symbol_table {
    #[inline]
    pub unsafe fn find(name: *const std_string,
                       args: *const octave_value_list, skip_variables: bool,
                       local_funcs: bool) -> octave_value {
        symbol_table_find(name, args, skip_variables, local_funcs)
    }
    #[inline]
    pub unsafe fn builtin_find(name: *const std_string) -> octave_value {
        symbol_table_builtin_find(name)
    }
    #[inline]
    pub unsafe fn find_submethod(name: *const std_string,
                                 dispatch_type: *const std_string)
     -> octave_value {
        symbol_table_find_submethod(name, dispatch_type)
    }
    #[inline]
    pub unsafe fn find_function(name: *const std_string,
                                args: *const octave_value_list,
                                local_funcs: bool) -> octave_value {
        symbol_table_find_function(name, args, local_funcs)
    }
    #[inline]
    pub unsafe fn install_nestfunction(name: *const std_string,
                                       fcn: *const octave_value,
                                       parent_scope: symbol_table_scope_id) {
        symbol_table_install_nestfunction(name, fcn, parent_scope)
    }
    #[inline]
    pub unsafe fn set_class_relationship(sup_class: *const std_string,
                                         inf_class: *const std_string)
     -> bool {
        symbol_table_set_class_relationship(sup_class, inf_class)
    }
    #[inline]
    pub unsafe fn is_superiorto(a: *const std_string, b: *const std_string)
     -> bool {
        symbol_table_is_superiorto(a, b)
    }
    #[inline]
    pub unsafe fn dump(os: *mut std_ostream, scope: symbol_table_scope_id) {
        symbol_table_dump(os, scope)
    }
    #[inline]
    pub unsafe fn dump_global(os: *mut std_ostream) {
        symbol_table_dump_global(os)
    }
    #[inline]
    pub unsafe fn dump_functions(os: *mut std_ostream) {
        symbol_table_dump_functions(os)
    }
    #[inline]
    pub unsafe fn stash_dir_name_for_subfunctions(scope:
                                                      symbol_table_scope_id,
                                                  dir_name:
                                                      *const std_string) {
        symbol_table_stash_dir_name_for_subfunctions(scope, dir_name)
    }
    #[inline]
    pub unsafe fn cleanup() { symbol_table_cleanup() }
}
extern "C" {
    #[link_name =
          "?out_of_date_check@@YA_NAEAVoctave_value@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z"]
    pub fn out_of_date_check(function: *mut octave_value,
                             dispatch_type: *const std_string,
                             check_relative: bool) -> bool;
}
extern "C" {
    #[link_name =
          "?get_dispatch_type@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBVoctave_value_list@@@Z"]
    pub fn get_dispatch_type(args: *const octave_value_list) -> std_string;
}
extern "C" {
    #[link_name =
          "?get_dispatch_type@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBVoctave_value_list@@AEAW4builtin_type_t@@@Z"]
    pub fn get_dispatch_type1(args: *const octave_value_list,
                              builtin_type: *mut builtin_type_t)
     -> std_string;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct jit_type([u8; 0]);
#[repr(C)]
#[derive(Debug)]
pub struct octave_builtin {
    pub _base: octave_function,
    pub f: octave_builtin_fcn,
    pub file: std_string,
    pub jtype: *mut jit_type,
}
pub type octave_builtin_fcn =
    ::std::option::Option<unsafe extern "C" fn(arg1: *const octave_value_list,
                                               arg2: ::std::os::raw::c_int)
                              -> octave_value_list>;
extern "C" {
    #[link_name =
          "?curr_lvalue_list@octave_builtin@@2PEBV?$list@Voctave_lvalue@@V?$allocator@Voctave_lvalue@@@std@@@std@@EB"]
    pub static mut octave_builtin_curr_lvalue_list: *const std_list;
}
extern "C" {
    #[link_name = "?t_id@octave_builtin@@0HA"]
    pub static mut octave_builtin_t_id: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name =
          "?t_name@octave_builtin@@0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B"]
    pub static octave_builtin_t_name: std_string;
}
extern "C" {
    #[link_name =
          "?c_name@octave_builtin@@0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B"]
    pub static octave_builtin_c_name: std_string;
}
#[test]
fn bindgen_test_layout_octave_builtin() {
    assert_eq!(::std::mem::size_of::<octave_builtin>() , 88usize , concat ! (
               "Size of: " , stringify ! ( octave_builtin ) ));
    assert_eq! (::std::mem::align_of::<octave_builtin>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( octave_builtin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_builtin ) ) . f as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_builtin ) , "::"
                , stringify ! ( f ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_builtin ) ) . file as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_builtin ) , "::"
                , stringify ! ( file ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_builtin ) ) . jtype as * const _
                as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_builtin ) , "::"
                , stringify ! ( jtype ) ));
}
extern "C" {
    #[link_name = "?to_jit@octave_builtin@@QEBAPEAVjit_type@@XZ"]
    pub fn octave_builtin_to_jit(this: *const octave_builtin)
     -> *mut jit_type;
}
extern "C" {
    #[link_name = "?stash_jit@octave_builtin@@QEAAXAEAVjit_type@@@Z"]
    pub fn octave_builtin_stash_jit(this: *mut octave_builtin,
                                    type_: *mut jit_type);
}
extern "C" {
    #[link_name =
          "?function@octave_builtin@@QEBAP6A?AVoctave_value_list@@AEBV2@H@ZXZ"]
    pub fn octave_builtin_function(this: *const octave_builtin)
     -> octave_builtin_fcn;
}
extern "C" {
    #[link_name = "?register_type@octave_builtin@@SAXXZ"]
    pub fn octave_builtin_register_type();
}
impl octave_builtin {
    #[inline]
    pub unsafe fn to_jit(&self) -> *mut jit_type {
        octave_builtin_to_jit(self)
    }
    #[inline]
    pub unsafe fn stash_jit(&mut self, type_: *mut jit_type) {
        octave_builtin_stash_jit(self, type_)
    }
    #[inline]
    pub unsafe fn function(&self) -> octave_builtin_fcn {
        octave_builtin_function(self)
    }
    #[inline]
    pub unsafe fn register_type() { octave_builtin_register_type() }
}
pub type octave_shlib = octave_dynamic_library;
#[repr(C)]
#[derive(Debug)]
pub struct octave_dld_function {
    pub _base: octave_builtin,
    pub sh_lib: octave_dynamic_library,
    pub t_checked: octave_sys_time,
    pub system_fcn_file: bool,
}
extern "C" {
    #[link_name = "?t_id@octave_dld_function@@0HA"]
    pub static mut octave_dld_function_t_id: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name =
          "?t_name@octave_dld_function@@0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B"]
    pub static octave_dld_function_t_name: std_string;
}
extern "C" {
    #[link_name =
          "?c_name@octave_dld_function@@0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B"]
    pub static octave_dld_function_c_name: std_string;
}
#[test]
fn bindgen_test_layout_octave_dld_function() {
    assert_eq!(::std::mem::size_of::<octave_dld_function>() , 120usize ,
               concat ! ( "Size of: " , stringify ! ( octave_dld_function )
               ));
    assert_eq! (::std::mem::align_of::<octave_dld_function>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( octave_dld_function ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_dld_function ) ) . sh_lib as *
                const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_dld_function ) ,
                "::" , stringify ! ( sh_lib ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_dld_function ) ) . t_checked as *
                const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_dld_function ) ,
                "::" , stringify ! ( t_checked ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_dld_function ) ) . system_fcn_file
                as * const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_dld_function ) ,
                "::" , stringify ! ( system_fcn_file ) ));
}
extern "C" {
    #[link_name =
          "?create@octave_dld_function@@SAPEAV1@P6A?AVoctave_value_list@@AEBV2@H@ZAEBVdynamic_library@octave@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@3@Z"]
    pub fn octave_dld_function_create(ff: octave_builtin_fcn,
                                      shl: *const octave_dynamic_library,
                                      nm: *const std_string,
                                      ds: *const std_string)
     -> *mut octave_dld_function;
}
extern "C" {
    #[link_name = "?register_type@octave_dld_function@@SAXXZ"]
    pub fn octave_dld_function_register_type();
}
extern "C" {
    #[link_name =
          "??0octave_dld_function@@QEAA@P6A?AVoctave_value_list@@AEBV1@H@ZAEBVdynamic_library@octave@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@3@Z"]
    pub fn octave_dld_function_octave_dld_function(this:
                                                       *mut octave_dld_function,
                                                   ff: octave_builtin_fcn,
                                                   shl:
                                                       *const octave_dynamic_library,
                                                   nm: *const std_string,
                                                   ds: *const std_string);
}
impl octave_dld_function {
    #[inline]
    pub unsafe fn create(ff: octave_builtin_fcn,
                         shl: *const octave_dynamic_library,
                         nm: *const std_string, ds: *const std_string)
     -> *mut octave_dld_function {
        octave_dld_function_create(ff, shl, nm, ds)
    }
    #[inline]
    pub unsafe fn register_type() { octave_dld_function_register_type() }
    #[inline]
    pub unsafe fn new(ff: octave_builtin_fcn,
                      shl: *const octave_dynamic_library,
                      nm: *const std_string, ds: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_dld_function_octave_dld_function(&mut __bindgen_tmp, ff, shl,
                                                nm, ds);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name =
          "?octave_www_statement@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z"]
    pub fn octave_www_statement(html: bool) -> std_string;
}
extern "C" {
    #[link_name =
          "?octave_contrib_statement@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z"]
    pub fn octave_contrib_statement(html: bool) -> std_string;
}
extern "C" {
    #[link_name =
          "?octave_bugs_statement@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z"]
    pub fn octave_bugs_statement(html: bool) -> std_string;
}
extern "C" {
    #[link_name =
          "?octave_name_version_and_copyright@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ"]
    pub fn octave_name_version_and_copyright() -> std_string;
}
extern "C" {
    #[link_name =
          "?octave_name_version_copyright_copying_and_warranty@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_NAEBV12@@Z"]
    pub fn octave_name_version_copyright_copying_and_warranty(html: bool,
                                                              extra_info:
                                                                  *const std_string)
     -> std_string;
}
extern "C" {
    #[link_name =
          "?octave_name_version_copyright_copying_warranty_and_bugs@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_NAEBV12@@Z"]
    pub fn octave_name_version_copyright_copying_warranty_and_bugs(html: bool,
                                                                   extra_info:
                                                                       *const std_string)
     -> std_string;
}
extern "C" {
    #[link_name =
          "?octave_startup_message@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z"]
    pub fn octave_startup_message(html: bool) -> std_string;
}
extern "C" {
    #[link_name = "?print_usage@@YAXXZ"]
    pub fn print_usage();
}
extern "C" {
    #[link_name =
          "?print_usage@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn print_usage1(arg1: *const std_string);
}
extern "C" {
    #[link_name =
          "?check_version@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z"]
    pub fn check_version(version: *const std_string, fcn: *const std_string);
}
extern "C" {
    #[link_name =
          "?install_builtin_function@@YAXP6A?AVoctave_value_list@@AEBV1@H@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@22_N@Z"]
    pub fn install_builtin_function(f: octave_builtin_fcn,
                                    name: *const std_string,
                                    file: *const std_string,
                                    doc: *const std_string,
                                    can_hide_function: bool);
}
extern "C" {
    #[link_name =
          "?install_dld_function@@YAXP6A?AVoctave_value_list@@AEBV1@H@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBVdynamic_library@octave@@2_N@Z"]
    pub fn install_dld_function(f: octave_builtin_fcn,
                                name: *const std_string,
                                shl: *const octave_dynamic_library,
                                doc: *const std_string, relative: bool);
}
extern "C" {
    #[link_name =
          "?install_mex_function@@YAXPEAX_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBVdynamic_library@octave@@1@Z"]
    pub fn install_mex_function(fptr: *mut ::std::os::raw::c_void, fmex: bool,
                                name: *const std_string,
                                shl: *const octave_dynamic_library,
                                relative: bool);
}
extern "C" {
    #[link_name =
          "?alias_builtin@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z"]
    pub fn alias_builtin(alias: *const std_string, name: *const std_string);
}
extern "C" {
    #[link_name = "?get_current_shlib@@YA?AVdynamic_library@octave@@XZ"]
    pub fn get_current_shlib() -> octave_dynamic_library;
}
#[repr(C)]
#[derive(Debug)]
pub struct octave_auto_shlib {
    pub _base: octave_dynamic_library,
}
#[test]
fn bindgen_test_layout_octave_auto_shlib() {
    assert_eq!(::std::mem::size_of::<octave_auto_shlib>() , 8usize , concat !
               ( "Size of: " , stringify ! ( octave_auto_shlib ) ));
    assert_eq! (::std::mem::align_of::<octave_auto_shlib>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( octave_auto_shlib ) ));
}
extern "C" {
    #[link_name = "?defun_isargout@@YA_NHH@Z"]
    pub fn defun_isargout(arg1: ::std::os::raw::c_int,
                          arg2: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    #[link_name = "?defun_isargout@@YAXHHPEA_N@Z"]
    pub fn defun_isargout1(arg1: ::std::os::raw::c_int,
                           arg2: ::std::os::raw::c_int, arg3: *mut bool);
}
pub type octave_dld_fcn_installer =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *const octave_dynamic_library,
                                               relative: bool) -> bool>;
pub type octave_dld_fcn_getter =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *const octave_dynamic_library,
                                               relative: bool)
                              -> *mut octave_function>;
extern "C" {
    #[link_name = "?err_2_or_3_dim_plot@@YAXXZ"]
    pub fn err_2_or_3_dim_plot();
}
extern "C" {
    #[link_name = "?err_data_conversion@@YAXPEBD0@Z"]
    pub fn err_data_conversion(from: *const ::std::os::raw::c_char,
                               to: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name =
          "?err_disabled_feature@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00@Z"]
    pub fn err_disabled_feature(fcn: *const std_string,
                                feature: *const std_string,
                                pkg: *const std_string);
}
extern "C" {
    #[link_name = "?err_indexed_cs_list@@YAXXZ"]
    pub fn err_indexed_cs_list();
}
extern "C" {
    #[link_name =
          "?err_invalid_conversion@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z"]
    pub fn err_invalid_conversion(from: *const std_string,
                                  to: *const std_string);
}
extern "C" {
    #[link_name = "?err_invalid_inquiry_subscript@@YAXXZ"]
    pub fn err_invalid_inquiry_subscript();
}
extern "C" {
    #[link_name = "?err_nonbraced_cs_list_assignment@@YAXXZ"]
    pub fn err_nonbraced_cs_list_assignment();
}
extern "C" {
    #[link_name = "?err_nonconformant@@YAXXZ"]
    pub fn err_nonconformant();
}
extern "C" {
    #[link_name = "?err_nonconformant@@YAXHHHH@Z"]
    pub fn err_nonconformant1(r1: octave_idx_type, c1: octave_idx_type,
                              r2: octave_idx_type, c2: octave_idx_type);
}
extern "C" {
    #[link_name = "?err_not_implemented@@YAXPEBD@Z"]
    pub fn err_not_implemented(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "?err_range_invalid@@YAXXZ"]
    pub fn err_range_invalid();
}
extern "C" {
    #[link_name = "?err_square_matrix_required@@YAXPEBD0@Z"]
    pub fn err_square_matrix_required(fcn: *const ::std::os::raw::c_char,
                                      name: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "?err_string_invalid@@YAXXZ"]
    pub fn err_string_invalid();
}
extern "C" {
    #[link_name = "?err_unrecognized_data_fmt@@YAXPEBD@Z"]
    pub fn err_unrecognized_data_fmt(name: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "?err_unrecognized_float_fmt@@YAXXZ"]
    pub fn err_unrecognized_float_fmt();
}
extern "C" {
    #[link_name = "?err_user_returned_invalid@@YAXPEBD@Z"]
    pub fn err_user_returned_invalid(name: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "?err_user_supplied_eval@@YAXPEBD@Z"]
    pub fn err_user_supplied_eval(name: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name =
          "?err_user_supplied_eval@@YAXAEAVexecution_exception@octave@@PEBD@Z"]
    pub fn err_user_supplied_eval1(e: *mut octave_execution_exception,
                                   name: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "?err_wrong_type_arg@@YAXPEBD0@Z"]
    pub fn err_wrong_type_arg(name: *const ::std::os::raw::c_char,
                              s: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name =
          "?err_wrong_type_arg@@YAXAEAVexecution_exception@octave@@PEBD1@Z"]
    pub fn err_wrong_type_arg1(e: *mut octave_execution_exception,
                               name: *const ::std::os::raw::c_char,
                               s: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name =
          "?err_wrong_type_arg@@YAXPEBDAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn err_wrong_type_arg2(name: *const ::std::os::raw::c_char,
                               s: *const std_string);
}
extern "C" {
    #[link_name =
          "?err_wrong_type_arg@@YAXAEAVexecution_exception@octave@@PEBDAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn err_wrong_type_arg3(e: *mut octave_execution_exception,
                               name: *const ::std::os::raw::c_char,
                               s: *const std_string);
}
extern "C" {
    #[link_name = "?err_wrong_type_arg@@YAXPEBDAEBVoctave_value@@@Z"]
    pub fn err_wrong_type_arg4(name: *const ::std::os::raw::c_char,
                               tc: *const octave_value);
}
extern "C" {
    #[link_name =
          "?err_wrong_type_arg@@YAXAEAVexecution_exception@octave@@PEBDAEBVoctave_value@@@Z"]
    pub fn err_wrong_type_arg5(e: *mut octave_execution_exception,
                               name: *const ::std::os::raw::c_char,
                               tc: *const octave_value);
}
extern "C" {
    #[link_name =
          "?err_wrong_type_arg@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBVoctave_value@@@Z"]
    pub fn err_wrong_type_arg6(name: *const std_string,
                               tc: *const octave_value);
}
extern "C" {
    #[link_name =
          "?err_wrong_type_arg@@YAXAEAVexecution_exception@octave@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBVoctave_value@@@Z"]
    pub fn err_wrong_type_arg7(e: *mut octave_execution_exception,
                               name: *const std_string,
                               tc: *const octave_value);
}
extern "C" {
    #[link_name = "?err_wrong_type_arg@@YAXPEBD@Z"]
    pub fn err_wrong_type_arg8(s: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name =
          "?err_wrong_type_arg@@YAXAEAVexecution_exception@octave@@PEBD@Z"]
    pub fn err_wrong_type_arg9(e: *mut octave_execution_exception,
                               s: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name =
          "?err_wrong_type_arg@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn err_wrong_type_arg10(s: *const std_string);
}
extern "C" {
    #[link_name =
          "?err_wrong_type_arg@@YAXAEAVexecution_exception@octave@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn err_wrong_type_arg11(e: *mut octave_execution_exception,
                                s: *const std_string);
}
extern "C" {
    #[link_name = "?err_wrong_type_arg@@YAXAEBVoctave_value@@@Z"]
    pub fn err_wrong_type_arg12(tc: *const octave_value);
}
extern "C" {
    #[link_name =
          "?err_wrong_type_arg@@YAXAEAVexecution_exception@octave@@AEBVoctave_value@@@Z"]
    pub fn err_wrong_type_arg13(e: *mut octave_execution_exception,
                                tc: *const octave_value);
}
extern "C" {
    #[link_name =
          "?err_wrong_type_arg_for_binary_op@@YAXAEBVoctave_value@@@Z"]
    pub fn err_wrong_type_arg_for_binary_op(op: *const octave_value);
}
extern "C" {
    #[link_name = "?err_wrong_type_arg_for_unary_op@@YAXAEBVoctave_value@@@Z"]
    pub fn err_wrong_type_arg_for_unary_op(op: *const octave_value);
}
extern "C" {
    #[link_name = "?warn_array_as_logical@@YAXAEBVdim_vector@@@Z"]
    pub fn warn_array_as_logical(dv: *const dim_vector);
}
extern "C" {
    #[link_name = "?warn_complex_cmp@@YAXXZ"]
    pub fn warn_complex_cmp();
}
extern "C" {
    #[link_name =
          "?warn_data_file_in_path@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z"]
    pub fn warn_data_file_in_path(fcn: *const std_string,
                                  file: *const std_string);
}
extern "C" {
    #[link_name =
          "?warn_disabled_feature@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00@Z"]
    pub fn warn_disabled_feature(fcn: *const std_string,
                                 feature: *const std_string,
                                 pkg: *const std_string);
}
extern "C" {
    #[link_name = "?warn_divide_by_zero@@YAXXZ"]
    pub fn warn_divide_by_zero();
}
extern "C" {
    #[link_name = "?warn_empty_arg@@YAXPEBD@Z"]
    pub fn warn_empty_arg(name: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "?warn_implicit_conversion@@YAXPEBD00@Z"]
    pub fn warn_implicit_conversion(id: *const ::std::os::raw::c_char,
                                    from: *const ::std::os::raw::c_char,
                                    to: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name =
          "?warn_implicit_conversion@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00@Z"]
    pub fn warn_implicit_conversion1(id: *const std_string,
                                     from: *const std_string,
                                     to: *const std_string);
}
extern "C" {
    #[link_name = "?warn_invalid_value_specified@@YAXPEBD@Z"]
    pub fn warn_invalid_value_specified(name: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "?warn_logical_conversion@@YAXXZ"]
    pub fn warn_logical_conversion();
}
extern "C" {
    #[link_name = "?warn_wrong_type_arg@@YAXPEBDAEBVoctave_value@@@Z"]
    pub fn warn_wrong_type_arg(name: *const ::std::os::raw::c_char,
                               tc: *const octave_value);
}
extern "C" {
    #[link_name = "?gripe_nan_to_logical_conversion@@YAXXZ"]
    pub fn gripe_nan_to_logical_conversion();
}
extern "C" {
    #[link_name = "?gripe_nan_to_character_conversion@@YAXXZ"]
    pub fn gripe_nan_to_character_conversion();
}
extern "C" {
    #[link_name = "?gripe_nonconformant@@YAXPEBDHH@Z"]
    pub fn gripe_nonconformant(op: *const ::std::os::raw::c_char,
                               op1_len: octave_idx_type,
                               op2_len: octave_idx_type);
}
extern "C" {
    #[link_name = "?gripe_nonconformant@@YAXPEBDHHHH@Z"]
    pub fn gripe_nonconformant1(op: *const ::std::os::raw::c_char,
                                op1_nr: octave_idx_type,
                                op1_nc: octave_idx_type,
                                op2_nr: octave_idx_type,
                                op2_nc: octave_idx_type);
}
extern "C" {
    #[link_name = "?gripe_nonconformant@@YAXPEBDAEBVdim_vector@@1@Z"]
    pub fn gripe_nonconformant2(op: *const ::std::os::raw::c_char,
                                op1_dims: *const dim_vector,
                                op2_dims: *const dim_vector);
}
extern "C" {
    #[link_name = "?gripe_index_out_of_range@@YAXHHHHAEBVdim_vector@@@Z"]
    pub fn gripe_index_out_of_range(nd: ::std::os::raw::c_int,
                                    dim: ::std::os::raw::c_int,
                                    iext: octave_idx_type,
                                    ext: octave_idx_type,
                                    d: *const dim_vector);
}
extern "C" {
    #[link_name = "?gripe_index_out_of_range@@YAXHHHH@Z"]
    pub fn gripe_index_out_of_range1(nd: ::std::os::raw::c_int,
                                     dim: ::std::os::raw::c_int,
                                     iext: octave_idx_type,
                                     ext: octave_idx_type);
}
extern "C" {
    #[link_name = "?gripe_del_index_out_of_range@@YAX_NHH@Z"]
    pub fn gripe_del_index_out_of_range(is1d: bool, iext: octave_idx_type,
                                        ext: octave_idx_type);
}
extern "C" {
    #[link_name =
          "?gripe_invalid_index@@YAXNHHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn gripe_invalid_index(arg1: f64, nd: octave_idx_type,
                               dim: octave_idx_type, var: *const std_string);
}
extern "C" {
    #[link_name =
          "?gripe_invalid_index@@YAXHHHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn gripe_invalid_index1(n: octave_idx_type, nd: octave_idx_type,
                                dim: octave_idx_type, var: *const std_string);
}
extern "C" {
    #[link_name =
          "?gripe_invalid_index@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HH0@Z"]
    pub fn gripe_invalid_index2(idx: *const std_string, nd: octave_idx_type,
                                dim: octave_idx_type, var: *const std_string);
}
extern "C" {
    #[link_name = "?gripe_invalid_resize@@YAXXZ"]
    pub fn gripe_invalid_resize();
}
extern "C" {
    #[link_name = "?gripe_singular_matrix@@YAXN@Z"]
    pub fn gripe_singular_matrix(rcond: f64);
}
extern "C" {
    #[link_name = "?gripe_2_or_3_dim_plot@@YAXXZ"]
    pub fn gripe_2_or_3_dim_plot();
}
extern "C" {
    #[link_name = "?gripe_data_conversion@@YAXPEBD0@Z"]
    pub fn gripe_data_conversion(from: *const ::std::os::raw::c_char,
                                 to: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name =
          "?gripe_data_file_in_path@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z"]
    pub fn gripe_data_file_in_path(fcn: *const std_string,
                                   file: *const std_string);
}
extern "C" {
    #[link_name =
          "?gripe_disabled_feature@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00@Z"]
    pub fn gripe_disabled_feature(fcn: *const std_string,
                                  feature: *const std_string,
                                  pkg: *const std_string);
}
extern "C" {
    #[link_name = "?gripe_divide_by_zero@@YAXXZ"]
    pub fn gripe_divide_by_zero();
}
extern "C" {
    #[link_name = "?gripe_empty_arg@@YAXPEBD_N@Z"]
    pub fn gripe_empty_arg(name: *const ::std::os::raw::c_char,
                           is_error: bool);
}
extern "C" {
    #[link_name = "?gripe_implicit_conversion@@YAXPEBD00@Z"]
    pub fn gripe_implicit_conversion(id: *const ::std::os::raw::c_char,
                                     from: *const ::std::os::raw::c_char,
                                     to: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name =
          "?gripe_implicit_conversion@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00@Z"]
    pub fn gripe_implicit_conversion1(id: *const std_string,
                                      from: *const std_string,
                                      to: *const std_string);
}
extern "C" {
    #[link_name = "?gripe_indexed_cs_list@@YAXXZ"]
    pub fn gripe_indexed_cs_list();
}
extern "C" {
    #[link_name =
          "?gripe_invalid_conversion@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z"]
    pub fn gripe_invalid_conversion(from: *const std_string,
                                    to: *const std_string);
}
extern "C" {
    #[link_name = "?gripe_invalid_inquiry_subscript@@YAXXZ"]
    pub fn gripe_invalid_inquiry_subscript();
}
extern "C" {
    #[link_name = "?gripe_invalid_value_specified@@YAXPEBD@Z"]
    pub fn gripe_invalid_value_specified(name: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "?gripe_logical_conversion@@YAXXZ"]
    pub fn gripe_logical_conversion();
}
extern "C" {
    #[link_name = "?gripe_nonbraced_cs_list_assignment@@YAXXZ"]
    pub fn gripe_nonbraced_cs_list_assignment();
}
extern "C" {
    #[link_name = "?gripe_nonconformant@@YAXXZ"]
    pub fn gripe_nonconformant3();
}
extern "C" {
    #[link_name = "?gripe_nonconformant@@YAXHHHH@Z"]
    pub fn gripe_nonconformant4(r1: octave_idx_type, c1: octave_idx_type,
                                r2: octave_idx_type, c2: octave_idx_type);
}
extern "C" {
    #[link_name = "?gripe_not_implemented@@YAXPEBD@Z"]
    pub fn gripe_not_implemented(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "?gripe_not_supported@@YAXPEBD@Z"]
    pub fn gripe_not_supported(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "?gripe_range_invalid@@YAXXZ"]
    pub fn gripe_range_invalid();
}
extern "C" {
    #[link_name = "?gripe_square_matrix_required@@YAXPEBD@Z"]
    pub fn gripe_square_matrix_required(name: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "?gripe_string_invalid@@YAXXZ"]
    pub fn gripe_string_invalid();
}
extern "C" {
    #[link_name = "?gripe_unrecognized_data_fmt@@YAXPEBD@Z"]
    pub fn gripe_unrecognized_data_fmt(warn_for:
                                           *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "?gripe_unrecognized_float_fmt@@YAXXZ"]
    pub fn gripe_unrecognized_float_fmt();
}
extern "C" {
    #[link_name = "?gripe_user_returned_invalid@@YAXPEBD@Z"]
    pub fn gripe_user_returned_invalid(name: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "?gripe_user_supplied_eval@@YAXPEBD@Z"]
    pub fn gripe_user_supplied_eval(name: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name =
          "?gripe_user_supplied_eval@@YAXAEAVexecution_exception@octave@@PEBD@Z"]
    pub fn gripe_user_supplied_eval1(e: *mut octave_execution_exception,
                                     name: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "?gripe_warn_complex_cmp@@YAXXZ"]
    pub fn gripe_warn_complex_cmp();
}
extern "C" {
    #[link_name = "?gripe_wrong_type_arg@@YAXPEBD0_N@Z"]
    pub fn gripe_wrong_type_arg(name: *const ::std::os::raw::c_char,
                                s: *const ::std::os::raw::c_char,
                                is_error: bool);
}
extern "C" {
    #[link_name =
          "?gripe_wrong_type_arg@@YAXAEAVexecution_exception@octave@@PEBD1_N@Z"]
    pub fn gripe_wrong_type_arg1(e: *mut octave_execution_exception,
                                 name: *const ::std::os::raw::c_char,
                                 s: *const ::std::os::raw::c_char,
                                 is_error: bool);
}
extern "C" {
    #[link_name =
          "?gripe_wrong_type_arg@@YAXPEBDAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z"]
    pub fn gripe_wrong_type_arg2(name: *const ::std::os::raw::c_char,
                                 s: *const std_string, is_error: bool);
}
extern "C" {
    #[link_name =
          "?gripe_wrong_type_arg@@YAXAEAVexecution_exception@octave@@PEBDAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z"]
    pub fn gripe_wrong_type_arg3(e: *mut octave_execution_exception,
                                 name: *const ::std::os::raw::c_char,
                                 s: *const std_string, is_error: bool);
}
extern "C" {
    #[link_name = "?gripe_wrong_type_arg@@YAXPEBDAEBVoctave_value@@_N@Z"]
    pub fn gripe_wrong_type_arg4(name: *const ::std::os::raw::c_char,
                                 tc: *const octave_value, is_error: bool);
}
extern "C" {
    #[link_name =
          "?gripe_wrong_type_arg@@YAXAEAVexecution_exception@octave@@PEBDAEBVoctave_value@@_N@Z"]
    pub fn gripe_wrong_type_arg5(e: *mut octave_execution_exception,
                                 name: *const ::std::os::raw::c_char,
                                 tc: *const octave_value, is_error: bool);
}
extern "C" {
    #[link_name =
          "?gripe_wrong_type_arg@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBVoctave_value@@_N@Z"]
    pub fn gripe_wrong_type_arg6(name: *const std_string,
                                 tc: *const octave_value, is_error: bool);
}
extern "C" {
    #[link_name =
          "?gripe_wrong_type_arg@@YAXAEAVexecution_exception@octave@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBVoctave_value@@_N@Z"]
    pub fn gripe_wrong_type_arg7(e: *mut octave_execution_exception,
                                 name: *const std_string,
                                 tc: *const octave_value, is_error: bool);
}
extern "C" {
    #[link_name = "?gripe_wrong_type_arg@@YAXPEBD_N@Z"]
    pub fn gripe_wrong_type_arg8(s: *const ::std::os::raw::c_char,
                                 is_error: bool);
}
extern "C" {
    #[link_name =
          "?gripe_wrong_type_arg@@YAXAEAVexecution_exception@octave@@PEBD_N@Z"]
    pub fn gripe_wrong_type_arg9(e: *mut octave_execution_exception,
                                 s: *const ::std::os::raw::c_char,
                                 is_error: bool);
}
extern "C" {
    #[link_name =
          "?gripe_wrong_type_arg@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z"]
    pub fn gripe_wrong_type_arg10(s: *const std_string, is_error: bool);
}
extern "C" {
    #[link_name =
          "?gripe_wrong_type_arg@@YAXAEAVexecution_exception@octave@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z"]
    pub fn gripe_wrong_type_arg11(e: *mut octave_execution_exception,
                                  s: *const std_string, is_error: bool);
}
extern "C" {
    #[link_name = "?gripe_wrong_type_arg@@YAXAEBVoctave_value@@_N@Z"]
    pub fn gripe_wrong_type_arg12(tc: *const octave_value, is_error: bool);
}
extern "C" {
    #[link_name =
          "?gripe_wrong_type_arg@@YAXAEAVexecution_exception@octave@@AEBVoctave_value@@_N@Z"]
    pub fn gripe_wrong_type_arg13(e: *mut octave_execution_exception,
                                  tc: *const octave_value, is_error: bool);
}
extern "C" {
    #[link_name =
          "?gripe_wrong_type_arg_for_binary_op@@YAXAEBVoctave_value@@@Z"]
    pub fn gripe_wrong_type_arg_for_binary_op(op: *const octave_value);
}
extern "C" {
    #[link_name =
          "?gripe_wrong_type_arg_for_unary_op@@YAXAEBVoctave_value@@@Z"]
    pub fn gripe_wrong_type_arg_for_unary_op(op: *const octave_value);
}
extern "C" {
    #[link_name = "?make_name_list@@YA?AVstring_vector@@XZ"]
    pub fn make_name_list() -> string_vector;
}
extern "C" {
    #[link_name =
          "?raw_help@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV12@AEA_N@Z"]
    pub fn raw_help(arg1: *const std_string, arg2: *mut bool) -> std_string;
}
extern "C" {
    #[link_name =
          "?Vdoc_cache_file@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A"]
    pub static mut Vdoc_cache_file: std_string;
}
extern "C" {
    #[link_name =
          "?Vtexi_macros_file@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A"]
    pub static mut Vtexi_macros_file: std_string;
}
extern "C" {
    #[link_name =
          "?Vinfo_file@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A"]
    pub static mut Vinfo_file: std_string;
}
extern "C" {
    #[link_name =
          "?Vinfo_program@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A"]
    pub static mut Vinfo_program: std_string;
}
extern "C" {
    #[link_name =
          "?do_which@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV12@@Z"]
    pub fn do_which(name: *const std_string) -> std_string;
}
#[repr(C)]
#[derive(Debug)]
pub struct octave_pager_buf {
    pub _base: std_stringbuf,
    pub diary_skip: usize,
}
#[test]
fn bindgen_test_layout_octave_pager_buf() {
    assert_eq!(::std::mem::size_of::<octave_pager_buf>() , 88usize , concat !
               ( "Size of: " , stringify ! ( octave_pager_buf ) ));
    assert_eq! (::std::mem::align_of::<octave_pager_buf>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( octave_pager_buf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_pager_buf ) ) . diary_skip as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_pager_buf ) ,
                "::" , stringify ! ( diary_skip ) ));
}
extern "C" {
    #[link_name =
          "?flush_current_contents_to_diary@octave_pager_buf@@QEAAXXZ"]
    pub fn octave_pager_buf_flush_current_contents_to_diary(this:
                                                                *mut octave_pager_buf);
}
extern "C" {
    #[link_name = "?set_diary_skip@octave_pager_buf@@QEAAXXZ"]
    pub fn octave_pager_buf_set_diary_skip(this: *mut octave_pager_buf);
}
impl octave_pager_buf {
    #[inline]
    pub unsafe fn flush_current_contents_to_diary(&mut self) {
        octave_pager_buf_flush_current_contents_to_diary(self)
    }
    #[inline]
    pub unsafe fn set_diary_skip(&mut self) {
        octave_pager_buf_set_diary_skip(self)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct octave_pager_stream {
    pub _base: std_ostream,
    pub pb: *mut octave_pager_buf,
}
extern "C" {
    #[link_name = "?instance@octave_pager_stream@@0PEAV1@EA"]
    pub static mut octave_pager_stream_instance: *mut octave_pager_stream;
}
#[test]
fn bindgen_test_layout_octave_pager_stream() {
    assert_eq!(::std::mem::size_of::<octave_pager_stream>() , 280usize ,
               concat ! ( "Size of: " , stringify ! ( octave_pager_stream )
               ));
    assert_eq! (::std::mem::align_of::<octave_pager_stream>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( octave_pager_stream ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_pager_stream ) ) . pb as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_pager_stream ) ,
                "::" , stringify ! ( pb ) ));
}
extern "C" {
    #[link_name =
          "?flush_current_contents_to_diary@octave_pager_stream@@SAXXZ"]
    pub fn octave_pager_stream_flush_current_contents_to_diary();
}
extern "C" {
    #[link_name = "?set_diary_skip@octave_pager_stream@@SAXXZ"]
    pub fn octave_pager_stream_set_diary_skip();
}
extern "C" {
    #[link_name =
          "?stream@octave_pager_stream@@SAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@XZ"]
    pub fn octave_pager_stream_stream() -> *mut std_ostream;
}
extern "C" {
    #[link_name = "?reset@octave_pager_stream@@SAXXZ"]
    pub fn octave_pager_stream_reset();
}
extern "C" {
    #[link_name = "??0octave_pager_stream@@IEAA@XZ"]
    pub fn octave_pager_stream_octave_pager_stream(this:
                                                       *mut octave_pager_stream);
}
impl octave_pager_stream {
    #[inline]
    pub unsafe fn flush_current_contents_to_diary() {
        octave_pager_stream_flush_current_contents_to_diary()
    }
    #[inline]
    pub unsafe fn set_diary_skip() { octave_pager_stream_set_diary_skip() }
    #[inline]
    pub unsafe fn stream() -> *mut std_ostream {
        octave_pager_stream_stream()
    }
    #[inline]
    pub unsafe fn reset() { octave_pager_stream_reset() }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_pager_stream_octave_pager_stream(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct octave_diary_buf {
    pub _base: std_stringbuf,
}
#[test]
fn bindgen_test_layout_octave_diary_buf() {
    assert_eq!(::std::mem::size_of::<octave_diary_buf>() , 80usize , concat !
               ( "Size of: " , stringify ! ( octave_diary_buf ) ));
    assert_eq! (::std::mem::align_of::<octave_diary_buf>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( octave_diary_buf ) ));
}
#[repr(C)]
#[derive(Debug)]
pub struct octave_diary_stream {
    pub _base: std_ostream,
    pub db: *mut octave_diary_buf,
}
extern "C" {
    #[link_name = "?instance@octave_diary_stream@@0PEAV1@EA"]
    pub static mut octave_diary_stream_instance: *mut octave_diary_stream;
}
#[test]
fn bindgen_test_layout_octave_diary_stream() {
    assert_eq!(::std::mem::size_of::<octave_diary_stream>() , 280usize ,
               concat ! ( "Size of: " , stringify ! ( octave_diary_stream )
               ));
    assert_eq! (::std::mem::align_of::<octave_diary_stream>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( octave_diary_stream ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octave_diary_stream ) ) . db as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( octave_diary_stream ) ,
                "::" , stringify ! ( db ) ));
}
extern "C" {
    #[link_name =
          "?stream@octave_diary_stream@@SAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@XZ"]
    pub fn octave_diary_stream_stream() -> *mut std_ostream;
}
extern "C" {
    #[link_name = "?reset@octave_diary_stream@@SAXXZ"]
    pub fn octave_diary_stream_reset();
}
extern "C" {
    #[link_name = "??0octave_diary_stream@@IEAA@XZ"]
    pub fn octave_diary_stream_octave_diary_stream(this:
                                                       *mut octave_diary_stream);
}
impl octave_diary_stream {
    #[inline]
    pub unsafe fn stream() -> *mut std_ostream {
        octave_diary_stream_stream()
    }
    #[inline]
    pub unsafe fn reset() { octave_diary_stream_reset() }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        octave_diary_stream_octave_diary_stream(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "?flush_octave_stdout@@YAXXZ"]
    pub fn flush_octave_stdout();
}
extern "C" {
    #[link_name = "?valid_identifier@@YA_NPEBD@Z"]
    pub fn valid_identifier(s: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    #[link_name =
          "?valid_identifier@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn valid_identifier1(s: *const std_string) -> bool;
}
extern "C" {
    #[link_name =
          "?same_file@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z"]
    pub fn same_file(f: *const std_string, g: *const std_string) -> bool;
}
extern "C" {
    #[link_name =
          "?almost_match@@YAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0HH@Z"]
    pub fn almost_match(std: *const std_string, s: *const std_string,
                        min_match_len: ::std::os::raw::c_int,
                        case_sens: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name =
          "?keyword_almost_match@@YAHPEBQEBDPEAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HH@Z"]
    pub fn keyword_almost_match(std: *const *const ::std::os::raw::c_char,
                                min_len: *mut ::std::os::raw::c_int,
                                s: *const std_string,
                                min_toks_to_match: ::std::os::raw::c_int,
                                max_toks: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "?empty_arg@@YAHPEBDHH@Z"]
    pub fn empty_arg(name: *const ::std::os::raw::c_char, nr: octave_idx_type,
                     nc: octave_idx_type) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name =
          "?search_path_for_file@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV12@AEBVstring_vector@@@Z"]
    pub fn search_path_for_file(arg1: *const std_string,
                                arg2: *const string_vector) -> std_string;
}
extern "C" {
    #[link_name =
          "?search_path_for_all_files@@YA?AVstring_vector@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV1@@Z"]
    pub fn search_path_for_all_files(arg1: *const std_string,
                                     arg2: *const string_vector)
     -> string_vector;
}
extern "C" {
    #[link_name =
          "?file_in_path@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV12@0@Z"]
    pub fn file_in_path(arg1: *const std_string, arg2: *const std_string)
     -> std_string;
}
extern "C" {
    #[link_name =
          "?find_data_file_in_load_path@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV12@0_N@Z"]
    pub fn find_data_file_in_load_path(fcn: *const std_string,
                                       file: *const std_string,
                                       require_regular_file: bool)
     -> std_string;
}
extern "C" {
    #[link_name =
          "?contents_file_in_path@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV12@@Z"]
    pub fn contents_file_in_path(arg1: *const std_string) -> std_string;
}
extern "C" {
    #[link_name =
          "?fcn_file_in_path@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV12@@Z"]
    pub fn fcn_file_in_path(arg1: *const std_string) -> std_string;
}
extern "C" {
    #[link_name =
          "?oct_file_in_path@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV12@@Z"]
    pub fn oct_file_in_path(arg1: *const std_string) -> std_string;
}
extern "C" {
    #[link_name =
          "?mex_file_in_path@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV12@@Z"]
    pub fn mex_file_in_path(arg1: *const std_string) -> std_string;
}
extern "C" {
    #[link_name =
          "?do_string_escapes@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV12@@Z"]
    pub fn do_string_escapes(s: *const std_string) -> std_string;
}
extern "C" {
    #[link_name = "?undo_string_escape@@YAPEBDD@Z"]
    pub fn undo_string_escape(c: ::std::os::raw::c_char)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name =
          "?undo_string_escapes@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV12@@Z"]
    pub fn undo_string_escapes(s: *const std_string) -> std_string;
}
extern "C" {
    #[link_name = "?check_dimensions@@YAXAEAVdim_vector@@PEBD@Z"]
    pub fn check_dimensions(dim: *mut dim_vector,
                            warnfor: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name =
          "?get_dimensions@@YAXAEBVoctave_value@@PEBDAEAVdim_vector@@@Z"]
    pub fn get_dimensions(a: *const octave_value,
                          warn_for: *const ::std::os::raw::c_char,
                          dim: *mut dim_vector);
}
extern "C" {
    #[link_name = "?get_dimensions@@YAXAEBVoctave_value@@0PEBDAEAH2@Z"]
    pub fn get_dimensions1(a: *const octave_value, b: *const octave_value,
                           warn_for: *const ::std::os::raw::c_char,
                           nr: *mut octave_idx_type,
                           nc: *mut octave_idx_type);
}
extern "C" {
    #[link_name = "?get_dimensions@@YAXAEBVoctave_value@@PEBDAEAH2@Z"]
    pub fn get_dimensions2(a: *const octave_value,
                           warn_for: *const ::std::os::raw::c_char,
                           nr: *mut octave_idx_type,
                           nc: *mut octave_idx_type);
}
extern "C" {
    #[link_name =
          "?dims_to_numel@@YAHAEBVdim_vector@@AEBVoctave_value_list@@@Z"]
    pub fn dims_to_numel(dims: *const dim_vector,
                         idx: *const octave_value_list) -> octave_idx_type;
}
extern "C" {
    #[link_name = "?identity_matrix@@YA?AVMatrix@@HH@Z"]
    pub fn identity_matrix(nr: octave_idx_type, nc: octave_idx_type)
     -> Matrix;
}
extern "C" {
    #[link_name = "?float_identity_matrix@@YA?AVFloatMatrix@@HH@Z"]
    pub fn float_identity_matrix(nr: octave_idx_type, nc: octave_idx_type)
     -> FloatMatrix;
}
extern "C" {
    #[link_name =
          "?octave_format@@YA_KAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@PEBDZZ"]
    pub fn octave_format(os: *mut std_ostream,
                         fmt: *const ::std::os::raw::c_char, ...) -> usize;
}
extern "C" {
    #[link_name =
          "?octave_vformat@@YA_KAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@PEBDPEAD@Z"]
    pub fn octave_vformat(os: *mut std_ostream,
                          fmt: *const ::std::os::raw::c_char, args: va_list)
     -> usize;
}
extern "C" {
    #[link_name =
          "?octave_vasprintf@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDPEAD@Z"]
    pub fn octave_vasprintf(fmt: *const ::std::os::raw::c_char, args: va_list)
     -> std_string;
}
extern "C" {
    #[link_name =
          "?octave_asprintf@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDZZ"]
    pub fn octave_asprintf(fmt: *const ::std::os::raw::c_char, ...)
     -> std_string;
}
extern "C" {
    #[link_name = "?octave_sleep@@YAXN@Z"]
    pub fn octave_sleep(seconds: f64);
}
extern "C" {
    #[link_name =
          "?do_simple_cellfun@@YA?AVoctave_value_list@@P6A?AV1@AEBV1@H@ZPEBD0H@Z"]
    pub fn do_simple_cellfun(fun:
                                 ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                *const octave_value_list,
                                                                            arg2:
                                                                                ::std::os::raw::c_int)
                                                           ->
                                                               octave_value_list>,
                             fun_name: *const ::std::os::raw::c_char,
                             args: *const octave_value_list,
                             nargout: ::std::os::raw::c_int)
     -> octave_value_list;
}
extern "C" {
    #[link_name =
          "?do_simple_cellfun@@YA?AVoctave_value@@P6A?AVoctave_value_list@@AEBV2@H@ZPEBD0@Z"]
    pub fn do_simple_cellfun1(fun:
                                  ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                 *const octave_value_list,
                                                                             arg2:
                                                                                 ::std::os::raw::c_int)
                                                            ->
                                                                octave_value_list>,
                              fun_name: *const ::std::os::raw::c_char,
                              args: *const octave_value_list) -> octave_value;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tree_identifier([u8; 0]);
extern "C" {
    #[link_name = "?clear_mex_functions@@YAXXZ"]
    pub fn clear_mex_functions();
}
extern "C" {
    #[link_name =
          "?is_valid_function@@YAPEAVoctave_function@@AEBVoctave_value@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z"]
    pub fn is_valid_function(arg1: *const octave_value,
                             arg2: *const std_string, warn: bool)
     -> *mut octave_function;
}
extern "C" {
    #[link_name =
          "?is_valid_function@@YAPEAVoctave_function@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0_N@Z"]
    pub fn is_valid_function1(arg1: *const std_string,
                              arg2: *const std_string, warn: bool)
     -> *mut octave_function;
}
extern "C" {
    #[link_name =
          "?extract_function@@YAPEAVoctave_function@@AEBVoctave_value@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@111@Z"]
    pub fn extract_function(arg: *const octave_value,
                            warn_for: *const std_string,
                            fname: *const std_string,
                            header: *const std_string,
                            trailer: *const std_string)
     -> *mut octave_function;
}
extern "C" {
    #[link_name =
          "?get_struct_elts@@YA?AVstring_vector@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn get_struct_elts(text: *const std_string) -> string_vector;
}
extern "C" {
    #[link_name =
          "?generate_struct_completions@@YA?AVstring_vector@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV23@1@Z"]
    pub fn generate_struct_completions(text: *const std_string,
                                       prefix: *mut std_string,
                                       hint: *mut std_string)
     -> string_vector;
}
extern "C" {
    #[link_name =
          "?looks_like_struct@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@D@Z"]
    pub fn looks_like_struct(text: *const std_string,
                             prev_char: ::std::os::raw::c_char) -> bool;
}
extern "C" {
    #[link_name =
          "?symbol_exist@@YAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z"]
    pub fn symbol_exist(name: *const std_string, type_: *const std_string)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name =
          "?unique_symbol_name@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV12@@Z"]
    pub fn unique_symbol_name(basename: *const std_string) -> std_string;
}
extern "C" {
    #[link_name =
          "?lookup_function_handle@@YA?AVoctave_value@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn lookup_function_handle(nm: *const std_string) -> octave_value;
}
extern "C" {
    #[link_name =
          "?get_global_value@@YA?AVoctave_value@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z"]
    pub fn get_global_value(nm: *const std_string, silent: bool)
     -> octave_value;
}
extern "C" {
    #[link_name =
          "?set_global_value@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBVoctave_value@@@Z"]
    pub fn set_global_value(nm: *const std_string, val: *const octave_value);
}
extern "C" {
    #[link_name =
          "?get_top_level_value@@YA?AVoctave_value@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z"]
    pub fn get_top_level_value(nm: *const std_string, silent: bool)
     -> octave_value;
}
extern "C" {
    #[link_name =
          "?set_top_level_value@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBVoctave_value@@@Z"]
    pub fn set_top_level_value(nm: *const std_string,
                               val: *const octave_value);
}
extern "C" {
    #[link_name =
          "?set_internal_variable@@YA?AVoctave_value@@AEA_NAEBVoctave_value_list@@HPEBD@Z"]
    pub fn set_internal_variable(var: *mut bool,
                                 args: *const octave_value_list,
                                 nargout: ::std::os::raw::c_int,
                                 nm: *const ::std::os::raw::c_char)
     -> octave_value;
}
extern "C" {
    #[link_name =
          "?set_internal_variable@@YA?AVoctave_value@@AEADAEBVoctave_value_list@@HPEBD@Z"]
    pub fn set_internal_variable1(var: *mut ::std::os::raw::c_char,
                                  args: *const octave_value_list,
                                  nargout: ::std::os::raw::c_int,
                                  nm: *const ::std::os::raw::c_char)
     -> octave_value;
}
extern "C" {
    #[link_name =
          "?set_internal_variable@@YA?AVoctave_value@@AEAHAEBVoctave_value_list@@HPEBDHH@Z"]
    pub fn set_internal_variable2(var: *mut ::std::os::raw::c_int,
                                  args: *const octave_value_list,
                                  nargout: ::std::os::raw::c_int,
                                  nm: *const ::std::os::raw::c_char,
                                  minval: ::std::os::raw::c_int,
                                  maxval: ::std::os::raw::c_int)
     -> octave_value;
}
extern "C" {
    #[link_name =
          "?set_internal_variable@@YA?AVoctave_value@@AEANAEBVoctave_value_list@@HPEBDNN@Z"]
    pub fn set_internal_variable3(var: *mut f64,
                                  args: *const octave_value_list,
                                  nargout: ::std::os::raw::c_int,
                                  nm: *const ::std::os::raw::c_char,
                                  minval: f64, maxval: f64) -> octave_value;
}
extern "C" {
    #[link_name =
          "?set_internal_variable@@YA?AVoctave_value@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBVoctave_value_list@@HPEBD_N@Z"]
    pub fn set_internal_variable4(var: *mut std_string,
                                  args: *const octave_value_list,
                                  nargout: ::std::os::raw::c_int,
                                  nm: *const ::std::os::raw::c_char,
                                  empty_ok: bool) -> octave_value;
}
extern "C" {
    #[link_name =
          "?set_internal_variable@@YA?AVoctave_value@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBVoctave_value_list@@HPEBDPEAPEBD@Z"]
    pub fn set_internal_variable5(var: *mut std_string,
                                  args: *const octave_value_list,
                                  nargout: ::std::os::raw::c_int,
                                  nm: *const ::std::os::raw::c_char,
                                  choices: *mut *const ::std::os::raw::c_char)
     -> octave_value;
}
extern "C" {
    #[link_name =
          "?set_internal_variable@@YA?AVoctave_value@@AEAHAEBVoctave_value_list@@HPEBDPEAPEBD@Z"]
    pub fn set_internal_variable6(var: *mut ::std::os::raw::c_int,
                                  args: *const octave_value_list,
                                  nargout: ::std::os::raw::c_int,
                                  nm: *const ::std::os::raw::c_char,
                                  choices: *mut *const ::std::os::raw::c_char)
     -> octave_value;
}
extern "C" {
    #[link_name =
          "?builtin_string_variable@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV12@@Z"]
    pub fn builtin_string_variable(arg1: *const std_string) -> std_string;
}
extern "C" {
    #[link_name =
          "?builtin_real_scalar_variable@@YAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAN@Z"]
    pub fn builtin_real_scalar_variable(arg1: *const std_string,
                                        arg2: *mut f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name =
          "?builtin_any_variable@@YA?AVoctave_value@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn builtin_any_variable(arg1: *const std_string) -> octave_value;
}
extern "C" {
    #[link_name = "?bind_ans@@YAXAEBVoctave_value@@_N@Z"]
    pub fn bind_ans(val: *const octave_value, print: bool);
}
extern "C" {
    #[link_name =
          "?bind_internal_variable@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBVoctave_value@@@Z"]
    pub fn bind_internal_variable(fname: *const std_string,
                                  val: *const octave_value);
}
extern "C" {
    #[link_name = "?mlock@@YAXXZ"]
    pub fn mlock();
}
extern "C" {
    #[link_name =
          "?munlock@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn munlock(arg1: *const std_string);
}
extern "C" {
    #[link_name =
          "?mislocked@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn mislocked(arg1: *const std_string) -> bool;
}
extern "C" {
    #[link_name =
          "?clear_function@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn clear_function(nm: *const std_string);
}
extern "C" {
    #[link_name =
          "?clear_variable@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn clear_variable(nm: *const std_string);
}
extern "C" {
    #[link_name =
          "?clear_symbol@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn clear_symbol(nm: *const std_string);
}
extern "C" {
    #[link_name =
          "?maybe_missing_function_hook@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn maybe_missing_function_hook(name: *const std_string);
}
pub type __builtin_va_list = *mut ::std::os::raw::c_char;
#[test]
fn __bindgen_test_layout_std_allocator_instantiation_70491() {
    assert_eq!(::std::mem::size_of::<std_allocator>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std_allocator ) ));
    assert_eq!(::std::mem::align_of::<std_allocator>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_allocator ) ));
}
#[test]
fn __bindgen_test_layout_std_basic_string_instantiation_70487() {
    assert_eq!(::std::mem::size_of::<std_basic_string<u16, std_allocator>>() ,
               8usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std_basic_string<u16, std_allocator> ) ));
    assert_eq!(::std::mem::align_of::<std_basic_string<u16, std_allocator>>()
               , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_basic_string<u16, std_allocator> ) ));
}
#[test]
fn __bindgen_test_layout_std_allocator_instantiation_70500() {
    assert_eq!(::std::mem::size_of::<std_allocator>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std_allocator ) ));
    assert_eq!(::std::mem::align_of::<std_allocator>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_allocator ) ));
}
#[test]
fn __bindgen_test_layout_std_basic_string_instantiation_70496() {
    assert_eq!(::std::mem::size_of::<std_basic_string<u32, std_allocator>>() ,
               8usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std_basic_string<u32, std_allocator> ) ));
    assert_eq!(::std::mem::align_of::<std_basic_string<u32, std_allocator>>()
               , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_basic_string<u32, std_allocator> ) ));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_1 {
    pub _address: u8,
}
impl Clone for _bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn __bindgen_test_layout_std_integral_constant_instantiation_70574() {
    assert_eq!(::std::mem::size_of::<u8>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! ( u8 ) ));
    assert_eq!(::std::mem::align_of::<u8>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! ( u8 )
               ));
}
#[test]
fn __bindgen_test_layout_std_integral_constant_instantiation_70578() {
    assert_eq!(::std::mem::size_of::<u8>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! ( u8 ) ));
    assert_eq!(::std::mem::align_of::<u8>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! ( u8 )
               ));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_2 {
    pub _address: u8,
}
impl Clone for _bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_3 {
    pub _address: u8,
}
impl Clone for _bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_4 {
    pub _address: u8,
}
impl Clone for _bindgen_ty_4 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_5 {
    pub _address: u8,
}
impl Clone for _bindgen_ty_5 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_6 {
    pub _address: u8,
}
impl Clone for _bindgen_ty_6 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_7 {
    pub _address: u8,
}
impl Clone for _bindgen_ty_7 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_8 {
    pub _address: u8,
}
impl Clone for _bindgen_ty_8 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_9 {
    pub _address: u8,
}
impl Clone for _bindgen_ty_9 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_10 {
    pub _address: u8,
}
impl Clone for _bindgen_ty_10 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_11 {
    pub _address: u8,
}
impl Clone for _bindgen_ty_11 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_12 {
    pub _address: u8,
}
impl Clone for _bindgen_ty_12 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_13 {
    pub _address: u8,
}
impl Clone for _bindgen_ty_13 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_14 {
    pub _address: u8,
}
impl Clone for _bindgen_ty_14 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_15 {
    pub _address: u8,
}
impl Clone for _bindgen_ty_15 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_16 {
    pub _address: u8,
}
impl Clone for _bindgen_ty_16 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_17 {
    pub _address: u8,
}
impl Clone for _bindgen_ty_17 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn __bindgen_test_layout_std_integral_constant_instantiation_70604() {
    assert_eq!(::std::mem::size_of::<u8>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! ( u8 ) ));
    assert_eq!(::std::mem::align_of::<u8>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! ( u8 )
               ));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_18 {
    pub _address: u8,
}
impl Clone for _bindgen_ty_18 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_19 {
    pub _address: u8,
}
impl Clone for _bindgen_ty_19 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_20 {
    pub _address: u8,
}
impl Clone for _bindgen_ty_20 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_21 {
    pub _address: u8,
}
impl Clone for _bindgen_ty_21 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_22 {
    pub _address: u8,
}
impl Clone for _bindgen_ty_22 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_23 {
    pub _address: u8,
}
impl Clone for _bindgen_ty_23 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_24 {
    pub _address: u8,
}
impl Clone for _bindgen_ty_24 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_25 {
    pub _address: u8,
}
impl Clone for _bindgen_ty_25 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_26 {
    pub _address: u8,
}
impl Clone for _bindgen_ty_26 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_27 {
    pub _address: u8,
}
impl Clone for _bindgen_ty_27 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_28 {
    pub _address: u8,
}
impl Clone for _bindgen_ty_28 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_29 {
    pub _address: u8,
}
impl Clone for _bindgen_ty_29 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_30 {
    pub _address: u8,
}
impl Clone for _bindgen_ty_30 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_31 {
    pub _address: u8,
}
impl Clone for _bindgen_ty_31 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_32 {
    pub _address: u8,
}
impl Clone for _bindgen_ty_32 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_33 {
    pub _address: u8,
}
impl Clone for _bindgen_ty_33 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_34 {
    pub _address: u8,
}
impl Clone for _bindgen_ty_34 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_35 {
    pub _address: u8,
}
impl Clone for _bindgen_ty_35 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_36 {
    pub _address: u8,
}
impl Clone for _bindgen_ty_36 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_37 {
    pub _address: u8,
}
impl Clone for _bindgen_ty_37 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_38 {
    pub _address: u8,
}
impl Clone for _bindgen_ty_38 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_39 {
    pub _address: u8,
}
impl Clone for _bindgen_ty_39 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn __bindgen_test_layout_std_iterator_instantiation_70737() {
    assert_eq!(::std::mem::size_of::<std_iterator>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std_iterator ) ));
    assert_eq!(::std::mem::align_of::<std_iterator>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_iterator ) ));
}
pub type size_type = usize;
pub type size_type = usize;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_40 {
    pub _address: u8,
}
impl Clone for _bindgen_ty_40 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn __bindgen_test_layout_std_iterator_instantiation_74798() {
    assert_eq!(::std::mem::size_of::<std_iterator>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std_iterator ) ));
    assert_eq!(::std::mem::align_of::<std_iterator>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_iterator ) ));
}
pub type size_type = usize;
pub type iterator = std__Bit_iterator;
#[test]
fn __bindgen_test_layout_std_mersenne_twister_engine_instantiation_74895() {
    assert_eq!(::std::mem::size_of::<[u64; 313usize]>() , 2504usize , concat !
               (
               "Size of template specialization: " , stringify ! (
               [u64; 313usize] ) ));
    assert_eq!(::std::mem::align_of::<[u64; 313usize]>() , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               [u64; 313usize] ) ));
}
#[test]
fn __bindgen_test_layout_std_allocator_instantiation_75072() {
    assert_eq!(::std::mem::size_of::<std_allocator>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std_allocator ) ));
    assert_eq!(::std::mem::align_of::<std_allocator>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_allocator ) ));
}
#[test]
fn __bindgen_test_layout_std_vector_instantiation_75069() {
    assert_eq!(::std::mem::size_of::<std_vector>() , 24usize , concat ! (
               "Size of template specialization: " , stringify ! ( std_vector
               ) ));
    assert_eq!(::std::mem::align_of::<std_vector>() , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_vector ) ));
}
#[test]
fn __bindgen_test_layout_std_allocator_instantiation_75103() {
    assert_eq!(::std::mem::size_of::<std_allocator>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std_allocator ) ));
    assert_eq!(::std::mem::align_of::<std_allocator>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_allocator ) ));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_41 {
    pub _address: u8,
}
impl Clone for _bindgen_ty_41 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_42 {
    pub _address: u8,
}
impl Clone for _bindgen_ty_42 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_43 {
    pub _address: u8,
}
impl Clone for _bindgen_ty_43 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_44 {
    pub _address: u8,
}
impl Clone for _bindgen_ty_44 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_45 {
    pub _address: u8,
}
impl Clone for _bindgen_ty_45 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_46 {
    pub _address: u8,
}
impl Clone for _bindgen_ty_46 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn __bindgen_test_layout_std_integral_constant_instantiation_75722() {
    assert_eq!(::std::mem::size_of::<u8>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! ( u8 ) ));
    assert_eq!(::std::mem::align_of::<u8>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! ( u8 )
               ));
}
#[test]
fn __bindgen_test_layout_octave_int_instantiation_75886() {
    assert_eq!(::std::mem::size_of::<octave_int<::std::os::raw::c_schar>>() ,
               1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               octave_int<::std::os::raw::c_schar> ) ));
    assert_eq!(::std::mem::align_of::<octave_int<::std::os::raw::c_schar>>() ,
               1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               octave_int<::std::os::raw::c_schar> ) ));
}
#[test]
fn __bindgen_test_layout_octave_int_instantiation_75890() {
    assert_eq!(::std::mem::size_of::<octave_int<::std::os::raw::c_short>>() ,
               2usize , concat ! (
               "Size of template specialization: " , stringify ! (
               octave_int<::std::os::raw::c_short> ) ));
    assert_eq!(::std::mem::align_of::<octave_int<::std::os::raw::c_short>>() ,
               2usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               octave_int<::std::os::raw::c_short> ) ));
}
#[test]
fn __bindgen_test_layout_octave_int_instantiation_75894() {
    assert_eq!(::std::mem::size_of::<octave_int<::std::os::raw::c_int>>() ,
               4usize , concat ! (
               "Size of template specialization: " , stringify ! (
               octave_int<::std::os::raw::c_int> ) ));
    assert_eq!(::std::mem::align_of::<octave_int<::std::os::raw::c_int>>() ,
               4usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               octave_int<::std::os::raw::c_int> ) ));
}
#[test]
fn __bindgen_test_layout_octave_int_instantiation_75898() {
    assert_eq!(::std::mem::size_of::<octave_int<::std::os::raw::c_longlong>>()
               , 8usize , concat ! (
               "Size of template specialization: " , stringify ! (
               octave_int<::std::os::raw::c_longlong> ) ));
    assert_eq!(::std::mem::align_of::<octave_int<::std::os::raw::c_longlong>>()
               , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               octave_int<::std::os::raw::c_longlong> ) ));
}
#[test]
fn __bindgen_test_layout_octave_int_instantiation_75902() {
    assert_eq!(::std::mem::size_of::<octave_int<::std::os::raw::c_uchar>>() ,
               1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               octave_int<::std::os::raw::c_uchar> ) ));
    assert_eq!(::std::mem::align_of::<octave_int<::std::os::raw::c_uchar>>() ,
               1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               octave_int<::std::os::raw::c_uchar> ) ));
}
#[test]
fn __bindgen_test_layout_octave_int_instantiation_75906() {
    assert_eq!(::std::mem::size_of::<octave_int<::std::os::raw::c_ushort>>() ,
               2usize , concat ! (
               "Size of template specialization: " , stringify ! (
               octave_int<::std::os::raw::c_ushort> ) ));
    assert_eq!(::std::mem::align_of::<octave_int<::std::os::raw::c_ushort>>()
               , 2usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               octave_int<::std::os::raw::c_ushort> ) ));
}
#[test]
fn __bindgen_test_layout_octave_int_instantiation_75910() {
    assert_eq!(::std::mem::size_of::<octave_int<::std::os::raw::c_uint>>() ,
               4usize , concat ! (
               "Size of template specialization: " , stringify ! (
               octave_int<::std::os::raw::c_uint> ) ));
    assert_eq!(::std::mem::align_of::<octave_int<::std::os::raw::c_uint>>() ,
               4usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               octave_int<::std::os::raw::c_uint> ) ));
}
#[test]
fn __bindgen_test_layout_octave_int_instantiation_75914() {
    assert_eq!(::std::mem::size_of::<octave_int<::std::os::raw::c_ulonglong>>()
               , 8usize , concat ! (
               "Size of template specialization: " , stringify ! (
               octave_int<::std::os::raw::c_ulonglong> ) ));
    assert_eq!(::std::mem::align_of::<octave_int<::std::os::raw::c_ulonglong>>()
               , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               octave_int<::std::os::raw::c_ulonglong> ) ));
}
#[test]
fn __bindgen_test_layout_Array_instantiation_75969() {
    assert_eq!(::std::mem::size_of::<Array<::std::os::raw::c_int>>() , 40usize
               , concat ! (
               "Size of template specialization: " , stringify ! (
               Array<::std::os::raw::c_int> ) ));
    assert_eq!(::std::mem::align_of::<Array<::std::os::raw::c_int>>() , 8usize
               , concat ! (
               "Alignment of template specialization: " , stringify ! (
               Array<::std::os::raw::c_int> ) ));
}
#[test]
fn __bindgen_test_layout_Array_instantiation_75984() {
    assert_eq!(::std::mem::size_of::<Array<f64>>() , 40usize , concat ! (
               "Size of template specialization: " , stringify ! ( Array<f64>
               ) ));
    assert_eq!(::std::mem::align_of::<Array<f64>>() , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               Array<f64> ) ));
}
#[test]
fn __bindgen_test_layout_Array_instantiation_76052() {
    assert_eq!(::std::mem::size_of::<Array<bool>>() , 40usize , concat ! (
               "Size of template specialization: " , stringify ! ( Array<bool>
               ) ));
    assert_eq!(::std::mem::align_of::<Array<bool>>() , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               Array<bool> ) ));
}
#[test]
fn __bindgen_test_layout_Sparse_instantiation_76057() {
    assert_eq!(::std::mem::size_of::<Sparse<bool>>() , 24usize , concat ! (
               "Size of template specialization: " , stringify ! (
               Sparse<bool> ) ));
    assert_eq!(::std::mem::align_of::<Sparse<bool>>() , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               Sparse<bool> ) ));
}
#[test]
fn __bindgen_test_layout_Array_instantiation_76124() {
    assert_eq!(::std::mem::size_of::<Array<f32>>() , 40usize , concat ! (
               "Size of template specialization: " , stringify ! ( Array<f32>
               ) ));
    assert_eq!(::std::mem::align_of::<Array<f32>>() , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               Array<f32> ) ));
}
pub type char_type = ::std::os::raw::c_char;
pub type int_type = ::std::os::raw::c_int;
pub type char_type = u16;
pub type int_type = wint_t;
#[test]
fn __bindgen_test_layout_MDiagArray2_instantiation_77395() {
    assert_eq!(::std::mem::size_of::<MDiagArray2<f64>>() , 48usize , concat !
               (
               "Size of template specialization: " , stringify ! (
               MDiagArray2<f64> ) ));
    assert_eq!(::std::mem::align_of::<MDiagArray2<f64>>() , 8usize , concat !
               (
               "Alignment of template specialization: " , stringify ! (
               MDiagArray2<f64> ) ));
}
#[test]
fn __bindgen_test_layout_DiagArray2_instantiation_77400() {
    assert_eq!(::std::mem::size_of::<DiagArray2<f64>>() , 48usize , concat ! (
               "Size of template specialization: " , stringify ! (
               DiagArray2<f64> ) ));
    assert_eq!(::std::mem::align_of::<DiagArray2<f64>>() , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               DiagArray2<f64> ) ));
}
#[test]
fn __bindgen_test_layout_MDiagArray2_instantiation_77964() {
    assert_eq!(::std::mem::size_of::<MDiagArray2<std_complex<f64>>>() ,
               48usize , concat ! (
               "Size of template specialization: " , stringify ! (
               MDiagArray2<std_complex<f64>> ) ));
    assert_eq!(::std::mem::align_of::<MDiagArray2<std_complex<f64>>>() ,
               8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               MDiagArray2<std_complex<f64>> ) ));
}
#[test]
fn __bindgen_test_layout_DiagArray2_instantiation_77968() {
    assert_eq!(::std::mem::size_of::<DiagArray2<std_complex<f64>>>() , 48usize
               , concat ! (
               "Size of template specialization: " , stringify ! (
               DiagArray2<std_complex<f64>> ) ));
    assert_eq!(::std::mem::align_of::<DiagArray2<std_complex<f64>>>() , 8usize
               , concat ! (
               "Alignment of template specialization: " , stringify ! (
               DiagArray2<std_complex<f64>> ) ));
}
#[test]
fn __bindgen_test_layout_MDiagArray2_instantiation_78559() {
    assert_eq!(::std::mem::size_of::<MDiagArray2<f32>>() , 48usize , concat !
               (
               "Size of template specialization: " , stringify ! (
               MDiagArray2<f32> ) ));
    assert_eq!(::std::mem::align_of::<MDiagArray2<f32>>() , 8usize , concat !
               (
               "Alignment of template specialization: " , stringify ! (
               MDiagArray2<f32> ) ));
}
#[test]
fn __bindgen_test_layout_DiagArray2_instantiation_78564() {
    assert_eq!(::std::mem::size_of::<DiagArray2<f32>>() , 48usize , concat ! (
               "Size of template specialization: " , stringify ! (
               DiagArray2<f32> ) ));
    assert_eq!(::std::mem::align_of::<DiagArray2<f32>>() , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               DiagArray2<f32> ) ));
}
#[test]
fn __bindgen_test_layout_MDiagArray2_instantiation_79122() {
    assert_eq!(::std::mem::size_of::<MDiagArray2<std_complex<f32>>>() ,
               48usize , concat ! (
               "Size of template specialization: " , stringify ! (
               MDiagArray2<std_complex<f32>> ) ));
    assert_eq!(::std::mem::align_of::<MDiagArray2<std_complex<f32>>>() ,
               8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               MDiagArray2<std_complex<f32>> ) ));
}
#[test]
fn __bindgen_test_layout_DiagArray2_instantiation_79126() {
    assert_eq!(::std::mem::size_of::<DiagArray2<std_complex<f32>>>() , 48usize
               , concat ! (
               "Size of template specialization: " , stringify ! (
               DiagArray2<std_complex<f32>> ) ));
    assert_eq!(::std::mem::align_of::<DiagArray2<std_complex<f32>>>() , 8usize
               , concat ! (
               "Alignment of template specialization: " , stringify ! (
               DiagArray2<std_complex<f32>> ) ));
}
#[test]
fn __bindgen_test_layout_MSparse_instantiation_79693() {
    assert_eq!(::std::mem::size_of::<MSparse<f64>>() , 24usize , concat ! (
               "Size of template specialization: " , stringify ! (
               MSparse<f64> ) ));
    assert_eq!(::std::mem::align_of::<MSparse<f64>>() , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               MSparse<f64> ) ));
}
#[test]
fn __bindgen_test_layout_Sparse_instantiation_79714() {
    assert_eq!(::std::mem::size_of::<Sparse<f64>>() , 24usize , concat ! (
               "Size of template specialization: " , stringify ! ( Sparse<f64>
               ) ));
    assert_eq!(::std::mem::align_of::<Sparse<f64>>() , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               Sparse<f64> ) ));
}
#[test]
fn __bindgen_test_layout_MSparse_instantiation_80394() {
    assert_eq!(::std::mem::size_of::<MSparse<std_complex<f64>>>() , 24usize ,
               concat ! (
               "Size of template specialization: " , stringify ! (
               MSparse<std_complex<f64>> ) ));
    assert_eq!(::std::mem::align_of::<MSparse<std_complex<f64>>>() , 8usize ,
               concat ! (
               "Alignment of template specialization: " , stringify ! (
               MSparse<std_complex<f64>> ) ));
}
#[test]
fn __bindgen_test_layout_Sparse_instantiation_80414() {
    assert_eq!(::std::mem::size_of::<Sparse<std_complex<f64>>>() , 24usize ,
               concat ! (
               "Size of template specialization: " , stringify ! (
               Sparse<std_complex<f64>> ) ));
    assert_eq!(::std::mem::align_of::<Sparse<std_complex<f64>>>() , 8usize ,
               concat ! (
               "Alignment of template specialization: " , stringify ! (
               Sparse<std_complex<f64>> ) ));
}
#[test]
fn __bindgen_test_layout_Array_instantiation_80422() {
    assert_eq!(::std::mem::size_of::<Array<std_complex<f64>>>() , 40usize ,
               concat ! (
               "Size of template specialization: " , stringify ! (
               Array<std_complex<f64>> ) ));
    assert_eq!(::std::mem::align_of::<Array<std_complex<f64>>>() , 8usize ,
               concat ! (
               "Alignment of template specialization: " , stringify ! (
               Array<std_complex<f64>> ) ));
}
#[test]
fn __bindgen_test_layout_Array_instantiation_81156() {
    assert_eq!(::std::mem::size_of::<Array<::std::os::raw::c_char>>() ,
               40usize , concat ! (
               "Size of template specialization: " , stringify ! (
               Array<::std::os::raw::c_char> ) ));
    assert_eq!(::std::mem::align_of::<Array<::std::os::raw::c_char>>() ,
               8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               Array<::std::os::raw::c_char> ) ));
}
#[test]
fn __bindgen_test_layout_MArray_instantiation_81180() {
    assert_eq!(::std::mem::size_of::<MArray<f64>>() , 40usize , concat ! (
               "Size of template specialization: " , stringify ! ( MArray<f64>
               ) ));
    assert_eq!(::std::mem::align_of::<MArray<f64>>() , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               MArray<f64> ) ));
}
#[test]
fn __bindgen_test_layout_MArray_instantiation_81281() {
    assert_eq!(::std::mem::size_of::<MArray<std_complex<f64>>>() , 40usize ,
               concat ! (
               "Size of template specialization: " , stringify ! (
               MArray<std_complex<f64>> ) ));
    assert_eq!(::std::mem::align_of::<MArray<std_complex<f64>>>() , 8usize ,
               concat ! (
               "Alignment of template specialization: " , stringify ! (
               MArray<std_complex<f64>> ) ));
}
#[test]
fn __bindgen_test_layout_MArray_instantiation_81371() {
    assert_eq!(::std::mem::size_of::<MArray<f32>>() , 40usize , concat ! (
               "Size of template specialization: " , stringify ! ( MArray<f32>
               ) ));
    assert_eq!(::std::mem::align_of::<MArray<f32>>() , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               MArray<f32> ) ));
}
#[test]
fn __bindgen_test_layout_MArray_instantiation_81461() {
    assert_eq!(::std::mem::size_of::<MArray<std_complex<f32>>>() , 40usize ,
               concat ! (
               "Size of template specialization: " , stringify ! (
               MArray<std_complex<f32>> ) ));
    assert_eq!(::std::mem::align_of::<MArray<std_complex<f32>>>() , 8usize ,
               concat ! (
               "Alignment of template specialization: " , stringify ! (
               MArray<std_complex<f32>> ) ));
}
#[test]
fn __bindgen_test_layout_Array_instantiation_81756() {
    assert_eq!(::std::mem::size_of::<Array<std_complex<f32>>>() , 40usize ,
               concat ! (
               "Size of template specialization: " , stringify ! (
               Array<std_complex<f32>> ) ));
    assert_eq!(::std::mem::align_of::<Array<std_complex<f32>>>() , 8usize ,
               concat ! (
               "Alignment of template specialization: " , stringify ! (
               Array<std_complex<f32>> ) ));
}
#[test]
fn __bindgen_test_layout_Array_instantiation_82580() {
    assert_eq!(::std::mem::size_of::<Array<std_basic_string<::std::os::raw::c_char,
                                             std_allocator>>>()
               , 40usize , concat ! (
               "Size of template specialization: " , stringify ! (
               Array<std_basic_string<::std::os::raw::c_char, std_allocator>>
               ) ));
    assert_eq!(::std::mem::align_of::<Array<std_basic_string<::std::os::raw::c_char,
                                              std_allocator>>>()
               , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               Array<std_basic_string<::std::os::raw::c_char, std_allocator>>
               ) ));
}
#[test]
fn __bindgen_test_layout_std_allocator_instantiation_82622() {
    assert_eq!(::std::mem::size_of::<std_allocator>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std_allocator ) ));
    assert_eq!(::std::mem::align_of::<std_allocator>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_allocator ) ));
}
#[test]
fn __bindgen_test_layout_std_list_instantiation_82620() {
    assert_eq!(::std::mem::size_of::<std_list>() , 16usize , concat ! (
               "Size of template specialization: " , stringify ! ( std_list )
               ));
    assert_eq!(::std::mem::align_of::<std_list>() , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_list ) ));
}
#[test]
fn __bindgen_test_layout_intNDArray_instantiation_85102() {
    assert_eq!(::std::mem::size_of::<intNDArray<octave_int<::std::os::raw::c_schar>>>()
               , 40usize , concat ! (
               "Size of template specialization: " , stringify ! (
               intNDArray<octave_int<::std::os::raw::c_schar>> ) ));
    assert_eq!(::std::mem::align_of::<intNDArray<octave_int<::std::os::raw::c_schar>>>()
               , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               intNDArray<octave_int<::std::os::raw::c_schar>> ) ));
}
#[test]
fn __bindgen_test_layout_intNDArray_instantiation_85333() {
    assert_eq!(::std::mem::size_of::<intNDArray<octave_int<::std::os::raw::c_short>>>()
               , 40usize , concat ! (
               "Size of template specialization: " , stringify ! (
               intNDArray<octave_int<::std::os::raw::c_short>> ) ));
    assert_eq!(::std::mem::align_of::<intNDArray<octave_int<::std::os::raw::c_short>>>()
               , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               intNDArray<octave_int<::std::os::raw::c_short>> ) ));
}
#[test]
fn __bindgen_test_layout_intNDArray_instantiation_85564() {
    assert_eq!(::std::mem::size_of::<intNDArray<octave_int<::std::os::raw::c_int>>>()
               , 40usize , concat ! (
               "Size of template specialization: " , stringify ! (
               intNDArray<octave_int<::std::os::raw::c_int>> ) ));
    assert_eq!(::std::mem::align_of::<intNDArray<octave_int<::std::os::raw::c_int>>>()
               , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               intNDArray<octave_int<::std::os::raw::c_int>> ) ));
}
#[test]
fn __bindgen_test_layout_intNDArray_instantiation_85795() {
    assert_eq!(::std::mem::size_of::<intNDArray<octave_int<::std::os::raw::c_longlong>>>()
               , 40usize , concat ! (
               "Size of template specialization: " , stringify ! (
               intNDArray<octave_int<::std::os::raw::c_longlong>> ) ));
    assert_eq!(::std::mem::align_of::<intNDArray<octave_int<::std::os::raw::c_longlong>>>()
               , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               intNDArray<octave_int<::std::os::raw::c_longlong>> ) ));
}
#[test]
fn __bindgen_test_layout_intNDArray_instantiation_86026() {
    assert_eq!(::std::mem::size_of::<intNDArray<octave_int<::std::os::raw::c_uchar>>>()
               , 40usize , concat ! (
               "Size of template specialization: " , stringify ! (
               intNDArray<octave_int<::std::os::raw::c_uchar>> ) ));
    assert_eq!(::std::mem::align_of::<intNDArray<octave_int<::std::os::raw::c_uchar>>>()
               , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               intNDArray<octave_int<::std::os::raw::c_uchar>> ) ));
}
#[test]
fn __bindgen_test_layout_intNDArray_instantiation_86257() {
    assert_eq!(::std::mem::size_of::<intNDArray<octave_int<::std::os::raw::c_ushort>>>()
               , 40usize , concat ! (
               "Size of template specialization: " , stringify ! (
               intNDArray<octave_int<::std::os::raw::c_ushort>> ) ));
    assert_eq!(::std::mem::align_of::<intNDArray<octave_int<::std::os::raw::c_ushort>>>()
               , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               intNDArray<octave_int<::std::os::raw::c_ushort>> ) ));
}
#[test]
fn __bindgen_test_layout_intNDArray_instantiation_86488() {
    assert_eq!(::std::mem::size_of::<intNDArray<octave_int<::std::os::raw::c_uint>>>()
               , 40usize , concat ! (
               "Size of template specialization: " , stringify ! (
               intNDArray<octave_int<::std::os::raw::c_uint>> ) ));
    assert_eq!(::std::mem::align_of::<intNDArray<octave_int<::std::os::raw::c_uint>>>()
               , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               intNDArray<octave_int<::std::os::raw::c_uint>> ) ));
}
#[test]
fn __bindgen_test_layout_intNDArray_instantiation_86719() {
    assert_eq!(::std::mem::size_of::<intNDArray<octave_int<::std::os::raw::c_ulonglong>>>()
               , 40usize , concat ! (
               "Size of template specialization: " , stringify ! (
               intNDArray<octave_int<::std::os::raw::c_ulonglong>> ) ));
    assert_eq!(::std::mem::align_of::<intNDArray<octave_int<::std::os::raw::c_ulonglong>>>()
               , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               intNDArray<octave_int<::std::os::raw::c_ulonglong>> ) ));
}
#[test]
fn __bindgen_test_layout_Array_instantiation_100160() {
    assert_eq!(::std::mem::size_of::<Array<octave_value>>() , 40usize , concat
               ! (
               "Size of template specialization: " , stringify ! (
               Array<octave_value> ) ));
    assert_eq!(::std::mem::align_of::<Array<octave_value>>() , 8usize , concat
               ! (
               "Alignment of template specialization: " , stringify ! (
               Array<octave_value> ) ));
}
#[test]
fn __bindgen_test_layout_std_allocator_instantiation_100385() {
    assert_eq!(::std::mem::size_of::<std_allocator>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std_allocator ) ));
    assert_eq!(::std::mem::align_of::<std_allocator>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_allocator ) ));
}
#[test]
fn __bindgen_test_layout_std_allocator_instantiation_100454() {
    assert_eq!(::std::mem::size_of::<std_allocator>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std_allocator ) ));
    assert_eq!(::std::mem::align_of::<std_allocator>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_allocator ) ));
}
#[test]
fn __bindgen_test_layout_std_allocator_instantiation_100511() {
    assert_eq!(::std::mem::size_of::<std_allocator>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std_allocator ) ));
    assert_eq!(::std::mem::align_of::<std_allocator>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_allocator ) ));
}
#[test]
fn __bindgen_test_layout_std_list_instantiation_100509() {
    assert_eq!(::std::mem::size_of::<std_list>() , 16usize , concat ! (
               "Size of template specialization: " , stringify ! ( std_list )
               ));
    assert_eq!(::std::mem::align_of::<std_list>() , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_list ) ));
}
#[test]
fn __bindgen_test_layout_std_allocator_instantiation_100724() {
    assert_eq!(::std::mem::size_of::<std_allocator>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std_allocator ) ));
    assert_eq!(::std::mem::align_of::<std_allocator>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_allocator ) ));
}
#[test]
fn __bindgen_test_layout_std_deque_instantiation_100721() {
    assert_eq!(::std::mem::size_of::<std_deque<*mut action_container_elem>>()
               , 80usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std_deque<*mut action_container_elem> ) ));
    assert_eq!(::std::mem::align_of::<std_deque<*mut action_container_elem>>()
               , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_deque<*mut action_container_elem> ) ));
}
#[test]
fn __bindgen_test_layout_Array_instantiation_101030() {
    assert_eq!(::std::mem::size_of::<Array<octave_int<::std::os::raw::c_schar>>>()
               , 40usize , concat ! (
               "Size of template specialization: " , stringify ! (
               Array<octave_int<::std::os::raw::c_schar>> ) ));
    assert_eq!(::std::mem::align_of::<Array<octave_int<::std::os::raw::c_schar>>>()
               , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               Array<octave_int<::std::os::raw::c_schar>> ) ));
}
#[test]
fn __bindgen_test_layout_Array_instantiation_101036() {
    assert_eq!(::std::mem::size_of::<Array<octave_int<::std::os::raw::c_short>>>()
               , 40usize , concat ! (
               "Size of template specialization: " , stringify ! (
               Array<octave_int<::std::os::raw::c_short>> ) ));
    assert_eq!(::std::mem::align_of::<Array<octave_int<::std::os::raw::c_short>>>()
               , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               Array<octave_int<::std::os::raw::c_short>> ) ));
}
#[test]
fn __bindgen_test_layout_Array_instantiation_101042() {
    assert_eq!(::std::mem::size_of::<Array<octave_int<::std::os::raw::c_int>>>()
               , 40usize , concat ! (
               "Size of template specialization: " , stringify ! (
               Array<octave_int<::std::os::raw::c_int>> ) ));
    assert_eq!(::std::mem::align_of::<Array<octave_int<::std::os::raw::c_int>>>()
               , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               Array<octave_int<::std::os::raw::c_int>> ) ));
}
#[test]
fn __bindgen_test_layout_Array_instantiation_101048() {
    assert_eq!(::std::mem::size_of::<Array<octave_int<::std::os::raw::c_longlong>>>()
               , 40usize , concat ! (
               "Size of template specialization: " , stringify ! (
               Array<octave_int<::std::os::raw::c_longlong>> ) ));
    assert_eq!(::std::mem::align_of::<Array<octave_int<::std::os::raw::c_longlong>>>()
               , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               Array<octave_int<::std::os::raw::c_longlong>> ) ));
}
#[test]
fn __bindgen_test_layout_Array_instantiation_101054() {
    assert_eq!(::std::mem::size_of::<Array<octave_int<::std::os::raw::c_uchar>>>()
               , 40usize , concat ! (
               "Size of template specialization: " , stringify ! (
               Array<octave_int<::std::os::raw::c_uchar>> ) ));
    assert_eq!(::std::mem::align_of::<Array<octave_int<::std::os::raw::c_uchar>>>()
               , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               Array<octave_int<::std::os::raw::c_uchar>> ) ));
}
#[test]
fn __bindgen_test_layout_Array_instantiation_101060() {
    assert_eq!(::std::mem::size_of::<Array<octave_int<::std::os::raw::c_ushort>>>()
               , 40usize , concat ! (
               "Size of template specialization: " , stringify ! (
               Array<octave_int<::std::os::raw::c_ushort>> ) ));
    assert_eq!(::std::mem::align_of::<Array<octave_int<::std::os::raw::c_ushort>>>()
               , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               Array<octave_int<::std::os::raw::c_ushort>> ) ));
}
#[test]
fn __bindgen_test_layout_Array_instantiation_101066() {
    assert_eq!(::std::mem::size_of::<Array<octave_int<::std::os::raw::c_uint>>>()
               , 40usize , concat ! (
               "Size of template specialization: " , stringify ! (
               Array<octave_int<::std::os::raw::c_uint>> ) ));
    assert_eq!(::std::mem::align_of::<Array<octave_int<::std::os::raw::c_uint>>>()
               , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               Array<octave_int<::std::os::raw::c_uint>> ) ));
}
#[test]
fn __bindgen_test_layout_Array_instantiation_101072() {
    assert_eq!(::std::mem::size_of::<Array<octave_int<::std::os::raw::c_ulonglong>>>()
               , 40usize , concat ! (
               "Size of template specialization: " , stringify ! (
               Array<octave_int<::std::os::raw::c_ulonglong>> ) ));
    assert_eq!(::std::mem::align_of::<Array<octave_int<::std::os::raw::c_ulonglong>>>()
               , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               Array<octave_int<::std::os::raw::c_ulonglong>> ) ));
}
#[test]
fn __bindgen_test_layout_std_less_instantiation_102279() {
    assert_eq!(::std::mem::size_of::<std_less>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! ( std_less )
               ));
    assert_eq!(::std::mem::align_of::<std_less>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_less ) ));
}
#[test]
fn __bindgen_test_layout_std_pair_instantiation_102283() {
    assert_eq!(::std::mem::size_of::<std_pair<std_basic_string<::std::os::raw::c_char,
                                                std_allocator>,
                               ::std::os::raw::c_int>>()
               , 16usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std_pair<std_basic_string<::std::os::raw::c_char, std_allocator>,
         ::std::os::raw::c_int>
               ) ));
    assert_eq!(::std::mem::align_of::<std_pair<std_basic_string<::std::os::raw::c_char,
                                                 std_allocator>,
                                ::std::os::raw::c_int>>()
               , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_pair<std_basic_string<::std::os::raw::c_char, std_allocator>,
         ::std::os::raw::c_int>
               ) ));
}
#[test]
fn __bindgen_test_layout_std_allocator_instantiation_102282() {
    assert_eq!(::std::mem::size_of::<std_allocator>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std_allocator ) ));
    assert_eq!(::std::mem::align_of::<std_allocator>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_allocator ) ));
}
#[test]
fn __bindgen_test_layout_std_map_instantiation_102275() {
    assert_eq!(::std::mem::size_of::<std_map>() , 48usize , concat ! (
               "Size of template specialization: " , stringify ! ( std_map )
               ));
    assert_eq!(::std::mem::align_of::<std_map>() , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_map ) ));
}
#[test]
fn __bindgen_test_layout_octave_base_list_instantiation_102483() {
    assert_eq!(::std::mem::size_of::<octave_base_list>() , 24usize , concat !
               (
               "Size of template specialization: " , stringify ! (
               octave_base_list ) ));
    assert_eq!(::std::mem::align_of::<octave_base_list>() , 8usize , concat !
               (
               "Alignment of template specialization: " , stringify ! (
               octave_base_list ) ));
}
#[test]
fn __bindgen_test_layout_std_allocator_instantiation_102489() {
    assert_eq!(::std::mem::size_of::<std_allocator>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std_allocator ) ));
    assert_eq!(::std::mem::align_of::<std_allocator>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_allocator ) ));
}
#[test]
fn __bindgen_test_layout_std_list_instantiation_102487() {
    assert_eq!(::std::mem::size_of::<std_list>() , 16usize , concat ! (
               "Size of template specialization: " , stringify ! ( std_list )
               ));
    assert_eq!(::std::mem::align_of::<std_list>() , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_list ) ));
}
#[test]
fn __bindgen_test_layout_std_allocator_instantiation_102623() {
    assert_eq!(::std::mem::size_of::<std_allocator>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std_allocator ) ));
    assert_eq!(::std::mem::align_of::<std_allocator>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_allocator ) ));
}
#[test]
fn __bindgen_test_layout_std_list_instantiation_102620() {
    assert_eq!(::std::mem::size_of::<std_list>() , 16usize , concat ! (
               "Size of template specialization: " , stringify ! ( std_list )
               ));
    assert_eq!(::std::mem::align_of::<std_list>() , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_list ) ));
}
#[test]
fn __bindgen_test_layout_std_less_instantiation_102634() {
    assert_eq!(::std::mem::size_of::<std_less>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! ( std_less )
               ));
    assert_eq!(::std::mem::align_of::<std_less>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_less ) ));
}
#[test]
fn __bindgen_test_layout_std_pair_instantiation_102647() {
    assert_eq!(::std::mem::size_of::<std_pair<std_basic_string<::std::os::raw::c_char,
                                                std_allocator>,
                               std_basic_string<::std::os::raw::c_char,
                                                std_allocator>>>()
               , 16usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std_pair<std_basic_string<::std::os::raw::c_char, std_allocator>,
         std_basic_string<::std::os::raw::c_char, std_allocator>>
               ) ));
    assert_eq!(::std::mem::align_of::<std_pair<std_basic_string<::std::os::raw::c_char,
                                                 std_allocator>,
                                std_basic_string<::std::os::raw::c_char,
                                                 std_allocator>>>()
               , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_pair<std_basic_string<::std::os::raw::c_char, std_allocator>,
         std_basic_string<::std::os::raw::c_char, std_allocator>>
               ) ));
}
#[test]
fn __bindgen_test_layout_std_allocator_instantiation_102646() {
    assert_eq!(::std::mem::size_of::<std_allocator>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std_allocator ) ));
    assert_eq!(::std::mem::align_of::<std_allocator>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_allocator ) ));
}
#[test]
fn __bindgen_test_layout_std_map_instantiation_102642() {
    assert_eq!(::std::mem::size_of::<std_map>() , 48usize , concat ! (
               "Size of template specialization: " , stringify ! ( std_map )
               ));
    assert_eq!(::std::mem::align_of::<std_map>() , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_map ) ));
}
#[test]
fn __bindgen_test_layout_std_pair_instantiation_102654() {
    assert_eq!(::std::mem::size_of::<std_pair<::std::os::raw::c_int, octave_value>>()
               , 24usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std_pair<::std::os::raw::c_int, octave_value> ) ));
    assert_eq!(::std::mem::align_of::<std_pair<::std::os::raw::c_int, octave_value>>()
               , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_pair<::std::os::raw::c_int, octave_value> ) ));
}
#[test]
fn __bindgen_test_layout_std_pair_instantiation_102662() {
    assert_eq!(::std::mem::size_of::<std_pair<std_basic_string<::std::os::raw::c_char,
                                                std_allocator>,
                               octave_value>>()
               , 24usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std_pair<std_basic_string<::std::os::raw::c_char, std_allocator>,
         octave_value>
               ) ));
    assert_eq!(::std::mem::align_of::<std_pair<std_basic_string<::std::os::raw::c_char,
                                                 std_allocator>,
                                octave_value>>()
               , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_pair<std_basic_string<::std::os::raw::c_char, std_allocator>,
         octave_value>
               ) ));
}
#[test]
fn __bindgen_test_layout_std_pair_instantiation_102684() {
    assert_eq!(::std::mem::size_of::<std_pair<std_basic_string<::std::os::raw::c_char,
                                                std_allocator>,
                               octave_value>>()
               , 24usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std_pair<std_basic_string<::std::os::raw::c_char, std_allocator>,
         octave_value>
               ) ));
    assert_eq!(::std::mem::align_of::<std_pair<std_basic_string<::std::os::raw::c_char,
                                                 std_allocator>,
                                octave_value>>()
               , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_pair<std_basic_string<::std::os::raw::c_char, std_allocator>,
         octave_value>
               ) ));
}
#[test]
fn __bindgen_test_layout_std_allocator_instantiation_102715() {
    assert_eq!(::std::mem::size_of::<std_allocator>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std_allocator ) ));
    assert_eq!(::std::mem::align_of::<std_allocator>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_allocator ) ));
}
#[test]
fn __bindgen_test_layout_std_allocator_instantiation_103031() {
    assert_eq!(::std::mem::size_of::<std_allocator>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std_allocator ) ));
    assert_eq!(::std::mem::align_of::<std_allocator>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_allocator ) ));
}
#[test]
fn __bindgen_test_layout_std_list_instantiation_103029() {
    assert_eq!(::std::mem::size_of::<std_list>() , 16usize , concat ! (
               "Size of template specialization: " , stringify ! ( std_list )
               ));
    assert_eq!(::std::mem::align_of::<std_list>() , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_list ) ));
}
#[test]
fn __bindgen_test_layout_std_allocator_instantiation_103071() {
    assert_eq!(::std::mem::size_of::<std_allocator>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std_allocator ) ));
    assert_eq!(::std::mem::align_of::<std_allocator>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_allocator ) ));
}
#[test]
fn __bindgen_test_layout_std_list_instantiation_103069() {
    assert_eq!(::std::mem::size_of::<std_list>() , 16usize , concat ! (
               "Size of template specialization: " , stringify ! ( std_list )
               ));
    assert_eq!(::std::mem::align_of::<std_list>() , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_list ) ));
}
#[test]
fn __bindgen_test_layout_std_pair_instantiation_103100() {
    assert_eq!(::std::mem::size_of::<std_pair<std_basic_string<::std::os::raw::c_char,
                                                std_allocator>,
                               symbol_table_symbol_record>>()
               , 16usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std_pair<std_basic_string<::std::os::raw::c_char, std_allocator>,
         symbol_table_symbol_record>
               ) ));
    assert_eq!(::std::mem::align_of::<std_pair<std_basic_string<::std::os::raw::c_char,
                                                 std_allocator>,
                                symbol_table_symbol_record>>()
               , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_pair<std_basic_string<::std::os::raw::c_char, std_allocator>,
         symbol_table_symbol_record>
               ) ));
}
#[test]
fn __bindgen_test_layout_std_pair_instantiation_103111() {
    assert_eq!(::std::mem::size_of::<std_pair<::std::os::raw::c_int, *mut symbol_table>>()
               , 16usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std_pair<::std::os::raw::c_int, *mut symbol_table> ) ));
    assert_eq!(::std::mem::align_of::<std_pair<::std::os::raw::c_int, *mut symbol_table>>()
               , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_pair<::std::os::raw::c_int, *mut symbol_table> ) ));
}
#[test]
fn __bindgen_test_layout_std_pair_instantiation_103120() {
    assert_eq!(::std::mem::size_of::<std_pair<std_basic_string<::std::os::raw::c_char,
                                                std_allocator>,
                               symbol_table_fcn_info>>()
               , 16usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std_pair<std_basic_string<::std::os::raw::c_char, std_allocator>,
         symbol_table_fcn_info>
               ) ));
    assert_eq!(::std::mem::align_of::<std_pair<std_basic_string<::std::os::raw::c_char,
                                                 std_allocator>,
                                symbol_table_fcn_info>>()
               , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_pair<std_basic_string<::std::os::raw::c_char, std_allocator>,
         symbol_table_fcn_info>
               ) ));
}
#[test]
fn __bindgen_test_layout_std_allocator_instantiation_103130() {
    assert_eq!(::std::mem::size_of::<std_allocator>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std_allocator ) ));
    assert_eq!(::std::mem::align_of::<std_allocator>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_allocator ) ));
}
#[test]
fn __bindgen_test_layout_std_allocator_instantiation_103137() {
    assert_eq!(::std::mem::size_of::<std_allocator>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std_allocator ) ));
    assert_eq!(::std::mem::align_of::<std_allocator>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_allocator ) ));
}
#[test]
fn __bindgen_test_layout_std_allocator_instantiation_103147() {
    assert_eq!(::std::mem::size_of::<std_allocator>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std_allocator ) ));
    assert_eq!(::std::mem::align_of::<std_allocator>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_allocator ) ));
}
#[test]
fn __bindgen_test_layout_std_allocator_instantiation_103154() {
    assert_eq!(::std::mem::size_of::<std_allocator>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std_allocator ) ));
    assert_eq!(::std::mem::align_of::<std_allocator>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_allocator ) ));
}
#[test]
fn __bindgen_test_layout_std_allocator_instantiation_103158() {
    assert_eq!(::std::mem::size_of::<std_allocator>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std_allocator ) ));
    assert_eq!(::std::mem::align_of::<std_allocator>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_allocator ) ));
}
#[test]
fn __bindgen_test_layout_std_allocator_instantiation_103167() {
    assert_eq!(::std::mem::size_of::<std_allocator>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std_allocator ) ));
    assert_eq!(::std::mem::align_of::<std_allocator>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_allocator ) ));
}
#[test]
fn __bindgen_test_layout_std_pair_instantiation_103180() {
    assert_eq!(::std::mem::size_of::<std_pair<std_basic_string<::std::os::raw::c_char,
                                                std_allocator>, std_list>>()
               , 24usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std_pair<std_basic_string<::std::os::raw::c_char, std_allocator>, std_list>
               ) ));
    assert_eq!(::std::mem::align_of::<std_pair<std_basic_string<::std::os::raw::c_char,
                                                 std_allocator>, std_list>>()
               , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_pair<std_basic_string<::std::os::raw::c_char, std_allocator>, std_list>
               ) ));
}
#[test]
fn __bindgen_test_layout_std_allocator_instantiation_103179() {
    assert_eq!(::std::mem::size_of::<std_allocator>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std_allocator ) ));
    assert_eq!(::std::mem::align_of::<std_allocator>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_allocator ) ));
}
#[test]
fn __bindgen_test_layout_std_pair_instantiation_103370() {
    assert_eq!(::std::mem::size_of::<std_pair<std_basic_string<::std::os::raw::c_char,
                                                std_allocator>,
                               ::std::os::raw::c_ulonglong>>()
               , 16usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std_pair<std_basic_string<::std::os::raw::c_char, std_allocator>,
         ::std::os::raw::c_ulonglong>
               ) ));
    assert_eq!(::std::mem::align_of::<std_pair<std_basic_string<::std::os::raw::c_char,
                                                 std_allocator>,
                                ::std::os::raw::c_ulonglong>>()
               , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_pair<std_basic_string<::std::os::raw::c_char, std_allocator>,
         ::std::os::raw::c_ulonglong>
               ) ));
}
#[test]
fn __bindgen_test_layout_std_allocator_instantiation_103382() {
    assert_eq!(::std::mem::size_of::<std_allocator>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std_allocator ) ));
    assert_eq!(::std::mem::align_of::<std_allocator>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_allocator ) ));
}
#[test]
fn __bindgen_test_layout_std_pair_instantiation_103390() {
    assert_eq!(::std::mem::size_of::<std_pair<std_basic_string<::std::os::raw::c_char,
                                                std_allocator>,
                               *mut octave_dynamic_library_dynlib_rep>>()
               , 16usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std_pair<std_basic_string<::std::os::raw::c_char, std_allocator>,
         *mut octave_dynamic_library_dynlib_rep>
               ) ));
    assert_eq!(::std::mem::align_of::<std_pair<std_basic_string<::std::os::raw::c_char,
                                                 std_allocator>,
                                *mut octave_dynamic_library_dynlib_rep>>()
               , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_pair<std_basic_string<::std::os::raw::c_char, std_allocator>,
         *mut octave_dynamic_library_dynlib_rep>
               ) ));
}
#[test]
fn __bindgen_test_layout_std_allocator_instantiation_103389() {
    assert_eq!(::std::mem::size_of::<std_allocator>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std_allocator ) ));
    assert_eq!(::std::mem::align_of::<std_allocator>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std_allocator ) ));
}
